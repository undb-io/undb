/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@scalar/api-reference@1.24.52/dist/browser/standalone.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!(function () {
  "use strict"
  try {
    if ("undefined" != typeof document) {
      var e = document.createElement("style")
      e.appendChild(
        document.createTextNode(
          '.workspace-avatar{align-items:center;background:var(--scalar-background-1);border:1px solid var(--scalar-border-color);border-radius:8px;display:flex;justify-content:center;transition:border .2s;min-height:37px;height:37px;width:100%}.dark-mode .workspace-avatar{--gradient-color-1: color-mix( in srgb, var(--scalar-brand) 30%, var(--scalar-background-1) );--gradient-color-2: color-mix( in srgb, var(--scalar-brand) 20%, var(--scalar-background-1) )}.workspace-avatar:hover{border:1px solid #00000033}.workspace-avatar-image{top:0;right:0;bottom:0;left:0;position:absolute;aspect-ratio:1 / 1;background-size:cover;background-position:center;z-index:1}.shine-effect{overflow:hidden;position:relative}.shine-effect:before{background-color:#fff3;content:"";filter:blur(2px);height:150%;left:-100%;position:absolute;transform:rotate(30deg);width:16px}.dark-mode .shine-effect:before{background-color:#0003;content:"";filter:blur(2px);height:150%;left:-100%;position:absolute;transform:rotate(30deg);width:16px}.shine-effect:hover:before{left:100%;transition:left 1s ease}.nav-item[data-v-26cc8e34]{padding:0 1rem;cursor:pointer;flex:1;justify-content:center;align-items:center;display:flex;border-radius:var(--scalar-radius);background:var(--scalar-background-2);border:1px solid var(--scalar-background-2);color:var(--scalar-color-3);padding:4.5px;min-width:0;overflow:hidden;position:relative}.nav-item-icon-copy[data-v-26cc8e34]{max-width:100%;white-space:nowrap;overflow:hidden;-webkit-mask-image:linear-gradient(to left,transparent 0,var(--scalar-background-2) 20px);mask-image:linear-gradient(to left,transparent 0,var(--scalar-background-2) 20px)}.nav-item:hover .nav-item-icon-copy[data-v-26cc8e34]{-webkit-mask-image:linear-gradient(to left,transparent 20px,var(--scalar-background-2) 40px);mask-image:linear-gradient(to left,transparent 20px,var(--scalar-background-2) 40px)}.nav-item-copy[data-v-26cc8e34]{max-width:calc(100% - 20px)}.nav-item[data-v-26cc8e34]:hover{color:var(--scalar-color-1)}.nav-item__active[data-v-26cc8e34]{background-color:var(--scalar-background-1);color:var(--scalar-color-1);border-color:var(--scalar-border-color)}.nav-item-close[data-v-26cc8e34]{position:absolute;right:3px;padding:2px;border-radius:var(--scalar-radius);background:transparent;max-width:20px;stroke-width:1.5px;color:var(--scalar-color-3);margin-left:-20px;opacity:0}.nav-item:hover .nav-item-close[data-v-26cc8e34]{opacity:1}.nav-item-close[data-v-26cc8e34]:hover{background-color:var(--scalar-background-4)}.nav-item__active .nav-item-close[data-v-26cc8e34]:hover{background-color:var(--scalar-background-2)}.webkit-app-no-drag[data-v-26cc8e34]{-webkit-app-region:no-drag}.t-app__top-nav[data-v-31a24876]{padding-left:53px;padding-right:9px;position:relative}.t-app__top-nav-draggable[data-v-31a24876]{-webkit-app-region:drag;position:absolute;top:0;left:0;width:100%;height:100%}.webkit-app-no-drag[data-v-31a24876]{-webkit-app-region:no-drag}.commandmenu[data-v-caaeb4c4]{box-shadow:var(--scalar-shadow-2);border-radius:var(--scalar-radius-lg);background-color:var(--scalar-background-1);width:100%;max-width:580px;padding:12px;margin:12px;position:fixed;left:50%;top:150px;opacity:0;transform:translate3d(-50%,10px,0);z-index:100;animation:fadeincommandmenu-caaeb4c4 ease-in-out .3s forwards;animation-delay:.1s}.commandmenu-clickout[data-v-caaeb4c4]{background:#0003;animation:fadeincommand-caaeb4c4 ease-in-out .3s forwards;position:fixed;top:0;left:0;width:100%;height:100%;z-index:100;cursor:pointer}@keyframes fadeincommand-caaeb4c4{0%{opacity:0}to{opacity:1}}@keyframes fadeincommandmenu-caaeb4c4{0%{opacity:0;transform:translate3d(-50%,10px,0)}to{opacity:1;transform:translate3d(-50%,0,0)}}@layer scalar-base,scalar-theme;@layer scalar-base{body{margin:0;line-height:inherit}}@layer scalar-base{:root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}.light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }}.scalar-app .markdown summary:after{display:block;content:"";position:absolute;top:1px;left:1px;width:16px;height:16px;background-color:var(--scalar-color-3);-webkit-mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\');mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\')}@layer scalar-base,scalar-theme;@layer scalar-base{body{margin:0;line-height:inherit}}@layer scalar-base{:root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}.light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}*,:before,:after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }}#scalar-client{display:flex;flex-direction:column;height:100vh;width:100vw;background:var(--scalar-background-1)}@layer scalar-base,scalar-theme;@layer scalar-base{body{margin:0;line-height:inherit}}@layer scalar-base{:root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}.light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }}:where(.scalar-app) .group:hover .group-hover\\:shadow-border{--tw-shadow: inset 0 0 0 1px var(--scalar-border-color);--tw-shadow-colored: inset 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow);--tw-shadow-color: var(--scalar-border-color);--tw-shadow: var(--tw-shadow-colored)}.scalar-app .markdown summary:after{display:block;content:"";position:absolute;top:1px;left:1px;width:16px;height:16px;background-color:var(--scalar-color-3);-webkit-mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\');mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\')}@layer scalar-base{*,:before,:after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }}.scalar-client{line-height:1.5;color:var(--scalar-color-1)}.scalar-client .row{display:flex;flex-direction:row}.scalar-client .row-1{display:flex;flex-direction:row;flex:1 1 0%}.scalar-client .col{display:flex;flex-direction:column}.scalar-client .col-1{display:flex;flex-direction:column;flex:1 1 0%}.scalar-client .flex-center{display:flex;justify-content:center;align-items:center}.scalar-client .centered-x{left:50%;--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .centered-y{top:50%;--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .centered{left:50%;--tw-translate-x: -50%;top:50%;--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.scalar-client .pointer-events-none{pointer-events:none}.scalar-client .visible{visibility:visible}.scalar-client .static{position:static}.scalar-client .fixed{position:fixed}.scalar-client .absolute{position:absolute}.scalar-client .relative{position:relative}.scalar-client .sticky{position:sticky}.scalar-client .inset-0{top:0;right:0;bottom:0;left:0}.scalar-client .bottom-\\[50px\\]{bottom:50px}.scalar-client .left-0{left:0}.scalar-client .left-2{left:8px}.scalar-client .right-0{right:0}.scalar-client .right-1{right:4px}.scalar-client .right-2{right:8px}.scalar-client .right-4{right:16px}.scalar-client .right-7{right:28px}.scalar-client .top-0{top:0}.scalar-client .top-\\[0\\.5px\\]{top:.5px}.scalar-client .top-\\[33px\\]{top:33px}.scalar-client .z-0{z-index:0}.scalar-client .z-1{z-index:1}.scalar-client .z-10{z-index:10}.scalar-client .z-20{z-index:20}.scalar-client .z-50{z-index:50}.scalar-client .z-\\[1\\]{z-index:1}.scalar-client .order-last{order:9999}.scalar-client .col-span-full{grid-column:1 / -1}.scalar-client .\\!m-0{margin:0!important}.scalar-client .m-0{margin:0}.scalar-client .m-1{margin:4px}.scalar-client .m-1\\.5{margin:6px}.scalar-client .m-auto{margin:auto}.scalar-client .-my-1{margin-top:-4px;margin-bottom:-4px}.scalar-client .mx-1{margin-left:4px;margin-right:4px}.scalar-client .-ml-1{margin-left:-4px}.scalar-client .mb-0{margin-bottom:0}.scalar-client .mb-0\\.5{margin-bottom:2px}.scalar-client .mb-2{margin-bottom:8px}.scalar-client .mb-2\\.5{margin-bottom:10px}.scalar-client .mb-\\[\\.5px\\]{margin-bottom:.5px}.scalar-client .ml-1{margin-left:4px}.scalar-client .ml-1\\.5{margin-left:6px}.scalar-client .ml-auto{margin-left:auto}.scalar-client .mr-1{margin-right:4px}.scalar-client .mr-2{margin-right:8px}.scalar-client .mr-2\\.5{margin-right:10px}.scalar-client .mt-0{margin-top:0}.scalar-client .mt-2{margin-top:8px}.scalar-client .mt-3{margin-top:12px}.scalar-client .mt-3\\.5{margin-top:14px}.scalar-client .mt-auto{margin-top:auto}.scalar-client .block{display:block}.scalar-client .inline-block{display:inline-block}.scalar-client .flex{display:flex}.scalar-client .inline-flex{display:inline-flex}.scalar-client .table{display:table}.scalar-client .grid{display:grid}.scalar-client .contents{display:contents}.scalar-client .hidden{display:none}.scalar-client .size-2{width:8px;height:8px}.scalar-client .size-2\\.5{width:10px;height:10px}.scalar-client .size-3{width:12px;height:12px}.scalar-client .size-3\\.5{width:14px;height:14px}.scalar-client .size-4{width:16px;height:16px}.scalar-client .h-10{height:40px}.scalar-client .h-2{height:8px}.scalar-client .h-2\\.5{height:10px}.scalar-client .h-24{height:96px}.scalar-client .h-3{height:12px}.scalar-client .h-3\\.5{height:14px}.scalar-client .h-4{height:16px}.scalar-client .h-5{height:20px}.scalar-client .h-6{height:24px}.scalar-client .h-7{height:28px}.scalar-client .h-8{height:32px}.scalar-client .h-\\[calc\\(100\\%_-_50px\\)\\]{height:calc(100% - 50px)}.scalar-client .h-auto{height:auto}.scalar-client .h-fit{height:-moz-fit-content;height:fit-content}.scalar-client .h-full{height:100%}.scalar-client .max-h-40{max-height:160px}.scalar-client .max-h-8{max-height:32px}.scalar-client .max-h-\\[300px\\]{max-height:300px}.scalar-client .min-h-0{min-height:0px}.scalar-client .min-h-10{min-height:40px}.scalar-client .min-h-12{min-height:48px}.scalar-client .min-h-14{min-height:56px}.scalar-client .min-h-20{min-height:80px}.scalar-client .min-h-8{min-height:32px}.scalar-client .w-2{width:8px}.scalar-client .w-2\\.5{width:10px}.scalar-client .w-20{width:80px}.scalar-client .w-3{width:12px}.scalar-client .w-3\\.5{width:14px}.scalar-client .w-4{width:16px}.scalar-client .w-5{width:20px}.scalar-client .w-6{width:24px}.scalar-client .w-6\\/12{width:50%}.scalar-client .w-60{width:240px}.scalar-client .w-\\[15px\\]{width:15px}.scalar-client .w-\\[37px\\]{width:37px}.scalar-client .w-\\[calc\\(100\\%_-_8px\\)\\]{width:calc(100% - 8px)}.scalar-client .w-fit{width:-moz-fit-content;width:fit-content}.scalar-client .w-full{width:100%}.scalar-client .w-max{width:-moz-max-content;width:max-content}.scalar-client .w-sidebar{width:var(--scalar-sidebar-width)}.scalar-client .min-w-0{min-width:0px}.scalar-client .min-w-2{min-width:8px}.scalar-client .min-w-2\\.5{min-width:10px}.scalar-client .min-w-48{min-width:192px}.scalar-client .min-w-8{min-width:32px}.scalar-client .min-w-\\[100px\\]{min-width:100px}.scalar-client .min-w-\\[44px\\]{min-width:44px}.scalar-client .min-w-full{min-width:100%}.scalar-client .max-w-\\[100\\%\\]{max-width:100%}.scalar-client .max-w-\\[14px\\]{max-width:14px}.scalar-client .flex-1{flex:1 1 0%}.scalar-client .shrink-0{flex-shrink:0}.scalar-client .basis-1\\/2{flex-basis:50%}.scalar-client .-translate-x-1\\/2{--tw-translate-x:-50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .-translate-x-full{--tw-translate-x:-100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .translate-x-0{--tw-translate-x:0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .-rotate-90{--tw-rotate:-90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .rotate-180{--tw-rotate:180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .rotate-90{--tw-rotate:90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .cursor-help{cursor:help}.scalar-client .cursor-pointer{cursor:pointer}.scalar-client .cursor-text{cursor:text}.scalar-client .resize{resize:both}.scalar-client .auto-rows-auto{grid-auto-rows:auto}.scalar-client .flex-row{flex-direction:row}.scalar-client .flex-col{flex-direction:column}.scalar-client .flex-wrap{flex-wrap:wrap}.scalar-client .items-start{align-items:flex-start}.scalar-client .items-end{align-items:flex-end}.scalar-client .items-center{align-items:center}.scalar-client .items-stretch{align-items:stretch}.scalar-client .justify-start{justify-content:flex-start}.scalar-client .justify-end{justify-content:flex-end}.scalar-client .justify-center{justify-content:center}.scalar-client .justify-between{justify-content:space-between}.scalar-client .\\!gap-1{gap:4px!important}.scalar-client .\\!gap-1\\.5{gap:6px!important}.scalar-client .\\!gap-2{gap:8px!important}.scalar-client .gap-0{gap:0px}.scalar-client .gap-0\\.5{gap:2px}.scalar-client .gap-1{gap:4px}.scalar-client .gap-1\\.5{gap:6px}.scalar-client .gap-2{gap:8px}.scalar-client .gap-2\\.5{gap:10px}.scalar-client .gap-3{gap:12px}.scalar-client .gap-6{gap:24px}.scalar-client .gap-\\[\\.5px\\]{gap:.5px}.scalar-client .space-x-1>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-right:calc(4px * var(--tw-space-x-reverse));margin-left:calc(4px * calc(1 - var(--tw-space-x-reverse)))}.scalar-client .divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(var(--scalar-border-width) * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(var(--scalar-border-width) * var(--tw-divide-y-reverse))}.scalar-client .self-center{align-self:center}.scalar-client .justify-self-end{justify-self:end}.scalar-client .overflow-hidden{overflow:hidden}.scalar-client .overflow-visible{overflow:visible}.scalar-client .overflow-x-auto{overflow-x:auto}.scalar-client .truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.scalar-client .text-ellipsis{text-overflow:ellipsis}.scalar-client .whitespace-nowrap{white-space:nowrap}.scalar-client .whitespace-pre{white-space:pre}.scalar-client .text-pretty{text-wrap:pretty}.scalar-client .rounded{border-radius:var(--scalar-radius)}.scalar-client .rounded-full{border-radius:9999px}.scalar-client .rounded-lg{border-radius:var(--scalar-radius-lg)}.scalar-client .rounded-md{border-radius:var(--scalar-radius)}.scalar-client .rounded-xl{border-radius:var(--scalar-radius-xl)}.scalar-client .rounded-b{border-bottom-right-radius:var(--scalar-radius);border-bottom-left-radius:var(--scalar-radius)}.scalar-client .rounded-t{border-top-left-radius:var(--scalar-radius);border-top-right-radius:var(--scalar-radius)}.scalar-client .border{border-width:var(--scalar-border-width)}.scalar-client .border-0{border-width:0}.scalar-client .border-1\\/2{border-width:calc(var(--scalar-border-width) / 2)}.scalar-client .border-b{border-bottom-width:var(--scalar-border-width)}.scalar-client .border-b-0{border-bottom-width:0}.scalar-client .border-b-1\\/2{border-bottom-width:calc(var(--scalar-border-width) / 2)}.scalar-client .border-l-0{border-left-width:0}.scalar-client .border-r{border-right-width:var(--scalar-border-width)}.scalar-client .border-r-0{border-right-width:0}.scalar-client .border-r-1\\/2{border-right-width:calc(var(--scalar-border-width) / 2)}.scalar-client .border-t{border-top-width:var(--scalar-border-width)}.scalar-client .border-t-0{border-top-width:0}.scalar-client .border-t-1\\/2{border-top-width:calc(var(--scalar-border-width) / 2)}.scalar-client .border-solid{border-style:solid}.scalar-client .border-dashed{border-style:dashed}.scalar-client .border-none{border-style:none}.scalar-client .border-b-3{border-color:var(--scalar-background-3)}.scalar-client .border-transparent{border-color:transparent}.scalar-client .border-r-transparent{border-right-color:transparent}.scalar-client .bg-b-1{background-color:var(--scalar-background-1)}.scalar-client .bg-b-2{background-color:var(--scalar-background-2)}.scalar-client .bg-blue{background-color:var(--scalar-color-blue)}.scalar-client .bg-c-2{background-color:var(--scalar-color-2)}.scalar-client .bg-green{background-color:var(--scalar-color-green)}.scalar-client .bg-grey{background-color:var(--scalar-color-3)}.scalar-client .bg-orange{background-color:var(--scalar-color-orange)}.scalar-client .bg-pink{background-color:var(--scalar-color-pink)}.scalar-client .bg-purple{background-color:var(--scalar-color-purple)}.scalar-client .bg-red{background-color:var(--scalar-color-red)}.scalar-client .bg-sidebar-active-b{background-color:var(--scalar-sidebar-item-active-background, var(--scalar-background-2))}.scalar-client .bg-yellow{background-color:var(--scalar-color-yellow)}.scalar-client .bg-none{background-image:none}.scalar-client .fill-current{fill:currentColor}.scalar-client .p-0{padding:0}.scalar-client .p-0\\.5{padding:2px}.scalar-client .p-1{padding:4px}.scalar-client .p-1\\.5{padding:6px}.scalar-client .p-2{padding:8px}.scalar-client .p-4{padding:16px}.scalar-client .p-\\[2\\.25px\\]{padding:2.25px}.scalar-client .p-\\[3px\\]{padding:3px}.scalar-client .p-\\[5px\\]{padding:5px}.scalar-client .p-\\[7px\\]{padding:7px}.scalar-client .px-0{padding-left:0;padding-right:0}.scalar-client .px-1{padding-left:4px;padding-right:4px}.scalar-client .px-1\\.5{padding-left:6px;padding-right:6px}.scalar-client .px-2{padding-left:8px;padding-right:8px}.scalar-client .px-2\\.5{padding-left:10px;padding-right:10px}.scalar-client .px-3{padding-left:12px;padding-right:12px}.scalar-client .px-4{padding-left:16px;padding-right:16px}.scalar-client .px-5{padding-left:20px;padding-right:20px}.scalar-client .px-\\[0px\\]{padding-left:0;padding-right:0}.scalar-client .px-\\[2\\.25px\\]{padding-left:2.25px;padding-right:2.25px}.scalar-client .py-0{padding-top:0;padding-bottom:0}.scalar-client .py-0\\.5{padding-top:2px;padding-bottom:2px}.scalar-client .py-1{padding-top:4px;padding-bottom:4px}.scalar-client .py-1\\.5{padding-top:6px;padding-bottom:6px}.scalar-client .py-2{padding-top:8px;padding-bottom:8px}.scalar-client .py-2\\.5{padding-top:10px;padding-bottom:10px}.scalar-client .py-\\[0px\\]{padding-top:0;padding-bottom:0}.scalar-client .py-\\[2\\.25px\\]{padding-top:2.25px;padding-bottom:2.25px}.scalar-client .py-px{padding-top:1px;padding-bottom:1px}.scalar-client .pb-0{padding-bottom:0}.scalar-client .pb-12{padding-bottom:48px}.scalar-client .pl-1{padding-left:4px}.scalar-client .pl-2{padding-left:8px}.scalar-client .pl-8{padding-left:32px}.scalar-client .pr-0{padding-right:0}.scalar-client .pr-2{padding-right:8px}.scalar-client .pr-2\\.5{padding-right:10px}.scalar-client .pr-3{padding-right:12px}.scalar-client .pr-\\[26px\\]{padding-right:26px}.scalar-client .pt-0{padding-top:0}.scalar-client .pt-2{padding-top:8px}.scalar-client .pt-2\\.5{padding-top:10px}.scalar-client .pt-px{padding-top:1px}.scalar-client .text-left{text-align:left}.scalar-client .text-center{text-align:center}.scalar-client .text-right{text-align:right}.scalar-client .font-code{font-family:var(--scalar-font-code)}.scalar-client .text-3xs{font-size:var(--scalar-font-size-7)}.scalar-client .text-\\[11px\\]{font-size:11px}.scalar-client .text-\\[6px\\]{font-size:6px}.scalar-client .text-base{font-size:var(--scalar-font-size-3)}.scalar-client .text-sm{font-size:var(--scalar-font-size-4)}.scalar-client .text-xs{font-size:var(--scalar-font-size-5)}.scalar-client .text-xxs{font-size:var(--scalar-font-size-6)}.scalar-client .font-bold{font-weight:var(--scalar-bold)}.scalar-client .font-medium{font-weight:var(--scalar-semibold)}.scalar-client .font-normal{font-weight:var(--scalar-regular)}.scalar-client .uppercase{text-transform:uppercase}.scalar-client .capitalize{text-transform:capitalize}.scalar-client .leading-3{line-height:var(--scalar-line-height-3)}.scalar-client .leading-5{line-height:var(--scalar-line-height-5)}.scalar-client .leading-\\[1\\.44\\]{line-height:1.44}.scalar-client .leading-\\[7px\\]{line-height:7px}.scalar-client .leading-snug{line-height:1.375}.scalar-client .text-b-1{color:var(--scalar-background-1)}.scalar-client .text-blue{color:var(--scalar-color-blue)}.scalar-client .text-border{color:var(--scalar-border-color)}.scalar-client .text-c-1{color:var(--scalar-color-1)}.scalar-client .text-c-2{color:var(--scalar-color-2)}.scalar-client .text-c-3{color:var(--scalar-color-3)}.scalar-client .text-green{color:var(--scalar-color-green)}.scalar-client .text-grey{color:var(--scalar-color-3)}.scalar-client .text-orange{color:var(--scalar-color-orange)}.scalar-client .text-purple{color:var(--scalar-color-purple)}.scalar-client .text-red{color:var(--scalar-color-red)}.scalar-client .text-sidebar-active-c{color:var(--scalar-sidebar-color-active, currentColor)}.scalar-client .text-sidebar-c-2{color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.scalar-client .text-transparent{color:transparent}.scalar-client .text-yellow{color:var(--scalar-color-yellow)}.scalar-client .underline{text-decoration-line:underline}.scalar-client .no-underline{text-decoration-line:none}.scalar-client .decoration-c-3{text-decoration-color:var(--scalar-color-3)}.scalar-client .underline-offset-2{text-underline-offset:2px}.scalar-client .opacity-0{opacity:0}.scalar-client .opacity-100{opacity:1}.scalar-client .shadow{--tw-shadow:var(--scalar-shadow-1);--tw-shadow-colored:var(--scalar-shadow-1);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .shadow-\\[-8px_0_4px_var\\(--scalar-background-1\\)\\]{--tw-shadow:-8px 0 4px var(--scalar-background-1);--tw-shadow-colored:-8px 0 4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .shadow-border{--tw-shadow:inset 0 0 0 1px var(--scalar-border-color);--tw-shadow-colored:inset 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .shadow-lg{--tw-shadow:var(--scalar-shadow-2);--tw-shadow-colored:var(--scalar-shadow-2);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .shadow-none{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .shadow-border{--tw-shadow-color:var(--scalar-border-color);--tw-shadow:var(--tw-shadow-colored)}.scalar-client .outline-none{outline:2px solid transparent;outline-offset:2px}.scalar-client .outline{outline-style:solid}.scalar-client .ring-1{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.scalar-client .ring-offset-4{--tw-ring-offset-width:4px}.scalar-client .blur{--tw-blur:blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.scalar-client .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.scalar-client .backdrop-blur{--tw-backdrop-blur:blur(8px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.scalar-client .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-client .transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-client .transition-none{transition-property:none}.scalar-client .transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-client .transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-client .duration-150{transition-duration:.15s}.scalar-client .duration-300{transition-duration:.3s}.scalar-client .ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.scalar-client .bg-mix-transparent{background-color:color-mix(var(--tw-bg-mix-method, in srgb),transparent calc(var(--tw-bg-mix-amount, 0) * 1%),var(--tw-bg-base))}.scalar-client .bg-mix-amount-30{--tw-bg-mix-amount:30}.scalar-client .bg-mix-amount-95{--tw-bg-mix-amount:95}.scalar-client .bg-b-1{--tw-bg-base:var(--scalar-background-1)}.scalar-client .bg-b-2{--tw-bg-base:var(--scalar-background-2)}.scalar-client .bg-blue{--tw-bg-base:var(--scalar-color-blue)}.scalar-client .bg-c-2{--tw-bg-base:var(--scalar-color-2)}.scalar-client .bg-green{--tw-bg-base:var(--scalar-color-green)}.scalar-client .bg-grey{--tw-bg-base:var(--scalar-color-3)}.scalar-client .bg-orange{--tw-bg-base:var(--scalar-color-orange)}.scalar-client .bg-pink{--tw-bg-base:var(--scalar-color-pink)}.scalar-client .bg-purple{--tw-bg-base:var(--scalar-color-purple)}.scalar-client .bg-red{--tw-bg-base:var(--scalar-color-red)}.scalar-client .bg-sidebar-active-b{--tw-bg-base:var(--scalar-sidebar-item-active-background, var(--scalar-background-2))}.scalar-client .bg-yellow{--tw-bg-base:var(--scalar-color-yellow)}.scalar-client .before\\:pointer-events-none:before{content:var(--tw-content);pointer-events:none}.scalar-client .before\\:absolute:before{content:var(--tw-content);position:absolute}.scalar-client .before\\:left-0:before{content:var(--tw-content);left:0}.scalar-client .before\\:left-1\\/2:before{content:var(--tw-content);left:50%}.scalar-client .before\\:left-\\[calc\\(\\.75rem_\\+_\\.5px\\)\\]:before{content:var(--tw-content);left:calc(.75rem + .5px)}.scalar-client .before\\:top-0:before{content:var(--tw-content);top:0}.scalar-client .before\\:top-1\\/2:before{content:var(--tw-content);top:50%}.scalar-client .before\\:top-\\[-33px\\]:before{content:var(--tw-content);top:-33px}.scalar-client .before\\:z-10:before{content:var(--tw-content);z-index:10}.scalar-client .before\\:mx-\\[0\\.5ch\\]:before{content:var(--tw-content);margin-left:.5ch;margin-right:.5ch}.scalar-client .before\\:block:before{content:var(--tw-content);display:block}.scalar-client .before\\:aspect-square:before{content:var(--tw-content);aspect-ratio:1 / 1}.scalar-client .before\\:h-\\[calc\\(100\\%\\+33px\\)\\]:before{content:var(--tw-content);height:calc(100% + 33px)}.scalar-client .before\\:h-\\[calc\\(100\\%_\\+_\\.5px\\)\\]:before{content:var(--tw-content);height:calc(100% + .5px)}.scalar-client .before\\:w-9\\/12:before{content:var(--tw-content);width:75%}.scalar-client .before\\:w-full:before{content:var(--tw-content);width:100%}.scalar-client .before\\:w-px:before{content:var(--tw-content);width:1px}.scalar-client .before\\:-translate-x-1\\/2:before{content:var(--tw-content);--tw-translate-x:-50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .before\\:-translate-y-1\\/2:before{content:var(--tw-content);--tw-translate-y:-50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .before\\:transform:before{content:var(--tw-content);transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .before\\:rounded:before{content:var(--tw-content);border-radius:var(--scalar-radius)}.scalar-client .before\\:border:before{content:var(--tw-content);border-width:var(--scalar-border-width)}.scalar-client .before\\:border-\\[1px\\]:before{content:var(--tw-content);border-width:1px}.scalar-client .before\\:bg-b-3:before{content:var(--tw-content);background-color:var(--scalar-background-3)}.scalar-client .before\\:opacity-0:before{content:var(--tw-content);opacity:0}.scalar-client .before\\:shadow-lg:before{content:var(--tw-content);--tw-shadow:var(--scalar-shadow-2);--tw-shadow-colored:var(--scalar-shadow-2);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .before\\:content-\\[\\\'\\\'\\]:before{--tw-content:"";content:var(--tw-content)}.scalar-client .before\\:bg-b-3:before{content:var(--tw-content);--tw-bg-base:var(--scalar-background-3)}.scalar-client .last\\:mb-0:last-child{margin-bottom:0}.scalar-client .last\\:border-r-0:last-child{border-right-width:0}.scalar-client .last\\:before\\:h-full:last-child:before{content:var(--tw-content);height:100%}.scalar-client .focus-within\\:bg-b-1:focus-within{background-color:var(--scalar-background-1)}.scalar-client .focus-within\\:bg-b-2:focus-within{background-color:var(--scalar-background-2)}.scalar-client .focus-within\\:text-c-1:focus-within{color:var(--scalar-color-1)}.scalar-client .focus-within\\:shadow-border:focus-within{--tw-shadow:inset 0 0 0 1px var(--scalar-border-color);--tw-shadow-colored:inset 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .focus-within\\:shadow-border:focus-within{--tw-shadow-color:var(--scalar-border-color);--tw-shadow:var(--tw-shadow-colored)}.scalar-client .focus-within\\:bg-b-1:focus-within{--tw-bg-base:var(--scalar-background-1)}.scalar-client .focus-within\\:bg-b-2:focus-within{--tw-bg-base:var(--scalar-background-2)}.scalar-client .hover\\:cursor-auto:hover{cursor:auto}.scalar-client .hover\\:bg-b-2:hover{background-color:var(--scalar-background-2)}.scalar-client .hover\\:bg-b-3:hover{background-color:var(--scalar-background-3)}.scalar-client .hover\\:bg-sidebar-active-b:hover{background-color:var(--scalar-sidebar-item-active-background, var(--scalar-background-2))}.scalar-client .hover\\:text-c-1:hover{color:var(--scalar-color-1)}.scalar-client .hover\\:bg-mix-b-2:hover{background-color:color-mix(var(--tw-bg-mix-method, in srgb),var(--scalar-background-2) calc(var(--tw-bg-mix-amount, 0) * 1%),var(--tw-bg-base))}.scalar-client .hover\\:bg-b-2:hover{--tw-bg-base:var(--scalar-background-2)}.scalar-client .hover\\:bg-b-3:hover{--tw-bg-base:var(--scalar-background-3)}.scalar-client .hover\\:bg-sidebar-active-b:hover{--tw-bg-base:var(--scalar-sidebar-item-active-background, var(--scalar-background-2))}.scalar-client .focus\\:text-c-1:focus{color:var(--scalar-color-1)}.scalar-client .focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.scalar-client .active\\:text-c-1:active{color:var(--scalar-color-1)}.scalar-client .group:last-child .group-last\\:border-b-transparent{border-bottom-color:transparent}.scalar-client .group\\/upload:hover .group-hover\\/upload\\:block,.scalar-client .group:hover .group-hover\\:block{display:block}.scalar-client .group:hover .group-hover\\:flex{display:flex}.scalar-client .group:hover .group-hover\\:hidden{display:none}.scalar-client .group\\/info:hover .group-hover\\/info\\:text-c-1{color:var(--scalar-color-1)}.scalar-client .group\\/scopes-accordion:hover .group-hover\\/scopes-accordion\\:text-c-2{color:var(--scalar-color-2)}.scalar-client .group:hover .group-hover\\:text-c-1{color:var(--scalar-color-1)}.scalar-client .group\\/params:hover .group-hover\\/params\\:opacity-100,.scalar-client .group:hover .group-hover\\:opacity-100{opacity:1}.scalar-client .group:hover .group-hover\\:opacity-80{opacity:.8}.scalar-client .group\\/item:hover .group-hover\\/item\\:shadow-border,.scalar-client .group:hover .group-hover\\:shadow-border{--tw-shadow:inset 0 0 0 1px var(--scalar-border-color);--tw-shadow-colored:inset 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-client .group\\/item:hover .group-hover\\/item\\:shadow-border,.scalar-client .group:hover .group-hover\\:shadow-border{--tw-shadow-color:var(--scalar-border-color);--tw-shadow:var(--tw-shadow-colored)}.scalar-client .group\\/cell:hover .group-hover\\/cell\\:before\\:opacity-100:before{content:var(--tw-content);opacity:1}.scalar-client .peer:checked~.peer-checked\\:text-c-2{color:var(--scalar-color-2)}.scalar-client .peer:focus~.peer-focus\\:opacity-0{opacity:0}.scalar-client .peer:has(.cm-focused)~.peer-has-\\[\\.cm-focused\\]\\:opacity-0{opacity:0}.scalar-client .ui-open\\:mb-3[data-headlessui-state~=open]{margin-bottom:12px}.scalar-client .ui-open\\:flex[data-headlessui-state~=open]{display:flex}.scalar-client .ui-open\\:rotate-90[data-headlessui-state~=open]{--tw-rotate:90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .ui-open\\:pb-1[data-headlessui-state~=open]{padding-bottom:4px}.scalar-client :where([data-headlessui-state~=open]) .ui-open\\:mb-3{margin-bottom:12px}.scalar-client :where([data-headlessui-state~=open]) .ui-open\\:flex{display:flex}.scalar-client :where([data-headlessui-state~=open]) .ui-open\\:rotate-90{--tw-rotate:90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client :where([data-headlessui-state~=open]) .ui-open\\:pb-1{padding-bottom:4px}.scalar-client .ui-not-open\\:invisible[data-headlessui-state]:not([data-headlessui-state~=open]){visibility:hidden}.scalar-client .ui-not-open\\:mb-0[data-headlessui-state]:not([data-headlessui-state~=open]){margin-bottom:0}.scalar-client .ui-not-open\\:rotate-0[data-headlessui-state]:not([data-headlessui-state~=open]){--tw-rotate:0deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client .ui-not-open\\:bg-transparent[data-headlessui-state]:not([data-headlessui-state~=open]){background-color:transparent}.scalar-client .ui-not-open\\:pb-0[data-headlessui-state]:not([data-headlessui-state~=open]){padding-bottom:0}.scalar-client .ui-not-open\\:bg-transparent[data-headlessui-state]:not([data-headlessui-state~=open]){--tw-bg-base:transparent}.scalar-client :where([data-headlessui-state]:not([data-headlessui-state~=open])) .ui-not-open\\:invisible:not([data-headlessui-state]){visibility:hidden}.scalar-client :where([data-headlessui-state]:not([data-headlessui-state~=open])) .ui-not-open\\:mb-0:not([data-headlessui-state]){margin-bottom:0}.scalar-client :where([data-headlessui-state]:not([data-headlessui-state~=open])) .ui-not-open\\:rotate-0:not([data-headlessui-state]){--tw-rotate:0deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-client :where([data-headlessui-state]:not([data-headlessui-state~=open])) .ui-not-open\\:bg-transparent:not([data-headlessui-state]){background-color:transparent}.scalar-client :where([data-headlessui-state]:not([data-headlessui-state~=open])) .ui-not-open\\:pb-0:not([data-headlessui-state]){padding-bottom:0}.scalar-client :where([data-headlessui-state]:not([data-headlessui-state~=open])) .ui-not-open\\:bg-transparent:not([data-headlessui-state]){--tw-bg-base:transparent}.scalar-client .ui-active\\:bg-b-2[data-headlessui-state~=active]{background-color:var(--scalar-background-2)}.scalar-client .ui-active\\:text-c-1[data-headlessui-state~=active]{color:var(--scalar-color-1)}.scalar-client .ui-active\\:bg-b-2[data-headlessui-state~=active]{--tw-bg-base:var(--scalar-background-2)}.scalar-client :where([data-headlessui-state~=active]) .ui-active\\:bg-b-2{background-color:var(--scalar-background-2)}.scalar-client :where([data-headlessui-state~=active]) .ui-active\\:text-c-1{color:var(--scalar-color-1)}.scalar-client :where([data-headlessui-state~=active]) .ui-active\\:bg-b-2{--tw-bg-base:var(--scalar-background-2)}@media (min-width: 1000px){.scalar-client .lg\\:order-none{order:0}}@media (min-width: 1000px){.scalar-client .lg\\:mb-0{margin-bottom:0}}@media (min-width: 1000px){.scalar-client .lg\\:flex{display:flex}}@media (min-width: 1000px){.scalar-client .lg\\:min-h-header{min-height:var(--scalar-client-header-height)}}@media (min-width: 1000px){.scalar-client .lg\\:w-auto{width:auto}}@media (min-width: 1000px){.scalar-client .lg\\:min-w-\\[720px\\]{min-width:720px}}@media (min-width: 1000px){.scalar-client .lg\\:max-w-\\[720px\\]{max-width:720px}}@media (min-width: 1000px){.scalar-client .lg\\:flex-1{flex:1 1 0%}}@media (min-width: 1000px){.scalar-client .lg\\:px-1{padding-left:4px;padding-right:4px}}@media (min-width: 1000px){.scalar-client .lg\\:text-sm{font-size:var(--scalar-font-size-4)}}@media (min-width: 1200px){.scalar-client .xl\\:flex{display:flex}}@media (min-width: 1200px){.scalar-client .xl\\:min-h-header{min-height:var(--scalar-client-header-height)}}@media (min-width: 1200px){.scalar-client .xl\\:min-w-0{min-width:0px}}@media (min-width: 1200px){.scalar-client .xl\\:flex-1{flex:1 1 0%}}@media (min-width: 1200px){.scalar-client .xl\\:flex-row{flex-direction:row}}@media (min-width: 1200px){.scalar-client .xl\\:divide-x>:not([hidden])~:not([hidden]){--tw-divide-x-reverse:0;border-right-width:calc(var(--scalar-border-width) * var(--tw-divide-x-reverse));border-left-width:calc(var(--scalar-border-width) * calc(1 - var(--tw-divide-x-reverse)))}}@media (min-width: 1200px){.scalar-client .xl\\:divide-y-0>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(0px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(0px * var(--tw-divide-y-reverse))}}@media (min-width: 1200px){.scalar-client .xl\\:overflow-hidden{overflow:hidden}}@media (min-width: 1200px){.scalar-client .xl\\:rounded-lg{border-radius:var(--scalar-radius-lg)}}@media (min-width: 1200px){.scalar-client .xl\\:border{border-width:var(--scalar-border-width)}}@media (min-width: 1200px){.scalar-client .xl\\:px-5{padding-left:20px;padding-right:20px}}@media (min-width: 1200px){.scalar-client .xl\\:px-6{padding-left:24px;padding-right:24px}}.scalar-client .dark\\:bg-b-3:where(.dark-mode,.dark-mode *){background-color:var(--scalar-background-3)}.scalar-client .dark\\:bg-b-3:where(.dark-mode,.dark-mode *){--tw-bg-base:var(--scalar-background-3)}:root{--scalar-client-header-height: 50px;--scalar-sidebar-width: 280px;--scalar-toc-width: 280px}.scalar .scalar-api-client[data-v-5357614d]{max-height:calc(100% - calc(var(--scalar-app-header-height)));border-radius:8px}.scalar .scalar-app[data-v-5357614d]{background:var(--scalar-background-3);height:calc(100% - 120px);max-width:1390px;width:100%;margin:auto;opacity:0;animation:scalarapiclientfadein-5357614d .35s forwards;z-index:1002;position:relative;overflow:hidden;border-radius:8px}@keyframes scalarapiclientfadein-5357614d{0%{opacity:0}to{opacity:1}}.scalar .scalar-app-exit[data-v-5357614d]{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#00000038;transition:all .3s ease-in-out;z-index:1000;cursor:pointer;animation:scalardrawerexitfadein-5357614d .35s forwards}.scalar .scalar-app-exit[data-v-5357614d]:before{font-family:sans-serif;position:absolute;top:0;font-size:30px;font-weight:100;line-height:50px;right:12px;text-align:center;color:#fff;opacity:.6}.scalar .scalar-app-exit[data-v-5357614d]:hover:before{opacity:1}@keyframes scalardrawerexitfadein-5357614d{0%{opacity:0}to{opacity:1}}.scalar-container[data-v-5357614d]{overflow:hidden;visibility:visible;position:fixed;bottom:0;top:0;left:0;width:100%;height:100%;z-index:1001;display:flex;align-items:center;justify-content:center}.scalar .url-form-input[data-v-5357614d]{min-height:auto!important}.scalar .scalar-container[data-v-5357614d]{line-height:normal}.scalar .scalar-app-header span[data-v-5357614d]{color:var(--scalar-color-3)}.scalar .scalar-app-header a[data-v-5357614d]{color:var(--scalar-color-1)}.scalar .scalar-app-header a[data-v-5357614d]:hover{text-decoration:underline}.scalar-activate[data-v-5357614d]{width:-moz-fit-content;width:fit-content;margin:0px .75rem .75rem auto;line-height:24px;cursor:pointer;font-size:.875rem;font-weight:600;display:flex;align-items:center;gap:6px}.scalar-activate-button[data-v-5357614d]{display:flex;gap:6px;align-items:center;color:var(--scalar-color-blue);-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;background:transparent;padding:0 .5rem}.scalar-activate:hover .scalar-activate-button[data-v-5357614d]{background:var(--scalar-background-3);border-radius:3px}.required[data-v-7949fbac]:after{content:"Required"}input[data-v-7949fbac]::-moz-placeholder{color:var(--scalar-color-3)}input[data-v-7949fbac]::placeholder{color:var(--scalar-color-3)}.sidebar-height{min-height:calc(100% - 50px)}[data-v-5c9fc64f] .cm-editor{height:100%;outline:none;padding:0;background:transparent}[data-v-5c9fc64f] .cm-content{font-family:var(--scalar-font-code);font-size:var(--scalar-mini)}[data-v-5c9fc64f] .cm-tooltip{background:transparent!important;filter:brightness(var(--scalar-lifted-brightness));border-radius:var(--scalar-radius);box-shadow:var(--scalar-shadow-2);border:none!important;outline:none!important;overflow:hidden!important}[data-v-5c9fc64f] .cm-tooltip-autocomplete ul li{padding:3px 6px!important}[data-v-5c9fc64f] .cm-completionIcon-type:after{color:var(--scalar-color-3)!important}[data-v-5c9fc64f] .cm-tooltip-autocomplete ul li[aria-selected]{background:var(--scalar-background-2)!important;color:var(--scalar-color-1)!important}[data-v-5c9fc64f] .cm-tooltip-autocomplete ul{padding:6px!important;z-index:10000;position:relative}[data-v-5c9fc64f] .cm-tooltip-autocomplete ul li:hover{border-radius:3px;color:var(--scalar-color-1)!important;background:var(--scalar-background-3)!important}[data-v-5c9fc64f] .cm-activeLine,[data-v-5c9fc64f] .cm-activeLineGutter{background-color:transparent}[data-v-5c9fc64f] .cm-selectionMatch,[data-v-5c9fc64f] .cm-matchingBracket{border-radius:var(--scalar-radius);background:var(--scalar-background-4)!important}[data-v-5c9fc64f] .cm-css-color-picker-wrapper{display:inline-flex;outline:1px solid var(--scalar-background-3);border-radius:3px;overflow:hidden}[data-v-5c9fc64f] .cm-gutters{background-color:transparent;border-right:none;color:var(--scalar-color-3);font-size:var(--scalar-mini);line-height:1.44}[data-v-5c9fc64f] .cm-gutterElement{font-family:var(--scalar-font-code)!important;padding:0 6px 0 8px!important;display:flex;align-items:center;justify-content:flex-end}[data-v-5c9fc64f] .cm-gutter+.cm-gutter .cm-gutterElement{padding-left:0!important}.cm-pill{background-color:var(--scalar-background-1);color:var(--tw-bg-base);padding:1.5px 6px;margin:0 6px;display:inline-block;border-radius:30px;font-size:var(--scalar-mini);background:color-mix(in srgb,var(--tw-bg-base),transparent 90%)!important}.dark-mode .cm-pill{background:color-mix(in srgb,var(--tw-bg-base),transparent 80%)!important}.cm-pill:first-of-type{margin-left:0}[data-v-231a70ec] .cm-editor{background-color:var(--scalar-background-1);height:100%;outline:none;width:100%}[data-v-231a70ec] .cm-content{padding:0;display:flex;align-items:center}.scroll-timeline-x[data-v-231a70ec]{scroll-timeline:--scroll-timeline x;scroll-timeline:--scroll-timeline horizontal;-ms-overflow-style:none}.scroll-timeline-x-hidden[data-v-231a70ec]{overflow:auto;scrollbar-width:none}.scroll-timeline-x-hidden[data-v-231a70ec]::-webkit-scrollbar{width:0;height:0}.scroll-timeline-x-address[data-v-231a70ec]{line-height:27px;scrollbar-width:none}.scroll-timeline-x-address[data-v-231a70ec]:after{content:"";position:absolute;height:100%;width:24px;right:0;cursor:text}.scroll-timeline-x-address[data-v-231a70ec]:empty:before{content:"Enter URL or cURL request";color:var(--scalar-color-3);pointer-events:none}.fade-left[data-v-231a70ec],.fade-right[data-v-231a70ec]{content:"";position:sticky;height:100%;animation-name:fadein-231a70ec;animation-duration:1ms;animation-direction:reverse;animation-timeline:--scroll-timeline;z-index:1;pointer-events:none}.fade-left[data-v-231a70ec]{background:linear-gradient(-90deg,color-mix(in srgb,var(--scalar-background-1),transparent 100%) 0%,color-mix(in srgb,var(--scalar-background-1),transparent 20%) 30%,var(--scalar-background-1) 100%);left:0;min-width:3px;animation-direction:normal}.fade-right[data-v-231a70ec]{background:linear-gradient(90deg,color-mix(in srgb,var(--scalar-background-1),transparent 100%) 0%,color-mix(in srgb,var(--scalar-background-1),transparent 20%) 30%,var(--scalar-background-1) 100%);right:0;min-width:24px}@keyframes fadein-231a70ec{0%{opacity:0}1%{opacity:1}}a[data-v-b9a9246e]{text-decoration:none}.ref-search-container[data-v-b9a9246e]{display:flex;flex-direction:column;padding:12px 12px 0}.ref-search-results[data-v-b9a9246e]{padding:12px}.ref-search-meta[data-v-b9a9246e]{background:var(--scalar-background-3);padding:6px 12px;font-size:var(--scalar-font-size-4);color:var(--scalar-color-3);font-weight:var(--scalar-semibold);display:flex;gap:12px}[data-v-92212893] .cm-editor{padding:0}[data-v-92212893] .cm-content{background-color:transparent;font-family:var(--scalar-font);font-size:var(--scalar-mini);padding:6px 8px}[data-v-92212893] .cm-content:has(.cm-pill){padding:4px 8px}[data-v-92212893] .cm-line{padding:0}.filemask[data-v-92212893]{-webkit-mask-image:linear-gradient(to right,transparent 0,var(--scalar-background-2) 20px);mask-image:linear-gradient(to right,transparent 0,var(--scalar-background-2) 20px)}.request-section-content{--scalar-border-width: .5px}.request-section-content-filter{box-shadow:0 -10px 0 10px var(--scalar-background-1)}.request-item:focus-within .request-meta-buttons{opacity:1}.force-text-sm[data-v-223b333c]{--scalar-small: 13px}[data-v-223b333c] .cm-editor{background-color:transparent;font-size:var(--scalar-mini);outline:none;border-radius:var(--scalar-radius);border:.5px solid var(--scalar-border-color)}[data-v-223b333c] .cm-gutters{background-color:var(--scalar-background-1);border-radius:var(--scalar-radius) 0 0 var(--scalar-radius)}.ascii-art-animate .ascii-art-line[data-v-80684d49]{border-right:1ch solid transparent;animation:typewriter-80684d49 4s steps(1) 1s 1 normal both,blinkTextCursor-80684d49 .5s steps(1) infinite normal}@keyframes typewriter-80684d49{0%{width:0}to{width:100%}}@keyframes blinkTextCursor-80684d49{0%{border-right-color:currentColor}50%{border-right-color:transparent}}.dragover-asChild,.dragover-above,.dragover-below{position:relative}.dragover-above:after,.dragover-below:after{content:"";position:absolute;top:-1.5px;height:3px;width:100%;display:block;background:color-mix(in srgb,var(--scalar-color-blue),transparent 85%);pointer-events:none;border-radius:var(--scalar-radius)}.dragover-below:after{top:initial;bottom:-1.5px}.dragover-asChild:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;display:block;background:color-mix(in srgb,var(--scalar-color-blue),transparent 85%);pointer-events:none;border-radius:var(--scalar-radius)}.indent-border-line-offset[data-v-18928cac]:before{left:var(--28f0b1bd)}.indent-padding-left[data-v-18928cac]{padding-left:calc(var(--9782e23e) + 6px)}.editable-sidebar-hover:hover .editable-sidebar-hover-item[data-v-18928cac]{-webkit-mask-image:linear-gradient(to left,transparent 0,var(--scalar-background-2) 20px);mask-image:linear-gradient(to left,transparent 0,var(--scalar-background-2) 20px)}.request-text-color-text[data-v-60c28ddd]{color:var(--scalar-color-1);background:linear-gradient(var(--scalar-background-1),var(--scalar-background-3));box-shadow:0 0 0 1px var(--scalar-border-color)}@media screen and (max-width: 780px){.sidebar-active-hide-layout[data-v-60c28ddd]{display:none}.sidebar-active-width[data-v-60c28ddd]{width:100%;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius)}}.dark-mode .client-wrapper-bg-color[data-v-60c28ddd]{background:linear-gradient(color-mix(in srgb,var(--tw-bg-base) 6%,transparent) 1%,color-mix(in srgb,var(--scalar-background-1) 30%,black) 9%)}.light-mode .client-wrapper-bg-color[data-v-60c28ddd]{background-color:var(--scalar-background-2)!important}.active-link[data-v-f43d5cfd]{background-color:var(--scalar-background-2);color:var(--scalar-color-1);--tw-bg-base: var(--scalar-background-2) }.base-url-variable{color:var(--scalar-color-1)}.base-url[data-v-f5297e83]{color:var(--scalar-color-2);cursor:pointer;font-family:var(--scalar-font-code);display:inline-block;font-size:var(--scalar-micro);min-width:0;white-space:nowrap;text-overflow:ellipsis}.url-select[data-v-eb9d4d8e]{padding:0;min-height:32px;color:var(--scalar-color-1);align-items:center;display:flex;font-size:var(--scalar-micro);font-weight:var(--scalar-regular);gap:3px;height:auto;outline:none;width:100%}.url-select span[data-v-eb9d4d8e]{display:flex;align-items:center}.url-select svg[data-v-eb9d4d8e]{color:var(--scalar-color-2);stroke-width:1}.variable-select[data-v-4b092d90]{padding:9px 9px 9px 0;color:var(--scalar-color-1);align-items:center;border-color:transparent;border-radius:0;border-top:1px solid var(--scalar-border-color);display:flex;font-size:var(--scalar-micro);font-weight:var(--scalar-regular);gap:3px;height:auto;outline:none;width:100%}.variable-select svg[data-v-4b092d90]{color:var(--scalar-color-2);stroke-width:1}.variable-textbox[data-v-fbcac0a4]{padding:9px 9px 9px 0;color:var(--scalar-color-1);align-items:center;border-color:transparent;border-radius:0;border-top:1px solid var(--scalar-border-color);display:flex;font-size:var(--scalar-micro);font-weight:var(--scalar-regular);gap:3px;height:auto;outline:none;width:100%}.variable-container-item[data-v-d5675216]{display:flex;width:100%}.variable-label[data-v-d5675216]{padding:9px 0 9px 9px;color:var(--scalar-color-2);border-top:1px solid var(--scalar-border-color);font-size:var(--scalar-micro)}.variable-label[data-v-d5675216]:after{content:":";margin-right:6px}.server-form-title[data-v-1bd31bc3]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);text-transform:uppercase;display:block}.server-form[data-v-1bd31bc3]{margin-top:6px}.server-form-container[data-v-1bd31bc3]{box-shadow:0 0 0 1px var(--scalar-border-color);border-radius:var(--scalar-radius)}.server-item[data-v-1bd31bc3]{padding:0 9px}.description[data-v-1bd31bc3]{padding:6px 12px;font-size:var(--scalar-small)}.description[data-v-1bd31bc3] .markdown{font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color--1);padding:4px 0;display:block}.description[data-v-1bd31bc3] .markdown>*:first-child{margin-top:0}.card-form[data-v-21a1cfbf]{color:var(--scalar-color-1);width:100%;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius)}.card-form-button[data-v-502d153b]{display:flex;align-items:center;position:relative;background:transparent;cursor:pointer;padding:9px;outline:none;white-space:nowrap;font-family:var(--scalar-font);font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color-2)}.card-form-button[data-v-502d153b]:hover{color:var(--scalar-color-1)}.card-form-group[data-v-88abf5f7]{display:flex}:where(.card-form-rows[data-v-1611fc76]){display:flex;flex-direction:column;width:100%}:where(.card-form-rows[data-v-1611fc76])>*+*{border-top:1px solid var(--scalar-border-color)}.card-form-input[data-v-2c06084d]{background:transparent;position:relative;width:100%;text-align:left;display:flex;align-items:baseline;border-color:inherit}.card-form-input label[data-v-2c06084d],.card-form-input input[data-v-2c06084d]{padding:9px;border:0;outline:none;font-size:var(--scalar-mini);color:var(--scalar-color-2);width:100%;background:transparent;-moz-appearance:none;appearance:none;-webkit-appearance:none;left:0}.card-form-input label[data-v-2c06084d]{width:fit-content;white-space:nowrap;cursor:text;padding:9px 0 9px 9px;border-radius:var(--scalar-radius);font-weight:var(--scalar-semibold)}.card-form-input input[data-v-2c06084d]{position:relative;z-index:99;color:var(--scalar-color-1)}.card-form-input+.card-form-input[data-v-2c06084d]{border-left:1px solid var(--scalar-border-color)}.card-form-input input:not(:placeholder-shown)+label[data-v-2c06084d]{color:var(--scalar-color-2)}.password-mask[data-v-2c06084d]{padding:4px;margin-right:6px;height:24px;width:auto;align-self:center;stroke-width:.75}.wrapper[data-v-0957134f]{display:grid;border-color:inherit}.scopes-label[data-v-0957134f]{display:inline-flex;align-items:center;height:1em;line-height:1;gap:4px}.scopes-label-badge[data-v-0957134f]{display:inline-flex;align-items:center;gap:2px}.scopes-label-badge em[data-v-0957134f]{transform:rotate(10deg) translateY(-.9px)}.floating[data-v-0957134f]{position:relative;z-index:1010}.dropdown[data-v-0957134f]{background:var(--scalar-background-1);filter:brightness(var(--scalar-lifted-brightness));border-radius:var(--scalar-radius);box-shadow:var(--scalar-shadow-2);padding:4px;font-style:normal;display:flex;flex-direction:column;gap:10px}.dropdown-item[data-v-0957134f]{display:grid;grid-template-areas:"check title" "check description";grid-template-columns:auto 1fr;padding:6px 10px 8px 6px;row-gap:2px;column-gap:8px;border-radius:var(--scalar-radius);font-size:var(--scalar-mini);cursor:pointer}.dropdown-item[data-headlessui-state=active][data-v-0957134f],.dropdown-item[data-headlessui-state="active selected"][data-v-0957134f]{background:var(--scalar-background-2)}.dropdown-item-title[data-v-0957134f]{grid-area:title;color:var(--scalar-color-1);font-weight:var(--scalar-semibold)}.dropdown-item-description[data-v-0957134f]{grid-area:description;color:var(--scalar-color-2);line-height:initial}.dropdown-item-check[data-v-0957134f]{all:unset;position:relative;grid-area:check;width:20px;height:20px;color:var(--scalar-color-2);background:var(--scalar-background-1);border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius)}.dropdown-item-check[data-v-0957134f]:checked:after{content:"";position:absolute;border-bottom:1.5px solid currentColor;border-right:1.5px solid currentColor;width:6px;height:12px;top:calc(50% - 1.5px);left:50%;transform:translate(-50%,-50%) rotate(45deg)}.dropdown-item-check[data-v-0957134f]:checked{background:var(--scalar-color-accent);color:var(--scalar-background-1);border:1px solid currentColor}.description[data-v-3bdd11a8]{padding:12px 4px 4px;font-size:var(--scalar-mini)}.cardform-auth-button[data-v-3bdd11a8]{background:var(--scalar-button-1);color:var(--scalar-button-1-color);font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);border-radius:var(--scalar-radius);margin:3px;padding:0 9px;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.cardform-auth-button[data-v-3bdd11a8]:hover{background:var(--scalar-button-1-hover)}.security-scheme-selector[data-v-d4d9bca1]{position:relative;border-radius:var(--scalar-radius);color:var(--scalar-color-3);display:flex;align-items:center;gap:4px;cursor:pointer}.security-scheme-selector[data-v-d4d9bca1]:hover{color:var(--scalar-color-1)}.security-scheme-label[data-v-d4d9bca1]{color:var(--scalar-color-3);font-size:var(--scalar-mini)}.security-scheme-selector:hover .security-scheme-label[data-v-d4d9bca1]{color:var(--scalar-color-1)}.security-scheme-selector select[data-v-d4d9bca1]{position:absolute;cursor:pointer;opacity:0;right:0;-moz-appearance:none;-webkit-appearance:none;appearance:none;width:100%;margin-top:-5px;padding:10px 0}.security-scheme-selector svg[data-v-d4d9bca1]{width:12px;stroke:currentColor}.authentication-header[data-v-9052a928]{white-space:nowrap}.selector[data-v-9052a928]{margin-bottom:6px}.client-libraries-content[data-v-ab6bf947]{container:client-libraries-content / inline-size;display:flex;justify-content:center;overflow:hidden;padding:3px;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius) var(--scalar-radius) 0 0}.client-libraries[data-v-ab6bf947]{display:flex;align-items:center;justify-content:center;width:100%;position:relative;cursor:pointer;white-space:nowrap;padding:5px;gap:6px;color:var(--scalar-color-3);border-radius:var(--scalar-radius);border:.5px solid transparent;-webkit-user-select:none;user-select:none}.client-libraries[data-v-ab6bf947]:hover{color:var(--scalar-color-1)}@media screen and (max-width: 450px){.client-libraries[data-v-ab6bf947]:nth-of-type(4),.client-libraries[data-v-ab6bf947]:nth-of-type(5){display:none}}.client-libraries-icon[data-v-ab6bf947]{max-width:14px;max-height:14px;min-width:14px;width:100%;aspect-ratio:1;display:flex;align-items:center;justify-content:center;position:relative;box-sizing:border-box;color:currentColor}.client-libraries-icon__more svg[data-v-ab6bf947]{height:initial}@container client-libraries-content (width < 400px){.client-libraries__select[data-v-ab6bf947]{width:fit-content}.client-libraries__select .client-libraries-icon__more+span[data-v-ab6bf947]{display:none}}@container client-libraries-content (width < 380px){.client-libraries[data-v-ab6bf947]{width:100%}.client-libraries span[data-v-ab6bf947]{display:none}}.client-libraries__active[data-v-ab6bf947]{background-color:var(--scalar-background-2);color:var(--scalar-color-1);border-color:var(--scalar-border-color);filter:brightness(var(--scalar-lifted-brightness))}@keyframes codeloader-ab6bf947{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.client-libraries span[data-v-ab6bf947]{font-size:var(--scalar-mini);font-weight:var(--scalar-semibold)}.client-libraries__active span[data-v-ab6bf947]{color:var(--scalar-color-1)}.client-libraries__select select[data-v-ab6bf947]{background:var(--scalar-background-3);color:var(--scalar-color-2);opacity:0;height:100%;width:100%;aspect-ratio:1;position:absolute;top:0;left:0;cursor:pointer;z-index:1;-moz-appearance:none;-webkit-appearance:none;appearance:none;border:none}.client-libraries__select span[data-v-ab6bf947]{position:relative;display:flex;align-items:center}@media screen and (max-width: 600px){.references-classic .client-libraries[data-v-ab6bf947]{flex-direction:column}}.selected-client[data-v-301043da]{color:var(--scalar-color-1);font-size:var(--scalar-mini);font-family:var(--scalar-font-code);padding:9px 12px;border:1px solid var(--scalar-border-color);border-top:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:12px;border-radius:0 0 var(--scalar-radius) var(--scalar-radius)}.client-libraries-heading[data-v-301043da]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);text-transform:uppercase;margin-bottom:6px;display:block}.badge[data-v-190574ac]{color:var(--scalar-color-2);font-size:var(--scalar-micro);background:var(--scalar-background-2);padding:2px 6px;border-radius:12px;font-weight:var(--scalar-semibold);display:inline-block;text-transform:uppercase}.section[data-v-7bdc2dab]{position:relative;display:flex;flex-direction:column;max-width:var(--refs-content-max-width);margin:auto;padding:90px 0;scroll-margin-top:var(--refs-header-height)}.references-classic .section[data-v-7bdc2dab]{padding:48px 0;gap:24px}@container narrow-references-container (max-width: 900px){.references-classic .section[data-v-7bdc2dab],.section[data-v-7bdc2dab]{padding:48px 24px}}.section[data-v-7bdc2dab]:not(:last-of-type){border-bottom:1px solid var(--scalar-border-color)}.section-wrapper[data-v-07cabcb0]{color:var(--scalar-color-1);padding-top:12px;margin-top:-12px}.section-accordion[data-v-07cabcb0]{display:flex;flex-direction:column;border-radius:var(--scalar-radius-lg);background:var(--scalar-background-2)}.section-accordion-transparent[data-v-07cabcb0]{background:transparent;border:1px solid var(--scalar-border-color)}.section-accordion-button[data-v-07cabcb0]{padding:6px}.section-accordion-button[data-v-07cabcb0]{display:flex;align-items:center;gap:6px;cursor:pointer}.section-accordion-button-content[data-v-07cabcb0]{flex:1;min-width:0}.section-accordion-button-actions[data-v-07cabcb0]{display:flex;align-items:center;gap:6px;color:var(--scalar-color-3)}.section-accordion-chevron[data-v-07cabcb0]{margin-right:4px;width:20px;cursor:pointer;opacity:1;color:var(--scalar-color-3)}.section-accordion-button:hover .section-accordion-chevron[data-v-07cabcb0]{color:var(--scalar-color-1)}.section-accordion-content[data-v-07cabcb0]{border-top:1px solid var(--scalar-border-color);display:flex;flex-direction:column}.section-accordion-description[data-v-07cabcb0]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color--1);padding:10px 12px 0}.section-accordion-content-card[data-v-07cabcb0] .property:last-of-type{padding-bottom:9px}.section-column[data-v-d64e7382]{flex:1;min-width:0}.section-column[data-v-d64e7382]:nth-of-type(2){padding-top:48px}@container narrow-references-container (max-width: 900px){.section-column[data-v-d64e7382]:nth-of-type(2){padding-top:0}}.section-columns[data-v-8b9602bf]{display:flex;gap:48px}@container narrow-references-container (max-width: 900px){.section-columns[data-v-8b9602bf]{flex-direction:column;gap:24px}}.section-container[data-v-34b26958]{position:relative;padding:0 60px;width:100%}.section-container[data-v-34b26958]:last-of-type{border-top:1px solid var(--scalar-border-color)}@container narrow-references-container (max-width: 900px){.section-container[data-v-34b26958]{padding:0}}.section-accordion-wrapper[data-v-2049975e]{padding:0 60px}.section-accordion[data-v-2049975e]{position:relative;width:100%;max-width:var(--refs-content-max-width);margin:auto}.section-accordion-content[data-v-2049975e]{display:flex;flex-direction:column;gap:12px;padding-top:12px}.section-accordion-button[data-v-2049975e]{width:100%;display:flex;cursor:pointer;padding:6px 0;margin:-6px 0;border-radius:var(--scalar-radius)}.section-accordion-chevron[data-v-2049975e]{width:24px;position:absolute;left:-24px;height:auto;top:10px;color:var(--scalar-color-3)}.section-accordion-button:hover .section-accordion-chevron[data-v-2049975e]{color:var(--scalar-color-1)}.section-accordion-title[data-v-2049975e]{display:flex;flex-direction:column;align-items:flex-start;flex:1;padding:0 6px}.section-accordion-title[data-v-2049975e] .section-header{margin-bottom:0}@container narrow-references-container (max-width: 900px){.section-accordion-chevron[data-v-2049975e]{width:16px;left:-16px;top:14px}.section-accordion-wrapper[data-v-2049975e]{padding:calc(var(--refs-header-height)) 24px 0 24px}}.loading[data-v-c90b2c46]{background:var(--scalar-background-3);animation:loading-skeleton-c90b2c46 1.5s infinite alternate;border-radius:var(--scalar-radius-lg);min-height:1.6em;margin:.6em 0;max-width:100%}.loading[data-v-c90b2c46]:first-of-type{min-height:3em;margin-bottom:24px;margin-top:0}.loading[data-v-c90b2c46]:last-of-type{width:60%}.loading.single-line[data-v-c90b2c46]{min-height:3em;margin:.6em 0;max-width:80%}@keyframes loading-skeleton-c90b2c46{0%{opacity:1}to{opacity:.33}}@container narrow-references-container (max-width: 900px){.section-content--with-columns[data-v-9735459e]{flex-direction:column;gap:24px}}.section-header[data-v-3bd1b9f0]{font-size:var(--font-size, var(--scalar-heading-2));font-weight:var(--font-weight, var(--scalar-bold));color:var(--scalar-color-1);word-wrap:break-word;line-height:1.45;margin-top:0;margin-bottom:12px}.section-header.tight[data-v-3bd1b9f0]{margin-bottom:6px}.section-header.loading[data-v-3bd1b9f0]{width:80%}.introduction-description-heading[data-v-61b651b9]{scroll-margin-top:64px}.introduction-description[data-v-61b651b9]{display:flex;flex-direction:column;gap:18px}.references-classic .introduction-description[data-v-61b651b9] img{max-width:720px}.download-cta[data-v-810904a4]{margin-bottom:24px}.download-cta .download-button[data-v-810904a4]{color:var(--scalar-color-accent);text-decoration:var(--scalar-text-decoration)!important;font-size:var(--scalar-paragraph);cursor:pointer}.download-cta .download-button[data-v-810904a4]:hover{text-decoration:var(--scalar-text-decoration-hover)!important}.heading[data-v-83f73a98]{margin-top:0!important;word-wrap:break-word}.loading[data-v-83f73a98]{background:var(--scalar-background-3);animation:loading-skeleton 1.5s infinite alternate;border-radius:var(--scalar-radius-lg)}.badges[data-v-83f73a98]{display:flex;align-items:center;gap:4px;margin-bottom:3px}.heading.loading[data-v-83f73a98]{width:80%}.introduction-section[data-v-83f73a98]{gap:48px}.sticky-cards[data-v-83f73a98]{display:flex;flex-direction:column;position:sticky;top:calc(var(--refs-header-height) + 24px)}.screenreader-only[data-v-681ebf2c]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.label[data-v-d9801d4e]{position:relative;display:inline-block}.anchor[data-v-d9801d4e]{position:relative;display:inline-block;opacity:0}.anchor-copy[data-v-d9801d4e]{position:absolute;left:0;top:50%;transform:translateY(-50%);cursor:pointer;padding:0 6px;color:var(--scalar-color-3);font-weight:var(--scalar-semibold);font-size:.8em}.anchor-copy[data-v-d9801d4e]:hover,.anchor-copy[data-v-d9801d4e]:focus-visible{color:var(--scalar-color-2)}.label:hover .anchor[data-v-d9801d4e]{opacity:1}.text-select{position:relative;height:fit-content}.text-select--single-option{pointer-events:none}.text-select select{border:none;outline:none;cursor:pointer;background:var(--scalar-background-3);box-shadow:-2px 0 0 0 var(--scalar-background-3);position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.text-select span{font-size:var(--scalar-mini);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);white-space:nowrap;display:flex;align-items:center;justify-content:center}.text-select:hover span{color:var(--scalar-color-1)}.text-select:not(.text-select--single-option) span:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-2px,0);display:block;margin-left:6px;box-shadow:1px 1px 0 currentColor}.text-select span:hover{background:var(--scalar-background-2)}.example-selector[data-v-090632a2]{padding:4px}.scalar-card[data-v-dcabb131]{all:unset;font-family:var(--scalar-font);border-radius:var(--scalar-radius-lg);overflow:hidden;border:1px solid var(--scalar-border-color);background:var(--scalar-background-2);display:flex;flex-direction:column;max-height:calc(((var(--full-height) - var(--refs-header-height)) - 60px) / 2);position:relative}.scalar-card-sticky[data-v-dcabb131]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.scalar-card-content[data-v-1c1d215c]{overflow:auto;border-bottom:1px solid var(--scalar-border-color);display:grid}.scalar-card-content[data-v-1c1d215c] .simple-table .simple-header{display:none}.scalar-card-content[data-v-1c1d215c]:last-of-type,.scalar-card-content.scalar-card--borderless[data-v-1c1d215c]{border-bottom:none}.scalar-card--muted[data-v-1c1d215c]{background:var(--scalar-background-2)}.scalar-card--contrast[data-v-1c1d215c]{background:var(--scalar-background-3)}.scalar-card--frameless[data-v-1c1d215c]{padding:0}.scalar-card--transparent[data-v-1c1d215c]{background:var(--scalar-background-1)}.scalar-card-header[data-v-ef7873bc]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);padding:9px 3px 9px 12px;flex-shrink:0}.scalar-card-header.scalar-card--borderless[data-v-ef7873bc]+.scalar-card-content{margin-top:-9px}.scalar-card-header-slots[data-v-ef7873bc]{display:flex;justify-content:space-between;line-height:1.35}.scalar-card-header-title[data-v-ef7873bc]{text-transform:uppercase;flex:1;min-width:0;text-overflow:ellipsis;overflow:hidden}.scalar-card-header-actions[data-v-ef7873bc]{display:flex}.scalar-card-footer[data-v-918ab8d6]{flex-shrink:0}.tab-list[data-v-03fdb072]{display:flex;gap:6px;position:relative;flex:1;padding:9px 12px;overflow:auto}.scalar-card-header.scalar-card-header-tabs[data-v-03fdb072]{padding:0}.tab[data-v-f373ecc2]{background:none;border:none;font-size:var(--scalar-mini);font-family:var(--scalar-font);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);line-height:calc(var(--scalar-mini) + 2px);white-space:nowrap;cursor:pointer;padding:0;margin-right:3px;text-transform:uppercase;position:relative;line-height:1.35}.tab[data-v-f373ecc2]:before{content:"";position:absolute;z-index:0;left:-6px;top:-6px;width:calc(100% + 12px);height:calc(100% + 12px);border-radius:var(--scalar-radius);background:var(--scalar-background-3);opacity:0}.tab[data-v-f373ecc2]:hover:before{opacity:1}.tab span[data-v-f373ecc2]{z-index:1;position:relative}.tab-selected[data-v-f373ecc2]{color:var(--scalar-color-1);text-decoration:underline;text-underline-offset:var(--scalar-micro)}.request[data-v-eedd3e3e]{display:flex;flex-wrap:nowrap}.request-header[data-v-eedd3e3e]{display:flex;gap:6px;text-transform:initial}.request-method[data-v-eedd3e3e]{font-family:var(--scalar-font-code);text-transform:uppercase}.request-client-picker[data-v-eedd3e3e]{padding-left:12px;padding-right:9px}.request-card-footer[data-v-eedd3e3e]{display:flex;justify-content:flex-end;padding:6px;flex-shrink:0}.request-card-footer-addon[data-v-eedd3e3e]{display:flex;align-items:center;flex:1;min-width:0}.request-editor-section[data-v-eedd3e3e]{display:flex;flex:1}.code-snippet[data-v-eedd3e3e]{display:flex;flex-direction:column;width:100%}.schema-type-icon[data-v-c0a69ad0]{color:var(--scalar-color-1)}.schema-type[data-v-c0a69ad0]{font-family:var(--scalar-font-code)}.property-detail[data-v-16d94ef5]{display:inline-flex}.property-detail+.property-detail[data-v-16d94ef5]:before{display:block;content:"";margin:0 .5ch}.property-detail-truncate[data-v-16d94ef5]{overflow:hidden}.property-detail-truncate>.property-detail-value[data-v-16d94ef5]{overflow:hidden;text-overflow:ellipsis}.property-detail-prefix[data-v-16d94ef5]{color:var(--scalar-color-3)}code.property-detail-value[data-v-16d94ef5]{font-family:var(--scalar-font-code);font-size:var(--scalar-font-size-3);color:var(--scalar-color-2);background:var(--scalar-background-3);padding:1px 3px;border-radius:var(--scalar-radius)}.property-heading[data-v-38a47495]{display:flex;align-items:center;gap:9px;white-space:nowrap}.property-name[data-v-38a47495]{font-family:var(--scalar-font-code)}.property-additional[data-v-38a47495]{font-size:var(--scalar-font-size-3)}.property-required[data-v-38a47495],.property-optional[data-v-38a47495]{color:var(--scalar-color-2)}.property-required[data-v-38a47495]{text-transform:capitalize;color:var(--scalar-color-orange)}.property-read-only[data-v-38a47495],.property-write-only[data-v-38a47495]{font-size:var(--scalar-font-size-3);color:var(--scalar-color-blue)}.property-details[data-v-38a47495]{font-size:var(--scalar-font-size-3);color:var(--scalar-color-2);display:flex;align-items:center;min-width:0}.property-const[data-v-38a47495]{color:var(--scalar-color-1)}.property[data-v-fb06e93b]{color:var(--scalar-color-1);padding:10px;font-size:var(--scalar-mini)}.property[data-v-fb06e93b]:last-of-type{padding-bottom:0}.property--compact.property--level-0[data-v-fb06e93b]{padding:10px 0}.property--deprecated[data-v-fb06e93b]{background:repeating-linear-gradient(-45deg,var(--scalar-background-2) 0,var(--scalar-background-2) 2px,transparent 2px,transparent 5px);background-size:100%}.property--deprecated[data-v-fb06e93b]>*{opacity:.75}.property-description[data-v-fb06e93b]{margin-top:6px;line-height:1.4;font-size:var(--scalar-small)}[data-v-fb06e93b] .property-description *{color:var(--scalar-color-2)!important}.property[data-v-fb06e93b]:not(:last-of-type){border-bottom:1px solid var(--scalar-border-color)}.children[data-v-fb06e93b]{display:flex;flex-direction:column;padding-top:8px}.property-example[data-v-fb06e93b]{display:flex;flex-direction:column;gap:6px;margin-top:6px;padding:6px;max-height:calc(((var(--full-height) - var(--refs-header-height))) / 2);font-size:var(--scalar-micro);border:1px solid var(--scalar-border-color);background:var(--scalar-background-2);border-radius:var(--scalar-radius-lg)}.property-example-label[data-v-fb06e93b]{font-weight:var(--scalar-semibold);color:var(--scalar-color-3)}.property-example-value[data-v-fb06e93b]{font-family:var(--scalar-font-code);white-space:pre}.property-rule[data-v-fb06e93b]{display:flex;flex-direction:column;gap:6px;margin-top:12px;border-radius:var(--scalar-radius-lg)}.property-enum-value[data-v-fb06e93b]{padding:3px 0;color:var(--scalar-color-2)}.property-enum-value[data-v-fb06e93b]:before{content:"";margin-right:6px;color:var(--scalar-color-3)}.property-enum-values[data-v-fb06e93b]{margin-top:8px;list-style:none}.property--compact .property-example[data-v-fb06e93b]{display:none}.property-list[data-v-fb06e93b]{border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius);margin-top:10px}.property-list .property[data-v-fb06e93b]:last-of-type{padding-bottom:10px}.property-name[data-v-fb06e93b]{font-family:var(--scalar-font-code)}.error[data-v-25443e6c]{background-color:var(--scalar-color-red)}.schema-card[data-v-25443e6c]{z-index:0;position:relative;font-size:var(--scalar-font-size-4);color:var(--scalar-color-1)}.schema-card-title[data-v-25443e6c]{--schema-title-height: 38px;height:var(--schema-title-height);padding:10px 12px;display:flex;align-items:center;gap:4px;color:var(--scalar-color-2);font-weight:var(--scalar-semibold);font-size:var(--scalar-micro);background:var(--scalar-background-1);border-radius:var(--scalar-radius-lg);border-bottom:1px solid transparent}button.schema-card-title[data-v-25443e6c]{cursor:pointer}button.schema-card-title[data-v-25443e6c]:hover{color:var(--scalar-color-1)}.schema-card-title-icon[data-v-25443e6c]{margin-left:-4px}.schema-card-title-icon--open[data-v-25443e6c]{transform:rotate(90deg)}.schema-properties-open>.schema-card-title[data-v-25443e6c]{z-index:1;position:sticky;top:var(--refs-header-height);border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid var(--scalar-border-color)}.schema-properties-open>.schema-properties[data-v-25443e6c]{width:fit-content}.schema-card-description+.schema-properties[data-v-25443e6c]{width:fit-content}.schema-properties-open.schema-properties[data-v-25443e6c],.schema-properties-open>.schema-card--open[data-v-25443e6c]{width:100%}.schema-card .property[data-v-25443e6c]:last-of-type{padding-bottom:10px}.schema-properties[data-v-25443e6c]{display:flex;flex-direction:column;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg)}.schema-card--compact[data-v-25443e6c]{align-self:start}.schema-card--compact.schema-card--open[data-v-25443e6c]{align-self:initial}.schema-card-title--compact[data-v-25443e6c]{color:var(--scalar-color-3);padding:6px 10px;height:auto;border-bottom:none}.schema-card--compact>.schema-properties[data-v-25443e6c],.schema-card-title--compact[data-v-25443e6c]{border-radius:13.5px}.schema-card-title--compact>.schema-card-title-icon[data-v-25443e6c]{width:10px;height:10px;margin:0}.schema-card-title--compact>.schema-card-title-icon--open[data-v-25443e6c]{transform:rotate(45deg)}.schema-properties-open>.schema-card-title--compact[data-v-25443e6c]{position:static}.schema-card--compact.schema-card--level-0>.schema-properties[data-v-25443e6c]{border:none}[data-v-25443e6c] .schema-card-description p{font-size:var(--scalar-mini, var(--scalar-paragraph));color:var(--scalar-color-2);line-height:1.5;display:block;margin-bottom:6px}.schema-card-description[data-v-25443e6c]:first-of-type{padding-top:10px}.children .schema-card-description[data-v-25443e6c]:first-of-type{padding-top:0}.parameter-item[data-v-f70ee55c]{border-top:1px solid var(--scalar-border-color)}.parameter-item:last-of-type .parameter-schema[data-v-f70ee55c]{padding-bottom:0}.parameter-item-container[data-v-f70ee55c]{padding:0}.parameter-item-name[data-v-f70ee55c]{font-weight:500;margin-right:6px;font-family:var(--scalar-font-code);font-size:var(--scalar-mini);color:var(--scalar-color-1)}.parameter-item-type[data-v-f70ee55c],.parameter-item-required-optional[data-v-f70ee55c]{color:var(--scalar-color-3);font-weight:var(--scalar-semibold);margin-right:6px;position:relative}.parameter-item--required[data-v-f70ee55c]{text-transform:uppercase;font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color-orange)}.parameter-item-description[data-v-f70ee55c]{margin-top:3px!important;font-size:var(--scalar-small);color:var(--scalar-color-2);line-height:1.4}.parameter-item-description[data-v-f70ee55c] p{margin-top:4px;font-size:var(--scalar-small);color:var(--scalar-color-2);line-height:1.4}.parameter-schema[data-v-f70ee55c]{padding-bottom:9px;margin-top:3px}.parameters[data-v-45fca787]{margin-top:24px}.parameters-title[data-v-45fca787]{font-size:var(--scalar-heading-4);font-weight:var(--scalar-semibold);color:var(--scalar-color-1);line-height:1.45;margin-top:12px;margin-bottom:12px}.parameter-list[data-v-45fca787]{list-style:none;padding:0;margin:0 0 12px;font-size:var(--scalar-small)}.request-body-title[data-v-23ed11af]{display:flex;align-items:center;font-size:var(--scalar-heading-4);font-weight:var(--scalar-semibold);color:var(--scalar-color-1);line-height:1.45;margin-top:24px;padding-bottom:12px;border-bottom:1px solid var(--scalar-border-color);flex-flow:wrap}.request-body-title-select[data-v-23ed11af]{position:relative;padding-left:9px;height:fit-content;color:var(--scalar-color-2);font-size:var(--scalar-font-size-3);display:flex;align-items:center}.request-body-title-no-select.request-body-title-select[data-v-23ed11af]{pointer-events:none}.request-body-title-no-select.request-body-title-select[data-v-23ed11af]:after{display:none}.request-body-title-select span[data-v-23ed11af]{display:flex;align-items:center}.request-body-title-select[data-v-23ed11af]:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-4px,0);display:block;margin-left:7px;box-shadow:1px 1px 0 currentColor}.request-body-title-select select[data-v-23ed11af]{border:none;outline:none;cursor:pointer;background:var(--scalar-background-3);box-shadow:-2px 0 0 0 var(--scalar-background-3);position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.request-body-title-select[data-v-23ed11af]:hover{color:var(--scalar-color-1)}.request-body-description[data-v-23ed11af]{margin-top:6px;font-size:var(--scalar-small);width:100%}.request-body-description[data-v-23ed11af] .markdown *{color:var(--scalar-color-2)!important}@media (max-width: 460px){.request-body-title-select[data-v-23ed11af]{margin-left:auto;padding-right:3px}}.endpoint-path[data-v-a4eadd9b]{overflow:hidden;word-wrap:break-word;font-weight:var(--scalar-semibold)}.deprecated[data-v-a4eadd9b]{text-decoration:line-through}.empty-state[data-v-9fd95437]{margin:10px 0 10px 12px;text-align:center;font-size:var(--scalar-micro);min-height:56px;display:flex;align-items:center;justify-content:center;border-radius:var(--scalar-radius-lg);color:var(--scalar-color-2)}.rule-title[data-v-9fd95437]{font-family:var(--scalar-font-code);color:var(--scalar-color-1);display:inline-block;margin:12px 0 6px;border-radius:var(--scalar-radius)}.rule[data-v-9fd95437]{margin:0 12px;border-radius:var(--scalar-radius-lg)}.rule-items[data-v-9fd95437]{counter-reset:list-number;display:flex;flex-direction:column;gap:12px;border-left:1px solid var(--scalar-border-color);padding:12px 0}.rule-item[data-v-9fd95437]{counter-increment:list-number;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg);overflow:hidden;margin-left:24px}.rule-item[data-v-9fd95437]:before{border:1px solid var(--scalar-border-color);border-top:0;border-right:0;content:" ";display:block;width:24px;height:6px;border-radius:0 0 0 var(--scalar-radius-lg);margin-top:6px;color:var(--scalar-color-2);transform:translate(-25px);color:var(--scalar-color-1);position:absolute}.markdown[data-v-778ab953] *{margin:0}.code-copy[data-v-778ab953]{display:flex;align-items:center;justify-content:center;-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--scalar-color-3);border:none;padding:0;margin-right:12px}.code-copy[data-v-778ab953]:hover{color:var(--scalar-color-1)}.code-copy svg[data-v-778ab953]{width:13px;height:13px}.response-card-footer[data-v-778ab953]{display:flex;flex-direction:column;flex-shrink:0;padding:10px 12px;gap:8px;border-top:1px solid var(--scalar-border-color)}.response-example-selector[data-v-778ab953]{align-self:start;margin:-4px}.response-description[data-v-778ab953]{font-weight:var(--scalar-semibold);font-size:var(--scalar-micro);color:var(--scalar-color--1);display:flex;align-items:center;box-sizing:border-box}.schema-type[data-v-778ab953]{font-size:var(--scalar-micro);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);background:var(--scalar-background-3);padding:2px 4px;border-radius:4px;margin-right:4px}.schema-example[data-v-778ab953]{font-size:var(--scalar-micro);color:var(--scalar-color-2);font-weight:var(--scalar-semibold)}.example-response-tab[data-v-778ab953]{display:block;margin:6px}.scalar-card-container[data-v-778ab953]{flex:1;background:var(--scalar-background-2);display:grid}.scalar-card-container[data-v-778ab953] .cm-scroller{overflow-y:hidden}.scalar-card-checkbox[data-v-778ab953]{display:flex;align-items:center;justify-content:center;position:relative;min-height:17px;cursor:pointer;-webkit-user-select:none;user-select:none;font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-2);width:fit-content;white-space:nowrap;margin-right:9px;gap:6px}.scalar-card-checkbox[data-v-778ab953]:hover{color:var(--scalar-color--1)}.scalar-card-checkbox .scalar-card-checkbox-input[data-v-778ab953]{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.scalar-card-checkbox-checkmark[data-v-778ab953]{height:17px;width:17px;border-radius:var(--scalar-radius);background-color:transparent;background-color:var(--scalar-background-3);box-shadow:inset 0 0 0 1px var(--scalar-border-color)}.scalar-card-checkbox[data-v-778ab953]:has(.scalar-card-checkbox-input:checked){color:var(--scalar-color-1)}.scalar-card-checkbox .scalar-card-checkbox-input:checked~.scalar-card-checkbox-checkmark[data-v-778ab953]{background-color:var(--scalar-button-1);box-shadow:none}.scalar-card-checkbox-checkmark[data-v-778ab953]:after{content:"";position:absolute;display:none}.scalar-card-checkbox .scalar-card-checkbox-input:checked~.scalar-card-checkbox-checkmark[data-v-778ab953]:after{display:block}.scalar-card-checkbox .scalar-card-checkbox-checkmark[data-v-778ab953]:after{right:6px;top:36.5%;width:5px;height:9px;border:solid 1px var(--scalar-button-1-color);border-width:0 1.5px 1.5px 0;transform:rotate(45deg)}.show-api-client-button[data-v-8620cd40]{-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;padding:4px 6px;white-space:nowrap;border-radius:var(--scalar-radius);display:flex;justify-content:center;align-items:center;font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-background-2);font-family:var(--scalar-font);background:var(--scalar-button-1);position:relative;cursor:pointer;box-sizing:border-box;box-shadow:inset 0 0 0 1px #0000001a}.show-api-client-button span[data-v-8620cd40],.show-api-client-button svg[data-v-8620cd40]{fill:currentColor;color:var(--scalar-button-1-color);z-index:1}.show-api-client-button[data-v-8620cd40]:hover{background:var(--scalar-button-1-hover)}.show-api-client-button svg[data-v-8620cd40]{margin-right:4px}.examples[data-v-e99da259]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.deprecated[data-v-e99da259] *{text-decoration:line-through}.example-path[data-v-e99da259]{color:var(--scalar-color-2);font-family:var(--scalar-font-code)}.example-path[data-v-e99da259] em{color:var(--scalar-color-1)}.endpoint-details-card[data-v-f94bee14]{display:flex;flex-direction:column;gap:12px}.endpoint-details-card-item[data-v-f94bee14]{border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg);margin-top:0}.endpoint-details-card[data-v-f94bee14] .parameter-list:first-of-type:last-of-type{margin:0}.endpoint-details-card[data-v-f94bee14] .parameter-item:last-of-type .parameter-schema{padding-bottom:12px}.endpoint-details-card[data-v-f94bee14] .parameter-list .parameter-list{margin-bottom:12px}.endpoint-details-card[data-v-f94bee14] .parameter-list li{margin:0;padding:0 9px}.endpoint-details-card[data-v-f94bee14] .property{padding:9px;margin:0}.endpoint-details-card[data-v-f94bee14] .endpoint-title,.endpoint-details-card[data-v-f94bee14] .parameters-title,.endpoint-details-card[data-v-f94bee14] .request-body-title{text-transform:uppercase;font-weight:var(--scalar-bold);font-size:var(--scalar-mini);color:var(--scalar-color-2);line-height:1.33;padding:9px;margin:0}.endpoint-details-card[data-v-f94bee14] .request-body-title-select{text-transform:initial;font-weight:initial;margin-left:auto}.endpoint-header[data-v-28101aa3]{display:flex;justify-content:space-between}.endpoint-details[data-v-28101aa3]{display:flex;align-items:center;margin-top:0;gap:9px;min-width:0;flex-shrink:1}.endpoint-type[data-v-28101aa3]{display:flex;align-items:center;justify-content:center;gap:6px;position:relative;z-index:0;width:60px;padding:6px;flex-shrink:0;font-size:var(--scalar-small);text-transform:uppercase;font-weight:var(--scalar-bold);font-family:var(--scalar-font)}.endpoint-type[data-v-28101aa3]:after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;background:currentColor;opacity:.15;border-radius:var(--scalar-radius-lg)}.endpoint-anchor[data-v-28101aa3]{display:flex;align-items:center;min-width:0;flex-shrink:1;font-size:20px}.endpoint-anchor.label[data-v-28101aa3]{display:flex}.endpoint-label[data-v-28101aa3]{display:flex;align-items:baseline;gap:9px;min-width:0;flex-shrink:1;color:var(--scalar-color-1)}.endpoint-label-path[data-v-28101aa3]{font-family:var(--scalar-font-code);font-size:var(--scalar-mini);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.endpoint-label-path[data-v-28101aa3] em{color:var(--scalar-color-2)}.endpoint-label-name[data-v-28101aa3]{color:var(--scalar-color-2);font-size:var(--scalar-small);flex-shrink:1000000000;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.endpoint-try-hint[data-v-28101aa3]{padding:2px;height:24px;width:24px;flex-shrink:0}.endpoint-copy[data-v-28101aa3]{color:currentColor;padding:2px}.endpoint-copy[data-v-28101aa3] svg{stroke-width:2px}.endpoint-content[data-v-28101aa3]{display:grid;grid-template-columns:repeat(3,1fr);gap:9px;padding:9px}@container (max-width: 900px){.endpoint-content[data-v-28101aa3]{grid-template-columns:1fr}}.endpoint-content[data-v-28101aa3]>*{max-height:unset}.show-more[data-v-481def22]{background:var(--scalar-background-1);-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border:1px solid var(--scalar-border-color);margin:-48px auto 48px;padding:8px 12px;border-radius:30px;color:var(--scalar-color-1);font-weight:var(--scalar-semibold);font-size:var(--scalar-small);display:flex;align-items:center;justify-content:center;position:relative}.show-more[data-v-481def22]:hover{color:var(--scalar-color-2);cursor:pointer}.show-more-icon[data-v-481def22]{width:14px!important;height:14px!important;margin-left:3px}.show-more[data-v-481def22]:active{box-shadow:0 0 0 1px var(--scalar-border-color)}@container narrow-references-container (max-width: 900px){.show-more[data-v-481def22]{margin-top:-25px;margin-bottom:25px}}@media (max-width: 1165px){.show-more[data-v-481def22]{margin-top:-24px;margin-bottom:24px}}.endpoints[data-v-f0ef5b24]{overflow:auto;background:var(--scalar-background-2);padding:10px 12px}@media (max-width: 580px){.endpoints[data-v-f0ef5b24]{max-height:calc(100vh - 150px)}}.endpoints span+span[data-v-f0ef5b24]{text-align:left;margin-left:12px;text-transform:initial}.endpoint[data-v-f0ef5b24]{display:flex;white-space:nowrap;cursor:pointer}.endpoint span[data-v-f0ef5b24]:first-of-type{text-transform:uppercase}.endpoint .post[data-v-f0ef5b24],.endpoint .get[data-v-f0ef5b24],.endpoint .delete[data-v-f0ef5b24],.endpoint .put[data-v-f0ef5b24]{white-space:nowrap}.endpoint span[data-v-f0ef5b24]{color:var(--scalar-color-1);min-width:62px;display:inline-block;text-align:right;line-height:1.55;font-family:var(--scalar-font-code);font-size:var(--scalar-small);cursor:pointer}.section-container[data-v-e7d35918]{border-top:1px solid var(--scalar-border-color)}.tag-section[data-v-2a212e36]{margin-bottom:48px}.tag-name[data-v-2a212e36]{text-transform:capitalize}.tag-description[data-v-2a212e36]{padding-bottom:4px}.references-loading{position:absolute;top:0;left:0;right:0;z-index:1;grid-area:rendered;background:var(--scalar-background-1)}.references-loading-top-spacer{top:-1px}@media (min-width: 1001px){.references-loading-top-spacer{top:calc(var(--refs-header-height) - 1px)}}.references-loading-hidden-tag .section-container .section:first-child{display:none}.show-more[data-v-f19478dd]{margin-top:24px}.reference-models[data-v-304ad700]{margin-bottom:48px}.reference-models-anchor[data-v-304ad700]{display:flex;align-items:center;font-size:20px;padding-left:6px;color:var(--scalar-color-1)}.reference-models-label[data-v-304ad700]{font-size:var(--scalar-mini)}.reference-models-label[data-v-304ad700] em{font-weight:var(--scalar-bold)}.narrow-references-container{container-name:narrow-references-container;container-type:inline-size}.render-loading[data-v-0b17f72e]{height:calc(var(--full-height) - var(--refs-header-height));display:flex;align-items:center;justify-content:center}.introduction-card[data-v-0b17f72e]{display:flex;flex-direction:column;gap:12px;padding:12px 12px 0;background:var(--scalar-background-1);border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg)}.introduction-card[data-v-0b17f72e] .description{padding:0}.introduction-card-title[data-v-0b17f72e]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3)}.introduction-card-row[data-v-0b17f72e]{flex-flow:row wrap;gap:24px}.introduction-card-row[data-v-0b17f72e]>*{flex:1}@media (min-width: 600px){.introduction-card-row[data-v-0b17f72e]>*{min-width:min-content}}@media (max-width: 600px){.introduction-card-row[data-v-0b17f72e]>*{max-width:100%}}@container (max-width: 900px){.introduction-card-row[data-v-0b17f72e]{flex-direction:column;align-items:stretch}}.introduction-card[data-v-0b17f72e] .security-scheme-label{text-transform:uppercase;font-weight:var(--scalar-semibold)}.references-classic .introduction-card-row[data-v-0b17f72e] .card-footer,.references-classic .introduction-card-row[data-v-0b17f72e] .scalar-card,.references-classic .introduction-card-row[data-v-0b17f72e] .scalar-card--muted{background:var(--scalar-background-1)}.references-classic .introduction-card-row[data-v-0b17f72e] .scalar-card:nth-of-type(2) .scalar-card-header{display:none}.references-classic .introduction-card-row[data-v-0b17f72e] .scalar-card:nth-of-type(2) .scalar-card-header.scalar-card--borderless+.scalar-card-content{margin-top:0}.section-flare[data-v-0b17f72e]{position:absolute;top:0;right:0;pointer-events:none}.start[data-v-391b4e37]{padding:24px;display:flex;flex-flow:wrap;justify-content:space-between;position:relative;z-index:0}.swagger-editor .start[data-v-391b4e37]{padding-top:24px}.start-h1[data-v-391b4e37]{font-size:var(--scalar-heading-2);margin-top:0;line-height:1.45;margin-bottom:0;font-weight:var(--scalar-bold);color:var(--scalar-color-1);width:100%;position:relative}.start-h3[data-v-391b4e37]{font-size:var(--scalar-paragraph);margin-top:0;margin-bottom:6px;display:block;line-height:1.45;font-weight:var(--scalar-bold);color:var(--scalar-color-1);width:100%}.start-h1[data-v-391b4e37]:not(:first-of-type){margin-top:24px}.start-p[data-v-391b4e37]{font-size:var(--scalar-paragraph);color:var(--scalar-color-2);line-height:1.5;width:100%;margin-top:12px}.start-ul[data-v-391b4e37]{margin-top:12px;font-size:var(--scalar-paragraph);line-height:1.5;padding-left:0;list-style:initial;display:flex;flex-flow:wrap;gap:24px}.start-ul li[data-v-391b4e37]{margin:0;padding:0;list-style:none;width:calc(50% - 24px);color:var(--scalar-color-2)}.start-ul li[data-v-391b4e37]:first-of-type{margin-top:0}.start-section[data-v-391b4e37]{width:100%;margin-bottom:12px;display:flex;flex-flow:wrap}.start-section[data-v-391b4e37]:last-of-type{margin-bottom:48px}.start-h2[data-v-391b4e37]{background:var(--scalar-background-2);border-top-left-radius:var(--scalar-radius-lg);border-top-right-radius:var(--scalar-radius-lg);border:1px solid var(--scalar-border-color);color:var(--scalar-color-3);font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);padding:9px;width:100%}.start-item[data-v-391b4e37]{align-items:center;background:var(--scalar-background-2);border-right:1px solid var(--scalar-border-color);border-bottom:1px solid var(--scalar-border-color);color:var(--scalar-color-1);cursor:pointer;display:flex;flex:1;font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);padding:9px;text-transform:capitalize;-webkit-user-select:none;user-select:none}.start-section-integrations .start-item[data-v-391b4e37]:first-of-type{border-bottom-left-radius:var(--scalar-radius-lg);border-left:1px solid var(--scalar-border-color)}.start-section-integrations .start-item[data-v-391b4e37]:last-of-type{border-bottom-right-radius:var(--scalar-radius-lg)}.start-section-colors .start-item[data-v-391b4e37]{min-width:33.33%}.start-section-colors .start-item[data-v-391b4e37]:nth-child(3n+2){border-left:1px solid var(--scalar-border-color)}.start-section-colors .start-item[data-v-391b4e37]:last-of-type,.start-section-colors .start-item-active[data-v-391b4e37]:last-of-type:before{border-radius:0 0 var(--scalar-radius-lg) var(--scalar-radius-lg)}.start-item[data-v-391b4e37]:empty{pointer-events:none}.start-item svg[data-v-391b4e37]{width:14px;height:14px;margin-right:6px}.start-item[data-v-391b4e37]:hover{background:var(--scalar-background-3)}.start-item-active[data-v-391b4e37]{z-index:10;position:relative;color:var(--scalar-color-1)}.start-item-active[data-v-391b4e37]:before{border:1px solid var(--scalar-color-1);content:"";top:-1px;right:-1px;bottom:-1px;left:-1px;pointer-events:none;position:absolute}.start-section-color .start-item[data-v-391b4e37]{text-transform:capitalize}.start-cta[data-v-391b4e37]{display:flex;gap:12px;width:100%;margin-top:24px;margin-bottom:0}.start-row[data-v-391b4e37]{width:100%;margin-top:12px;overflow:hidden}.start-hero-copy[data-v-391b4e37]{background:var(--scalar-background-2);padding:12px;border-radius:var(--scalar-radius-lg)}.start-p-small[data-v-391b4e37]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-2);margin-bottom:12px;line-height:1.4}.start-cta[data-v-391b4e37]{margin-bottom:12px;width:fit-content;white-space:nowrap}.start-copy[data-v-391b4e37]{padding:76px 48px 48px;display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center}.start-logo[data-v-391b4e37]{color:var(--scalar-color-1);margin-bottom:24px;width:72px;aspect-ratio:1;position:relative;box-shadow:var(--scalar-shadow-2);border-radius:50%}.start-logo[data-v-391b4e37]:before{content:"";width:300%;aspect-ratio:1;left:-100%;top:-100%;position:absolute;z-index:-1;border-radius:50%;background-size:24px 24px;box-shadow:inset 0 0 50px var(--scalar-background-1),inset 0 0 50px var(--scalar-background-1);background-image:linear-gradient(to right,var(--scalar-border-color) 1px,transparent 1px),linear-gradient(to bottom,var(--scalar-border-color) 1px,transparent 1px)}.start-logo svg[data-v-391b4e37]{width:100%;height:auto;background:var(--scalar-background-1);padding:3px;border-radius:50%;position:relative}@media screen and (max-width: 600px){.start-section-colors .start-item[data-v-391b4e37],.start-item[data-v-391b4e37]{width:100%;border-radius:0;border-right:none;border-top:1px solid var(--scalar-border-color)}.start-item[data-v-391b4e37]:empty{display:none}.start-h2[data-v-391b4e37]{border-bottom:none}.start li[data-v-391b4e37]{width:100%}.start-copy[data-v-391b4e37]{padding:48px 0 24px}}@media screen and (max-width: 1000px){.start[data-v-391b4e37]{padding:0;overflow:auto}}.sidebar-heading-type[data-v-f51e2805]{display:block;min-width:3.9em;overflow:hidden;line-height:14px;flex-shrink:0;color:#fff;color:color-mix(in srgb,var(--method-color, var(--scalar-color-1)),transparent 0%);text-transform:uppercase;font-size:10px;font-weight:var(--scalar-bold);text-align:right;position:relative;font-family:var(--scalar-font-code);white-space:nowrap;margin-left:3px}.sidebar-heading[data-v-8f97b414]{display:flex;gap:6px;color:var(--scalar-sidebar-color-2, var(--scalar-color-2));font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);word-break:break-word;line-height:1.385;max-width:100%;position:relative;cursor:pointer;border-radius:var(--scalar-radius);flex:1;padding-right:9px;-webkit-user-select:none;user-select:none}.sidebar-heading-link-method[data-v-8f97b414]{margin:0}.sidebar-heading.deprecated .sidebar-heading-link-title[data-v-8f97b414]{text-decoration:line-through}.sidebar-heading-link-title[data-v-8f97b414]{margin:0}.sidebar-heading[data-v-8f97b414]:hover{background:var( --scalar-sidebar-item-hover-background, var(--scalar-background-2) )}.sidebar-heading:hover .sidebar-heading-link-title[data-v-8f97b414]{color:var(--scalar-sidebar-item-hover-color)}.active_page.sidebar-heading[data-v-8f97b414]:hover,.active_page.sidebar-heading[data-v-8f97b414]{color:var(--scalar-sidebar-color-active, var(--scalar-color-accent));background:var( --scalar-sidebar-item-active-background, var(--scalar-background-accent) )}.active_page.sidebar-heading:hover .sidebar-heading-link-title[data-v-8f97b414]{color:var(--scalar-sidebar-color-active, var(--scalar-color-accent))}.sidebar-indent-nested .sidebar-indent-nested .sidebar-heading[data-v-8f97b414]:before{content:"";position:absolute;top:0;left:calc((var(--scalar-sidebar-level) * 12px));width:1px;height:100%;background:var(--scalar-sidebar-indent-border)}.sidebar-indent-nested .sidebar-indent-nested .sidebar-heading[data-v-8f97b414]:hover:before{background:var(--scalar-sidebar-indent-border-hover)}.sidebar-indent-nested .sidebar-indent-nested .active_page.sidebar-heading[data-v-8f97b414]:before{background:var(--scalar-sidebar-indent-border-active)}.sidebar-heading-link[data-v-8f97b414]{text-decoration:none;color:inherit;padding:6px 0;display:flex;flex:1;justify-content:space-between;gap:2px}.sidebar-heading p[data-v-8f97b414]{height:fit-content;display:flex;align-items:center}.sidebar-heading p[data-v-8f97b414]:empty{display:none}.link-icon[data-v-8f97b414]{position:relative;left:4px}.sidebar-icon[data-v-8f97b414]{display:flex;align-items:center;justify-content:center;margin-right:6px;width:13px;height:13px}.sidebar-icon>svg[data-v-8f97b414]{width:13px;height:13px}.sidebar-group-item[data-v-8f97b414]{position:relative}.sidebar-heading-chevron[data-v-8f97b414]{margin:5px -5.5px 5px -9px}.toggle-nested-icon[data-v-8f97b414]{border:none;color:currentColor;padding:3px;color:var(--scalar-sidebar-color-2)}.active_page .toggle-nested-icon[data-v-8f97b414]{color:var(--scalar-sidebar-color-active, var(--scalar-color-accent))}.toggle-nested-icon[data-v-8f97b414]:hover,.toggle-nested-icon[data-v-8f97b414]:focus-visible{color:currentColor}.action-menu[data-v-8f97b414]{position:absolute;top:5px;right:5px;display:flex;gap:6px}.action-menu[data-v-8f97b414] .button-wrapper button{opacity:0;width:20px;height:20px;padding:4px}.action-menu[data-v-8f97b414]:hover .button-wrapper button,.action-menu[data-v-8f97b414] .button-wrapper button:hover,.sidebar-heading:hover~.action-menu[data-v-8f97b414] .button-wrapper button,.action-menu[data-v-8f97b414] .button-wrapper button[aria-expanded=true]{opacity:1}.sidebar-heading[data-v-8f97b414]:has(~.action-menu:hover){color:var(--scalar-sidebar-color-1, var(--scalar-color-1));background:var( --scalar-sidebar-item-hover-background, var(--scalar-background-2) )}.sidebar-group-item__folder[data-v-8f97b414]{color:var(--scalar-sidebar-color-1, var(--scalar-color-1));text-transform:var(--scalar-tag-text-transform, initial)}.sidebar-group[data-v-39c84840]{list-style:none;width:100%;margin:0;padding:0}.sidebar-indent-nested[data-v-39c84840] .sidebar-heading{padding-left:calc((var(--scalar-sidebar-level) * var(--scalar-sidebar-indent-base)) + 12px)!important}.sidebar-indent-nested[data-v-39c84840] .sidebar-heading .toggle-nested-icon{left:calc((var(--scalar-sidebar-level) * var(--scalar-sidebar-indent-base)) + 2px)!important}:where(.sidebar-indent-nested[data-v-39c84840]) .sidebar-heading{color:var(--scalar-sidebar-color-1, var(--scalar-color-1))}:where(.sidebar-indent-nested[data-v-39c84840]) :where(.sidebar-indent-nested) .sidebar-heading{color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.sidebar[data-v-14598096]{--scalar-sidebar-indent-base: 12px}.sidebar[data-v-14598096]{flex:1;height:100%;display:flex;flex-direction:column;border-right:1px solid var(--scalar-sidebar-border-color, var(--scalar-border-color));background:var(--scalar-sidebar-background-1, var(--scalar-background-1));--scalar-sidebar-level: 0}.sidebar-pages[data-v-14598096]{flex:1;padding:9px 12px}@media (max-width: 1000px){.sidebar[data-v-14598096]{min-height:0;border-right:none}.sidebar-pages[data-v-14598096]{padding-top:12px}}.sidebar-group-title[data-v-14598096]{color:var(--scalar-sidebar-color-1);font-size:var(--scalar-mini);padding:12px 6px 6px;font-weight:var(--scalar-semibold);text-transform:uppercase;word-break:break-word;line-height:1.385}.sidebar-group-item+.sidebar-group-title[data-v-14598096]{border-top:1px solid var(--scalar-sidebar-border-color);margin-top:9px}.scalar-modal-layout[data-v-17e9f7d4]{animation:modal-fade-17e9f7d4 .2s forwards}.scalar-modal[data-v-17e9f7d4]{animation:modal-pop-17e9f7d4 .15s .15s forwards;position:fixed;left:0;top:0;bottom:0;right:0}.scalar-modal.scalar-modal-search[data-v-17e9f7d4]{max-width:540px;max-height:540px;background-color:transparent}.modal-content-search .modal-body[data-v-17e9f7d4]{padding:0;overflow:hidden;display:flex;flex-direction:column;max-height:440px}@media (max-width: 1280px){.scalar-modal[data-v-17e9f7d4]{height:calc(100% - 56px);top:28px}}@keyframes modal-fade-17e9f7d4{0%{opacity:0}to{opacity:1}}@keyframes modal-pop-17e9f7d4{0%{opacity:0}to{opacity:1}}@layer scalar-base,scalar-theme;@layer scalar-base{body{margin:0;line-height:inherit}}:where(.scalar-app){font-family:var(--scalar-font);line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4}@layer scalar-base{:root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}.light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }}:where(.scalar-app) .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}:where(.scalar-app) .pointer-events-none{pointer-events:none}:where(.scalar-app) .visible{visibility:visible}:where(.scalar-app) .invisible{visibility:hidden}:where(.scalar-app) .fixed{position:fixed}:where(.scalar-app) .absolute{position:absolute}:where(.scalar-app) .relative{position:relative}:where(.scalar-app) .sticky{position:sticky}:where(.scalar-app) .inset-0{top:0;right:0;bottom:0;left:0}:where(.scalar-app) .left-0{left:0}:where(.scalar-app) .top-0{top:0}:where(.scalar-app) .top-\\[0\\.5px\\]{top:.5px}:where(.scalar-app) .-z-1{z-index:-1}:where(.scalar-app) .z-\\[1001\\]{z-index:1001}:where(.scalar-app) .z-overlay{z-index:10000}:where(.scalar-app) .m-0{margin:0}:where(.scalar-app) .-mx-0{margin-left:-0px;margin-right:-0px}:where(.scalar-app) .-mx-0\\.75{margin-left:-3px;margin-right:-3px}:where(.scalar-app) .mx-2{margin-left:8px;margin-right:8px}:where(.scalar-app) .mx-auto{margin-left:auto;margin-right:auto}:where(.scalar-app) .my-0{margin-top:0;margin-bottom:0}:where(.scalar-app) .my-0\\.75{margin-top:3px;margin-bottom:3px}:where(.scalar-app) .my-3{margin-top:12px;margin-bottom:12px}:where(.scalar-app) .mb-0{margin-bottom:0}:where(.scalar-app) .ml-1{margin-left:4px}:where(.scalar-app) .mr-2{margin-right:8px}:where(.scalar-app) .mr-3{margin-right:12px}:where(.scalar-app) .mt-0{margin-top:0}:where(.scalar-app) .mt-1{margin-top:4px}:where(.scalar-app) .mt-1\\.5{margin-top:6px}:where(.scalar-app) .mt-20{margin-top:80px}:where(.scalar-app) .block{display:block}:where(.scalar-app) .inline-block{display:inline-block}:where(.scalar-app) .flex{display:flex}:where(.scalar-app) .grid{display:grid}:where(.scalar-app) .contents{display:contents}:where(.scalar-app) .hidden{display:none}:where(.scalar-app) .aspect-square{aspect-ratio:1 / 1}:where(.scalar-app) .size-10{width:40px;height:40px}:where(.scalar-app) .size-2{width:8px;height:8px}:where(.scalar-app) .size-2\\.5{width:10px;height:10px}:where(.scalar-app) .size-3{width:12px;height:12px}:where(.scalar-app) .size-3\\.5{width:14px;height:14px}:where(.scalar-app) .size-4{width:16px;height:16px}:where(.scalar-app) .size-5{width:20px;height:20px}:where(.scalar-app) .size-6{width:24px;height:24px}:where(.scalar-app) .size-8{width:32px;height:32px}:where(.scalar-app) .size-full{width:100%;height:100%}:where(.scalar-app) .h-10{height:40px}:where(.scalar-app) .h-4{height:16px}:where(.scalar-app) .h-\\[100dvh\\]{height:100dvh}:where(.scalar-app) .h-fit{height:-moz-fit-content;height:fit-content}:where(.scalar-app) .h-full{height:100%}:where(.scalar-app) .h-px{height:1px}:where(.scalar-app) .h-screen{height:100vh}:where(.scalar-app) .max-h-\\[440px\\]{max-height:440px}:where(.scalar-app) .max-h-\\[calc\\(100dvh-240px\\)\\]{max-height:calc(100dvh - 240px)}:where(.scalar-app) .min-h-\\[77px\\]{min-height:77px}:where(.scalar-app) .w-4{width:16px}:where(.scalar-app) .w-40{width:160px}:where(.scalar-app) .w-48{width:192px}:where(.scalar-app) .w-56{width:224px}:where(.scalar-app) .w-\\[100dvw\\]{width:100dvw}:where(.scalar-app) .w-full{width:100%}:where(.scalar-app) .min-w-0{min-width:0px}:where(.scalar-app) .max-w-screen-lg{max-width:800px}:where(.scalar-app) .max-w-screen-md{max-width:640px}:where(.scalar-app) .max-w-screen-sm{max-width:540px}:where(.scalar-app) .max-w-screen-xs{max-width:480px}:where(.scalar-app) .flex-1{flex:1 1 0%}:where(.scalar-app) .origin-top-left{transform-origin:top left}:where(.scalar-app) .rotate-90{--tw-rotate: 90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where(.scalar-app) .transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where(.scalar-app) .cursor-not-allowed{cursor:not-allowed}:where(.scalar-app) .cursor-pointer{cursor:pointer}:where(.scalar-app) .resize-none{resize:none}:where(.scalar-app) .resize{resize:both}:where(.scalar-app) .appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}:where(.scalar-app) .flex-col{flex-direction:column}:where(.scalar-app) .flex-wrap{flex-wrap:wrap}:where(.scalar-app) .items-start{align-items:flex-start}:where(.scalar-app) .items-center{align-items:center}:where(.scalar-app) .justify-start{justify-content:flex-start}:where(.scalar-app) .justify-center{justify-content:center}:where(.scalar-app) .justify-between{justify-content:space-between}:where(.scalar-app) .gap-0{gap:0px}:where(.scalar-app) .gap-0\\.75{gap:3px}:where(.scalar-app) .gap-1{gap:4px}:where(.scalar-app) .gap-1\\.5{gap:6px}:where(.scalar-app) .gap-2{gap:8px}:where(.scalar-app) .gap-2\\.5{gap:10px}:where(.scalar-app) .gap-4{gap:16px}:where(.scalar-app) .divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse: 0;border-top-width:calc(var(--scalar-border-width) * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(var(--scalar-border-width) * var(--tw-divide-y-reverse))}:where(.scalar-app) .self-center{align-self:center}:where(.scalar-app) .overflow-hidden{overflow:hidden}:where(.scalar-app) .overflow-y-auto{overflow-y:auto}:where(.scalar-app) .truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.scalar-app) .text-wrap{text-wrap:wrap}:where(.scalar-app) .rounded{border-radius:var(--scalar-radius)}:where(.scalar-app) .rounded-full{border-radius:9999px}:where(.scalar-app) .rounded-lg{border-radius:var(--scalar-radius-lg)}:where(.scalar-app) .border{border-width:var(--scalar-border-width)}:where(.scalar-app) .border-0{border-width:0}:where(.scalar-app) .border-solid{border-style:solid}:where(.scalar-app) .border-none{border-style:none}:where(.scalar-app) .border-border{border-color:var(--scalar-border-color)}:where(.scalar-app) .border-c-3{border-color:var(--scalar-color-3)}:where(.scalar-app) .border-error{border-color:var(--scalar-error-color)}:where(.scalar-app) .bg-b-1{background-color:var(--scalar-background-1)}:where(.scalar-app) .bg-b-2{background-color:var(--scalar-background-2)}:where(.scalar-app) .bg-b-btn{background-color:var(--scalar-button-1)}:where(.scalar-app) .bg-backdrop{background-color:#00000038}:where(.scalar-app) .bg-blue{background-color:var(--scalar-color-blue)}:where(.scalar-app) .bg-border{background-color:var(--scalar-border-color)}:where(.scalar-app) .bg-error{background-color:var(--scalar-error-color)}:where(.scalar-app) .bg-transparent{background-color:transparent}:where(.scalar-app) .p-0{padding:0}:where(.scalar-app) .p-0\\.5{padding:2px}:where(.scalar-app) .p-0\\.75{padding:3px}:where(.scalar-app) .p-1{padding:4px}:where(.scalar-app) .p-2{padding:8px}:where(.scalar-app) .p-2\\.5{padding:10px}:where(.scalar-app) .p-3{padding:12px}:where(.scalar-app) .p-\\[3px\\]{padding:3px}:where(.scalar-app) .px-1{padding-left:4px;padding-right:4px}:where(.scalar-app) .px-2{padding-left:8px;padding-right:8px}:where(.scalar-app) .px-2\\.5{padding-left:10px;padding-right:10px}:where(.scalar-app) .px-3{padding-left:12px;padding-right:12px}:where(.scalar-app) .px-4{padding-left:16px;padding-right:16px}:where(.scalar-app) .px-6{padding-left:24px;padding-right:24px}:where(.scalar-app) .px-9{padding-left:36px;padding-right:36px}:where(.scalar-app) .py-1{padding-top:4px;padding-bottom:4px}:where(.scalar-app) .py-1\\.5{padding-top:6px;padding-bottom:6px}:where(.scalar-app) .py-3{padding-top:12px;padding-bottom:12px}:where(.scalar-app) .py-4{padding-top:16px;padding-bottom:16px}:where(.scalar-app) .pb-0{padding-bottom:0}:where(.scalar-app) .pb-4{padding-bottom:16px}:where(.scalar-app) .pt-3{padding-top:12px}:where(.scalar-app) .pt-6{padding-top:24px}:where(.scalar-app) .text-left{text-align:left}:where(.scalar-app) .font-code{font-family:var(--scalar-font-code)}:where(.scalar-app) .text-lg{font-size:var(--scalar-font-size-2)}:where(.scalar-app) .text-sm{font-size:var(--scalar-font-size-4)}:where(.scalar-app) .text-xs{font-size:var(--scalar-font-size-5)}:where(.scalar-app) .text-xxs{font-size:var(--scalar-font-size-6)}:where(.scalar-app) .font-bold{font-weight:var(--scalar-bold)}:where(.scalar-app) .font-medium{font-weight:var(--scalar-semibold)}:where(.scalar-app) .font-normal{font-weight:var(--scalar-regular)}:where(.scalar-app) .leading-snug{line-height:1.375}:where(.scalar-app) .text-b-1{color:var(--scalar-background-1)}:where(.scalar-app) .text-c-1{color:var(--scalar-color-1)}:where(.scalar-app) .text-c-2{color:var(--scalar-color-2)}:where(.scalar-app) .text-c-3{color:var(--scalar-color-3)}:where(.scalar-app) .text-c-btn{color:var(--scalar-button-1-color)}:where(.scalar-app) .text-c-ghost{color:var(--scalar-color-ghost)}:where(.scalar-app) .text-error{color:var(--scalar-error-color)}:where(.scalar-app) .text-transparent{color:transparent}:where(.scalar-app) .text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}:where(.scalar-app) .no-underline{text-decoration-line:none}:where(.scalar-app) .opacity-0{opacity:0}:where(.scalar-app) .opacity-50{opacity:.5}:where(.scalar-app) .shadow{--tw-shadow: var(--scalar-shadow-1);--tw-shadow-colored: var(--scalar-shadow-1);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .shadow-lg{--tw-shadow: var(--scalar-shadow-2);--tw-shadow-colored: var(--scalar-shadow-2);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .shadow-md{--tw-shadow: var(--scalar-shadow-1);--tw-shadow-colored: var(--scalar-shadow-1);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .shadow-sm{--tw-shadow: rgba(0, 0, 0, .09) 0px 1px 4px;--tw-shadow-colored: 0px 1px 4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .shadow-current{--tw-shadow-color: currentColor;--tw-shadow: var(--tw-shadow-colored)}:where(.scalar-app) .outline-none{outline:2px solid transparent;outline-offset:2px}:where(.scalar-app) .outline{outline-style:solid}:where(.scalar-app) .blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:where(.scalar-app) .brightness-lifted{--tw-brightness: brightness(var(--scalar-lifted-brightness));filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:where(.scalar-app) .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:where(.scalar-app) .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}:where(.scalar-app) .transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}:where(.scalar-app) .transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}:where(.scalar-app) .ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}:where(.scalar-app) .bg-b-1{--tw-bg-base: var(--scalar-background-1)}:where(.scalar-app) .bg-b-2{--tw-bg-base: var(--scalar-background-2)}:where(.scalar-app) .bg-b-btn{--tw-bg-base: var(--scalar-button-1)}:where(.scalar-app) .bg-backdrop{--tw-bg-base: rgba(0, 0, 0, .22)}:where(.scalar-app) .bg-blue{--tw-bg-base: var(--scalar-color-blue)}:where(.scalar-app) .bg-border{--tw-bg-base: var(--scalar-border-color)}:where(.scalar-app) .bg-error{--tw-bg-base: var(--scalar-error-color)}:where(.scalar-app) .bg-transparent{--tw-bg-base: transparent}:where(.scalar-app) .row,:where(.scalar-app) .scalar-row{display:flex;flex-direction:row}:where(.scalar-app) .col{display:flex;flex-direction:column}:where(.scalar-app) .centered-x{left:50%;--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where(.scalar-app) .centered{left:50%;--tw-translate-x: -50%;top:50%;--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where(.scalar-app) .before\\:mr-1:before{content:var(--tw-content);margin-right:4px}:where(.scalar-app) .before\\:mr-1\\.5:before{content:var(--tw-content);margin-right:6px}:where(.scalar-app) .before\\:block:before{content:var(--tw-content);display:block}:where(.scalar-app) .before\\:h-4:before{content:var(--tw-content);height:16px}:where(.scalar-app) .before\\:w-4:before{content:var(--tw-content);width:16px}:where(.scalar-app) .before\\:rounded-full:before{content:var(--tw-content);border-radius:9999px}:where(.scalar-app) .before\\:bg-error:before{content:var(--tw-content);background-color:var(--scalar-error-color)}:where(.scalar-app) .before\\:text-center:before{content:var(--tw-content);text-align:center}:where(.scalar-app) .before\\:text-xxs:before{content:var(--tw-content);font-size:var(--scalar-font-size-6)}:where(.scalar-app) .before\\:leading-4:before{content:var(--tw-content);line-height:var(--scalar-line-height-4)}:where(.scalar-app) .before\\:text-white:before{content:var(--tw-content);--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}:where(.scalar-app) .before\\:content-\\[\\\'\\!\\\'\\]:before{--tw-content: "!";content:var(--tw-content)}:where(.scalar-app) .before\\:bg-error:before{content:var(--tw-content);--tw-bg-base: var(--scalar-error-color)}:where(.scalar-app) .first-of-type\\:mt-0:first-of-type{margin-top:0}:where(.scalar-app) .first-of-type\\:mt-0\\.75:first-of-type{margin-top:3px}:where(.scalar-app) .last-of-type\\:mb-0:last-of-type{margin-bottom:0}:where(.scalar-app) .last-of-type\\:mb-0\\.75:last-of-type{margin-bottom:3px}:where(.scalar-app) .empty\\:hidden:empty{display:none}:where(.scalar-app) .focus-within\\:border-c-1:focus-within{border-color:var(--scalar-color-1)}:where(.scalar-app) .hover\\:bg-b-2:hover{background-color:var(--scalar-background-2)}:where(.scalar-app) .hover\\:text-c-1:hover{color:var(--scalar-color-1)}:where(.scalar-app) .hover\\:bg-b-2:hover{--tw-bg-base: var(--scalar-background-2)}:where(.scalar-app) .active\\:bg-b-btn:active{background-color:var(--scalar-button-1)}:where(.scalar-app) .active\\:text-c-1:active{color:var(--scalar-color-1)}:where(.scalar-app) .active\\:shadow-none:active{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .active\\:brightness-90:active{--tw-brightness: brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:where(.scalar-app) .active\\:bg-b-btn:active{--tw-bg-base: var(--scalar-button-1)}:where(.scalar-app) .group:hover .group-hover\\:text-c-1{color:var(--scalar-color-1)}:where(.scalar-app) .group:hover .group-hover\\:shadow-border{--tw-shadow: inset 0 0 0 1px var(--scalar-border-color);--tw-shadow-colored: inset 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}:where(.scalar-app) .group:hover .group-hover\\:shadow-border{--tw-shadow-color: var(--scalar-border-color);--tw-shadow: var(--tw-shadow-colored)}:where(.scalar-app) .ui-open\\:rotate-180[data-headlessui-state~=open]{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where(.scalar-app) :where([data-headlessui-state~=open]) .ui-open\\:rotate-180{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where(.scalar-app) .has-actv-btn\\:border:has(button:active){border-width:var(--scalar-border-width)}:where(.scalar-app) .has-actv-btn\\:border-border:has(button:active){border-color:var(--scalar-border-color)}:where(.scalar-app) .\\!empty\\:flex:not(:empty){display:flex}:where(.scalar-app) .\\!empty\\:w-7:not(:empty){width:28px}:where(.scalar-app) .\\!empty\\:items-center:not(:empty){align-items:center}:where(.scalar-app) .\\!empty\\:pr-3:not(:empty){padding-right:12px}:where(.scalar-app) .hocus\\:bg-h-btn:hover{background-color:var(--scalar-button-1-hover)}:where(.scalar-app) .hocus\\:text-c-1:hover{color:var(--scalar-color-1)}:where(.scalar-app) .hocus\\:brightness-90:hover{--tw-brightness: brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:where(.scalar-app) .hocus\\:bg-h-btn:hover{--tw-bg-base: var(--scalar-button-1-hover)}:where(.scalar-app) .hocus\\:bg-h-btn:focus-visible{background-color:var(--scalar-button-1-hover)}:where(.scalar-app) .hocus\\:text-c-1:focus-visible{color:var(--scalar-color-1)}:where(.scalar-app) .hocus\\:brightness-90:focus-visible{--tw-brightness: brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:where(.scalar-app) .hocus\\:bg-h-btn:focus-visible{--tw-bg-base: var(--scalar-button-1-hover)}@media (min-width: 800px){:where(.scalar-app) .md\\:row{display:flex;flex-direction:row}}.loader-wrapper[data-v-47faceda]{position:relative;height:var(--d6cae758);width:var(--d6cae758);display:flex;align-items:center;justify-content:center;--loader-size: 50%}.svg-loader[data-v-47faceda]{width:var(--loader-size);height:var(--loader-size);top:1rem;right:.9rem;overflow:visible;fill:none;background-color:transparent;stroke:currentColor}.svg-path[data-v-47faceda]{stroke-width:14;fill:none;transition:.3s}.svg-x-mark[data-v-47faceda]{stroke-dasharray:57;stroke-dashoffset:57;transition-delay:0s}.svg-check-mark[data-v-47faceda]{stroke-dasharray:149;stroke-dashoffset:149;transition-delay:0s}.icon-is-invalid .svg-x-mark[data-v-47faceda],.icon-is-valid .svg-check-mark[data-v-47faceda]{stroke-dashoffset:0;transition-delay:.3s}.circular-loader[data-v-47faceda]{animation:rotate-47faceda .7s linear infinite,fade-in-47faceda .4s;transform-origin:center center;transform:scale(5);background:transparent}.loader-path[data-v-47faceda]{stroke-dasharray:50,200;stroke-dashoffset:-100;stroke-linecap:round}.loader-path-off[data-v-47faceda]{stroke-dasharray:50,200;stroke-dashoffset:-100;transition:opacity .3s;opacity:0}@keyframes fade-in-47faceda{0%{opacity:0}70%{opacity:0}to{opacity:1}}@keyframes rotate-47faceda{0%{transform:scale(5) rotate(0)}to{transform:scale(5) rotate(360deg)}}.scalar-icon[data-v-43d05207],.scalar-icon[data-v-43d05207] *{stroke-width:var(--5933775d)}.scalar-code-block{padding:.5rem .5rem .5rem .75rem;position:relative;overflow:auto}.scalar-code-block:hover .copy-button{opacity:100;visibility:visible}.scalar-codeblock-pre{margin:0;overflow:auto;background:transparent;text-wrap:nowrap;white-space-collapse:preserve;border-radius:0}.copy-button{align-items:center;background-color:var(inherit, --scalar-background-2);border:1px solid var(--scalar-border-color);border-radius:3px;color:var(--scalar-color-3);cursor:pointer;display:flex;height:30px;margin-bottom:-30px;opacity:0;padding:6px;position:sticky;left:100dvw;top:0;transition:opacity .15s ease-in-out,color .15s ease-in-out;visibility:hidden}.copy-button:after{content:".";color:transparent;font-size:var(--scalar-mini);line-height:1.35;width:0px}.copy-button:hover{color:var(--scalar-color-1)}.copy-button svg{stroke-width:1.5}.scalar-app code.hljs *{font-size:var(--scalar-small);font-family:var(--scalar-font-code);text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:4;-o-tab-size:4;tab-size:4}.scalar-app code.hljs{font-size:var(--scalar-small);font-family:var(--scalar-font-code);display:inline-block;counter-reset:linenumber}.scalar-app .hljs{background:transparent;color:var(--scalar-color-2)}.scalar-app .hljs .line:before{color:var(--scalar-color-3);display:inline-block;counter-increment:linenumber;content:counter(linenumber);margin-right:.7em;min-width:calc(var(--line-digits) * 1ch);text-align:right}.scalar-app .hljs-comment,.scalar-app .hljs-quote{color:var(--scalar-color-3);font-style:italic}.scalar-app .hljs-number{color:var(--scalar-color-orange)}.scalar-app .hljs-regexp,.scalar-app .hljs-string,.scalar-app .hljs-built_in{color:var(--scalar-color-blue)}.scalar-app .hljs-title.class_{color:var(--scalar-color-1)}.scalar-app .hljs-keyword{color:var(--scalar-color-purple)}.scalar-app .hljs-title.function_{color:var(--scalar-color-orange)}.scalar-app .hljs-subst,.scalar-app .hljs-name{color:var(--scalar-color-blue)}.scalar-app .hljs-attr,.scalar-app .hljs-attribute{color:var(--scalar-color-1)}.scalar-app .hljs-addition,.scalar-app .hljs-literal,.scalar-app .hljs-selector-tag,.scalar-app .hljs-type{color:var(--scalar-color-green)}.scalar-app .hljs-selector-attr,.scalar-app .hljs-selector-pseudo{color:var(--scalar-color-orange)}.scalar-app .hljs-doctag,.scalar-app .hljs-section,.scalar-app .hljs-title{color:var(--scalar-color-blue)}.scalar-app .hljs-selector-id,.scalar-app .hljs-template-variable,.scalar-app .hljs-variable{color:var(--scalar-color-1)}.scalar-app .hljs-name,.scalar-app .hljs-section,.scalar-app .hljs-strong{font-weight:var(--scalar-semibold)}.scalar-app .hljs-bullet,.scalar-app .hljs-link,.scalar-app .hljs-meta,.scalar-app .hljs-symbol{color:var(--scalar-color-blue)}.scalar-app .hljs-deletion{color:var(--scalar-color-red)}.scalar-app .hljs-formula{background:var(--scalar-color-1)}.scalar-app .hljs-emphasis{font-style:italic}.scalar-app .credentials{font-size:0!important;color:transparent}.scalar-app .credentials:after{content:"";font-size:var(--scalar-small);color:var(--scalar-color-3);-webkit-user-select:none;-moz-user-select:none;user-select:none}.hljs.language-html{color:var(--scalar-color-1)}.hljs.language-html .hljs-attr{color:var(--scalar-color-2)}.hljs.language-curl .hljs-keyword{color:var(--scalar-color-orange)}.hljs.language-curl .hljs-string{color:var(--scalar-color-1)}.hljs.language-curl .hljs-literal,.hljs.language-php .hljs-variable{color:var(--scalar-color-blue)}.hljs.language-objectivec .hljs-meta{color:var(--scalar-color-1)}.hljs.language-objectivec .hljs-built_in,.hljs-built_in{color:var(--scalar-color-orange)}.scalar-app .markdown{font-family:var(--scalar-font);color:var(--scalar-color-1);word-break:break-word}.scalar-app .markdown h1,.scalar-app .markdown h2,.scalar-app .markdown h3,.scalar-app .markdown h4,.scalar-app .markdown h5,.scalar-app .markdown h6,.scalar-app .markdown p,.scalar-app .markdown div,.scalar-app .markdown img,.scalar-app .markdown details,.scalar-app .markdown summary,.scalar-app .markdown ul,.scalar-app .markdown ol,.scalar-app .markdown table,.scalar-app .markdown blockquote,.scalar-app .markdown code{margin:12px 0}.scalar-app .markdown details{margin:12px 0;color:var(--scalar-color-1)}.scalar-app .markdown summary{display:block;margin:12px 0;padding-left:20px;position:relative;font-weight:var(--scalar-semibold);cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none}.scalar-app .markdown summary:after{display:block;content:"";position:absolute;top:1px;left:1px;width:16px;height:16px;background-color:var(--scalar-color-3);-webkit-mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\');mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\')}.scalar-app .markdown summary:hover:after{background-color:var(--scalar-color-1)}.scalar-app .markdown details[open] summary:after{transform:rotate(90deg)}.scalar-app .markdown summary::-webkit-details-marker{display:none}.scalar-app .markdown img{overflow:hidden;border-radius:var(--scalar-radius);max-width:100%}.scalar-app .markdown>:first-child{margin-top:0}.scalar-app .markdown h1{--font-size: 1.4em}.scalar-app .markdown h2{--font-size: 1.25em}.scalar-app .markdown h3{--font-size: 1.1em}.scalar-app .markdown h4,.scalar-app .markdown h6{--font-size: 1em}.scalar-app .markdown h1,.scalar-app .markdown h2,.scalar-app .markdown h3,.scalar-app .markdown h4,.scalar-app .markdown h5,.scalar-app .markdown h6{font-size:var(--font-size);margin:18px 0 6px;font-weight:var(--scalar-bold);display:block;line-height:1.45}.scalar-app .markdown b,.scalar-app .markdown strong{font-weight:var(--scalar-bold)}.scalar-app .markdown p{color:var(--scalar-color-1);font-weight:var(--font-weight, var(--scalar-regular));line-height:1.5;margin-bottom:0;display:block}.scalar-app .markdown ul,.scalar-app .markdown ol{padding-left:24px;line-height:1.5;margin:12px 0;display:block}.scalar-app .markdown ul{list-style:disc}.scalar-app .markdown ol{list-style:decimal}.scalar-app .markdown ul.contains-task-list{list-style:none;padding-left:0}.scalar-app .markdown li{margin:6px 0;display:list-item}.scalar-app .markdown a{color:var(--scalar-color-accent);-webkit-text-decoration:var(--scalar-text-decoration);text-decoration:var(--scalar-text-decoration);cursor:pointer}.scalar-app .markdown a:hover{-webkit-text-decoration:var(--scalar-text-decoration-hover);text-decoration:var(--scalar-text-decoration-hover)}.scalar-app .markdown em{font-style:italic}.scalar-app .markdown sup{font-size:var(--scalar-micro);vertical-align:super;font-weight:450}.scalar-app .markdown sub{font-size:var(--scalar-micro);vertical-align:sub;font-weight:450}.scalar-app .markdown del{text-decoration:line-through}.scalar-app .markdown code{font-family:var(--scalar-font-code);background-color:var(--scalar-background-2);box-shadow:0 0 0 1px var(--scalar-border-color);font-size:var(--scalar-micro);border-radius:2px;padding:0 3px}.scalar-app .markdown pre code{display:block;white-space:pre;padding:12px;line-height:1.5;margin:12px 0;-webkit-overflow-scrolling:touch;overflow-x:auto;max-width:100%;min-width:100px}.scalar-app .markdown hr{border:none;border-bottom:1px solid var(--scalar-border-color)}.scalar-app .markdown blockquote{border-left:3px solid var(--scalar-border-color);padding-left:12px;margin:0;display:block}.scalar-app .markdown table{display:block;overflow-x:auto;position:relative;border-collapse:collapse;width:-moz-max-content;width:max-content;max-width:100%;margin:1em 0;box-shadow:0 0 0 1px var(--scalar-border-color);border-radius:var(--scalar-radius-lg)}.scalar-app .markdown tbody{display:table-row-group;vertical-align:middle}.scalar-app .markdown thead{display:table-header-group;vertical-align:middle}.scalar-app .markdown tr{display:table-row;border-color:inherit;vertical-align:inherit}.scalar-app .markdown td,.scalar-app .markdown th{display:table-cell;vertical-align:inherit;min-width:1em;padding:6px 9px;vertical-align:top;line-height:1.5;position:relative;word-break:initial;font-size:var(--scalar-small);color:var(--scalar-color-1);font-weight:var(--font-weight, var(--scalar-regular));border-right:1px solid var(--scalar-border-color);border-bottom:1px solid var(--scalar-border-color)}.scalar-app .markdown td>*,.scalar-app .markdown th>*{margin-bottom:0}.scalar-app .markdown th:empty{display:none}.scalar-app .markdown td:first-of-type,.scalar-app .markdown th:first-of-type{border-left:none}.scalar-app .markdown td:last-of-type,.scalar-app .markdown th:last-of-type{border-right:none}.scalar-app .markdown tr:last-of-type td{border-bottom:none}.scalar-app .markdown th{font-weight:var(--scalar-semibold)!important;text-align:left;border-left-color:transparent;background:var(--scalar-background-2)}.scalar-app .markdown tr>[align=left]{text-align:left}.scalar-app .markdown tr>[align=right]{text-align:right}.scalar-app .markdown tr>[align=center]{text-align:center}.scalar-input-wrapper-focus .scalar-input-label[data-v-94574cc9]{color:var(--scalar-color-1)}.scalar-input-wrapper-error .scalar-input-label[data-v-94574cc9]{color:var(--scalar-color-error-color)}.scalar-input[data-v-94574cc9]::-moz-selection{color:var(--scalar-color-1);background:#ffa55859}.scalar-input[data-v-94574cc9]::selection{color:var(--scalar-color-1);background:#ffa55859}.scalar-input[data-v-94574cc9]:has(+.scalar-input-label){opacity:0}.scalar-input[data-v-94574cc9]:not(:-moz-placeholder-shown){opacity:1;-moz-transition:opacity .2s ease-in-out .15s;transition:opacity .2s ease-in-out .15s}.scalar-input[data-v-94574cc9]:not(:placeholder-shown),.scalar-input-wrapper-focus .scalar-input[data-v-94574cc9]{opacity:1;transition:opacity .2s ease-in-out .15s}.scalar-input[data-v-94574cc9]:-webkit-autofill,.scalar-input[data-v-94574cc9]:-webkit-autofill:hover,.scalar-input[data-v-94574cc9]:-webkit-autofill:focus,.scalar-input[data-v-94574cc9]:-webkit-autofill:active,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill:hover,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill:focus,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill:active{-webkit-box-shadow:0 0 0px 1000px var(--scalar-background-1) inset!important;-webkit-text-fill-color:var(--scalar-color-1);color:var(--scalar-color-1);border-radius:var(--scalar-radius)}.scalar-input:not(:-moz-placeholder-shown)+.scalar-input-label[data-v-94574cc9]{transform:translate3d(0,-20px,0) scale(.8);transform-origin:top left}.scalar-input-wrapper-focus .scalar-input-label[data-v-94574cc9],.scalar-input:not(:placeholder-shown)+.scalar-input-label[data-v-94574cc9]{transform:translate3d(0,-20px,0) scale(.8);transform-origin:top left}.scalar-input-wrapper-focus:has(button:active) .scalar-input-label[data-v-94574cc9]{color:var(--scalar-color-3)!important}@layer scalar-base,scalar-theme;@layer scalar-base{body{margin:0;line-height:inherit}}:where(.scalar-app){font-family:var(--scalar-font);line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}:where(.scalar-app) *,:where(.scalar-app) *:before,:where(.scalar-app) *:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:var(--scalar-border-color);font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;color:inherit;margin:unset;padding:unset;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:where(.scalar-app) :before,:where(.scalar-app) :after{--tw-content: ""}:where(.scalar-app) button,:where(.scalar-app) input,:where(.scalar-app) optgroup,:where(.scalar-app) select,:where(.scalar-app) textarea,:where(.scalar-app) ::file-selector-button{background:transparent}:where(.scalar-app) ol,:where(.scalar-app) ul,:where(.scalar-app) menu{list-style:none}:where(.scalar-app) input:where(:not([type=button],[type=reset],[type=submit])),:where(.scalar-app) select,:where(.scalar-app) textarea{border-radius:var(--scalar-radius);border-width:1px}:where(.scalar-app) input::placeholder,:where(.scalar-app) input:-ms-input-placeholder,:where(.scalar-app) input::-webkit-input-placeholder{color:var(--scalar-color-3);font-family:var(--scalar-font)}:where(.scalar-app) input:-webkit-autofill{-webkit-background-clip:text!important;background-clip:text!important}:where(.scalar-app) :focus-visible{outline:1px solid var(--scalar-color-accent);outline-offset:1px}:where(.scalar-app) button,:where(.scalar-app) [role=button]{cursor:pointer}:where(.scalar-app) :disabled{cursor:default}:where(.scalar-app) img,:where(.scalar-app) svg,:where(.scalar-app) video,:where(.scalar-app) canvas,:where(.scalar-app) audio,:where(.scalar-app) iframe,:where(.scalar-app) embed,:where(.scalar-app) object{display:block;vertical-align:middle}:where(.scalar-app) [hidden]{display:none}.scalar-app .cm-scroller,.scalar-app .custom-scroll{overflow-y:auto;scrollbar-color:transparent transparent;scrollbar-width:thin;-webkit-overflow-scrolling:touch}.scalar-app .custom-scroll-self-contain-overflow{overscroll-behavior:contain}.scalar-app .cm-scroller:hover,.scalar-app .custom-scroll:hover{scrollbar-color:var(--scalar-scrollbar-color, transparent)}.scalar-app .cm-scroller:hover::-webkit-scrollbar-thumb,.scalar-app .custom-scroll:hover::-webkit-scrollbar-thumb{background:var(--scalar-scrollbar-color);background-clip:content-box;border:3px solid transparent}.scalar-app .cm-scroller::-webkit-scrollbar-thumb:active,.scalar-app .custom-scroll::-webkit-scrollbar-thumb:active{background:var(--scalar-scrollbar-color-active);background-clip:content-box;border:3px solid transparent}.scalar-app .cm-scroller::-webkit-scrollbar-corner,.scalar-app .custom-scroll::-webkit-scrollbar-corner{background:transparent}.scalar-app .cm-scroller::-webkit-scrollbar,.scalar-app .custom-scroll::-webkit-scrollbar{height:12px;width:12px}.scalar-app .cm-scroller::-webkit-scrollbar-track,.scalar-app .custom-scroll::-webkit-scrollbar-track{background:transparent}.scalar-app .cm-scroller::-webkit-scrollbar-thumb,.scalar-app .custom-scroll::-webkit-scrollbar-thumb{border-radius:20px;background:transparent;background-clip:content-box;border:3px solid transparent}@media (pointer: coarse){.scalar-app .cm-scroller,.scalar-app .custom-scroll{padding-right:12px}}@layer scalar-base{:root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}}@layer scalar-base{.light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}}:root{--scalar-loaded-api-reference: true}@layer scalar-config{.scalar-api-reference[data-v-4e8b0896]{--refs-sidebar-width: var(--scalar-sidebar-width, 0px);--refs-header-height: calc( var(--scalar-y-offset) + var(--scalar-header-height, 0px) );--refs-content-max-width: var(--scalar-content-max-width, 1540px)}.scalar-api-reference.references-classic[data-v-4e8b0896]{--refs-content-max-width: var(--scalar-content-max-width, 1420px);min-height:100dvh;--refs-sidebar-width: 0}}.references-layout[data-v-4e8b0896]{min-height:100dvh;min-width:100%;max-width:100%;flex:1;--full-height: 100dvh;display:grid;grid-template-rows:var(--scalar-header-height, 0px) repeat(2,auto);grid-template-columns:var(--refs-sidebar-width) 1fr;grid-template-areas:"header header" "navigation rendered" "footer footer";background:var(--scalar-background-1)}.references-header[data-v-4e8b0896]{grid-area:header;position:sticky;top:var(--scalar-custom-header-height, 0px);z-index:10;height:var(--scalar-header-height, 0px)}.references-editor[data-v-4e8b0896]{grid-area:editor;display:flex;min-width:0;background:var(--scalar-background-1);z-index:1}.references-navigation[data-v-4e8b0896]{grid-area:navigation}.references-rendered[data-v-4e8b0896]{position:relative;grid-area:rendered;min-width:0;background:var(--scalar-background-1)}.scalar-api-reference.references-classic[data-v-4e8b0896],.references-classic .references-rendered[data-v-4e8b0896]{--full-height: fit-content !important;height:initial!important;max-height:initial!important}.references-navigation-list[data-v-4e8b0896]{position:sticky;top:var(--refs-header-height);height:calc(100dvh - var(--refs-header-height));background:var(--scalar-sidebar-background-1 var(--scalar-background-1));overflow-y:auto;display:flex;flex-direction:column}.references-editor-textarea[data-v-4e8b0896]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));display:flex;min-width:0;flex:1}.references-editable[data-v-4e8b0896]{grid-template-columns:var(--refs-sidebar-width) 1fr 1fr;grid-template-areas:"header header header" "navigation editor rendered" "footer footer footer"}@layer scalar-config{.references-sidebar[data-v-4e8b0896]{--refs-sidebar-width: var(--scalar-sidebar-width, 280px)}}.references-footer[data-v-4e8b0896]{grid-area:footer}@media (max-width: 1150px){.references-layout[data-v-4e8b0896]{grid-template-columns:var(--refs-sidebar-width) 1fr 0px}}@media (max-width: 1000px){.references-layout[data-v-4e8b0896]{grid-template-columns:auto;grid-template-rows:var(--scalar-header-height, 0px) 0px auto auto;grid-template-areas:"header" "navigation" "rendered" "footer"}.references-editable[data-v-4e8b0896]{grid-template-areas:"header" "navigation" "editor"}.references-navigation[data-v-4e8b0896],.references-rendered[data-v-4e8b0896]{max-height:unset}.references-rendered[data-v-4e8b0896]{position:static}.references-navigation[data-v-4e8b0896]{display:none;z-index:10}.references-sidebar-mobile-open .references-navigation[data-v-4e8b0896]{display:block;top:var(--refs-header-height);height:calc(100dvh - var(--refs-header-height));width:100%;position:sticky}.references-navigation-list[data-v-4e8b0896]{position:absolute;top:-1px;height:calc(var(--full-height) - var(--refs-header-height) + 1px);width:100%;border-top:1px solid var(--scalar-border-color);display:flex;flex-direction:column}}.references-classic-header[data-v-a860f78f]{display:flex;align-items:center;justify-content:space-between;gap:12px;max-width:var(--refs-content-max-width);margin:auto;padding:12px 0}.references-classic-header-container[data-v-a860f78f]{padding:0 60px}@container narrow-references-container (max-width: 900px){.references-classic-header[data-v-a860f78f]{padding:12px 24px}.references-classic-header-container[data-v-a860f78f]{padding:0}}.references-classic-header-icon[data-v-a860f78f]{height:24px;color:var(--scalar-color-1)}.darklight[data-v-c2022750]{font-family:var(--scalar-font);border:none;border-top:1px solid var(--scalar-sidebar-border-color, var(--scalar-border-color));color:var(--scalar-sidebar-color-2, var(--scalar-color-2));font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;outline:none;padding:18px 24px 0;display:flex;align-items:center;text-indent:9px;width:100%}.darklight svg[data-v-c2022750]{stroke-width:1.5}.darklight-reference[data-v-c2022750]{width:100%;margin-top:auto}.darklight[data-v-c2022750]:hover{cursor:pointer;color:var(--scalar-sidebar-color-1, var(--scalar-color-1))}.darklight-reference-promo[data-v-c2022750]{padding:6px 24px 12px;display:flex;align-items:center;font-size:var(--scalar-mini);text-decoration:none;color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.darklight-reference-promo[data-v-c2022750]:hover{text-decoration:underline}.darklight[data-v-8f61ca56]{color:var(--scalar-sidebar-color-2, var(--scalar-color-2));display:flex;align-items:center;height:24px;width:24px;padding:4px}.darklight[data-v-8f61ca56]:hover{cursor:pointer;color:var(--scalar-sidebar-color-1, var(--scalar-color-1))}a[data-v-241cc7e9]{text-decoration:none}.ref-search-container[data-v-241cc7e9]{display:flex;flex-direction:column;padding:12px 12px 0}.ref-search-results[data-v-241cc7e9]{padding:12px}.ref-search-meta[data-v-241cc7e9]{background:var(--scalar-background-3);padding:6px 12px;font-size:var(--scalar-font-size-4);color:var(--scalar-color-3);font-weight:var(--scalar-semibold);display:flex;gap:12px}.sidebar-search[data-v-45e2b1ac]{display:flex;align-items:center;position:relative;padding:0 3px 0 9px;min-width:254px;max-width:100%;font-family:var(--scalar-font);background:var( --scalar-sidebar-search-background, var(--scalar-background-1) );color:var(--scalar-sidebar-color-2, var(--scalar-color-2));outline:none;border-radius:var(--scalar-radius);box-shadow:0 0 0 1px var(--scalar-sidebar-search-border-color, var(--scalar-border-color));cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none}.sidebar-search-input[data-v-45e2b1ac]{font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);height:31px;-webkit-user-select:none;user-select:none;z-index:10;position:relative;display:flex;width:100%;justify-content:space-between;align-items:center}.sidebar-search-shortcut[data-v-45e2b1ac]{text-transform:uppercase}.sidebar-search-key[data-v-45e2b1ac]{background-color:var(--scalar-background-2);padding:3px 5px;margin:2px;border-radius:var(--scalar-radius);color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.search-icon[data-v-45e2b1ac]{padding:0;margin-right:6px;width:12px}.references-mobile-header[data-v-b5fb4b8b]{display:none;align-items:center;height:100%;width:100%;padding:0 8px;background:var(--scalar-background-1);border-bottom:1px solid var(--scalar-border-color)}.references-mobile-breadcrumbs[data-v-b5fb4b8b]{flex:1;min-width:0;font-size:var(--scalar-small);font-weight:var(--scalar-semibold);color:var(--scalar-color-1);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.references-mobile-header-actions[data-v-b5fb4b8b]{display:flex;flex-direction:row;gap:4px;height:24px;align-items:center;padding-left:4px}@media (max-width: 1000px){.references-mobile-header[data-v-b5fb4b8b]{display:flex}}@media (max-width: 1000px){.scalar-api-references-standalone-mobile{--scalar-header-height: 50px}}.scalar-api-references-standalone-search[data-v-273f5da8]{display:flex;flex-direction:column;padding:12px 12px 6px}@layer scalar-base{body{margin:0;background-color:var(--scalar-background-1)}}',
        ),
      ),
        document.head.appendChild(e)
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e)
  }
})(),
  (function (e) {
    "function" == typeof define && define.amd ? define(e) : e()
  })(function () {
    "use strict"
    var e,
      t,
      n = Object.defineProperty,
      r = (e, t, r) =>
        ((e, t, r) => (t in e ? n(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)))(
          e,
          "symbol" != typeof t ? t + "" : t,
          r,
        )
    function a(e, t = {}, n) {
      for (const r in e) {
        const o = e[r],
          i = n ? `${n}:${r}` : r
        "object" == typeof o && null !== o ? a(o, t, i) : "function" == typeof o && (t[i] = o)
      }
      return t
    }
    const o = { run: (e) => e() },
      i = void 0 !== console.createTask ? console.createTask : () => o
    function s(e, t) {
      const n = t.shift(),
        r = i(n)
      return e.reduce((e, n) => e.then(() => r.run(() => n(...t))), Promise.resolve())
    }
    function l(e, t) {
      const n = t.shift(),
        r = i(n)
      return Promise.all(e.map((e) => r.run(() => e(...t))))
    }
    function c(e, t) {
      for (const n of [...e]) n(t)
    }
    class d {
      constructor() {
        ;(this._hooks = {}),
          (this._before = void 0),
          (this._after = void 0),
          (this._deprecatedMessages = void 0),
          (this._deprecatedHooks = {}),
          (this.hook = this.hook.bind(this)),
          (this.callHook = this.callHook.bind(this)),
          (this.callHookWith = this.callHookWith.bind(this))
      }
      hook(e, t, n = {}) {
        if (!e || "function" != typeof t) return () => {}
        const r = e
        let a
        for (; this._deprecatedHooks[e]; ) (a = this._deprecatedHooks[e]), (e = a.to)
        if (a && !n.allowDeprecated) {
          let e = a.message
          e || (e = `${r} hook has been deprecated` + (a.to ? `, please use ${a.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set()),
            this._deprecatedMessages.has(e) || (console.warn(e), this._deprecatedMessages.add(e))
        }
        if (!t.name)
          try {
            Object.defineProperty(t, "name", { get: () => "_" + e.replace(/\W+/g, "_") + "_hook_cb", configurable: !0 })
          } catch {}
        return (
          (this._hooks[e] = this._hooks[e] || []),
          this._hooks[e].push(t),
          () => {
            t && (this.removeHook(e, t), (t = void 0))
          }
        )
      }
      hookOnce(e, t) {
        let n,
          r = (...e) => ("function" == typeof n && n(), (n = void 0), (r = void 0), t(...e))
        return (n = this.hook(e, r)), n
      }
      removeHook(e, t) {
        if (this._hooks[e]) {
          const n = this._hooks[e].indexOf(t)
          ;-1 !== n && this._hooks[e].splice(n, 1), 0 === this._hooks[e].length && delete this._hooks[e]
        }
      }
      deprecateHook(e, t) {
        this._deprecatedHooks[e] = "string" == typeof t ? { to: t } : t
        const n = this._hooks[e] || []
        delete this._hooks[e]
        for (const t of n) this.hook(e, t)
      }
      deprecateHooks(e) {
        Object.assign(this._deprecatedHooks, e)
        for (const t in e) this.deprecateHook(t, e[t])
      }
      addHooks(e) {
        const t = a(e),
          n = Object.keys(t).map((e) => this.hook(e, t[e]))
        return () => {
          for (const e of n.splice(0, n.length)) e()
        }
      }
      removeHooks(e) {
        const t = a(e)
        for (const e in t) this.removeHook(e, t[e])
      }
      removeAllHooks() {
        for (const e in this._hooks) delete this._hooks[e]
      }
      callHook(e, ...t) {
        return t.unshift(e), this.callHookWith(s, e, ...t)
      }
      callHookParallel(e, ...t) {
        return t.unshift(e), this.callHookWith(l, e, ...t)
      }
      callHookWith(e, t, ...n) {
        const r = this._before || this._after ? { name: t, args: n, context: {} } : void 0
        this._before && c(this._before, r)
        const a = e(t in this._hooks ? [...this._hooks[t]] : [], n)
        return a instanceof Promise
          ? a.finally(() => {
              this._after && r && c(this._after, r)
            })
          : (this._after && r && c(this._after, r), a)
      }
      beforeEach(e) {
        return (
          (this._before = this._before || []),
          this._before.push(e),
          () => {
            if (void 0 !== this._before) {
              const t = this._before.indexOf(e)
              ;-1 !== t && this._before.splice(t, 1)
            }
          }
        )
      }
      afterEach(e) {
        return (
          (this._after = this._after || []),
          this._after.push(e),
          () => {
            if (void 0 !== this._after) {
              const t = this._after.indexOf(e)
              ;-1 !== t && this._after.splice(t, 1)
            }
          }
        )
      }
    }
    const u = ["title", "titleTemplate", "script", "style", "noscript"],
      p = ["base", "meta", "link", "style", "script", "noscript"],
      h = [
        "title",
        "titleTemplate",
        "templateParams",
        "base",
        "htmlAttrs",
        "bodyAttrs",
        "meta",
        "link",
        "style",
        "script",
        "noscript",
      ],
      f = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"],
      m = [
        "tagPosition",
        "tagPriority",
        "tagDuplicateStrategy",
        "children",
        "innerHTML",
        "textContent",
        "processTemplateParams",
      ],
      g = "undefined" != typeof window
    function b(e) {
      let t = 9
      for (let n = 0; n < e.length; ) t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9)
      return (65536 + (t ^ (t >>> 9))).toString(16).substring(1, 8).toLowerCase()
    }
    function v(e) {
      return (
        e._h ||
        b(
          e._d
            ? e._d
            : `${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props)
                .map(([e, t]) => `${e}:${String(t)}`)
                .join(",")}`,
        )
      )
    }
    function y(e, t) {
      const { props: n, tag: r } = e
      if (f.includes(r)) return r
      if ("link" === r && "canonical" === n.rel) return "canonical"
      if (n.charset) return "charset"
      const a = ["id"]
      "meta" === r && a.push("name", "property", "http-equiv")
      for (const e of a) if (void 0 !== n[e]) return `${r}:${e}:${String(n[e])}`
      return !1
    }
    function O(e, t) {
      return null == e ? t || null : "function" == typeof e ? e(t) : e
    }
    function w(e, t) {
      const n = [],
        r = t.resolveKeyData || ((e) => e.key),
        a = t.resolveValueData || ((e) => e.value)
      for (const [o, i] of Object.entries(e))
        n.push(
          ...(Array.isArray(i) ? i : [i])
            .map((e) => {
              const n = { key: o, value: e },
                i = a(n)
              return "object" == typeof i
                ? w(i, t)
                : Array.isArray(i)
                  ? i
                  : {
                      ["function" == typeof t.key ? t.key(n) : t.key]: r(n),
                      ["function" == typeof t.value ? t.value(n) : t.value]: i,
                    }
            })
            .flat(),
        )
      return n
    }
    function x(e, t) {
      return Object.entries(e)
        .map(([e, n]) => {
          if (("object" == typeof n && (n = x(n, t)), t.resolve)) {
            const r = t.resolve({ key: e, value: n })
            if (void 0 !== r) return r
          }
          return (
            "number" == typeof n && (n = n.toString()),
            "string" == typeof n &&
              t.wrapValue &&
              ((n = n.replace(new RegExp(t.wrapValue, "g"), `\\${t.wrapValue}`)),
              (n = `${t.wrapValue}${n}${t.wrapValue}`)),
            `${e}${t.keyValueSeparator || ""}${n}`
          )
        })
        .join(t.entrySeparator || "")
    }
    const k = (e) => ({ keyValue: e, metaKey: "property" }),
      _ = (e) => ({ keyValue: e }),
      S = {
        appleItunesApp: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => `${A(e)}=${t}` } },
        articleExpirationTime: k("article:expiration_time"),
        articleModifiedTime: k("article:modified_time"),
        articlePublishedTime: k("article:published_time"),
        bookReleaseDate: k("book:release_date"),
        charset: { metaKey: "charset" },
        contentSecurityPolicy: {
          unpack: { entrySeparator: "; ", resolve: ({ key: e, value: t }) => `${A(e)} ${t}` },
          metaKey: "http-equiv",
        },
        contentType: { metaKey: "http-equiv" },
        defaultStyle: { metaKey: "http-equiv" },
        fbAppId: k("fb:app_id"),
        msapplicationConfig: _("msapplication-Config"),
        msapplicationTileColor: _("msapplication-TileColor"),
        msapplicationTileImage: _("msapplication-TileImage"),
        ogAudioSecureUrl: k("og:audio:secure_url"),
        ogAudioUrl: k("og:audio"),
        ogImageSecureUrl: k("og:image:secure_url"),
        ogImageUrl: k("og:image"),
        ogSiteName: k("og:site_name"),
        ogVideoSecureUrl: k("og:video:secure_url"),
        ogVideoUrl: k("og:video"),
        profileFirstName: k("profile:first_name"),
        profileLastName: k("profile:last_name"),
        profileUsername: k("profile:username"),
        refresh: {
          metaKey: "http-equiv",
          unpack: {
            entrySeparator: ";",
            resolve({ key: e, value: t }) {
              if ("seconds" === e) return `${t}`
            },
          },
        },
        robots: {
          unpack: {
            entrySeparator: ", ",
            resolve: ({ key: e, value: t }) => ("boolean" == typeof t ? `${A(e)}` : `${A(e)}:${t}`),
          },
        },
        xUaCompatible: { metaKey: "http-equiv" },
      },
      E = ["og", "book", "article", "profile"]
    function T(e) {
      var t
      const n = A(e).split(":")[0]
      return E.includes(n) ? "property" : (null == (t = S[e]) ? void 0 : t.metaKey) || "name"
    }
    function A(e) {
      const t = e.replace(/([A-Z])/g, "-$1").toLowerCase(),
        n = t.split("-")[0]
      return E.includes(n) || "twitter" === n ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t
    }
    function C(e) {
      if (Array.isArray(e)) return e.map((e) => C(e))
      if ("object" != typeof e || Array.isArray(e)) return e
      const t = {}
      for (const [n, r] of Object.entries(e)) t[A(n)] = C(r)
      return t
    }
    function P(e, t) {
      const n = S[t]
      return "refresh" === t
        ? `${e.seconds};url=${e.url}`
        : x(C(e), {
            keyValueSeparator: "=",
            entrySeparator: ", ",
            resolve: ({ value: e, key: t }) => (null === e ? "" : "boolean" == typeof e ? `${t}` : void 0),
            ...(null == n ? void 0 : n.unpack),
          })
    }
    const D = ["og:image", "og:video", "og:audio", "twitter:image"]
    function R(e) {
      const t = {}
      return (
        Object.entries(e).forEach(([e, n]) => {
          "false" !== String(n) && e && (t[e] = n)
        }),
        t
      )
    }
    function N(e, t) {
      const n = R(t),
        r = A(e),
        a = T(r)
      if (D.includes(r)) {
        const t = {}
        return (
          Object.entries(n).forEach(([n, r]) => {
            t[`${e}${"url" === n ? "" : `${n.charAt(0).toUpperCase()}${n.slice(1)}`}`] = r
          }),
          $(t).sort((e, t) => {
            var n, r
            return ((null == (n = e[a]) ? void 0 : n.length) || 0) - ((null == (r = t[a]) ? void 0 : r.length) || 0)
          })
        )
      }
      return [{ [a]: r, ...n }]
    }
    function $(e) {
      const t = [],
        n = {}
      Object.entries(e).forEach(([e, r]) => {
        if (Array.isArray(r))
          r.forEach((n) => {
            t.push(...("string" == typeof n ? $({ [e]: n }) : N(e, n)))
          })
        else if ("object" == typeof r && r) {
          if (D.includes(A(e))) return void t.push(...N(e, r))
          n[e] = R(r)
        } else n[e] = r
      })
      const r = w(n, {
        key: ({ key: e }) => T(e),
        value: ({ key: e }) => ("charset" === e ? "charset" : "content"),
        resolveKeyData: ({ key: e }) =>
          (function (e) {
            var t
            return (null == (t = S[e]) ? void 0 : t.keyValue) || A(e)
          })(e),
        resolveValueData: ({ value: e, key: t }) =>
          null === e ? "_null" : "object" == typeof e ? P(e, t) : "number" == typeof e ? e.toString() : e,
      })
      return [...t, ...r].map((e) => ("_null" === e.content && (e.content = null), e))
    }
    function I(e, t) {
      var n
      const r = "class" === e ? " " : ";"
      return (
        "object" != typeof t ||
          Array.isArray(t) ||
          (t = Object.entries(t)
            .filter(([, e]) => e)
            .map(([t, n]) => ("style" === e ? `${t}:${n}` : t))),
        null == (n = String(Array.isArray(t) ? t.join(r) : t))
          ? void 0
          : n
              .split(r)
              .filter((e) => e.trim())
              .filter(Boolean)
              .join(r)
      )
    }
    async function M(e, t) {
      for (const n of Object.keys(e))
        if (["class", "style"].includes(n)) e[n] = I(n, e[n])
        else if ((e[n] instanceof Promise && (e[n] = await e[n]), !t && !m.includes(n))) {
          const t = String(e[n]),
            r = n.startsWith("data-")
          "true" === t || "" === t
            ? (e[n] = !r || "true")
            : e[n] || (r && "false" === t ? (e[n] = "false") : delete e[n])
        }
      return e
    }
    const L = 10
    async function Q(e) {
      const t = []
      return (
        Object.entries(e.resolvedInput)
          .filter(([e, t]) => void 0 !== t && h.includes(e))
          .forEach(([n, r]) => {
            const a = (function (e) {
              return Array.isArray(e) ? e : [e]
            })(r)
            t.push(
              ...a
                .map((t) =>
                  (async function (e, t, n) {
                    const r = {
                      tag: e,
                      props: await M(
                        "object" != typeof t || "function" == typeof t || t instanceof Promise
                          ? { [["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"]: t }
                          : { ...t },
                        ["templateParams", "titleTemplate"].includes(e),
                      ),
                    }
                    return (
                      m.forEach((e) => {
                        const t = void 0 !== r.props[e] ? r.props[e] : n[e]
                        void 0 !== t &&
                          ((["innerHTML", "textContent", "children"].includes(e) && !u.includes(r.tag)) ||
                            (r["children" === e ? "innerHTML" : e] = t),
                          delete r.props[e])
                      }),
                      r.props.body && ((r.tagPosition = "bodyClose"), delete r.props.body),
                      "script" === r.tag &&
                        "object" == typeof r.innerHTML &&
                        ((r.innerHTML = JSON.stringify(r.innerHTML)),
                        (r.props.type = r.props.type || "application/json")),
                      Array.isArray(r.props.content)
                        ? r.props.content.map((e) => ({ ...r, props: { ...r.props, content: e } }))
                        : r
                    )
                  })(n, t, e),
                )
                .flat(),
            )
          }),
        (await Promise.all(t))
          .flat()
          .filter(Boolean)
          .map((t, n) => ((t._e = e._i), e.mode && (t._m = e.mode), (t._p = (e._i << L) + n), t))
      )
    }
    const B = { base: -10, title: 10 },
      j = { critical: -80, high: -10, low: 20 }
    function U(e) {
      let t = 100
      const n = e.tagPriority
      return "number" == typeof n
        ? n
        : ("meta" === e.tag
            ? ("content-security-policy" === e.props["http-equiv"] && (t = -30),
              e.props.charset && (t = -20),
              "viewport" === e.props.name && (t = -15))
            : "link" === e.tag && "preconnect" === e.props.rel
              ? (t = 20)
              : e.tag in B && (t = B[e.tag]),
          "string" == typeof n && n in j ? t + j[n] : t)
    }
    const F = [
        { prefix: "before:", offset: -1 },
        { prefix: "after:", offset: 1 },
      ],
      z = ["onload", "onerror", "onabort", "onprogress", "onloadstart"],
      q = "%separator"
    function Z(e, t, n) {
      if ("string" != typeof e || !e.includes("%")) return e
      let r = e
      try {
        r = decodeURI(e)
      } catch {}
      return (
        (r.match(/%(\w+\.+\w+)|%(\w+)/g) || [])
          .sort()
          .reverse()
          .forEach((n) => {
            const r = (function (e) {
              let n
              return (
                (n = ["s", "pageTitle"].includes(e)
                  ? t.pageTitle
                  : e.includes(".")
                    ? e.split(".").reduce((e, t) => (e && e[t]) || void 0, t)
                    : t[e]),
                void 0 !== n && (n || "").replace(/"/g, '\\"')
              )
            })(n.slice(1))
            "string" == typeof r && (e = e.replace(new RegExp(`\\${n}(\\W|$)`, "g"), (e, t) => `${r}${t}`).trim())
          }),
        e.includes(q) &&
          (e.endsWith(q) && (e = e.slice(0, -10).trim()),
          e.startsWith(q) && (e = e.slice(10).trim()),
          (e = Z((e = e.replace(new RegExp(`\\${q}\\s*\\${q}`, "g"), q)), { separator: n }, n))),
        e
      )
    }
    function H(e) {
      return (t) => {
        var n, r
        const a =
          (null ==
          (r = null == (n = t.resolvedOptions.document) ? void 0 : n.head.querySelector('script[id="unhead:payload"]'))
            ? void 0
            : r.innerHTML) || !1
        return (
          a && t.push(JSON.parse(a)),
          {
            mode: "client",
            hooks: {
              "entries:updated": function (t) {
                !(async function (e, t = {}) {
                  const n = t.delayFn || ((e) => setTimeout(e, 10))
                  e._domUpdatePromise =
                    e._domUpdatePromise ||
                    new Promise((r) =>
                      n(async () => {
                        await (async function (e, t = {}) {
                          var n
                          const r = t.document || e.resolvedOptions.document
                          if (!r || !e.dirty) return
                          const a = { shouldRender: !0, tags: [] }
                          if ((await e.hooks.callHook("dom:beforeRender", a), !a.shouldRender)) return
                          const o = (await e.resolveTags()).map((e) => ({
                            tag: e,
                            id: p.includes(e.tag) ? v(e) : e.tag,
                            shouldRender: !0,
                          }))
                          let i = e._dom
                          if (!i) {
                            i = { elMap: { htmlAttrs: r.documentElement, bodyAttrs: r.body } }
                            for (const e of ["body", "head"]) {
                              const t = null == (n = r[e]) ? void 0 : n.children,
                                a = []
                              for (const e of [...t].filter((e) => p.includes(e.tagName.toLowerCase()))) {
                                const t = {
                                  tag: e.tagName.toLowerCase(),
                                  props: await M(
                                    e.getAttributeNames().reduce((t, n) => ({ ...t, [n]: e.getAttribute(n) }), {}),
                                  ),
                                  innerHTML: e.innerHTML,
                                }
                                let n = 1,
                                  r = y(t)
                                for (; r && a.find((e) => e._d === r); ) r = `${r}:${n++}`
                                ;(t._d = r || void 0), a.push(t), (i.elMap[e.getAttribute("data-hid") || v(t)] = e)
                              }
                            }
                          }
                          function s(e, t, n) {
                            const r = `${e}:${t}`
                            ;(i.sideEffects[r] = n), delete i.pendingSideEffects[r]
                          }
                          function l({ id: e, $el: t, tag: n }) {
                            const a = n.tag.endsWith("Attrs")
                            ;(i.elMap[e] = t),
                              a ||
                                (["textContent", "innerHTML"].forEach((e) => {
                                  n[e] && n[e] !== t[e] && (t[e] = n[e])
                                }),
                                s(e, "el", () => {
                                  var t
                                  null == (t = i.elMap[e]) || t.remove(), delete i.elMap[e]
                                }))
                            for (const [e, a] of Object.entries(n._eventHandlers || {}))
                              "" !== t.getAttribute(`data-${e}`) &&
                                (("bodyAttrs" === n.tag ? r.defaultView : t).addEventListener(
                                  e.replace("on", ""),
                                  a.bind(t),
                                ),
                                t.setAttribute(`data-${e}`, ""))
                            Object.entries(n.props).forEach(([n, r]) => {
                              const o = `attr:${n}`
                              if ("class" === n)
                                for (const n of (r || "").split(" ").filter(Boolean))
                                  a && s(e, `${o}:${n}`, () => t.classList.remove(n)),
                                    !t.classList.contains(n) && t.classList.add(n)
                              else if ("style" === n)
                                for (const n of (r || "").split(";").filter(Boolean)) {
                                  const [r, ...a] = n.split(":").map((e) => e.trim())
                                  s(e, `${o}:${n}:${r}`, () => {
                                    t.style.removeProperty(r)
                                  }),
                                    t.style.setProperty(r, a.join(":"))
                                }
                              else
                                t.getAttribute(n) !== r && t.setAttribute(n, !0 === r ? "" : String(r)),
                                  a && s(e, o, () => t.removeAttribute(n))
                            })
                          }
                          ;(i.pendingSideEffects = { ...(i.sideEffects || {}) }), (i.sideEffects = {})
                          const c = [],
                            d = { bodyClose: void 0, bodyOpen: void 0, head: void 0 }
                          for (const e of o) {
                            const { tag: t, shouldRender: n, id: a } = e
                            n &&
                              ("title" !== t.tag
                                ? ((e.$el = e.$el || i.elMap[a]), e.$el ? l(e) : p.includes(t.tag) && c.push(e))
                                : (r.title = t.textContent))
                          }
                          for (const e of c) {
                            const t = e.tag.tagPosition || "head"
                            ;(e.$el = r.createElement(e.tag.tag)),
                              l(e),
                              (d[t] = d[t] || r.createDocumentFragment()),
                              d[t].appendChild(e.$el)
                          }
                          for (const t of o) await e.hooks.callHook("dom:renderTag", t, r, s)
                          d.head && r.head.appendChild(d.head),
                            d.bodyOpen && r.body.insertBefore(d.bodyOpen, r.body.firstChild),
                            d.bodyClose && r.body.appendChild(d.bodyClose),
                            Object.values(i.pendingSideEffects).forEach((e) => e()),
                            (e._dom = i),
                            (e.dirty = !1),
                            await e.hooks.callHook("dom:rendered", { renders: o })
                        })(e, t),
                          delete e._domUpdatePromise,
                          r()
                      }),
                    )
                })(t, e)
              },
            },
          }
        )
      }
    }
    const V = ["templateParams", "htmlAttrs", "bodyAttrs"],
      W = {
        hooks: {
          "tag:normalise": function ({ tag: e }) {
            ;["hid", "vmid", "key"].forEach((t) => {
              e.props[t] && ((e.key = e.props[t]), delete e.props[t])
            })
            const t = y(e) || (!!e.key && `${e.tag}:${e.key}`)
            t && (e._d = t)
          },
          "tags:resolve": function (e) {
            const t = {}
            e.tags.forEach((e) => {
              const n = (e.key ? `${e.tag}:${e.key}` : e._d) || e._p,
                r = t[n]
              if (r) {
                let a = null == e ? void 0 : e.tagDuplicateStrategy
                if ((!a && V.includes(e.tag) && (a = "merge"), "merge" === a)) {
                  const a = r.props
                  return (
                    ["class", "style"].forEach((t) => {
                      a[t] &&
                        (e.props[t]
                          ? ("style" !== t || a[t].endsWith(";") || (a[t] += ";"),
                            (e.props[t] = `${a[t]} ${e.props[t]}`))
                          : (e.props[t] = a[t]))
                    }),
                    void (t[n].props = { ...a, ...e.props })
                  )
                }
                if (e._e === r._e)
                  return (r._duped = r._duped || []), (e._d = `${r._d}:${r._duped.length + 1}`), void r._duped.push(e)
                if (U(e) > U(r)) return
              }
              const a = Object.keys(e.props).length + (e.innerHTML ? 1 : 0) + (e.textContent ? 1 : 0)
              p.includes(e.tag) && 0 === a ? delete t[n] : (t[n] = e)
            })
            const n = []
            Object.values(t).forEach((e) => {
              const t = e._duped
              delete e._duped, n.push(e), t && n.push(...t)
            }),
              (e.tags = n),
              (e.tags = e.tags.filter(
                (e) => !("meta" === e.tag && (e.props.name || e.props.property) && !e.props.content),
              ))
          },
        },
      },
      X = {
        mode: "server",
        hooks: {
          "tags:resolve": function (e) {
            const t = {}
            e.tags
              .filter((e) => ["titleTemplate", "templateParams", "title"].includes(e.tag) && "server" === e._m)
              .forEach((e) => {
                t[e.tag] = e.tag.startsWith("title") ? e.textContent : e.props
              }),
              Object.keys(t).length &&
                e.tags.push({
                  tag: "script",
                  innerHTML: JSON.stringify(t),
                  props: { id: "unhead:payload", type: "application/json" },
                })
          },
        },
      },
      Y = ["script", "link", "bodyAttrs"],
      G = (e) => ({
        hooks: {
          "tags:resolve": function (t) {
            for (const n of t.tags.filter((e) => Y.includes(e.tag)))
              Object.entries(n.props).forEach(([t, r]) => {
                t.startsWith("on") &&
                  "function" == typeof r &&
                  (e.ssr && z.includes(t) ? (n.props[t] = `this.dataset.${t}fired = true`) : delete n.props[t],
                  (n._eventHandlers = n._eventHandlers || {}),
                  (n._eventHandlers[t] = r))
              }),
                e.ssr &&
                  n._eventHandlers &&
                  (n.props.src || n.props.href) &&
                  (n.key = n.key || b(n.props.src || n.props.href))
          },
          "dom:renderTag": function ({ $el: e, tag: t }) {
            var n, r
            for (const a of Object.keys((null == e ? void 0 : e.dataset) || {}).filter((e) =>
              z.some((t) => `${t}fired` === e),
            )) {
              const o = a.replace("fired", "")
              null == (r = null == (n = t._eventHandlers) ? void 0 : n[o]) || r.call(e, new Event(o.replace("on", "")))
            }
          },
        },
      }),
      K = ["link", "style", "script", "noscript"],
      J = {
        hooks: {
          "tag:normalise": ({ tag: e }) => {
            e.key && K.includes(e.tag) && (e.props["data-hid"] = e._h = b(e.key))
          },
        },
      },
      ee = {
        hooks: {
          "tags:resolve": (e) => {
            const t = (t) => {
              var n
              return null == (n = e.tags.find((e) => e._d === t)) ? void 0 : n._p
            }
            for (const { prefix: n, offset: r } of F)
              for (const a of e.tags.filter((e) => "string" == typeof e.tagPriority && e.tagPriority.startsWith(n))) {
                const e = t(a.tagPriority.replace(n, ""))
                void 0 !== e && (a._p = e + r)
              }
            e.tags.sort((e, t) => e._p - t._p).sort((e, t) => U(e) - U(t))
          },
        },
      },
      te = { meta: "content", link: "href", htmlAttrs: "lang" },
      ne = (e) => ({
        hooks: {
          "tags:resolve": (t) => {
            var n
            const { tags: r } = t,
              a = null == (n = r.find((e) => "title" === e.tag)) ? void 0 : n.textContent,
              o = r.findIndex((e) => "templateParams" === e.tag),
              i = -1 !== o ? r[o].props : {},
              s = i.separator || "|"
            delete i.separator, (i.pageTitle = Z(i.pageTitle || a || "", i, s))
            for (const e of r.filter((e) => !1 !== e.processTemplateParams)) {
              const t = te[e.tag]
              t && "string" == typeof e.props[t]
                ? (e.props[t] = Z(e.props[t], i, s))
                : (!0 === e.processTemplateParams || ["titleTemplate", "title"].includes(e.tag)) &&
                  ["innerHTML", "textContent"].forEach((t) => {
                    "string" == typeof e[t] && (e[t] = Z(e[t], i, s))
                  })
            }
            ;(e._templateParams = i), (e._separator = s), (t.tags = r.filter((e) => "templateParams" !== e.tag))
          },
        },
      }),
      re = {
        hooks: {
          "tags:resolve": (e) => {
            const { tags: t } = e
            let n = t.findIndex((e) => "titleTemplate" === e.tag)
            const r = t.findIndex((e) => "title" === e.tag)
            if (-1 !== r && -1 !== n) {
              const e = O(t[n].textContent, t[r].textContent)
              null !== e ? (t[r].textContent = e || t[r].textContent) : delete t[r]
            } else if (-1 !== n) {
              const e = O(t[n].textContent)
              null !== e && ((t[n].textContent = e), (t[n].tag = "title"), (n = -1))
            }
            ;-1 !== n && delete t[n], (e.tags = t.filter(Boolean))
          },
        },
      },
      ae = {
        hooks: {
          "tags:afterResolve": function (e) {
            for (const t of e.tags)
              "string" == typeof t.innerHTML &&
                (t.innerHTML && ["application/ld+json", "application/json"].includes(t.props.type)
                  ? (t.innerHTML = t.innerHTML.replace(/</g, "\\u003C"))
                  : (t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`, "g"), `<\\/${t.tag}`)))
          },
        },
      }
    let oe
    function ie(e, t) {
      return !e || ("server" === e && t) || ("client" === e && !t)
    }
    /**
     * @vue/shared v3.4.31
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/
    /*! #__NO_SIDE_EFFECTS__ */ function se(e, t) {
      const n = new Set(e.split(","))
      return (e) => n.has(e)
    }
    const le = {},
      ce = [],
      de = () => {},
      ue = () => !1,
      pe = (e) => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
      he = (e) => e.startsWith("onUpdate:"),
      fe = Object.assign,
      me = (e, t) => {
        const n = e.indexOf(t)
        n > -1 && e.splice(n, 1)
      },
      ge = Object.prototype.hasOwnProperty,
      be = (e, t) => ge.call(e, t),
      ve = Array.isArray,
      ye = (e) => "[object Map]" === Ae(e),
      Oe = (e) => "[object Set]" === Ae(e),
      we = (e) => "[object Date]" === Ae(e),
      xe = (e) => "function" == typeof e,
      ke = (e) => "string" == typeof e,
      _e = (e) => "symbol" == typeof e,
      Se = (e) => null !== e && "object" == typeof e,
      Ee = (e) => (Se(e) || xe(e)) && xe(e.then) && xe(e.catch),
      Te = Object.prototype.toString,
      Ae = (e) => Te.call(e),
      Ce = (e) => Ae(e).slice(8, -1),
      Pe = (e) => "[object Object]" === Ae(e),
      De = (e) => ke(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
      Re = se(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted",
      ),
      Ne = (e) => {
        const t = Object.create(null)
        return (n) => t[n] || (t[n] = e(n))
      },
      $e = /-(\w)/g,
      Ie = Ne((e) => e.replace($e, (e, t) => (t ? t.toUpperCase() : ""))),
      Me = /\B([A-Z])/g,
      Le = Ne((e) => e.replace(Me, "-$1").toLowerCase()),
      Qe = Ne((e) => e.charAt(0).toUpperCase() + e.slice(1)),
      Be = Ne((e) => (e ? `on${Qe(e)}` : "")),
      je = (e, t) => !Object.is(e, t),
      Ue = (e, ...t) => {
        for (let n = 0; n < e.length; n++) e[n](...t)
      },
      Fe = (e, t, n, r = !1) => {
        Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: r, value: n })
      },
      ze = (e) => {
        const t = parseFloat(e)
        return isNaN(t) ? e : t
      }
    let qe
    const Ze = () =>
      qe ||
      (qe =
        "undefined" != typeof globalThis
          ? globalThis
          : "undefined" != typeof self
            ? self
            : "undefined" != typeof window
              ? window
              : "undefined" != typeof global
                ? global
                : {})
    function He(e) {
      if (ve(e)) {
        const t = {}
        for (let n = 0; n < e.length; n++) {
          const r = e[n],
            a = ke(r) ? Ye(r) : He(r)
          if (a) for (const e in a) t[e] = a[e]
        }
        return t
      }
      if (ke(e) || Se(e)) return e
    }
    const Ve = /;(?![^(]*\))/g,
      We = /:([^]+)/,
      Xe = /\/\*[^]*?\*\//g
    function Ye(e) {
      const t = {}
      return (
        e
          .replace(Xe, "")
          .split(Ve)
          .forEach((e) => {
            if (e) {
              const n = e.split(We)
              n.length > 1 && (t[n[0].trim()] = n[1].trim())
            }
          }),
        t
      )
    }
    function Ge(e) {
      let t = ""
      if (ke(e)) t = e
      else if (ve(e))
        for (let n = 0; n < e.length; n++) {
          const r = Ge(e[n])
          r && (t += r + " ")
        }
      else if (Se(e)) for (const n in e) e[n] && (t += n + " ")
      return t.trim()
    }
    function Ke(e) {
      if (!e) return null
      let { class: t, style: n } = e
      return t && !ke(t) && (e.class = Ge(t)), n && (e.style = He(n)), e
    }
    const Je = se("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly")
    function et(e) {
      return !!e || "" === e
    }
    function tt(e, t) {
      if (e === t) return !0
      let n = we(e),
        r = we(t)
      if (n || r) return !(!n || !r) && e.getTime() === t.getTime()
      if (((n = _e(e)), (r = _e(t)), n || r)) return e === t
      if (((n = ve(e)), (r = ve(t)), n || r))
        return (
          !(!n || !r) &&
          (function (e, t) {
            if (e.length !== t.length) return !1
            let n = !0
            for (let r = 0; n && r < e.length; r++) n = tt(e[r], t[r])
            return n
          })(e, t)
        )
      if (((n = Se(e)), (r = Se(t)), n || r)) {
        if (!n || !r) return !1
        if (Object.keys(e).length !== Object.keys(t).length) return !1
        for (const n in e) {
          const r = e.hasOwnProperty(n),
            a = t.hasOwnProperty(n)
          if ((r && !a) || (!r && a) || !tt(e[n], t[n])) return !1
        }
      }
      return String(e) === String(t)
    }
    function nt(e, t) {
      return e.findIndex((e) => tt(e, t))
    }
    const rt = (e) => !(!e || !0 !== e.__v_isRef),
      at = (e) =>
        ke(e)
          ? e
          : null == e
            ? ""
            : ve(e) || (Se(e) && (e.toString === Te || !xe(e.toString)))
              ? rt(e)
                ? at(e.value)
                : JSON.stringify(e, ot, 2)
              : String(e),
      ot = (e, t) =>
        rt(t)
          ? ot(e, t.value)
          : ye(t)
            ? { [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, n], r) => ((e[it(t, r) + " =>"] = n), e), {}) }
            : Oe(t)
              ? { [`Set(${t.size})`]: [...t.values()].map((e) => it(e)) }
              : _e(t)
                ? it(t)
                : !Se(t) || ve(t) || Pe(t)
                  ? t
                  : String(t),
      it = (e, t = "") => {
        var n
        return _e(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e
      }
    /**
     * @vue/reactivity v3.4.31
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/ let st, lt
    class ct {
      constructor(e = !1) {
        ;(this.detached = e),
          (this._active = !0),
          (this.effects = []),
          (this.cleanups = []),
          (this.parent = st),
          !e && st && (this.index = (st.scopes || (st.scopes = [])).push(this) - 1)
      }
      get active() {
        return this._active
      }
      run(e) {
        if (this._active) {
          const t = st
          try {
            return (st = this), e()
          } finally {
            st = t
          }
        }
      }
      on() {
        st = this
      }
      off() {
        st = this.parent
      }
      stop(e) {
        if (this._active) {
          let t, n
          for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].stop()
          for (t = 0, n = this.cleanups.length; t < n; t++) this.cleanups[t]()
          if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0)
          if (!this.detached && this.parent && !e) {
            const e = this.parent.scopes.pop()
            e && e !== this && ((this.parent.scopes[this.index] = e), (e.index = this.index))
          }
          ;(this.parent = void 0), (this._active = !1)
        }
      }
    }
    function dt() {
      return st
    }
    function ut(e) {
      st && st.cleanups.push(e)
    }
    class pt {
      constructor(e, t, n, r) {
        ;(this.fn = e),
          (this.trigger = t),
          (this.scheduler = n),
          (this.active = !0),
          (this.deps = []),
          (this._dirtyLevel = 4),
          (this._trackId = 0),
          (this._runnings = 0),
          (this._shouldSchedule = !1),
          (this._depsLength = 0),
          (function (e, t = st) {
            t && t.active && t.effects.push(e)
          })(this, r)
      }
      get dirty() {
        if (2 === this._dirtyLevel || 3 === this._dirtyLevel) {
          ;(this._dirtyLevel = 1), yt()
          for (let e = 0; e < this._depsLength; e++) {
            const t = this.deps[e]
            if (t.computed && (t.computed.value, this._dirtyLevel >= 4)) break
          }
          1 === this._dirtyLevel && (this._dirtyLevel = 0), Ot()
        }
        return this._dirtyLevel >= 4
      }
      set dirty(e) {
        this._dirtyLevel = e ? 4 : 0
      }
      run() {
        if (((this._dirtyLevel = 0), !this.active)) return this.fn()
        let e = gt,
          t = lt
        try {
          return (gt = !0), (lt = this), this._runnings++, ht(this), this.fn()
        } finally {
          ft(this), this._runnings--, (lt = t), (gt = e)
        }
      }
      stop() {
        this.active && (ht(this), ft(this), this.onStop && this.onStop(), (this.active = !1))
      }
    }
    function ht(e) {
      e._trackId++, (e._depsLength = 0)
    }
    function ft(e) {
      if (e.deps.length > e._depsLength) {
        for (let t = e._depsLength; t < e.deps.length; t++) mt(e.deps[t], e)
        e.deps.length = e._depsLength
      }
    }
    function mt(e, t) {
      const n = e.get(t)
      void 0 !== n && t._trackId !== n && (e.delete(t), 0 === e.size && e.cleanup())
    }
    let gt = !0,
      bt = 0
    const vt = []
    function yt() {
      vt.push(gt), (gt = !1)
    }
    function Ot() {
      const e = vt.pop()
      gt = void 0 === e || e
    }
    function wt() {
      bt++
    }
    function xt() {
      for (bt--; !bt && _t.length; ) _t.shift()()
    }
    function kt(e, t, n) {
      if (t.get(e) !== e._trackId) {
        t.set(e, e._trackId)
        const n = e.deps[e._depsLength]
        n !== t ? (n && mt(n, e), (e.deps[e._depsLength++] = t)) : e._depsLength++
      }
    }
    const _t = []
    function St(e, t, n) {
      wt()
      for (const n of e.keys()) {
        let r
        n._dirtyLevel < t &&
          (null != r ? r : (r = e.get(n) === n._trackId)) &&
          (n._shouldSchedule || (n._shouldSchedule = 0 === n._dirtyLevel), (n._dirtyLevel = t)),
          n._shouldSchedule &&
            (null != r ? r : (r = e.get(n) === n._trackId)) &&
            (n.trigger(),
            (n._runnings && !n.allowRecurse) ||
              2 === n._dirtyLevel ||
              ((n._shouldSchedule = !1), n.scheduler && _t.push(n.scheduler)))
      }
      xt()
    }
    const Et = (e, t) => {
        const n = new Map()
        return (n.cleanup = e), (n.computed = t), n
      },
      Tt = new WeakMap(),
      At = Symbol(""),
      Ct = Symbol("")
    function Pt(e, t, n) {
      if (gt && lt) {
        let t = Tt.get(e)
        t || Tt.set(e, (t = new Map()))
        let r = t.get(n)
        r || t.set(n, (r = Et(() => t.delete(n)))), kt(lt, r)
      }
    }
    function Dt(e, t, n, r, a, o) {
      const i = Tt.get(e)
      if (!i) return
      let s = []
      if ("clear" === t) s = [...i.values()]
      else if ("length" === n && ve(e)) {
        const e = Number(r)
        i.forEach((t, n) => {
          ;("length" === n || (!_e(n) && n >= e)) && s.push(t)
        })
      } else
        switch ((void 0 !== n && s.push(i.get(n)), t)) {
          case "add":
            ve(e) ? De(n) && s.push(i.get("length")) : (s.push(i.get(At)), ye(e) && s.push(i.get(Ct)))
            break
          case "delete":
            ve(e) || (s.push(i.get(At)), ye(e) && s.push(i.get(Ct)))
            break
          case "set":
            ye(e) && s.push(i.get(At))
        }
      wt()
      for (const e of s) e && St(e, 4)
      xt()
    }
    const Rt = se("__proto__,__v_isRef,__isVue"),
      Nt = new Set(
        Object.getOwnPropertyNames(Symbol)
          .filter((e) => "arguments" !== e && "caller" !== e)
          .map((e) => Symbol[e])
          .filter(_e),
      ),
      $t = (function () {
        const e = {}
        return (
          ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
            e[t] = function (...e) {
              const n = _n(this)
              for (let e = 0, t = this.length; e < t; e++) Pt(n, 0, e + "")
              const r = n[t](...e)
              return -1 === r || !1 === r ? n[t](...e.map(_n)) : r
            }
          }),
          ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
            e[t] = function (...e) {
              yt(), wt()
              const n = _n(this)[t].apply(this, e)
              return xt(), Ot(), n
            }
          }),
          e
        )
      })()
    function It(e) {
      _e(e) || (e = String(e))
      const t = _n(this)
      return Pt(t, 0, e), t.hasOwnProperty(e)
    }
    class Mt {
      constructor(e = !1, t = !1) {
        ;(this._isReadonly = e), (this._isShallow = t)
      }
      get(e, t, n) {
        const r = this._isReadonly,
          a = this._isShallow
        if ("__v_isReactive" === t) return !r
        if ("__v_isReadonly" === t) return r
        if ("__v_isShallow" === t) return a
        if ("__v_raw" === t)
          return n === (r ? (a ? fn : hn) : a ? pn : un).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n)
            ? e
            : void 0
        const o = ve(e)
        if (!r) {
          if (o && be($t, t)) return Reflect.get($t, t, n)
          if ("hasOwnProperty" === t) return It
        }
        const i = Reflect.get(e, t, n)
        return (_e(t) ? Nt.has(t) : Rt(t))
          ? i
          : (r || Pt(e, 0, t), a ? i : Pn(i) ? (o && De(t) ? i : i.value) : Se(i) ? (r ? bn(i) : mn(i)) : i)
      }
    }
    class Lt extends Mt {
      constructor(e = !1) {
        super(!1, e)
      }
      set(e, t, n, r) {
        let a = e[t]
        if (!this._isShallow) {
          const t = wn(a)
          if ((xn(n) || wn(n) || ((a = _n(a)), (n = _n(n))), !ve(e) && Pn(a) && !Pn(n)))
            return !t && ((a.value = n), !0)
        }
        const o = ve(e) && De(t) ? Number(t) < e.length : be(e, t),
          i = Reflect.set(e, t, n, r)
        return e === _n(r) && (o ? je(n, a) && Dt(e, "set", t, n) : Dt(e, "add", t, n)), i
      }
      deleteProperty(e, t) {
        const n = be(e, t)
        e[t]
        const r = Reflect.deleteProperty(e, t)
        return r && n && Dt(e, "delete", t, void 0), r
      }
      has(e, t) {
        const n = Reflect.has(e, t)
        return (_e(t) && Nt.has(t)) || Pt(e, 0, t), n
      }
      ownKeys(e) {
        return Pt(e, 0, ve(e) ? "length" : At), Reflect.ownKeys(e)
      }
    }
    class Qt extends Mt {
      constructor(e = !1) {
        super(!0, e)
      }
      set(e, t) {
        return !0
      }
      deleteProperty(e, t) {
        return !0
      }
    }
    const Bt = new Lt(),
      jt = new Qt(),
      Ut = new Lt(!0),
      Ft = new Qt(!0),
      zt = (e) => e,
      qt = (e) => Reflect.getPrototypeOf(e)
    function Zt(e, t, n = !1, r = !1) {
      const a = _n((e = e.__v_raw)),
        o = _n(t)
      n || (je(t, o) && Pt(a, 0, t), Pt(a, 0, o))
      const { has: i } = qt(a),
        s = r ? zt : n ? En : Sn
      return i.call(a, t) ? s(e.get(t)) : i.call(a, o) ? s(e.get(o)) : void (e !== a && e.get(t))
    }
    function Ht(e, t = !1) {
      const n = this.__v_raw,
        r = _n(n),
        a = _n(e)
      return t || (je(e, a) && Pt(r, 0, e), Pt(r, 0, a)), e === a ? n.has(e) : n.has(e) || n.has(a)
    }
    function Vt(e, t = !1) {
      return (e = e.__v_raw), !t && Pt(_n(e), 0, At), Reflect.get(e, "size", e)
    }
    function Wt(e) {
      e = _n(e)
      const t = _n(this)
      return qt(t).has.call(t, e) || (t.add(e), Dt(t, "add", e, e)), this
    }
    function Xt(e, t) {
      t = _n(t)
      const n = _n(this),
        { has: r, get: a } = qt(n)
      let o = r.call(n, e)
      o || ((e = _n(e)), (o = r.call(n, e)))
      const i = a.call(n, e)
      return n.set(e, t), o ? je(t, i) && Dt(n, "set", e, t) : Dt(n, "add", e, t), this
    }
    function Yt(e) {
      const t = _n(this),
        { has: n, get: r } = qt(t)
      let a = n.call(t, e)
      a || ((e = _n(e)), (a = n.call(t, e))), r && r.call(t, e)
      const o = t.delete(e)
      return a && Dt(t, "delete", e, void 0), o
    }
    function Gt() {
      const e = _n(this),
        t = 0 !== e.size,
        n = e.clear()
      return t && Dt(e, "clear", void 0, void 0), n
    }
    function Kt(e, t) {
      return function (n, r) {
        const a = this,
          o = a.__v_raw,
          i = _n(o),
          s = t ? zt : e ? En : Sn
        return !e && Pt(i, 0, At), o.forEach((e, t) => n.call(r, s(e), s(t), a))
      }
    }
    function Jt(e, t, n) {
      return function (...r) {
        const a = this.__v_raw,
          o = _n(a),
          i = ye(o),
          s = "entries" === e || (e === Symbol.iterator && i),
          l = "keys" === e && i,
          c = a[e](...r),
          d = n ? zt : t ? En : Sn
        return (
          !t && Pt(o, 0, l ? Ct : At),
          {
            next() {
              const { value: e, done: t } = c.next()
              return t ? { value: e, done: t } : { value: s ? [d(e[0]), d(e[1])] : d(e), done: t }
            },
            [Symbol.iterator]() {
              return this
            },
          }
        )
      }
    }
    function en(e) {
      return function (...t) {
        return "delete" !== e && ("clear" === e ? void 0 : this)
      }
    }
    const [tn, nn, rn, an] = (function () {
      const e = {
          get(e) {
            return Zt(this, e)
          },
          get size() {
            return Vt(this)
          },
          has: Ht,
          add: Wt,
          set: Xt,
          delete: Yt,
          clear: Gt,
          forEach: Kt(!1, !1),
        },
        t = {
          get(e) {
            return Zt(this, e, !1, !0)
          },
          get size() {
            return Vt(this)
          },
          has: Ht,
          add: Wt,
          set: Xt,
          delete: Yt,
          clear: Gt,
          forEach: Kt(!1, !0),
        },
        n = {
          get(e) {
            return Zt(this, e, !0)
          },
          get size() {
            return Vt(this, !0)
          },
          has(e) {
            return Ht.call(this, e, !0)
          },
          add: en("add"),
          set: en("set"),
          delete: en("delete"),
          clear: en("clear"),
          forEach: Kt(!0, !1),
        },
        r = {
          get(e) {
            return Zt(this, e, !0, !0)
          },
          get size() {
            return Vt(this, !0)
          },
          has(e) {
            return Ht.call(this, e, !0)
          },
          add: en("add"),
          set: en("set"),
          delete: en("delete"),
          clear: en("clear"),
          forEach: Kt(!0, !0),
        }
      return (
        ["keys", "values", "entries", Symbol.iterator].forEach((a) => {
          ;(e[a] = Jt(a, !1, !1)), (n[a] = Jt(a, !0, !1)), (t[a] = Jt(a, !1, !0)), (r[a] = Jt(a, !0, !0))
        }),
        [e, n, t, r]
      )
    })()
    function on(e, t) {
      const n = t ? (e ? an : rn) : e ? nn : tn
      return (t, r, a) =>
        "__v_isReactive" === r
          ? !e
          : "__v_isReadonly" === r
            ? e
            : "__v_raw" === r
              ? t
              : Reflect.get(be(n, r) && r in t ? n : t, r, a)
    }
    const sn = { get: on(!1, !1) },
      ln = { get: on(!1, !0) },
      cn = { get: on(!0, !1) },
      dn = { get: on(!0, !0) },
      un = new WeakMap(),
      pn = new WeakMap(),
      hn = new WeakMap(),
      fn = new WeakMap()
    function mn(e) {
      return wn(e) ? e : yn(e, !1, Bt, sn, un)
    }
    function gn(e) {
      return yn(e, !1, Ut, ln, pn)
    }
    function bn(e) {
      return yn(e, !0, jt, cn, hn)
    }
    function vn(e) {
      return yn(e, !0, Ft, dn, fn)
    }
    function yn(e, t, n, r, a) {
      if (!Se(e)) return e
      if (e.__v_raw && (!t || !e.__v_isReactive)) return e
      const o = a.get(e)
      if (o) return o
      const i =
        (s = e).__v_skip || !Object.isExtensible(s)
          ? 0
          : (function (e) {
              switch (e) {
                case "Object":
                case "Array":
                  return 1
                case "Map":
                case "Set":
                case "WeakMap":
                case "WeakSet":
                  return 2
                default:
                  return 0
              }
            })(Ce(s))
      var s
      if (0 === i) return e
      const l = new Proxy(e, 2 === i ? r : n)
      return a.set(e, l), l
    }
    function On(e) {
      return wn(e) ? On(e.__v_raw) : !(!e || !e.__v_isReactive)
    }
    function wn(e) {
      return !(!e || !e.__v_isReadonly)
    }
    function xn(e) {
      return !(!e || !e.__v_isShallow)
    }
    function kn(e) {
      return !!e && !!e.__v_raw
    }
    function _n(e) {
      const t = e && e.__v_raw
      return t ? _n(t) : e
    }
    const Sn = (e) => (Se(e) ? mn(e) : e),
      En = (e) => (Se(e) ? bn(e) : e)
    class Tn {
      constructor(e, t, n, r) {
        ;(this.getter = e),
          (this._setter = t),
          (this.dep = void 0),
          (this.__v_isRef = !0),
          (this.__v_isReadonly = !1),
          (this.effect = new pt(
            () => e(this._value),
            () => Cn(this, 2 === this.effect._dirtyLevel ? 2 : 3),
          )),
          (this.effect.computed = this),
          (this.effect.active = this._cacheable = !r),
          (this.__v_isReadonly = n)
      }
      get value() {
        const e = _n(this)
        return (
          (e._cacheable && !e.effect.dirty) || !je(e._value, (e._value = e.effect.run())) || Cn(e, 4),
          An(e),
          e.effect._dirtyLevel >= 2 && Cn(e, 2),
          e._value
        )
      }
      set value(e) {
        this._setter(e)
      }
      get _dirty() {
        return this.effect.dirty
      }
      set _dirty(e) {
        this.effect.dirty = e
      }
    }
    function An(e) {
      var t
      gt &&
        lt &&
        ((e = _n(e)),
        kt(lt, null != (t = e.dep) ? t : (e.dep = Et(() => (e.dep = void 0), e instanceof Tn ? e : void 0))))
    }
    function Cn(e, t = 4, n, r) {
      const a = (e = _n(e)).dep
      a && St(a, t)
    }
    function Pn(e) {
      return !(!e || !0 !== e.__v_isRef)
    }
    function Dn(e) {
      return Nn(e, !1)
    }
    function Rn(e) {
      return Nn(e, !0)
    }
    function Nn(e, t) {
      return Pn(e) ? e : new $n(e, t)
    }
    class $n {
      constructor(e, t) {
        ;(this.__v_isShallow = t),
          (this.dep = void 0),
          (this.__v_isRef = !0),
          (this._rawValue = t ? e : _n(e)),
          (this._value = t ? e : Sn(e))
      }
      get value() {
        return An(this), this._value
      }
      set value(e) {
        const t = this.__v_isShallow || xn(e) || wn(e)
        ;(e = t ? e : _n(e)),
          je(e, this._rawValue) && (this._rawValue, (this._rawValue = e), (this._value = t ? e : Sn(e)), Cn(this, 4))
      }
    }
    function In(e) {
      return Pn(e) ? e.value : e
    }
    function Mn(e) {
      return xe(e) ? e() : In(e)
    }
    const Ln = {
      get: (e, t, n) => In(Reflect.get(e, t, n)),
      set: (e, t, n, r) => {
        const a = e[t]
        return Pn(a) && !Pn(n) ? ((a.value = n), !0) : Reflect.set(e, t, n, r)
      },
    }
    function Qn(e) {
      return On(e) ? e : new Proxy(e, Ln)
    }
    class Bn {
      constructor(e) {
        ;(this.dep = void 0), (this.__v_isRef = !0)
        const { get: t, set: n } = e(
          () => An(this),
          () => Cn(this),
        )
        ;(this._get = t), (this._set = n)
      }
      get value() {
        return this._get()
      }
      set value(e) {
        this._set(e)
      }
    }
    function jn(e) {
      const t = ve(e) ? new Array(e.length) : {}
      for (const n in e) t[n] = qn(e, n)
      return t
    }
    class Un {
      constructor(e, t, n) {
        ;(this._object = e), (this._key = t), (this._defaultValue = n), (this.__v_isRef = !0)
      }
      get value() {
        const e = this._object[this._key]
        return void 0 === e ? this._defaultValue : e
      }
      set value(e) {
        this._object[this._key] = e
      }
      get dep() {
        return (function (e, t) {
          const n = Tt.get(e)
          return n && n.get(t)
        })(_n(this._object), this._key)
      }
    }
    class Fn {
      constructor(e) {
        ;(this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
      }
      get value() {
        return this._getter()
      }
    }
    function zn(e, t, n) {
      return Pn(e) ? e : xe(e) ? new Fn(e) : Se(e) && arguments.length > 1 ? qn(e, t, n) : Dn(e)
    }
    function qn(e, t, n) {
      const r = e[t]
      return Pn(r) ? r : new Un(e, t, n)
    }
    /**
     * @vue/runtime-core v3.4.31
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/ function Zn(e, t, n, r) {
      try {
        return r ? e(...r) : e()
      } catch (e) {
        Vn(e, t, n)
      }
    }
    function Hn(e, t, n, r) {
      if (xe(e)) {
        const a = Zn(e, t, n, r)
        return (
          a &&
            Ee(a) &&
            a.catch((e) => {
              Vn(e, t, n)
            }),
          a
        )
      }
      if (ve(e)) {
        const a = []
        for (let o = 0; o < e.length; o++) a.push(Hn(e[o], t, n, r))
        return a
      }
    }
    function Vn(e, t, n, r = !0) {
      if ((t && t.vnode, t)) {
        let r = t.parent
        const a = t.proxy,
          o = `https://vuejs.org/error-reference/#runtime-${n}`
        for (; r; ) {
          const t = r.ec
          if (t) for (let n = 0; n < t.length; n++) if (!1 === t[n](e, a, o)) return
          r = r.parent
        }
        const i = t.appContext.config.errorHandler
        if (i) return yt(), Zn(i, null, 10, [e, a, o]), void Ot()
      }
      !(function (e, t, n, r = !0) {
        console.error(e)
      })(e, 0, 0, r)
    }
    let Wn = !1,
      Xn = !1
    const Yn = []
    let Gn = 0
    const Kn = []
    let Jn = null,
      er = 0
    const tr = Promise.resolve()
    let nr = null
    function rr(e) {
      const t = nr || tr
      return e ? t.then(this ? e.bind(this) : e) : t
    }
    function ar(e) {
      ;(Yn.length && Yn.includes(e, Wn && e.allowRecurse ? Gn + 1 : Gn)) ||
        (null == e.id
          ? Yn.push(e)
          : Yn.splice(
              (function (e) {
                let t = Gn + 1,
                  n = Yn.length
                for (; t < n; ) {
                  const r = (t + n) >>> 1,
                    a = Yn[r],
                    o = lr(a)
                  o < e || (o === e && a.pre) ? (t = r + 1) : (n = r)
                }
                return t
              })(e.id),
              0,
              e,
            ),
        or())
    }
    function or() {
      Wn || Xn || ((Xn = !0), (nr = tr.then(dr)))
    }
    function ir(e, t, n = Wn ? Gn + 1 : 0) {
      for (; n < Yn.length; n++) {
        const t = Yn[n]
        if (t && t.pre) {
          if (e && t.id !== e.uid) continue
          Yn.splice(n, 1), n--, t()
        }
      }
    }
    function sr(e) {
      if (Kn.length) {
        const e = [...new Set(Kn)].sort((e, t) => lr(e) - lr(t))
        if (((Kn.length = 0), Jn)) return void Jn.push(...e)
        for (Jn = e, er = 0; er < Jn.length; er++) {
          const e = Jn[er]
          !1 !== e.active && e()
        }
        ;(Jn = null), (er = 0)
      }
    }
    const lr = (e) => (null == e.id ? 1 / 0 : e.id),
      cr = (e, t) => {
        const n = lr(e) - lr(t)
        if (0 === n) {
          if (e.pre && !t.pre) return -1
          if (t.pre && !e.pre) return 1
        }
        return n
      }
    function dr(e) {
      ;(Xn = !1), (Wn = !0), Yn.sort(cr)
      try {
        for (Gn = 0; Gn < Yn.length; Gn++) {
          const e = Yn[Gn]
          e && !1 !== e.active && Zn(e, null, 14)
        }
      } finally {
        ;(Gn = 0), (Yn.length = 0), sr(), (Wn = !1), (nr = null), (Yn.length || Kn.length) && dr()
      }
    }
    function ur(e, t, ...n) {
      if (e.isUnmounted) return
      const r = e.vnode.props || le
      let a = n
      const o = t.startsWith("update:"),
        i = o && t.slice(7)
      if (i && i in r) {
        const e = `${"modelValue" === i ? "model" : i}Modifiers`,
          { number: t, trim: o } = r[e] || le
        o && (a = n.map((e) => (ke(e) ? e.trim() : e))), t && (a = n.map(ze))
      }
      let s,
        l = r[(s = Be(t))] || r[(s = Be(Ie(t)))]
      !l && o && (l = r[(s = Be(Le(t)))]), l && Hn(l, e, 6, a)
      const c = r[s + "Once"]
      if (c) {
        if (e.emitted) {
          if (e.emitted[s]) return
        } else e.emitted = {}
        ;(e.emitted[s] = !0), Hn(c, e, 6, a)
      }
    }
    function pr(e, t, n = !1) {
      const r = t.emitsCache,
        a = r.get(e)
      if (void 0 !== a) return a
      const o = e.emits
      let i = {},
        s = !1
      if (!xe(e)) {
        const r = (e) => {
          const n = pr(e, t, !0)
          n && ((s = !0), fe(i, n))
        }
        !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r)
      }
      return o || s
        ? (ve(o) ? o.forEach((e) => (i[e] = null)) : fe(i, o), Se(e) && r.set(e, i), i)
        : (Se(e) && r.set(e, null), null)
    }
    function hr(e, t) {
      return (
        !(!e || !pe(t)) &&
        ((t = t.slice(2).replace(/Once$/, "")), be(e, t[0].toLowerCase() + t.slice(1)) || be(e, Le(t)) || be(e, t))
      )
    }
    let fr = null,
      mr = null
    function gr(e) {
      const t = fr
      return (fr = e), (mr = (e && e.type.__scopeId) || null), t
    }
    function br(e) {
      mr = e
    }
    function vr() {
      mr = null
    }
    function yr(e, t = fr, n) {
      if (!t) return e
      if (e._n) return e
      const r = (...n) => {
        r._d && _o(-1)
        const a = gr(t)
        let o
        try {
          o = e(...n)
        } finally {
          gr(a), r._d && _o(1)
        }
        return o
      }
      return (r._n = !0), (r._c = !0), (r._d = !0), r
    }
    function Or(e) {
      const {
          type: t,
          vnode: n,
          proxy: r,
          withProxy: a,
          propsOptions: [o],
          slots: i,
          attrs: s,
          emit: l,
          render: c,
          renderCache: d,
          props: u,
          data: p,
          setupState: h,
          ctx: f,
          inheritAttrs: m,
        } = e,
        g = gr(e)
      let b, v
      try {
        if (4 & n.shapeFlag) {
          const e = a || r,
            t = e
          ;(b = Bo(c.call(t, e, d, u, h, p, f))), (v = s)
        } else {
          const e = t
          ;(b = Bo(e.length > 1 ? e(u, { attrs: s, slots: i, emit: l }) : e(u, null))), (v = t.props ? s : wr(s))
        }
      } catch (t) {
        ;(Oo.length = 0), Vn(t, e, 1), (b = No(vo))
      }
      let y = b
      if (v && !1 !== m) {
        const e = Object.keys(v),
          { shapeFlag: t } = y
        e.length && 7 & t && (o && e.some(he) && (v = xr(v, o)), (y = Io(y, v, !1, !0)))
      }
      return (
        n.dirs && ((y = Io(y, null, !1, !0)), (y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs)),
        n.transition && (y.transition = n.transition),
        (b = y),
        gr(g),
        b
      )
    }
    const wr = (e) => {
        let t
        for (const n in e) ("class" === n || "style" === n || pe(n)) && ((t || (t = {}))[n] = e[n])
        return t
      },
      xr = (e, t) => {
        const n = {}
        for (const r in e) (he(r) && r.slice(9) in t) || (n[r] = e[r])
        return n
      }
    function kr(e, t, n) {
      const r = Object.keys(t)
      if (r.length !== Object.keys(e).length) return !0
      for (let a = 0; a < r.length; a++) {
        const o = r[a]
        if (t[o] !== e[o] && !hr(n, o)) return !0
      }
      return !1
    }
    const _r = "components"
    function Sr(e, t) {
      return Ar(_r, e, !0, t) || e
    }
    const Er = Symbol.for("v-ndc")
    function Tr(e) {
      return ke(e) ? Ar(_r, e, !1) || e : e || Er
    }
    function Ar(e, t, n = !0, r = !1) {
      const a = fr || Ho
      if (a) {
        const n = a.type
        {
          const e = (function (e, t = !0) {
            return xe(e) ? e.displayName || e.name : e.name || (t && e.__name)
          })(n, !1)
          if (e && (e === t || e === Ie(t) || e === Qe(Ie(t)))) return n
        }
        const o = Cr(a[e] || n[e], t) || Cr(a.appContext[e], t)
        return !o && r ? n : o
      }
    }
    function Cr(e, t) {
      return e && (e[t] || e[Ie(t)] || e[Qe(Ie(t))])
    }
    function Pr(e, t, n = Ho, r = !1) {
      if (n) {
        const a = n[e] || (n[e] = []),
          o =
            t.__weh ||
            (t.__weh = (...r) => {
              yt()
              const a = Yo(n),
                o = Hn(t, n, e, r)
              return a(), Ot(), o
            })
        return r ? a.unshift(o) : a.push(o), o
      }
    }
    const Dr =
        (e) =>
        (t, n = Ho) => {
          ;(ei && "sp" !== e) || Pr(e, (...e) => t(...e), n)
        },
      Rr = Dr("bm"),
      Nr = Dr("m"),
      $r = Dr("bu"),
      Ir = Dr("u"),
      Mr = Dr("bum"),
      Lr = Dr("um"),
      Qr = Dr("sp"),
      Br = Dr("rtg"),
      jr = Dr("rtc")
    function Ur(e, t = Ho) {
      Pr("ec", e, t)
    }
    function Fr(e, t) {
      if (null === fr) return e
      const n = oi(fr),
        r = e.dirs || (e.dirs = [])
      for (let e = 0; e < t.length; e++) {
        let [a, o, i, s = le] = t[e]
        a &&
          (xe(a) && (a = { mounted: a, updated: a }),
          a.deep && eo(o),
          r.push({ dir: a, instance: n, value: o, oldValue: void 0, arg: i, modifiers: s }))
      }
      return e
    }
    function zr(e, t, n, r) {
      const a = e.dirs,
        o = t && t.dirs
      for (let i = 0; i < a.length; i++) {
        const s = a[i]
        o && (s.oldValue = o[i].value)
        let l = s.dir[r]
        l && (yt(), Hn(l, n, 8, [e.el, s, e, t]), Ot())
      }
    }
    function qr(e, t, n, r) {
      let a
      const o = n
      if (ve(e) || ke(e)) {
        a = new Array(e.length)
        for (let n = 0, r = e.length; n < r; n++) a[n] = t(e[n], n, void 0, o)
      } else if ("number" == typeof e) {
        a = new Array(e)
        for (let n = 0; n < e; n++) a[n] = t(n + 1, n, void 0, o)
      } else if (Se(e))
        if (e[Symbol.iterator]) a = Array.from(e, (e, n) => t(e, n, void 0, o))
        else {
          const n = Object.keys(e)
          a = new Array(n.length)
          for (let r = 0, i = n.length; r < i; r++) {
            const i = n[r]
            a[r] = t(e[i], i, r, o)
          }
        }
      else a = []
      return a
    }
    function Zr(e, t) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
        if (ve(r)) for (let t = 0; t < r.length; t++) e[r[t].name] = r[t].fn
        else
          r &&
            (e[r.name] = r.key
              ? (...e) => {
                  const t = r.fn(...e)
                  return t && (t.key = r.key), t
                }
              : r.fn)
      }
      return e
    }
    /*! #__NO_SIDE_EFFECTS__ */ function Hr(e, t) {
      return xe(e) ? fe({ name: e.name }, t, { setup: e }) : e
    }
    const Vr = (e) => !!e.type.__asyncLoader
    /*! #__NO_SIDE_EFFECTS__ */ function Wr(e, t) {
      const { ref: n, props: r, children: a, ce: o } = t.vnode,
        i = No(e, r, a)
      return (i.ref = n), (i.ce = o), delete t.vnode.ce, i
    }
    function Xr(e, t, n = {}, r, a) {
      if (fr.isCE || (fr.parent && Vr(fr.parent) && fr.parent.isCE))
        return "default" !== t && (n.name = t), No("slot", n, r && r())
      let o = e[t]
      o && o._c && (o._d = !1), xo()
      const i = o && Yr(o(n)),
        s = To(go, { key: n.key || (i && i.key) || `_${t}` }, i || (r ? r() : []), i && 1 === e._ ? 64 : -2)
      return !a && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), o && o._c && (o._d = !0), s
    }
    function Yr(e) {
      return e.some((e) => !Ao(e) || (e.type !== vo && !(e.type === go && !Yr(e.children)))) ? e : null
    }
    function Gr(e, t) {
      const n = {}
      for (const t in e) n[Be(t)] = e[t]
      return n
    }
    const Kr = (e) => (e ? (Ko(e) ? oi(e) : Kr(e.parent)) : null),
      Jr = fe(Object.create(null), {
        $: (e) => e,
        $el: (e) => e.vnode.el,
        $data: (e) => e.data,
        $props: (e) => e.props,
        $attrs: (e) => e.attrs,
        $slots: (e) => e.slots,
        $refs: (e) => e.refs,
        $parent: (e) => Kr(e.parent),
        $root: (e) => Kr(e.root),
        $emit: (e) => e.emit,
        $options: (e) => ca(e),
        $forceUpdate: (e) =>
          e.f ||
          (e.f = () => {
            ;(e.effect.dirty = !0), ar(e.update)
          }),
        $nextTick: (e) => e.n || (e.n = rr.bind(e.proxy)),
        $watch: (e) => Ka.bind(e),
      }),
      ea = (e, t) => e !== le && !e.__isScriptSetup && be(e, t),
      ta = {
        get({ _: e }, t) {
          if ("__v_skip" === t) return !0
          const { ctx: n, setupState: r, data: a, props: o, accessCache: i, type: s, appContext: l } = e
          let c
          if ("$" !== t[0]) {
            const s = i[t]
            if (void 0 !== s)
              switch (s) {
                case 1:
                  return r[t]
                case 2:
                  return a[t]
                case 4:
                  return n[t]
                case 3:
                  return o[t]
              }
            else {
              if (ea(r, t)) return (i[t] = 1), r[t]
              if (a !== le && be(a, t)) return (i[t] = 2), a[t]
              if ((c = e.propsOptions[0]) && be(c, t)) return (i[t] = 3), o[t]
              if (n !== le && be(n, t)) return (i[t] = 4), n[t]
              ia && (i[t] = 0)
            }
          }
          const d = Jr[t]
          let u, p
          return d
            ? ("$attrs" === t && Pt(e.attrs, 0, ""), d(e))
            : (u = s.__cssModules) && (u = u[t])
              ? u
              : n !== le && be(n, t)
                ? ((i[t] = 4), n[t])
                : ((p = l.config.globalProperties), be(p, t) ? p[t] : void 0)
        },
        set({ _: e }, t, n) {
          const { data: r, setupState: a, ctx: o } = e
          return ea(a, t)
            ? ((a[t] = n), !0)
            : r !== le && be(r, t)
              ? ((r[t] = n), !0)
              : !(be(e.props, t) || ("$" === t[0] && t.slice(1) in e) || ((o[t] = n), 0))
        },
        has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: a, propsOptions: o } }, i) {
          let s
          return (
            !!n[i] ||
            (e !== le && be(e, i)) ||
            ea(t, i) ||
            ((s = o[0]) && be(s, i)) ||
            be(r, i) ||
            be(Jr, i) ||
            be(a.config.globalProperties, i)
          )
        },
        defineProperty(e, t, n) {
          return (
            null != n.get ? (e._.accessCache[t] = 0) : be(n, "value") && this.set(e, t, n.value, null),
            Reflect.defineProperty(e, t, n)
          )
        },
      }
    function na() {
      return aa().slots
    }
    function ra() {
      return aa().attrs
    }
    function aa() {
      const e = Vo()
      return e.setupContext || (e.setupContext = ai(e))
    }
    function oa(e) {
      return ve(e) ? e.reduce((e, t) => ((e[t] = null), e), {}) : e
    }
    let ia = !0
    function sa(e, t, n) {
      Hn(ve(e) ? e.map((e) => e.bind(t.proxy)) : e.bind(t.proxy), t, n)
    }
    function la(e, t, n, r) {
      const a = r.includes(".") ? Ja(n, r) : () => n[r]
      if (ke(e)) {
        const n = t[e]
        xe(n) && Ya(a, n)
      } else if (xe(e)) Ya(a, e.bind(n))
      else if (Se(e))
        if (ve(e)) e.forEach((e) => la(e, t, n, r))
        else {
          const r = xe(e.handler) ? e.handler.bind(n) : t[e.handler]
          xe(r) && Ya(a, r, e)
        }
    }
    function ca(e) {
      const t = e.type,
        { mixins: n, extends: r } = t,
        {
          mixins: a,
          optionsCache: o,
          config: { optionMergeStrategies: i },
        } = e.appContext,
        s = o.get(t)
      let l
      return (
        s
          ? (l = s)
          : a.length || n || r
            ? ((l = {}), a.length && a.forEach((e) => da(l, e, i, !0)), da(l, t, i))
            : (l = t),
        Se(t) && o.set(t, l),
        l
      )
    }
    function da(e, t, n, r = !1) {
      const { mixins: a, extends: o } = t
      o && da(e, o, n, !0), a && a.forEach((t) => da(e, t, n, !0))
      for (const a in t)
        if (r && "expose" === a);
        else {
          const r = ua[a] || (n && n[a])
          e[a] = r ? r(e[a], t[a]) : t[a]
        }
      return e
    }
    const ua = {
      data: pa,
      props: ga,
      emits: ga,
      methods: ma,
      computed: ma,
      beforeCreate: fa,
      created: fa,
      beforeMount: fa,
      mounted: fa,
      beforeUpdate: fa,
      updated: fa,
      beforeDestroy: fa,
      beforeUnmount: fa,
      destroyed: fa,
      unmounted: fa,
      activated: fa,
      deactivated: fa,
      errorCaptured: fa,
      serverPrefetch: fa,
      components: ma,
      directives: ma,
      watch: function (e, t) {
        if (!e) return t
        if (!t) return e
        const n = fe(Object.create(null), e)
        for (const r in t) n[r] = fa(e[r], t[r])
        return n
      },
      provide: pa,
      inject: function (e, t) {
        return ma(ha(e), ha(t))
      },
    }
    function pa(e, t) {
      return t
        ? e
          ? function () {
              return fe(xe(e) ? e.call(this, this) : e, xe(t) ? t.call(this, this) : t)
            }
          : t
        : e
    }
    function ha(e) {
      if (ve(e)) {
        const t = {}
        for (let n = 0; n < e.length; n++) t[e[n]] = e[n]
        return t
      }
      return e
    }
    function fa(e, t) {
      return e ? [...new Set([].concat(e, t))] : t
    }
    function ma(e, t) {
      return e ? fe(Object.create(null), e, t) : t
    }
    function ga(e, t) {
      return e
        ? ve(e) && ve(t)
          ? [...new Set([...e, ...t])]
          : fe(Object.create(null), oa(e), oa(null != t ? t : {}))
        : t
    }
    function ba() {
      return {
        app: null,
        config: {
          isNativeTag: ue,
          performance: !1,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
      }
    }
    let va = 0
    function ya(e, t) {
      return function (n, r = null) {
        xe(n) || (n = fe({}, n)), null == r || Se(r) || (r = null)
        const a = ba(),
          o = new WeakSet()
        let i = !1
        const s = (a.app = {
          _uid: va++,
          _component: n,
          _props: r,
          _container: null,
          _context: a,
          _instance: null,
          version: li,
          get config() {
            return a.config
          },
          set config(e) {},
          use: (e, ...t) => (
            o.has(e) || (e && xe(e.install) ? (o.add(e), e.install(s, ...t)) : xe(e) && (o.add(e), e(s, ...t))), s
          ),
          mixin: (e) => (a.mixins.includes(e) || a.mixins.push(e), s),
          component: (e, t) => (t ? ((a.components[e] = t), s) : a.components[e]),
          directive: (e, t) => (t ? ((a.directives[e] = t), s) : a.directives[e]),
          mount(o, l, c) {
            if (!i) {
              const d = No(n, r)
              return (
                (d.appContext = a),
                !0 === c ? (c = "svg") : !1 === c && (c = void 0),
                l && t ? t(d, o) : e(d, o, c),
                (i = !0),
                (s._container = o),
                (o.__vue_app__ = s),
                oi(d.component)
              )
            }
          },
          unmount() {
            i && (e(null, s._container), delete s._container.__vue_app__)
          },
          provide: (e, t) => ((a.provides[e] = t), s),
          runWithContext(e) {
            const t = Oa
            Oa = s
            try {
              return e()
            } finally {
              Oa = t
            }
          },
        })
        return s
      }
    }
    let Oa = null
    function wa(e, t) {
      if (Ho) {
        let n = Ho.provides
        const r = Ho.parent && Ho.parent.provides
        r === n && (n = Ho.provides = Object.create(r)), (n[e] = t)
      }
    }
    function xa(e, t, n = !1) {
      const r = Ho || fr
      if (r || Oa) {
        const a = r
          ? null == r.parent
            ? r.vnode.appContext && r.vnode.appContext.provides
            : r.parent.provides
          : Oa._context.provides
        if (a && e in a) return a[e]
        if (arguments.length > 1) return n && xe(t) ? t.call(r && r.proxy) : t
      }
    }
    const ka = {},
      _a = () => Object.create(ka),
      Sa = (e) => Object.getPrototypeOf(e) === ka
    function Ea(e, t, n, r) {
      const [a, o] = e.propsOptions
      let i,
        s = !1
      if (t)
        for (let l in t) {
          if (Re(l)) continue
          const c = t[l]
          let d
          a && be(a, (d = Ie(l)))
            ? o && o.includes(d)
              ? ((i || (i = {}))[d] = c)
              : (n[d] = c)
            : hr(e.emitsOptions, l) || (l in r && c === r[l]) || ((r[l] = c), (s = !0))
        }
      if (o) {
        const t = _n(n),
          r = i || le
        for (let i = 0; i < o.length; i++) {
          const s = o[i]
          n[s] = Ta(a, t, s, r[s], e, !be(r, s))
        }
      }
      return s
    }
    function Ta(e, t, n, r, a, o) {
      const i = e[n]
      if (null != i) {
        const e = be(i, "default")
        if (e && void 0 === r) {
          const e = i.default
          if (i.type !== Function && !i.skipFactory && xe(e)) {
            const { propsDefaults: o } = a
            if (n in o) r = o[n]
            else {
              const i = Yo(a)
              ;(r = o[n] = e.call(null, t)), i()
            }
          } else r = e
        }
        i[0] && (o && !e ? (r = !1) : !i[1] || ("" !== r && r !== Le(n)) || (r = !0))
      }
      return r
    }
    function Aa(e, t, n = !1) {
      const r = t.propsCache,
        a = r.get(e)
      if (a) return a
      const o = e.props,
        i = {},
        s = []
      let l = !1
      if (!xe(e)) {
        const r = (e) => {
          l = !0
          const [n, r] = Aa(e, t, !0)
          fe(i, n), r && s.push(...r)
        }
        !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r)
      }
      if (!o && !l) return Se(e) && r.set(e, ce), ce
      if (ve(o))
        for (let e = 0; e < o.length; e++) {
          const t = Ie(o[e])
          Ca(t) && (i[t] = le)
        }
      else if (o)
        for (const e in o) {
          const t = Ie(e)
          if (Ca(t)) {
            const n = o[e],
              r = (i[t] = ve(n) || xe(n) ? { type: n } : fe({}, n))
            if (r) {
              const e = Ra(Boolean, r.type),
                n = Ra(String, r.type)
              ;(r[0] = e > -1), (r[1] = n < 0 || e < n), (e > -1 || be(r, "default")) && s.push(t)
            }
          }
        }
      const c = [i, s]
      return Se(e) && r.set(e, c), c
    }
    function Ca(e) {
      return "$" !== e[0] && !Re(e)
    }
    function Pa(e) {
      return null === e
        ? "null"
        : "function" == typeof e
          ? e.name || ""
          : ("object" == typeof e && e.constructor && e.constructor.name) || ""
    }
    function Da(e, t) {
      return Pa(e) === Pa(t)
    }
    function Ra(e, t) {
      return ve(t) ? t.findIndex((t) => Da(t, e)) : xe(t) && Da(t, e) ? 0 : -1
    }
    const Na = (e) => "_" === e[0] || "$stable" === e,
      $a = (e) => (ve(e) ? e.map(Bo) : [Bo(e)]),
      Ia = (e, t, n) => {
        if (t._n) return t
        const r = yr((...e) => $a(t(...e)), n)
        return (r._c = !1), r
      },
      Ma = (e, t, n) => {
        const r = e._ctx
        for (const n in e) {
          if (Na(n)) continue
          const a = e[n]
          if (xe(a)) t[n] = Ia(0, a, r)
          else if (null != a) {
            const e = $a(a)
            t[n] = () => e
          }
        }
      },
      La = (e, t) => {
        const n = $a(t)
        e.slots.default = () => n
      }
    function Qa(e, t, n, r, a = !1) {
      if (ve(e)) return void e.forEach((e, o) => Qa(e, t && (ve(t) ? t[o] : t), n, r, a))
      if (Vr(r) && !a) return
      const o = 4 & r.shapeFlag ? oi(r.component) : r.el,
        i = a ? null : o,
        { i: s, r: l } = e,
        c = t && t.r,
        d = s.refs === le ? (s.refs = {}) : s.refs,
        u = s.setupState
      if (
        (null != c && c !== l && (ke(c) ? ((d[c] = null), be(u, c) && (u[c] = null)) : Pn(c) && (c.value = null)),
        xe(l))
      )
        Zn(l, s, 12, [i, d])
      else {
        const t = ke(l),
          r = Pn(l)
        if (t || r) {
          const s = () => {
            if (e.f) {
              const n = t ? (be(u, l) ? u[l] : d[l]) : l.value
              a
                ? ve(n) && me(n, o)
                : ve(n)
                  ? n.includes(o) || n.push(o)
                  : t
                    ? ((d[l] = [o]), be(u, l) && (u[l] = d[l]))
                    : ((l.value = [o]), e.k && (d[e.k] = l.value))
            } else t ? ((d[l] = i), be(u, l) && (u[l] = i)) : r && ((l.value = i), e.k && (d[e.k] = i))
          }
          i ? ((s.id = -1), Ba(s, n)) : s()
        }
      }
    }
    const Ba = function (e, t) {
      var n
      t && t.pendingBranch
        ? ve(e)
          ? t.effects.push(...e)
          : t.effects.push(e)
        : (ve((n = e)) ? Kn.push(...n) : (Jn && Jn.includes(n, n.allowRecurse ? er + 1 : er)) || Kn.push(n), or())
    }
    function ja(e) {
      return (function (e, t) {
        Ze().__VUE__ = !0
        const {
            insert: n,
            remove: r,
            patchProp: a,
            createElement: o,
            createText: i,
            createComment: s,
            setText: l,
            setElementText: c,
            parentNode: d,
            nextSibling: u,
            setScopeId: p = de,
            insertStaticContent: h,
          } = e,
          f = (e, t, n, r = null, a = null, o = null, i = void 0, s = null, l = !!t.dynamicChildren) => {
            if (e === t) return
            e && !Co(e, t) && ((r = j(e)), I(e, a, o, !0), (e = null)),
              -2 === t.patchFlag && ((l = !1), (t.dynamicChildren = null))
            const { type: c, ref: d, shapeFlag: u } = t
            switch (c) {
              case bo:
                m(e, t, n, r)
                break
              case vo:
                g(e, t, n, r)
                break
              case yo:
                null == e && b(t, n, r, i)
                break
              case go:
                S(e, t, n, r, a, o, i, s, l)
                break
              default:
                1 & u
                  ? v(e, t, n, r, a, o, i, s, l)
                  : 6 & u
                    ? E(e, t, n, r, a, o, i, s, l)
                    : (64 & u || 128 & u) && c.process(e, t, n, r, a, o, i, s, l, z)
            }
            null != d && a && Qa(d, e && e.ref, o, t || e, !t)
          },
          m = (e, t, r, a) => {
            if (null == e) n((t.el = i(t.children)), r, a)
            else {
              const n = (t.el = e.el)
              t.children !== e.children && l(n, t.children)
            }
          },
          g = (e, t, r, a) => {
            null == e ? n((t.el = s(t.children || "")), r, a) : (t.el = e.el)
          },
          b = (e, t, n, r) => {
            ;[e.el, e.anchor] = h(e.children, t, n, r, e.el, e.anchor)
          },
          v = (e, t, n, r, a, o, i, s, l) => {
            "svg" === t.type ? (i = "svg") : "math" === t.type && (i = "mathml"),
              null == e ? y(t, n, r, a, o, i, s, l) : x(e, t, a, o, i, s, l)
          },
          y = (e, t, r, i, s, l, d, u) => {
            let p, h
            const { props: f, shapeFlag: m, transition: g, dirs: b } = e
            if (
              ((p = e.el = o(e.type, l, f && f.is, f)),
              8 & m ? c(p, e.children) : 16 & m && w(e.children, p, null, i, s, Ua(e, l), d, u),
              b && zr(e, null, i, "created"),
              O(p, e, e.scopeId, d, i),
              f)
            ) {
              for (const t in f) "value" === t || Re(t) || a(p, t, null, f[t], l, e.children, i, s, B)
              "value" in f && a(p, "value", null, f.value, l), (h = f.onVnodeBeforeMount) && zo(h, i, e)
            }
            b && zr(e, null, i, "beforeMount")
            const v = (function (e, t) {
              return (!e || (e && !e.pendingBranch)) && t && !t.persisted
            })(s, g)
            v && g.beforeEnter(p),
              n(p, t, r),
              ((h = f && f.onVnodeMounted) || v || b) &&
                Ba(() => {
                  h && zo(h, i, e), v && g.enter(p), b && zr(e, null, i, "mounted")
                }, s)
          },
          O = (e, t, n, r, a) => {
            if ((n && p(e, n), r)) for (let t = 0; t < r.length; t++) p(e, r[t])
            if (a && t === a.subTree) {
              const t = a.vnode
              O(e, t, t.scopeId, t.slotScopeIds, a.parent)
            }
          },
          w = (e, t, n, r, a, o, i, s, l = 0) => {
            for (let c = l; c < e.length; c++) {
              const l = (e[c] = s ? jo(e[c]) : Bo(e[c]))
              f(null, l, t, n, r, a, o, i, s)
            }
          },
          x = (e, t, n, r, o, i, s) => {
            const l = (t.el = e.el)
            let { patchFlag: d, dynamicChildren: u, dirs: p } = t
            d |= 16 & e.patchFlag
            const h = e.props || le,
              f = t.props || le
            let m
            if (
              (n && Fa(n, !1),
              (m = f.onVnodeBeforeUpdate) && zo(m, n, t, e),
              p && zr(t, e, n, "beforeUpdate"),
              n && Fa(n, !0),
              u ? k(e.dynamicChildren, u, l, n, r, Ua(t, o), i) : s || D(e, t, l, null, n, r, Ua(t, o), i, !1),
              d > 0)
            ) {
              if (16 & d) _(l, t, h, f, n, r, o)
              else if (
                (2 & d && h.class !== f.class && a(l, "class", null, f.class, o),
                4 & d && a(l, "style", h.style, f.style, o),
                8 & d)
              ) {
                const i = t.dynamicProps
                for (let t = 0; t < i.length; t++) {
                  const s = i[t],
                    c = h[s],
                    d = f[s]
                  ;(d === c && "value" !== s) || a(l, s, c, d, o, e.children, n, r, B)
                }
              }
              1 & d && e.children !== t.children && c(l, t.children)
            } else s || null != u || _(l, t, h, f, n, r, o)
            ;((m = f.onVnodeUpdated) || p) &&
              Ba(() => {
                m && zo(m, n, t, e), p && zr(t, e, n, "updated")
              }, r)
          },
          k = (e, t, n, r, a, o, i) => {
            for (let s = 0; s < t.length; s++) {
              const l = e[s],
                c = t[s],
                u = l.el && (l.type === go || !Co(l, c) || 70 & l.shapeFlag) ? d(l.el) : n
              f(l, c, u, null, r, a, o, i, !0)
            }
          },
          _ = (e, t, n, r, o, i, s) => {
            if (n !== r) {
              if (n !== le) for (const l in n) Re(l) || l in r || a(e, l, n[l], null, s, t.children, o, i, B)
              for (const l in r) {
                if (Re(l)) continue
                const c = r[l],
                  d = n[l]
                c !== d && "value" !== l && a(e, l, d, c, s, t.children, o, i, B)
              }
              "value" in r && a(e, "value", n.value, r.value, s)
            }
          },
          S = (e, t, r, a, o, s, l, c, d) => {
            const u = (t.el = e ? e.el : i("")),
              p = (t.anchor = e ? e.anchor : i(""))
            let { patchFlag: h, dynamicChildren: f, slotScopeIds: m } = t
            m && (c = c ? c.concat(m) : m),
              null == e
                ? (n(u, r, a), n(p, r, a), w(t.children || [], r, p, o, s, l, c, d))
                : h > 0 && 64 & h && f && e.dynamicChildren
                  ? (k(e.dynamicChildren, f, r, o, s, l, c), (null != t.key || (o && t === o.subTree)) && za(e, t, !0))
                  : D(e, t, r, p, o, s, l, c, d)
          },
          E = (e, t, n, r, a, o, i, s, l) => {
            ;(t.slotScopeIds = s),
              null == e ? (512 & t.shapeFlag ? a.ctx.activate(t, n, r, i, l) : T(t, n, r, a, o, i, l)) : A(e, t, l)
          },
          T = (e, t, n, r, a, o, i) => {
            const s = (e.component = (function (e, t, n) {
              const r = e.type,
                a = (t ? t.appContext : e.appContext) || qo,
                o = {
                  uid: Zo++,
                  vnode: e,
                  type: r,
                  parent: t,
                  appContext: a,
                  root: null,
                  next: null,
                  subTree: null,
                  effect: null,
                  update: null,
                  scope: new ct(!0),
                  render: null,
                  proxy: null,
                  exposed: null,
                  exposeProxy: null,
                  withProxy: null,
                  provides: t ? t.provides : Object.create(a.provides),
                  accessCache: null,
                  renderCache: [],
                  components: null,
                  directives: null,
                  propsOptions: Aa(r, a),
                  emitsOptions: pr(r, a),
                  emit: null,
                  emitted: null,
                  propsDefaults: le,
                  inheritAttrs: r.inheritAttrs,
                  ctx: le,
                  data: le,
                  props: le,
                  attrs: le,
                  slots: le,
                  refs: le,
                  setupState: le,
                  setupContext: null,
                  attrsProxy: null,
                  slotsProxy: null,
                  suspense: n,
                  suspenseId: n ? n.pendingId : 0,
                  asyncDep: null,
                  asyncResolved: !1,
                  isMounted: !1,
                  isUnmounted: !1,
                  isDeactivated: !1,
                  bc: null,
                  c: null,
                  bm: null,
                  m: null,
                  bu: null,
                  u: null,
                  um: null,
                  bum: null,
                  da: null,
                  a: null,
                  rtg: null,
                  rtc: null,
                  ec: null,
                  sp: null,
                }
              return (o.ctx = { _: o }), (o.root = t ? t.root : o), (o.emit = ur.bind(null, o)), e.ce && e.ce(o), o
            })(e, r, a))
            if (
              (to(e) && (s.ctx.renderer = z),
              (function (e, t = !1) {
                t && Xo(t)
                const { props: n, children: r } = e.vnode,
                  a = Ko(e)
                ;(function (e, t, n, r = !1) {
                  const a = {},
                    o = _a()
                  ;(e.propsDefaults = Object.create(null)), Ea(e, t, a, o)
                  for (const t in e.propsOptions[0]) t in a || (a[t] = void 0)
                  n ? (e.props = r ? a : gn(a)) : e.type.props ? (e.props = a) : (e.props = o), (e.attrs = o)
                })(e, n, a, t),
                  ((e, t) => {
                    const n = (e.slots = _a())
                    if (32 & e.vnode.shapeFlag) {
                      const e = t._
                      e ? (fe(n, t), Fe(n, "_", e, !0)) : Ma(t, n)
                    } else t && La(e, t)
                  })(e, r)
                a &&
                  (function (e, t) {
                    const n = e.type
                    ;(e.accessCache = Object.create(null)), (e.proxy = new Proxy(e.ctx, ta))
                    const { setup: r } = n
                    if (r) {
                      const n = (e.setupContext = r.length > 1 ? ai(e) : null),
                        a = Yo(e)
                      yt()
                      const o = Zn(r, e, 0, [e.props, n])
                      if ((Ot(), a(), Ee(o))) {
                        if ((o.then(Go, Go), t))
                          return o
                            .then((n) => {
                              ti(e, n, t)
                            })
                            .catch((t) => {
                              Vn(t, e, 0)
                            })
                        e.asyncDep = o
                      } else ti(e, o, t)
                    } else ni(e, t)
                  })(e, t)
                t && Xo(!1)
              })(s),
              s.asyncDep)
            ) {
              if ((a && a.registerDep(s, C, i), !e.el)) {
                const e = (s.subTree = No(vo))
                g(null, e, t, n)
              }
            } else C(s, e, t, n, a, o, i)
          },
          A = (e, t, n) => {
            const r = (t.component = e.component)
            if (
              (function (e, t, n) {
                const { props: r, children: a, component: o } = e,
                  { props: i, children: s, patchFlag: l } = t,
                  c = o.emitsOptions
                if (t.dirs || t.transition) return !0
                if (!(n && l >= 0))
                  return !((!a && !s) || (s && s.$stable)) || (r !== i && (r ? !i || kr(r, i, c) : !!i))
                if (1024 & l) return !0
                if (16 & l) return r ? kr(r, i, c) : !!i
                if (8 & l) {
                  const e = t.dynamicProps
                  for (let t = 0; t < e.length; t++) {
                    const n = e[t]
                    if (i[n] !== r[n] && !hr(c, n)) return !0
                  }
                }
                return !1
              })(e, t, n)
            ) {
              if (r.asyncDep && !r.asyncResolved) return void P(r, t, n)
              ;(r.next = t),
                (function (e) {
                  const t = Yn.indexOf(e)
                  t > Gn && Yn.splice(t, 1)
                })(r.update),
                (r.effect.dirty = !0),
                r.update()
            } else (t.el = e.el), (r.vnode = t)
          },
          C = (e, t, n, r, a, o, i) => {
            const s = () => {
                if (e.isMounted) {
                  let { next: t, bu: n, u: r, parent: l, vnode: c } = e
                  {
                    const n = qa(e)
                    if (n)
                      return (
                        t && ((t.el = c.el), P(e, t, i)),
                        void n.asyncDep.then(() => {
                          e.isUnmounted || s()
                        })
                      )
                  }
                  let u,
                    p = t
                  Fa(e, !1),
                    t ? ((t.el = c.el), P(e, t, i)) : (t = c),
                    n && Ue(n),
                    (u = t.props && t.props.onVnodeBeforeUpdate) && zo(u, l, t, c),
                    Fa(e, !0)
                  const h = Or(e),
                    m = e.subTree
                  ;(e.subTree = h),
                    f(m, h, d(m.el), j(m), e, a, o),
                    (t.el = h.el),
                    null === p &&
                      (function ({ vnode: e, parent: t }, n) {
                        for (; t; ) {
                          const r = t.subTree
                          if ((r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r !== e)) break
                          ;((e = t.vnode).el = n), (t = t.parent)
                        }
                      })(e, h.el),
                    r && Ba(r, a),
                    (u = t.props && t.props.onVnodeUpdated) && Ba(() => zo(u, l, t, c), a)
                } else {
                  let i
                  const { el: s, props: l } = t,
                    { bm: c, m: d, parent: u } = e,
                    p = Vr(t)
                  Fa(e, !1), c && Ue(c), !p && (i = l && l.onVnodeBeforeMount) && zo(i, u, t), Fa(e, !0)
                  {
                    const i = (e.subTree = Or(e))
                    f(null, i, n, r, e, a, o), (t.el = i.el)
                  }
                  if ((d && Ba(d, a), !p && (i = l && l.onVnodeMounted))) {
                    const e = t
                    Ba(() => zo(i, u, e), a)
                  }
                  ;(256 & t.shapeFlag || (u && Vr(u.vnode) && 256 & u.vnode.shapeFlag)) && e.a && Ba(e.a, a),
                    (e.isMounted = !0),
                    (t = n = r = null)
                }
              },
              l = (e.effect = new pt(s, de, () => ar(c), e.scope)),
              c = (e.update = () => {
                l.dirty && l.run()
              })
            ;(c.id = e.uid), Fa(e, !0), c()
          },
          P = (e, t, n) => {
            t.component = e
            const r = e.vnode.props
            ;(e.vnode = t),
              (e.next = null),
              (function (e, t, n, r) {
                const {
                    props: a,
                    attrs: o,
                    vnode: { patchFlag: i },
                  } = e,
                  s = _n(a),
                  [l] = e.propsOptions
                let c = !1
                if (!(r || i > 0) || 16 & i) {
                  let r
                  Ea(e, t, a, o) && (c = !0)
                  for (const o in s)
                    (t && (be(t, o) || ((r = Le(o)) !== o && be(t, r)))) ||
                      (l
                        ? !n || (void 0 === n[o] && void 0 === n[r]) || (a[o] = Ta(l, s, o, void 0, e, !0))
                        : delete a[o])
                  if (o !== s) for (const e in o) (t && be(t, e)) || (delete o[e], (c = !0))
                } else if (8 & i) {
                  const n = e.vnode.dynamicProps
                  for (let r = 0; r < n.length; r++) {
                    let i = n[r]
                    if (hr(e.emitsOptions, i)) continue
                    const d = t[i]
                    if (l)
                      if (be(o, i)) d !== o[i] && ((o[i] = d), (c = !0))
                      else {
                        const t = Ie(i)
                        a[t] = Ta(l, s, t, d, e, !1)
                      }
                    else d !== o[i] && ((o[i] = d), (c = !0))
                  }
                }
                c && Dt(e.attrs, "set", "")
              })(e, t.props, r, n),
              ((e, t, n) => {
                const { vnode: r, slots: a } = e
                let o = !0,
                  i = le
                if (32 & r.shapeFlag) {
                  const e = t._
                  e ? (n && 1 === e ? (o = !1) : (fe(a, t), n || 1 !== e || delete a._)) : ((o = !t.$stable), Ma(t, a)),
                    (i = t)
                } else t && (La(e, t), (i = { default: 1 }))
                if (o) for (const e in a) Na(e) || null != i[e] || delete a[e]
              })(e, t.children, n),
              yt(),
              ir(e),
              Ot()
          },
          D = (e, t, n, r, a, o, i, s, l = !1) => {
            const d = e && e.children,
              u = e ? e.shapeFlag : 0,
              p = t.children,
              { patchFlag: h, shapeFlag: f } = t
            if (h > 0) {
              if (128 & h) return void N(d, p, n, r, a, o, i, s, l)
              if (256 & h) return void R(d, p, n, r, a, o, i, s, l)
            }
            8 & f
              ? (16 & u && B(d, a, o), p !== d && c(n, p))
              : 16 & u
                ? 16 & f
                  ? N(d, p, n, r, a, o, i, s, l)
                  : B(d, a, o, !0)
                : (8 & u && c(n, ""), 16 & f && w(p, n, r, a, o, i, s, l))
          },
          R = (e, t, n, r, a, o, i, s, l) => {
            t = t || ce
            const c = (e = e || ce).length,
              d = t.length,
              u = Math.min(c, d)
            let p
            for (p = 0; p < u; p++) {
              const r = (t[p] = l ? jo(t[p]) : Bo(t[p]))
              f(e[p], r, n, null, a, o, i, s, l)
            }
            c > d ? B(e, a, o, !0, !1, u) : w(t, n, r, a, o, i, s, l, u)
          },
          N = (e, t, n, r, a, o, i, s, l) => {
            let c = 0
            const d = t.length
            let u = e.length - 1,
              p = d - 1
            for (; c <= u && c <= p; ) {
              const r = e[c],
                d = (t[c] = l ? jo(t[c]) : Bo(t[c]))
              if (!Co(r, d)) break
              f(r, d, n, null, a, o, i, s, l), c++
            }
            for (; c <= u && c <= p; ) {
              const r = e[u],
                c = (t[p] = l ? jo(t[p]) : Bo(t[p]))
              if (!Co(r, c)) break
              f(r, c, n, null, a, o, i, s, l), u--, p--
            }
            if (c > u) {
              if (c <= p) {
                const e = p + 1,
                  u = e < d ? t[e].el : r
                for (; c <= p; ) f(null, (t[c] = l ? jo(t[c]) : Bo(t[c])), n, u, a, o, i, s, l), c++
              }
            } else if (c > p) for (; c <= u; ) I(e[c], a, o, !0), c++
            else {
              const h = c,
                m = c,
                g = new Map()
              for (c = m; c <= p; c++) {
                const e = (t[c] = l ? jo(t[c]) : Bo(t[c]))
                null != e.key && g.set(e.key, c)
              }
              let b,
                v = 0
              const y = p - m + 1
              let O = !1,
                w = 0
              const x = new Array(y)
              for (c = 0; c < y; c++) x[c] = 0
              for (c = h; c <= u; c++) {
                const r = e[c]
                if (v >= y) {
                  I(r, a, o, !0)
                  continue
                }
                let d
                if (null != r.key) d = g.get(r.key)
                else
                  for (b = m; b <= p; b++)
                    if (0 === x[b - m] && Co(r, t[b])) {
                      d = b
                      break
                    }
                void 0 === d
                  ? I(r, a, o, !0)
                  : ((x[d - m] = c + 1), d >= w ? (w = d) : (O = !0), f(r, t[d], n, null, a, o, i, s, l), v++)
              }
              const k = O
                ? (function (e) {
                    const t = e.slice(),
                      n = [0]
                    let r, a, o, i, s
                    const l = e.length
                    for (r = 0; r < l; r++) {
                      const l = e[r]
                      if (0 !== l) {
                        if (((a = n[n.length - 1]), e[a] < l)) {
                          ;(t[r] = a), n.push(r)
                          continue
                        }
                        for (o = 0, i = n.length - 1; o < i; ) (s = (o + i) >> 1), e[n[s]] < l ? (o = s + 1) : (i = s)
                        l < e[n[o]] && (o > 0 && (t[r] = n[o - 1]), (n[o] = r))
                      }
                    }
                    for (o = n.length, i = n[o - 1]; o-- > 0; ) (n[o] = i), (i = t[i])
                    return n
                  })(x)
                : ce
              for (b = k.length - 1, c = y - 1; c >= 0; c--) {
                const e = m + c,
                  u = t[e],
                  p = e + 1 < d ? t[e + 1].el : r
                0 === x[c] ? f(null, u, n, p, a, o, i, s, l) : O && (b < 0 || c !== k[b] ? $(u, n, p, 2) : b--)
              }
            }
          },
          $ = (e, t, r, a, o = null) => {
            const { el: i, type: s, transition: l, children: c, shapeFlag: d } = e
            if (6 & d) $(e.component.subTree, t, r, a)
            else if (128 & d) e.suspense.move(t, r, a)
            else if (64 & d) s.move(e, t, r, z)
            else if (s !== go)
              if (s !== yo)
                if (2 !== a && 1 & d && l)
                  if (0 === a) l.beforeEnter(i), n(i, t, r), Ba(() => l.enter(i), o)
                  else {
                    const { leave: e, delayLeave: a, afterLeave: o } = l,
                      s = () => n(i, t, r),
                      c = () => {
                        e(i, () => {
                          s(), o && o()
                        })
                      }
                    a ? a(i, s, c) : c()
                  }
                else n(i, t, r)
              else
                (({ el: e, anchor: t }, r, a) => {
                  let o
                  for (; e && e !== t; ) (o = u(e)), n(e, r, a), (e = o)
                  n(t, r, a)
                })(e, t, r)
            else {
              n(i, t, r)
              for (let e = 0; e < c.length; e++) $(c[e], t, r, a)
              n(e.anchor, t, r)
            }
          },
          I = (e, t, n, r = !1, a = !1) => {
            const {
              type: o,
              props: i,
              ref: s,
              children: l,
              dynamicChildren: c,
              shapeFlag: d,
              patchFlag: u,
              dirs: p,
              memoIndex: h,
            } = e
            if (
              (-2 === u && (a = !1),
              null != s && Qa(s, null, n, e, !0),
              null != h && (t.renderCache[h] = void 0),
              256 & d)
            )
              return void t.ctx.deactivate(e)
            const f = 1 & d && p,
              m = !Vr(e)
            let g
            if ((m && (g = i && i.onVnodeBeforeUnmount) && zo(g, t, e), 6 & d)) Q(e.component, n, r)
            else {
              if (128 & d) return void e.suspense.unmount(n, r)
              f && zr(e, null, t, "beforeUnmount"),
                64 & d
                  ? e.type.remove(e, t, n, z, r)
                  : c && (o !== go || (u > 0 && 64 & u))
                    ? B(c, t, n, !1, !0)
                    : ((o === go && 384 & u) || (!a && 16 & d)) && B(l, t, n),
                r && M(e)
            }
            ;((m && (g = i && i.onVnodeUnmounted)) || f) &&
              Ba(() => {
                g && zo(g, t, e), f && zr(e, null, t, "unmounted")
              }, n)
          },
          M = (e) => {
            const { type: t, el: n, anchor: a, transition: o } = e
            if (t === go) return void L(n, a)
            if (t === yo)
              return void (({ el: e, anchor: t }) => {
                let n
                for (; e && e !== t; ) (n = u(e)), r(e), (e = n)
                r(t)
              })(e)
            const i = () => {
              r(n), o && !o.persisted && o.afterLeave && o.afterLeave()
            }
            if (1 & e.shapeFlag && o && !o.persisted) {
              const { leave: t, delayLeave: r } = o,
                a = () => t(n, i)
              r ? r(e.el, i, a) : a()
            } else i()
          },
          L = (e, t) => {
            let n
            for (; e !== t; ) (n = u(e)), r(e), (e = n)
            r(t)
          },
          Q = (e, t, n) => {
            const { bum: r, scope: a, update: o, subTree: i, um: s, m: l, a: c } = e
            Za(l),
              Za(c),
              r && Ue(r),
              a.stop(),
              o && ((o.active = !1), I(i, e, t, n)),
              s && Ba(s, t),
              Ba(() => {
                e.isUnmounted = !0
              }, t),
              t &&
                t.pendingBranch &&
                !t.isUnmounted &&
                e.asyncDep &&
                !e.asyncResolved &&
                e.suspenseId === t.pendingId &&
                (t.deps--, 0 === t.deps && t.resolve())
          },
          B = (e, t, n, r = !1, a = !1, o = 0) => {
            for (let i = o; i < e.length; i++) I(e[i], t, n, r, a)
          },
          j = (e) =>
            6 & e.shapeFlag ? j(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : u(e.anchor || e.el)
        let U = !1
        const F = (e, t, n) => {
            null == e ? t._vnode && I(t._vnode, null, null, !0) : f(t._vnode || null, e, t, null, null, null, n),
              U || ((U = !0), ir(), sr(), (U = !1)),
              (t._vnode = e)
          },
          z = { p: f, um: I, m: $, r: M, mt: T, mc: w, pc: D, pbc: k, n: j, o: e }
        let q
        return { render: F, hydrate: q, createApp: ya(F, q) }
      })(e)
    }
    function Ua({ type: e, props: t }, n) {
      return ("svg" === n && "foreignObject" === e) ||
        ("mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html"))
        ? void 0
        : n
    }
    function Fa({ effect: e, update: t }, n) {
      e.allowRecurse = t.allowRecurse = n
    }
    function za(e, t, n = !1) {
      const r = e.children,
        a = t.children
      if (ve(r) && ve(a))
        for (let e = 0; e < r.length; e++) {
          const t = r[e]
          let o = a[e]
          1 & o.shapeFlag &&
            !o.dynamicChildren &&
            ((o.patchFlag <= 0 || 32 === o.patchFlag) && ((o = a[e] = jo(a[e])), (o.el = t.el)),
            n || -2 === o.patchFlag || za(t, o)),
            o.type === bo && (o.el = t.el)
        }
    }
    function qa(e) {
      const t = e.subTree.component
      if (t) return t.asyncDep && !t.asyncResolved ? t : qa(t)
    }
    function Za(e) {
      if (e) for (let t = 0; t < e.length; t++) e[t].active = !1
    }
    const Ha = Symbol.for("v-scx"),
      Va = () => xa(Ha)
    function Wa(e, t) {
      return Ga(e, null, t)
    }
    const Xa = {}
    function Ya(e, t, n) {
      return Ga(e, t, n)
    }
    function Ga(e, t, { immediate: n, deep: r, flush: a, once: o, onTrack: i, onTrigger: s } = le) {
      if (t && o) {
        const e = t
        t = (...t) => {
          e(...t), w()
        }
      }
      const l = Ho,
        c = (e) => (!0 === r ? e : eo(e, !1 === r ? 1 : void 0))
      let d,
        u,
        p = !1,
        h = !1
      if (
        (Pn(e)
          ? ((d = () => e.value), (p = xn(e)))
          : On(e)
            ? ((d = () => c(e)), (p = !0))
            : ve(e)
              ? ((h = !0),
                (p = e.some((e) => On(e) || xn(e))),
                (d = () => e.map((e) => (Pn(e) ? e.value : On(e) ? c(e) : xe(e) ? Zn(e, l, 2) : void 0))))
              : (d = xe(e) ? (t ? () => Zn(e, l, 2) : () => (u && u(), Hn(e, l, 3, [m]))) : de),
        t && r)
      ) {
        const e = d
        d = () => eo(e())
      }
      let f,
        m = (e) => {
          u = y.onStop = () => {
            Zn(e, l, 4), (u = y.onStop = void 0)
          }
        }
      if (ei) {
        if (((m = de), t ? n && Hn(t, l, 3, [d(), h ? [] : void 0, m]) : d(), "sync" !== a)) return de
        {
          const e = Va()
          f = e.__watcherHandles || (e.__watcherHandles = [])
        }
      }
      let g = h ? new Array(e.length).fill(Xa) : Xa
      const b = () => {
        if (y.active && y.dirty)
          if (t) {
            const e = y.run()
            ;(r || p || (h ? e.some((e, t) => je(e, g[t])) : je(e, g))) &&
              (u && u(), Hn(t, l, 3, [e, g === Xa ? void 0 : h && g[0] === Xa ? [] : g, m]), (g = e))
          } else y.run()
      }
      let v
      ;(b.allowRecurse = !!t),
        "sync" === a
          ? (v = b)
          : "post" === a
            ? (v = () => Ba(b, l && l.suspense))
            : ((b.pre = !0), l && (b.id = l.uid), (v = () => ar(b)))
      const y = new pt(d, de, v),
        O = dt(),
        w = () => {
          y.stop(), O && me(O.effects, y)
        }
      return (
        t ? (n ? b() : (g = y.run())) : "post" === a ? Ba(y.run.bind(y), l && l.suspense) : y.run(), f && f.push(w), w
      )
    }
    function Ka(e, t, n) {
      const r = this.proxy,
        a = ke(e) ? (e.includes(".") ? Ja(r, e) : () => r[e]) : e.bind(r, r)
      let o
      xe(t) ? (o = t) : ((o = t.handler), (n = t))
      const i = Yo(this),
        s = Ga(a, o.bind(r), n)
      return i(), s
    }
    function Ja(e, t) {
      const n = t.split(".")
      return () => {
        let t = e
        for (let e = 0; e < n.length && t; e++) t = t[n[e]]
        return t
      }
    }
    function eo(e, t = 1 / 0, n) {
      if (t <= 0 || !Se(e) || e.__v_skip) return e
      if ((n = n || new Set()).has(e)) return e
      if ((n.add(e), t--, Pn(e))) eo(e.value, t, n)
      else if (ve(e)) for (let r = 0; r < e.length; r++) eo(e[r], t, n)
      else if (Oe(e) || ye(e))
        e.forEach((e) => {
          eo(e, t, n)
        })
      else if (Pe(e)) {
        for (const r in e) eo(e[r], t, n)
        for (const r of Object.getOwnPropertySymbols(e))
          Object.prototype.propertyIsEnumerable.call(e, r) && eo(e[r], t, n)
      }
      return e
    }
    const to = (e) => e.type.__isKeepAlive
    function no(e, t) {
      ao(e, "a", t)
    }
    function ro(e, t) {
      ao(e, "da", t)
    }
    function ao(e, t, n = Ho) {
      const r =
        e.__wdc ||
        (e.__wdc = () => {
          let t = n
          for (; t; ) {
            if (t.isDeactivated) return
            t = t.parent
          }
          return e()
        })
      if ((Pr(t, r, n), n)) {
        let e = n.parent
        for (; e && e.parent; ) to(e.parent.vnode) && oo(r, t, n, e), (e = e.parent)
      }
    }
    function oo(e, t, n, r) {
      const a = Pr(t, e, r, !0)
      Lr(() => {
        me(r[t], a)
      }, n)
    }
    function io(e, t) {
      6 & e.shapeFlag && e.component
        ? io(e.component.subTree, t)
        : 128 & e.shapeFlag
          ? ((e.ssContent.transition = t.clone(e.ssContent)), (e.ssFallback.transition = t.clone(e.ssFallback)))
          : (e.transition = t)
    }
    const so = (e) => e && (e.disabled || "" === e.disabled),
      lo = (e) => "undefined" != typeof SVGElement && e instanceof SVGElement,
      co = (e) => "function" == typeof MathMLElement && e instanceof MathMLElement,
      uo = (e, t) => {
        const n = e && e.to
        return ke(n) ? (t ? t(n) : null) : n
      },
      po = {
        name: "Teleport",
        __isTeleport: !0,
        process(e, t, n, r, a, o, i, s, l, c) {
          const {
              mc: d,
              pc: u,
              pbc: p,
              o: { insert: h, querySelector: f, createText: m, createComment: g },
            } = c,
            b = so(t.props)
          let { shapeFlag: v, children: y, dynamicChildren: O } = t
          if (null == e) {
            const e = (t.el = m("")),
              c = (t.anchor = m(""))
            h(e, n, r), h(c, n, r)
            const u = (t.target = uo(t.props, f)),
              p = (t.targetAnchor = m(""))
            u && (h(p, u), "svg" === i || lo(u) ? (i = "svg") : ("mathml" === i || co(u)) && (i = "mathml"))
            const g = (e, t) => {
              16 & v && d(y, e, t, a, o, i, s, l)
            }
            b ? g(n, c) : u && g(u, p)
          } else {
            t.el = e.el
            const r = (t.anchor = e.anchor),
              d = (t.target = e.target),
              h = (t.targetAnchor = e.targetAnchor),
              m = so(e.props),
              g = m ? n : d,
              v = m ? r : h
            if (
              ("svg" === i || lo(d) ? (i = "svg") : ("mathml" === i || co(d)) && (i = "mathml"),
              O ? (p(e.dynamicChildren, O, g, a, o, i, s), za(e, t, !0)) : l || u(e, t, g, v, a, o, i, s, !1),
              b)
            )
              m ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : ho(t, n, r, c, 1)
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
              const e = (t.target = uo(t.props, f))
              e && ho(t, e, null, c, 0)
            } else m && ho(t, d, h, c, 1)
          }
          mo(t)
        },
        remove(e, t, n, { um: r, o: { remove: a } }, o) {
          const { shapeFlag: i, children: s, anchor: l, targetAnchor: c, target: d, props: u } = e
          if ((d && a(c), o && a(l), 16 & i)) {
            const e = o || !so(u)
            for (let a = 0; a < s.length; a++) {
              const o = s[a]
              r(o, t, n, e, !!o.dynamicChildren)
            }
          }
        },
        move: ho,
        hydrate: function (e, t, n, r, a, o, { o: { nextSibling: i, parentNode: s, querySelector: l } }, c) {
          const d = (t.target = uo(t.props, l))
          if (d) {
            const l = d._lpa || d.firstChild
            if (16 & t.shapeFlag)
              if (so(t.props)) (t.anchor = c(i(e), t, s(e), n, r, a, o)), (t.targetAnchor = l)
              else {
                t.anchor = i(e)
                let s = l
                for (; s; )
                  if (((s = i(s)), s && 8 === s.nodeType && "teleport anchor" === s.data)) {
                    ;(t.targetAnchor = s), (d._lpa = t.targetAnchor && i(t.targetAnchor))
                    break
                  }
                c(l, t, d, n, r, a, o)
              }
            mo(t)
          }
          return t.anchor && i(t.anchor)
        },
      }
    function ho(e, t, n, { o: { insert: r }, m: a }, o = 2) {
      0 === o && r(e.targetAnchor, t, n)
      const { el: i, anchor: s, shapeFlag: l, children: c, props: d } = e,
        u = 2 === o
      if ((u && r(i, t, n), (!u || so(d)) && 16 & l)) for (let e = 0; e < c.length; e++) a(c[e], t, n, 2)
      u && r(s, t, n)
    }
    const fo = po
    function mo(e) {
      const t = e.ctx
      if (t && t.ut) {
        let n = e.children[0].el
        for (; n && n !== e.targetAnchor; )
          1 === n.nodeType && n.setAttribute("data-v-owner", t.uid), (n = n.nextSibling)
        t.ut()
      }
    }
    const go = Symbol.for("v-fgt"),
      bo = Symbol.for("v-txt"),
      vo = Symbol.for("v-cmt"),
      yo = Symbol.for("v-stc"),
      Oo = []
    let wo = null
    function xo(e = !1) {
      Oo.push((wo = e ? null : []))
    }
    let ko = 1
    function _o(e) {
      ko += e
    }
    function So(e) {
      return (
        (e.dynamicChildren = ko > 0 ? wo || ce : null),
        Oo.pop(),
        (wo = Oo[Oo.length - 1] || null),
        ko > 0 && wo && wo.push(e),
        e
      )
    }
    function Eo(e, t, n, r, a, o) {
      return So(Ro(e, t, n, r, a, o, !0))
    }
    function To(e, t, n, r, a) {
      return So(No(e, t, n, r, a, !0))
    }
    function Ao(e) {
      return !!e && !0 === e.__v_isVNode
    }
    function Co(e, t) {
      return e.type === t.type && e.key === t.key
    }
    const Po = ({ key: e }) => (null != e ? e : null),
      Do = ({ ref: e, ref_key: t, ref_for: n }) => (
        "number" == typeof e && (e = "" + e),
        null != e ? (ke(e) || Pn(e) || xe(e) ? { i: fr, r: e, k: t, f: !!n } : e) : null
      )
    function Ro(e, t = null, n = null, r = 0, a = null, o = e === go ? 0 : 1, i = !1, s = !1) {
      const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && Po(t),
        ref: t && Do(t),
        scopeId: mr,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: o,
        patchFlag: r,
        dynamicProps: a,
        dynamicChildren: null,
        appContext: null,
        ctx: fr,
      }
      return (
        s ? (Uo(l, n), 128 & o && e.normalize(l)) : n && (l.shapeFlag |= ke(n) ? 8 : 16),
        ko > 0 && !i && wo && (l.patchFlag > 0 || 6 & o) && 32 !== l.patchFlag && wo.push(l),
        l
      )
    }
    const No = function (e, t = null, n = null, r = 0, a = null, o = !1) {
      if (((e && e !== Er) || (e = vo), Ao(e))) {
        const r = Io(e, t, !0)
        return (
          n && Uo(r, n),
          ko > 0 && !o && wo && (6 & r.shapeFlag ? (wo[wo.indexOf(e)] = r) : wo.push(r)),
          (r.patchFlag = -2),
          r
        )
      }
      var i
      if ((xe((i = e)) && "__vccOpts" in i && (e = e.__vccOpts), t)) {
        t = $o(t)
        let { class: e, style: n } = t
        e && !ke(e) && (t.class = Ge(e)), Se(n) && (kn(n) && !ve(n) && (n = fe({}, n)), (t.style = He(n)))
      }
      return Ro(
        e,
        t,
        n,
        r,
        a,
        ke(e) ? 1 : ((e) => e.__isSuspense)(e) ? 128 : ((e) => e.__isTeleport)(e) ? 64 : Se(e) ? 4 : xe(e) ? 2 : 0,
        o,
        !0,
      )
    }
    function $o(e) {
      return e ? (kn(e) || Sa(e) ? fe({}, e) : e) : null
    }
    function Io(e, t, n = !1, r = !1) {
      const { props: a, ref: o, patchFlag: i, children: s, transition: l } = e,
        c = t ? Fo(a || {}, t) : a,
        d = {
          __v_isVNode: !0,
          __v_skip: !0,
          type: e.type,
          props: c,
          key: c && Po(c),
          ref: t && t.ref ? (n && o ? (ve(o) ? o.concat(Do(t)) : [o, Do(t)]) : Do(t)) : o,
          scopeId: e.scopeId,
          slotScopeIds: e.slotScopeIds,
          children: s,
          target: e.target,
          targetAnchor: e.targetAnchor,
          staticCount: e.staticCount,
          shapeFlag: e.shapeFlag,
          patchFlag: t && e.type !== go ? (-1 === i ? 16 : 16 | i) : i,
          dynamicProps: e.dynamicProps,
          dynamicChildren: e.dynamicChildren,
          appContext: e.appContext,
          dirs: e.dirs,
          transition: l,
          component: e.component,
          suspense: e.suspense,
          ssContent: e.ssContent && Io(e.ssContent),
          ssFallback: e.ssFallback && Io(e.ssFallback),
          el: e.el,
          anchor: e.anchor,
          ctx: e.ctx,
          ce: e.ce,
        }
      return l && r && io(d, l.clone(d)), d
    }
    function Mo(e = " ", t = 0) {
      return No(bo, null, e, t)
    }
    function Lo(e, t) {
      const n = No(yo, null, e)
      return (n.staticCount = t), n
    }
    function Qo(e = "", t = !1) {
      return t ? (xo(), To(vo, null, e)) : No(vo, null, e)
    }
    function Bo(e) {
      return null == e || "boolean" == typeof e
        ? No(vo)
        : ve(e)
          ? No(go, null, e.slice())
          : "object" == typeof e
            ? jo(e)
            : No(bo, null, String(e))
    }
    function jo(e) {
      return (null === e.el && -1 !== e.patchFlag) || e.memo ? e : Io(e)
    }
    function Uo(e, t) {
      let n = 0
      const { shapeFlag: r } = e
      if (null == t) t = null
      else if (ve(t)) n = 16
      else if ("object" == typeof t) {
        if (65 & r) {
          const n = t.default
          return void (n && (n._c && (n._d = !1), Uo(e, n()), n._c && (n._d = !0)))
        }
        {
          n = 32
          const r = t._
          r || Sa(t)
            ? 3 === r && fr && (1 === fr.slots._ ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
            : (t._ctx = fr)
        }
      } else
        xe(t)
          ? ((t = { default: t, _ctx: fr }), (n = 32))
          : ((t = String(t)), 64 & r ? ((n = 16), (t = [Mo(t)])) : (n = 8))
      ;(e.children = t), (e.shapeFlag |= n)
    }
    function Fo(...e) {
      const t = {}
      for (let n = 0; n < e.length; n++) {
        const r = e[n]
        for (const e in r)
          if ("class" === e) t.class !== r.class && (t.class = Ge([t.class, r.class]))
          else if ("style" === e) t.style = He([t.style, r.style])
          else if (pe(e)) {
            const n = t[e],
              a = r[e]
            !a || n === a || (ve(n) && n.includes(a)) || (t[e] = n ? [].concat(n, a) : a)
          } else "" !== e && (t[e] = r[e])
      }
      return t
    }
    function zo(e, t, n, r = null) {
      Hn(e, t, 7, [n, r])
    }
    const qo = ba()
    let Zo = 0,
      Ho = null
    const Vo = () => Ho || fr
    let Wo, Xo
    {
      const e = Ze(),
        t = (t, n) => {
          let r
          return (
            (r = e[t]) || (r = e[t] = []),
            r.push(n),
            (e) => {
              r.length > 1 ? r.forEach((t) => t(e)) : r[0](e)
            }
          )
        }
      ;(Wo = t("__VUE_INSTANCE_SETTERS__", (e) => (Ho = e))), (Xo = t("__VUE_SSR_SETTERS__", (e) => (ei = e)))
    }
    const Yo = (e) => {
        const t = Ho
        return (
          Wo(e),
          e.scope.on(),
          () => {
            e.scope.off(), Wo(t)
          }
        )
      },
      Go = () => {
        Ho && Ho.scope.off(), Wo(null)
      }
    function Ko(e) {
      return 4 & e.vnode.shapeFlag
    }
    let Jo,
      ei = !1
    function ti(e, t, n) {
      xe(t) ? (e.type.__ssrInlineRender ? (e.ssrRender = t) : (e.render = t)) : Se(t) && (e.setupState = Qn(t)),
        ni(e, n)
    }
    function ni(e, t, n) {
      const r = e.type
      if (!e.render) {
        if (!t && Jo && !r.render) {
          const t = r.template || ca(e).template
          if (t) {
            const { isCustomElement: n, compilerOptions: a } = e.appContext.config,
              { delimiters: o, compilerOptions: i } = r,
              s = fe(fe({ isCustomElement: n, delimiters: o }, a), i)
            r.render = Jo(t, s)
          }
        }
        e.render = r.render || de
      }
      {
        const t = Yo(e)
        yt()
        try {
          !(function (e) {
            const t = ca(e),
              n = e.proxy,
              r = e.ctx
            ;(ia = !1), t.beforeCreate && sa(t.beforeCreate, e, "bc")
            const {
              data: a,
              computed: o,
              methods: i,
              watch: s,
              provide: l,
              inject: c,
              created: d,
              beforeMount: u,
              mounted: p,
              beforeUpdate: h,
              updated: f,
              activated: m,
              deactivated: g,
              beforeDestroy: b,
              beforeUnmount: v,
              destroyed: y,
              unmounted: O,
              render: w,
              renderTracked: x,
              renderTriggered: k,
              errorCaptured: _,
              serverPrefetch: S,
              expose: E,
              inheritAttrs: T,
              components: A,
              directives: C,
              filters: P,
            } = t
            if (
              (c &&
                (function (e, t, n = de) {
                  ve(e) && (e = ha(e))
                  for (const n in e) {
                    const r = e[n]
                    let a
                    ;(a = Se(r) ? ("default" in r ? xa(r.from || n, r.default, !0) : xa(r.from || n)) : xa(r)),
                      Pn(a)
                        ? Object.defineProperty(t, n, {
                            enumerable: !0,
                            configurable: !0,
                            get: () => a.value,
                            set: (e) => (a.value = e),
                          })
                        : (t[n] = a)
                  }
                })(c, r, null),
              i)
            )
              for (const e in i) {
                const t = i[e]
                xe(t) && (r[e] = t.bind(n))
              }
            if (a) {
              const t = a.call(n, n)
              Se(t) && (e.data = mn(t))
            }
            if (((ia = !0), o))
              for (const e in o) {
                const t = o[e],
                  a = xe(t) ? t.bind(n, n) : xe(t.get) ? t.get.bind(n, n) : de,
                  i = !xe(t) && xe(t.set) ? t.set.bind(n) : de,
                  s = ii({ get: a, set: i })
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  configurable: !0,
                  get: () => s.value,
                  set: (e) => (s.value = e),
                })
              }
            if (s) for (const e in s) la(s[e], r, n, e)
            if (l) {
              const e = xe(l) ? l.call(n) : l
              Reflect.ownKeys(e).forEach((t) => {
                wa(t, e[t])
              })
            }
            function D(e, t) {
              ve(t) ? t.forEach((t) => e(t.bind(n))) : t && e(t.bind(n))
            }
            if (
              (d && sa(d, e, "c"),
              D(Rr, u),
              D(Nr, p),
              D($r, h),
              D(Ir, f),
              D(no, m),
              D(ro, g),
              D(Ur, _),
              D(jr, x),
              D(Br, k),
              D(Mr, v),
              D(Lr, O),
              D(Qr, S),
              ve(E))
            )
              if (E.length) {
                const t = e.exposed || (e.exposed = {})
                E.forEach((e) => {
                  Object.defineProperty(t, e, { get: () => n[e], set: (t) => (n[e] = t) })
                })
              } else e.exposed || (e.exposed = {})
            w && e.render === de && (e.render = w),
              null != T && (e.inheritAttrs = T),
              A && (e.components = A),
              C && (e.directives = C)
          })(e)
        } finally {
          Ot(), t()
        }
      }
    }
    const ri = { get: (e, t) => (Pt(e, 0, ""), e[t]) }
    function ai(e) {
      return {
        attrs: new Proxy(e.attrs, ri),
        slots: e.slots,
        emit: e.emit,
        expose: (t) => {
          e.exposed = t || {}
        },
      }
    }
    function oi(e) {
      return e.exposed
        ? e.exposeProxy ||
            (e.exposeProxy = new Proxy(Qn(((t = e.exposed), Object.isExtensible(t) && Fe(t, "__v_skip", !0), t)), {
              get: (t, n) => (n in t ? t[n] : n in Jr ? Jr[n](e) : void 0),
              has: (e, t) => t in e || t in Jr,
            }))
        : e.proxy
      var t
    }
    const ii = (e, t) => {
      const n = (function (e, t, n = !1) {
        let r, a
        const o = xe(e)
        return o ? ((r = e), (a = de)) : ((r = e.get), (a = e.set)), new Tn(r, a, o || !a, n)
      })(e, 0, ei)
      return n
    }
    function si(e, t, n) {
      const r = arguments.length
      return 2 === r
        ? Se(t) && !ve(t)
          ? Ao(t)
            ? No(e, null, [t])
            : No(e, t)
          : No(e, null, t)
        : (r > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : 3 === r && Ao(n) && (n = [n]), No(e, t, n))
    }
    const li = "3.4.31",
      ci = "undefined" != typeof document ? document : null,
      di = ci && ci.createElement("template"),
      ui = {
        insert: (e, t, n) => {
          t.insertBefore(e, n || null)
        },
        remove: (e) => {
          const t = e.parentNode
          t && t.removeChild(e)
        },
        createElement: (e, t, n, r) => {
          const a =
            "svg" === t
              ? ci.createElementNS("http://www.w3.org/2000/svg", e)
              : "mathml" === t
                ? ci.createElementNS("http://www.w3.org/1998/Math/MathML", e)
                : n
                  ? ci.createElement(e, { is: n })
                  : ci.createElement(e)
          return "select" === e && r && null != r.multiple && a.setAttribute("multiple", r.multiple), a
        },
        createText: (e) => ci.createTextNode(e),
        createComment: (e) => ci.createComment(e),
        setText: (e, t) => {
          e.nodeValue = t
        },
        setElementText: (e, t) => {
          e.textContent = t
        },
        parentNode: (e) => e.parentNode,
        nextSibling: (e) => e.nextSibling,
        querySelector: (e) => ci.querySelector(e),
        setScopeId(e, t) {
          e.setAttribute(t, "")
        },
        insertStaticContent(e, t, n, r, a, o) {
          const i = n ? n.previousSibling : t.lastChild
          if (a && (a === o || a.nextSibling))
            for (; t.insertBefore(a.cloneNode(!0), n), a !== o && (a = a.nextSibling); );
          else {
            di.innerHTML = "svg" === r ? `<svg>${e}</svg>` : "mathml" === r ? `<math>${e}</math>` : e
            const a = di.content
            if ("svg" === r || "mathml" === r) {
              const e = a.firstChild
              for (; e.firstChild; ) a.appendChild(e.firstChild)
              a.removeChild(e)
            }
            t.insertBefore(a, n)
          }
          return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
        },
      },
      pi = Symbol("_vtc"),
      hi = Symbol("_vod"),
      fi = Symbol("_vsh"),
      mi = {
        beforeMount(e, { value: t }, { transition: n }) {
          ;(e[hi] = "none" === e.style.display ? "" : e.style.display), n && t ? n.beforeEnter(e) : gi(e, t)
        },
        mounted(e, { value: t }, { transition: n }) {
          n && t && n.enter(e)
        },
        updated(e, { value: t, oldValue: n }, { transition: r }) {
          !t != !n &&
            (r
              ? t
                ? (r.beforeEnter(e), gi(e, !0), r.enter(e))
                : r.leave(e, () => {
                    gi(e, !1)
                  })
              : gi(e, t))
        },
        beforeUnmount(e, { value: t }) {
          gi(e, t)
        },
      }
    /**
     * @vue/runtime-dom v3.4.31
     * (c) 2018-present Yuxi (Evan) You and Vue contributors
     * @license MIT
     **/ function gi(e, t) {
      ;(e.style.display = t ? e[hi] : "none"), (e[fi] = !t)
    }
    const bi = Symbol("")
    function vi(e) {
      const t = Vo()
      if (!t) return
      const n = (t.ut = (n = e(t.proxy)) => {
          Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach((e) => Oi(e, n))
        }),
        r = () => {
          const r = e(t.proxy)
          yi(t.subTree, r), n(r)
        }
      Nr(() => {
        Ga(r, null, { flush: "post" })
        const e = new MutationObserver(r)
        e.observe(t.subTree.el.parentNode, { childList: !0 }), Lr(() => e.disconnect())
      })
    }
    function yi(e, t) {
      if (128 & e.shapeFlag) {
        const n = e.suspense
        ;(e = n.activeBranch),
          n.pendingBranch &&
            !n.isHydrating &&
            n.effects.push(() => {
              yi(n.activeBranch, t)
            })
      }
      for (; e.component; ) e = e.component.subTree
      if (1 & e.shapeFlag && e.el) Oi(e.el, t)
      else if (e.type === go) e.children.forEach((e) => yi(e, t))
      else if (e.type === yo) {
        let { el: n, anchor: r } = e
        for (; n && (Oi(n, t), n !== r); ) n = n.nextSibling
      }
    }
    function Oi(e, t) {
      if (1 === e.nodeType) {
        const n = e.style
        let r = ""
        for (const e in t) n.setProperty(`--${e}`, t[e]), (r += `--${e}: ${t[e]};`)
        n[bi] = r
      }
    }
    const wi = /(^|;)\s*display\s*:/,
      xi = /\s*!important$/
    function ki(e, t, n) {
      if (ve(n)) n.forEach((n) => ki(e, t, n))
      else if ((null == n && (n = ""), t.startsWith("--"))) e.setProperty(t, n)
      else {
        const r = (function (e, t) {
          const n = Si[t]
          if (n) return n
          let r = Ie(t)
          if ("filter" !== r && r in e) return (Si[t] = r)
          r = Qe(r)
          for (let n = 0; n < _i.length; n++) {
            const a = _i[n] + r
            if (a in e) return (Si[t] = a)
          }
          return t
        })(e, t)
        xi.test(n) ? e.setProperty(Le(r), n.replace(xi, ""), "important") : (e[r] = n)
      }
    }
    const _i = ["Webkit", "Moz", "ms"],
      Si = {},
      Ei = "http://www.w3.org/1999/xlink"
    function Ti(e, t, n, r, a, o = Je(t)) {
      r && t.startsWith("xlink:")
        ? null == n
          ? e.removeAttributeNS(Ei, t.slice(6, t.length))
          : e.setAttributeNS(Ei, t, n)
        : null == n || (o && !et(n))
          ? e.removeAttribute(t)
          : e.setAttribute(t, o ? "" : _e(n) ? String(n) : n)
    }
    function Ai(e, t, n, r) {
      e.addEventListener(t, n, r)
    }
    const Ci = Symbol("_vei")
    const Pi = /(?:Once|Passive|Capture)$/
    let Di = 0
    const Ri = Promise.resolve(),
      Ni = () => Di || (Ri.then(() => (Di = 0)), (Di = Date.now())),
      $i = (e) => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
      Ii = (e) => {
        const t = e.props["onUpdate:modelValue"] || !1
        return ve(t) ? (e) => Ue(t, e) : t
      }
    function Mi(e) {
      e.target.composing = !0
    }
    function Li(e) {
      const t = e.target
      t.composing && ((t.composing = !1), t.dispatchEvent(new Event("input")))
    }
    const Qi = Symbol("_assign"),
      Bi = {
        created(e, { modifiers: { lazy: t, trim: n, number: r } }, a) {
          e[Qi] = Ii(a)
          const o = r || (a.props && "number" === a.props.type)
          Ai(e, t ? "change" : "input", (t) => {
            if (t.target.composing) return
            let r = e.value
            n && (r = r.trim()), o && (r = ze(r)), e[Qi](r)
          }),
            n &&
              Ai(e, "change", () => {
                e.value = e.value.trim()
              }),
            t || (Ai(e, "compositionstart", Mi), Ai(e, "compositionend", Li), Ai(e, "change", Li))
        },
        mounted(e, { value: t }) {
          e.value = null == t ? "" : t
        },
        beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: r, trim: a, number: o } }, i) {
          if (((e[Qi] = Ii(i)), e.composing)) return
          const s = null == t ? "" : t
          if (((!o && "number" !== e.type) || /^0\d/.test(e.value) ? e.value : ze(e.value)) !== s) {
            if (document.activeElement === e && "range" !== e.type) {
              if (r && t === n) return
              if (a && e.value.trim() === s) return
            }
            e.value = s
          }
        },
      },
      ji = {
        deep: !0,
        created(e, t, n) {
          ;(e[Qi] = Ii(n)),
            Ai(e, "change", () => {
              const t = e._modelValue,
                n = qi(e),
                r = e.checked,
                a = e[Qi]
              if (ve(t)) {
                const e = nt(t, n),
                  o = -1 !== e
                if (r && !o) a(t.concat(n))
                else if (!r && o) {
                  const n = [...t]
                  n.splice(e, 1), a(n)
                }
              } else if (Oe(t)) {
                const e = new Set(t)
                r ? e.add(n) : e.delete(n), a(e)
              } else a(Zi(e, r))
            })
        },
        mounted: Ui,
        beforeUpdate(e, t, n) {
          ;(e[Qi] = Ii(n)), Ui(e, t, n)
        },
      }
    function Ui(e, { value: t, oldValue: n }, r) {
      ;(e._modelValue = t),
        ve(t)
          ? (e.checked = nt(t, r.props.value) > -1)
          : Oe(t)
            ? (e.checked = t.has(r.props.value))
            : t !== n && (e.checked = tt(t, Zi(e, !0)))
    }
    const Fi = {
      deep: !0,
      created(e, { value: t, modifiers: { number: n } }, r) {
        const a = Oe(t)
        Ai(e, "change", () => {
          const t = Array.prototype.filter.call(e.options, (e) => e.selected).map((e) => (n ? ze(qi(e)) : qi(e)))
          e[Qi](e.multiple ? (a ? new Set(t) : t) : t[0]),
            (e._assigning = !0),
            rr(() => {
              e._assigning = !1
            })
        }),
          (e[Qi] = Ii(r))
      },
      mounted(e, { value: t, modifiers: { number: n } }) {
        zi(e, t)
      },
      beforeUpdate(e, t, n) {
        e[Qi] = Ii(n)
      },
      updated(e, { value: t, modifiers: { number: n } }) {
        e._assigning || zi(e, t)
      },
    }
    function zi(e, t, n) {
      const r = e.multiple,
        a = ve(t)
      if (!r || a || Oe(t)) {
        for (let n = 0, o = e.options.length; n < o; n++) {
          const o = e.options[n],
            i = qi(o)
          if (r)
            if (a) {
              const e = typeof i
              o.selected = "string" === e || "number" === e ? t.some((e) => String(e) === String(i)) : nt(t, i) > -1
            } else o.selected = t.has(i)
          else if (tt(qi(o), t)) return void (e.selectedIndex !== n && (e.selectedIndex = n))
        }
        r || -1 === e.selectedIndex || (e.selectedIndex = -1)
      }
    }
    function qi(e) {
      return "_value" in e ? e._value : e.value
    }
    function Zi(e, t) {
      const n = t ? "_trueValue" : "_falseValue"
      return n in e ? e[n] : t
    }
    const Hi = ["ctrl", "shift", "alt", "meta"],
      Vi = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && 0 !== e.button,
        middle: (e) => "button" in e && 1 !== e.button,
        right: (e) => "button" in e && 2 !== e.button,
        exact: (e, t) => Hi.some((n) => e[`${n}Key`] && !t.includes(n)),
      },
      Wi = (e, t) => {
        const n = e._withMods || (e._withMods = {}),
          r = t.join(".")
        return (
          n[r] ||
          (n[r] = (n, ...r) => {
            for (let e = 0; e < t.length; e++) {
              const r = Vi[t[e]]
              if (r && r(n, t)) return
            }
            return e(n, ...r)
          })
        )
      },
      Xi = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace",
      },
      Yi = (e, t) => {
        const n = e._withKeys || (e._withKeys = {}),
          r = t.join(".")
        return (
          n[r] ||
          (n[r] = (n) => {
            if (!("key" in n)) return
            const r = Le(n.key)
            return t.some((e) => e === r || Xi[e] === r) ? e(n) : void 0
          })
        )
      },
      Gi = fe(
        {
          patchProp: (e, t, n, r, a, o, i, s, l) => {
            const c = "svg" === a
            "class" === t
              ? (function (e, t, n) {
                  const r = e[pi]
                  r && (t = (t ? [t, ...r] : [...r]).join(" ")),
                    null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : (e.className = t)
                })(e, r, c)
              : "style" === t
                ? (function (e, t, n) {
                    const r = e.style,
                      a = ke(n)
                    let o = !1
                    if (n && !a) {
                      if (t)
                        if (ke(t))
                          for (const e of t.split(";")) {
                            const t = e.slice(0, e.indexOf(":")).trim()
                            null == n[t] && ki(r, t, "")
                          }
                        else for (const e in t) null == n[e] && ki(r, e, "")
                      for (const e in n) "display" === e && (o = !0), ki(r, e, n[e])
                    } else if (a) {
                      if (t !== n) {
                        const e = r[bi]
                        e && (n += ";" + e), (r.cssText = n), (o = wi.test(n))
                      }
                    } else t && e.removeAttribute("style")
                    hi in e && ((e[hi] = o ? r.display : ""), e[fi] && (r.display = "none"))
                  })(e, n, r)
                : pe(t)
                  ? he(t) ||
                    (function (e, t, n, r, a = null) {
                      const o = e[Ci] || (e[Ci] = {}),
                        i = o[t]
                      if (r && i) i.value = r
                      else {
                        const [n, s] = (function (e) {
                          let t
                          if (Pi.test(e)) {
                            let n
                            for (t = {}; (n = e.match(Pi)); )
                              (e = e.slice(0, e.length - n[0].length)), (t[n[0].toLowerCase()] = !0)
                          }
                          return [":" === e[2] ? e.slice(3) : Le(e.slice(2)), t]
                        })(t)
                        if (r) {
                          const i = (o[t] = (function (e, t) {
                            const n = (e) => {
                              if (e._vts) {
                                if (e._vts <= n.attached) return
                              } else e._vts = Date.now()
                              Hn(
                                (function (e, t) {
                                  if (ve(t)) {
                                    const n = e.stopImmediatePropagation
                                    return (
                                      (e.stopImmediatePropagation = () => {
                                        n.call(e), (e._stopped = !0)
                                      }),
                                      t.map((e) => (t) => !t._stopped && e && e(t))
                                    )
                                  }
                                  return t
                                })(e, n.value),
                                t,
                                5,
                                [e],
                              )
                            }
                            return (n.value = e), (n.attached = Ni()), n
                          })(r, a))
                          Ai(e, n, i, s)
                        } else
                          i &&
                            ((function (e, t, n, r) {
                              e.removeEventListener(t, n, r)
                            })(e, n, i, s),
                            (o[t] = void 0))
                      }
                    })(e, t, 0, r, i)
                  : (
                        "." === t[0]
                          ? ((t = t.slice(1)), 1)
                          : "^" === t[0]
                            ? ((t = t.slice(1)), 0)
                            : (function (e, t, n, r) {
                                if (r) return "innerHTML" === t || "textContent" === t || !!(t in e && $i(t) && xe(n))
                                if ("spellcheck" === t || "draggable" === t || "translate" === t) return !1
                                if ("form" === t) return !1
                                if ("list" === t && "INPUT" === e.tagName) return !1
                                if ("type" === t && "TEXTAREA" === e.tagName) return !1
                                if ("width" === t || "height" === t) {
                                  const t = e.tagName
                                  if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t) return !1
                                }
                                return (!$i(t) || !ke(n)) && t in e
                              })(e, t, r, c)
                      )
                    ? ((function (e, t, n, r, a, o, i) {
                        if ("innerHTML" === t || "textContent" === t)
                          return r && i(r, a, o), void (e[t] = null == n ? "" : n)
                        const s = e.tagName
                        if ("value" === t && "PROGRESS" !== s && !s.includes("-")) {
                          const r = "OPTION" === s ? e.getAttribute("value") || "" : e.value,
                            a = null == n ? "" : String(n)
                          return (
                            (r === a && "_value" in e) || (e.value = a),
                            null == n && e.removeAttribute(t),
                            void (e._value = n)
                          )
                        }
                        let l = !1
                        if ("" === n || null == n) {
                          const r = typeof e[t]
                          "boolean" === r
                            ? (n = et(n))
                            : null == n && "string" === r
                              ? ((n = ""), (l = !0))
                              : "number" === r && ((n = 0), (l = !0))
                        }
                        try {
                          e[t] = n
                        } catch (e) {}
                        l && e.removeAttribute(t)
                      })(e, t, r, o, i, s, l),
                      e.tagName.includes("-") ||
                        ("value" !== t && "checked" !== t && "selected" !== t) ||
                        Ti(e, t, r, c, 0, "value" !== t))
                    : ("true-value" === t ? (e._trueValue = r) : "false-value" === t && (e._falseValue = r),
                      Ti(e, t, r, c))
          },
        },
        ui,
      )
    let Ki
    const Ji = (...e) => {
        const t = (Ki || (Ki = ja(Gi))).createApp(...e),
          { mount: n } = t
        return (
          (t.mount = (e) => {
            const r = (function (e) {
              return ke(e) ? document.querySelector(e) : e
            })(e)
            if (!r) return
            const a = t._component
            xe(a) || a.render || a.template || (a.template = r.innerHTML), (r.innerHTML = "")
            const o = n(
              r,
              !1,
              (function (e) {
                return e instanceof SVGElement
                  ? "svg"
                  : "function" == typeof MathMLElement && e instanceof MathMLElement
                    ? "mathml"
                    : void 0
              })(r),
            )
            return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o
          }),
          t
        )
      },
      es = li.startsWith("3")
    function ts(e, t = "") {
      if (e instanceof Promise) return e
      const n = "function" == typeof (r = e) ? r() : In(r)
      var r
      return e && n
        ? Array.isArray(n)
          ? n.map((e) => ts(e, t))
          : "object" == typeof n
            ? Object.fromEntries(
                Object.entries(n).map(([e, t]) =>
                  "titleTemplate" === e || e.startsWith("on") ? [e, In(t)] : [e, ts(t, e)],
                ),
              )
            : n
        : n
    }
    const ns = {
        hooks: {
          "entries:resolve": function (e) {
            for (const t of e.entries) t.resolvedInput = ts(t.input)
          },
        },
      },
      rs = "usehead"
    function as(e = {}) {
      e.domDelayFn = e.domDelayFn || ((e) => rr(() => setTimeout(() => e(), 0)))
      const t = (function (e = {}) {
        const t = (function (e = {}) {
          const t = new d()
          t.addHooks(e.hooks || {}), (e.document = e.document || (g ? document : void 0))
          const n = !e.document,
            r = () => {
              ;(s.dirty = !0), t.callHook("entries:updated", s)
            }
          let a = 0,
            o = []
          const i = [],
            s = {
              plugins: i,
              dirty: !1,
              resolvedOptions: e,
              hooks: t,
              headEntries: () => o,
              use(e) {
                const r = "function" == typeof e ? e(s) : e
                ;(r.key && i.some((e) => e.key === r.key)) || (i.push(r), ie(r.mode, n) && t.addHooks(r.hooks || {}))
              },
              push(e, i) {
                null == i || delete i.head
                const l = { _i: a++, input: e, ...i }
                return (
                  ie(l.mode, n) && (o.push(l), r()),
                  {
                    dispose() {
                      ;(o = o.filter((e) => e._i !== l._i)), t.callHook("entries:updated", s), r()
                    },
                    patch(e) {
                      ;(o = o.map((t) => (t._i === l._i && (t.input = l.input = e), t))), r()
                    },
                  }
                )
              },
              async resolveTags() {
                const e = { tags: [], entries: [...o] }
                await t.callHook("entries:resolve", e)
                for (const n of e.entries) {
                  const r = n.resolvedInput || n.input
                  if (((n.resolvedInput = await (n.transform ? n.transform(r) : r)), n.resolvedInput))
                    for (const r of await Q(n)) {
                      const a = { tag: r, entry: n, resolvedOptions: s.resolvedOptions }
                      await t.callHook("tag:normalise", a), e.tags.push(a.tag)
                    }
                }
                return (
                  await t.callHook("tags:beforeResolve", e),
                  await t.callHook("tags:resolve", e),
                  await t.callHook("tags:afterResolve", e),
                  e.tags
                )
              },
              ssr: n,
            }
          return (
            [W, X, G, J, ee, ne, re, ae, ...((null == e ? void 0 : e.plugins) || [])].forEach((e) => s.use(e)),
            s.hooks.callHook("init", s),
            s
          )
        })(e)
        return t.use(H()), (oe = t)
      })(e)
      return (
        t.use(ns),
        (t.install = (function (e) {
          return {
            install(t) {
              es && ((t.config.globalProperties.$unhead = e), (t.config.globalProperties.$head = e), t.provide(rs, e))
            },
          }.install
        })(t)),
        t
      )
    }
    const os =
        "undefined" != typeof globalThis
          ? globalThis
          : "undefined" != typeof window
            ? window
            : "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : {},
      is = "__unhead_injection_handler__"
    function ss(e, t = {}) {
      const n = t.head || (is in os ? os[is]() : xa(rs) || oe)
      if (n)
        return n.ssr
          ? n.push(e, t)
          : (function (e, t, n = {}) {
              const r = Dn(!1),
                a = Dn({})
              Wa(() => {
                a.value = r.value ? {} : ts(t)
              })
              const o = e.push(a.value, n)
              return (
                Ya(a, (e) => {
                  o.patch(e)
                }),
                Vo() &&
                  (Mr(() => {
                    o.dispose()
                  }),
                  ro(() => {
                    r.value = !0
                  }),
                  no(() => {
                    r.value = !1
                  })),
                o
              )
            })(n, e, t)
    }
    const ls = ["GET", "POST", "PUT", "HEAD", "DELETE", "PATCH", "OPTIONS", "CONNECT", "TRACE"]
    function cs(e, t) {
      var n, r
      const a = [],
        o = [],
        i = []
      if (
        !e.customSecurity &&
        (!e.preferredSecurityScheme ||
          !(s = t) ||
          (Array.isArray(s) && !s.length) ||
          (s ?? []).some((e) => !Object.keys(e).length))
      )
        return { headers: a, queryString: o, cookies: i }
      var s
      const l =
          (null == t
            ? void 0
            : t.some((t) => e.preferredSecurityScheme && Object.keys(t).includes(e.preferredSecurityScheme))) ||
          e.customSecurity
            ? e.preferredSecurityScheme
            : Object.keys((null == t ? void 0 : t[0]) ?? {}).pop(),
        c = null == (n = e.securitySchemes) ? void 0 : n[l ?? ""]
      if (c)
        if ("type" in c && "apiKey" === c.type) {
          if ("in" in c && "header" === c.in) {
            const t = (null == (r = e.apiKey.token) ? void 0 : r.length) ? e.apiKey.token : "YOUR_TOKEN"
            a.push({ name: "name" in c ? c.name : "", value: t })
          } else if ("in" in c && "cookie" === c.in) {
            const t = e.apiKey.token.length ? e.apiKey.token : "YOUR_TOKEN"
            i.push({ name: c.name, value: t })
          } else if ("in" in c && "query" === c.in) {
            const t = e.apiKey.token.length ? e.apiKey.token : "YOUR_TOKEN"
            o.push({ name: c.name, value: t })
          }
        } else if (!("type" in c) || ("http" !== c.type && "basic" !== c.type)) {
          if ("type" in c && "oauth2" === c.type.toLowerCase()) {
            const t = e.oAuth2.accessToken || "YOUR_SECRET_TOKEN"
            a.push({ name: "Authorization", value: `Bearer ${t}` })
          }
        } else if ("type" in c && ("basic" === c.type || ("http" === c.type && "basic" === c.scheme))) {
          const { username: t, password: n } = e.http.basic,
            r = ds(t, n)
          a.push({ name: "Authorization", value: `Basic ${r}`.trim() })
        } else if ("type" in c && "http" === c.type && "bearer" === c.scheme) {
          const t = e.http.bearer.token.length ? e.http.bearer.token : "YOUR_SECRET_TOKEN"
          a.push({ name: "Authorization", value: `Bearer ${t}` })
        }
      return { headers: a, queryString: o, cookies: i }
    }
    function ds(e, t) {
      return (null == e ? void 0 : e.length) || (null == t ? void 0 : t.length)
        ? ((n = `${e}:${t}`), "undefined" == typeof window ? Buffer.from(n).toString("base64") : btoa(n))
        : ""
      var n
    }
    function us(e) {
      return [
        e.apiKey.token,
        e.http.bearer.token,
        e.oAuth2.accessToken,
        ds(e.http.basic.username, e.http.basic.password),
        e.http.basic.password,
      ].filter(Boolean)
    }
    const ps = (e, t) => {
        if ("string" != typeof t || !t.length) return e
        const n = e.trim(),
          r = t.trim()
        return [n.endsWith("/") ? n : `${n}/`, r.startsWith("/") ? r.slice(1) : r].join("")
      },
      hs = (e) => {
        let t = 0,
          n = 0,
          r = 0
        if (!(null == e ? void 0 : e.length)) return n
        for (r = 0; r < e.length; r++) (t = e.charCodeAt(r)), (n = (n << 5) - n + t), (n |= 0)
        return n
      },
      fs = (e) => e && "object" == typeof e && !Array.isArray(e),
      ms = (e, ...t) => {
        if (!t.length) return e
        const n = t.shift()
        if (fs(e) && fs(n))
          for (const t in n)
            fs(n[t]) ? (e[t] || Object.assign(e, { [t]: {} }), ms(e[t], n[t])) : Object.assign(e, { [t]: n[t] })
        return ms(e, ...t)
      }
    function gs(e, t) {
      if (!bs(e, t)) return t ?? ""
      const n = new URL(t)
      return (n.href = e), n.searchParams.append("scalar_url", t), n.toString()
    }
    function bs(e, t) {
      return !(
        !e ||
        !t ||
        (!t.startsWith("http://") && !t.startsWith("https://")) ||
        (function (e) {
          const { hostname: t } = new URL(e)
          return ["localhost", "127.0.0.1", "[::1]"].includes(t)
        })(t)
      )
    }
    const vs = Symbol.for("yaml.alias"),
      ys = Symbol.for("yaml.document"),
      Os = Symbol.for("yaml.map"),
      ws = Symbol.for("yaml.pair"),
      xs = Symbol.for("yaml.scalar"),
      ks = Symbol.for("yaml.seq"),
      _s = Symbol.for("yaml.node.type"),
      Ss = (e) => !!e && "object" == typeof e && e[_s] === vs,
      Es = (e) => !!e && "object" == typeof e && e[_s] === ys,
      Ts = (e) => !!e && "object" == typeof e && e[_s] === Os,
      As = (e) => !!e && "object" == typeof e && e[_s] === ws,
      Cs = (e) => !!e && "object" == typeof e && e[_s] === xs,
      Ps = (e) => !!e && "object" == typeof e && e[_s] === ks
    function Ds(e) {
      if (e && "object" == typeof e)
        switch (e[_s]) {
          case Os:
          case ks:
            return !0
        }
      return !1
    }
    function Rs(e) {
      if (e && "object" == typeof e)
        switch (e[_s]) {
          case vs:
          case Os:
          case xs:
          case ks:
            return !0
        }
      return !1
    }
    const Ns = (e) => (Cs(e) || Ds(e)) && !!e.anchor,
      $s = Symbol("break visit"),
      Is = Symbol("skip children"),
      Ms = Symbol("remove node")
    function Ls(e, t) {
      const n = (function (e) {
        return "object" == typeof e && (e.Collection || e.Node || e.Value)
          ? Object.assign(
              { Alias: e.Node, Map: e.Node, Scalar: e.Node, Seq: e.Node },
              e.Value && { Map: e.Value, Scalar: e.Value, Seq: e.Value },
              e.Collection && { Map: e.Collection, Seq: e.Collection },
              e,
            )
          : e
      })(t)
      Es(e)
        ? Qs(null, e.contents, n, Object.freeze([e])) === Ms && (e.contents = null)
        : Qs(null, e, n, Object.freeze([]))
    }
    function Qs(e, t, n, r) {
      const a = (function (e, t, n, r) {
        var a, o, i, s, l
        return "function" == typeof n
          ? n(e, t, r)
          : Ts(t)
            ? null == (a = n.Map)
              ? void 0
              : a.call(n, e, t, r)
            : Ps(t)
              ? null == (o = n.Seq)
                ? void 0
                : o.call(n, e, t, r)
              : As(t)
                ? null == (i = n.Pair)
                  ? void 0
                  : i.call(n, e, t, r)
                : Cs(t)
                  ? null == (s = n.Scalar)
                    ? void 0
                    : s.call(n, e, t, r)
                  : Ss(t)
                    ? null == (l = n.Alias)
                      ? void 0
                      : l.call(n, e, t, r)
                    : void 0
      })(e, t, n, r)
      if (Rs(a) || As(a))
        return (
          (function (e, t, n) {
            const r = t[t.length - 1]
            if (Ds(r)) r.items[e] = n
            else if (As(r)) "key" === e ? (r.key = n) : (r.value = n)
            else {
              if (!Es(r)) {
                const e = Ss(r) ? "alias" : "scalar"
                throw new Error(`Cannot replace node with ${e} parent`)
              }
              r.contents = n
            }
          })(e, r, a),
          Qs(e, a, n, r)
        )
      if ("symbol" != typeof a)
        if (Ds(t)) {
          r = Object.freeze(r.concat(t))
          for (let e = 0; e < t.items.length; ++e) {
            const a = Qs(e, t.items[e], n, r)
            if ("number" == typeof a) e = a - 1
            else {
              if (a === $s) return $s
              a === Ms && (t.items.splice(e, 1), (e -= 1))
            }
          }
        } else if (As(t)) {
          r = Object.freeze(r.concat(t))
          const e = Qs("key", t.key, n, r)
          if (e === $s) return $s
          e === Ms && (t.key = null)
          const a = Qs("value", t.value, n, r)
          if (a === $s) return $s
          a === Ms && (t.value = null)
        }
      return a
    }
    ;(Ls.BREAK = $s), (Ls.SKIP = Is), (Ls.REMOVE = Ms)
    const Bs = { "!": "%21", ",": "%2C", "[": "%5B", "]": "%5D", "{": "%7B", "}": "%7D" }
    class js {
      constructor(e, t) {
        ;(this.docStart = null),
          (this.docEnd = !1),
          (this.yaml = Object.assign({}, js.defaultYaml, e)),
          (this.tags = Object.assign({}, js.defaultTags, t))
      }
      clone() {
        const e = new js(this.yaml, this.tags)
        return (e.docStart = this.docStart), e
      }
      atDocument() {
        const e = new js(this.yaml, this.tags)
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = !0
            break
          case "1.2":
            ;(this.atNextDocument = !1),
              (this.yaml = { explicit: js.defaultYaml.explicit, version: "1.2" }),
              (this.tags = Object.assign({}, js.defaultTags))
        }
        return e
      }
      add(e, t) {
        this.atNextDocument &&
          ((this.yaml = { explicit: js.defaultYaml.explicit, version: "1.1" }),
          (this.tags = Object.assign({}, js.defaultTags)),
          (this.atNextDocument = !1))
        const n = e.trim().split(/[ \t]+/),
          r = n.shift()
        switch (r) {
          case "%TAG": {
            if (2 !== n.length && (t(0, "%TAG directive should contain exactly two parts"), n.length < 2)) return !1
            const [e, r] = n
            return (this.tags[e] = r), !0
          }
          case "%YAML": {
            if (((this.yaml.explicit = !0), 1 !== n.length))
              return t(0, "%YAML directive should contain exactly one part"), !1
            const [e] = n
            return "1.1" === e || "1.2" === e
              ? ((this.yaml.version = e), !0)
              : (t(6, `Unsupported YAML version ${e}`, /^\d+\.\d+$/.test(e)), !1)
          }
          default:
            return t(0, `Unknown directive ${r}`, !0), !1
        }
      }
      tagName(e, t) {
        if ("!" === e) return "!"
        if ("!" !== e[0]) return t(`Not a valid tag: ${e}`), null
        if ("<" === e[1]) {
          const n = e.slice(2, -1)
          return "!" === n || "!!" === n
            ? (t(`Verbatim tags aren't resolved, so ${e} is invalid.`), null)
            : (">" !== e[e.length - 1] && t("Verbatim tags must end with a >"), n)
        }
        const [, n, r] = e.match(/^(.*!)([^!]*)$/s)
        r || t(`The ${e} tag has no suffix`)
        const a = this.tags[n]
        if (a)
          try {
            return a + decodeURIComponent(r)
          } catch (e) {
            return t(String(e)), null
          }
        return "!" === n ? e : (t(`Could not resolve tag: ${e}`), null)
      }
      tagString(e) {
        for (const [t, n] of Object.entries(this.tags))
          if (e.startsWith(n)) return t + e.substring(n.length).replace(/[!,[\]{}]/g, (e) => Bs[e])
        return "!" === e[0] ? e : `!<${e}>`
      }
      toString(e) {
        const t = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [],
          n = Object.entries(this.tags)
        let r
        if (e && n.length > 0 && Rs(e.contents)) {
          const t = {}
          Ls(e.contents, (e, n) => {
            Rs(n) && n.tag && (t[n.tag] = !0)
          }),
            (r = Object.keys(t))
        } else r = []
        for (const [a, o] of n)
          ("!!" === a && "tag:yaml.org,2002:" === o) ||
            (e && !r.some((e) => e.startsWith(o))) ||
            t.push(`%TAG ${a} ${o}`)
        return t.join("\n")
      }
    }
    function Us(e) {
      if (/[\x00-\x19\s,[\]{}]/.test(e)) {
        const t = JSON.stringify(e)
        throw new Error(`Anchor must not contain whitespace or control characters: ${t}`)
      }
      return !0
    }
    function Fs(e) {
      const t = new Set()
      return (
        Ls(e, {
          Value(e, n) {
            n.anchor && t.add(n.anchor)
          },
        }),
        t
      )
    }
    function zs(e, t) {
      for (let n = 1; ; ++n) {
        const r = `${e}${n}`
        if (!t.has(r)) return r
      }
    }
    function qs(e, t, n, r) {
      if (r && "object" == typeof r)
        if (Array.isArray(r))
          for (let t = 0, n = r.length; t < n; ++t) {
            const n = r[t],
              a = qs(e, r, String(t), n)
            void 0 === a ? delete r[t] : a !== n && (r[t] = a)
          }
        else if (r instanceof Map)
          for (const t of Array.from(r.keys())) {
            const n = r.get(t),
              a = qs(e, r, t, n)
            void 0 === a ? r.delete(t) : a !== n && r.set(t, a)
          }
        else if (r instanceof Set)
          for (const t of Array.from(r)) {
            const n = qs(e, r, t, t)
            void 0 === n ? r.delete(t) : n !== t && (r.delete(t), r.add(n))
          }
        else
          for (const [t, n] of Object.entries(r)) {
            const a = qs(e, r, t, n)
            void 0 === a ? delete r[t] : a !== n && (r[t] = a)
          }
      return e.call(t, n, r)
    }
    function Zs(e, t, n) {
      if (Array.isArray(e)) return e.map((e, t) => Zs(e, String(t), n))
      if (e && "function" == typeof e.toJSON) {
        if (!n || !Ns(e)) return e.toJSON(t, n)
        const r = { aliasCount: 0, count: 1, res: void 0 }
        n.anchors.set(e, r),
          (n.onCreate = (e) => {
            ;(r.res = e), delete n.onCreate
          })
        const a = e.toJSON(t, n)
        return n.onCreate && n.onCreate(a), a
      }
      return "bigint" != typeof e || (null == n ? void 0 : n.keep) ? e : Number(e)
    }
    ;(js.defaultYaml = { explicit: !1, version: "1.2" }), (js.defaultTags = { "!!": "tag:yaml.org,2002:" })
    class Hs {
      constructor(e) {
        Object.defineProperty(this, _s, { value: e })
      }
      clone() {
        const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this))
        return this.range && (e.range = this.range.slice()), e
      }
      toJS(e, { mapAsMap: t, maxAliasCount: n, onAnchor: r, reviver: a } = {}) {
        if (!Es(e)) throw new TypeError("A document argument is required")
        const o = {
            anchors: new Map(),
            doc: e,
            keep: !0,
            mapAsMap: !0 === t,
            mapKeyWarned: !1,
            maxAliasCount: "number" == typeof n ? n : 100,
          },
          i = Zs(this, "", o)
        if ("function" == typeof r) for (const { count: e, res: t } of o.anchors.values()) r(t, e)
        return "function" == typeof a ? qs(a, { "": i }, "", i) : i
      }
    }
    let Vs = class extends Hs {
      constructor(e) {
        super(vs),
          (this.source = e),
          Object.defineProperty(this, "tag", {
            set() {
              throw new Error("Alias nodes cannot have tags")
            },
          })
      }
      resolve(e) {
        let t
        return (
          Ls(e, {
            Node: (e, n) => {
              if (n === this) return Ls.BREAK
              n.anchor === this.source && (t = n)
            },
          }),
          t
        )
      }
      toJSON(e, t) {
        if (!t) return { source: this.source }
        const { anchors: n, doc: r, maxAliasCount: a } = t,
          o = this.resolve(r)
        if (!o) {
          const e = `Unresolved alias (the anchor must be set before the alias): ${this.source}`
          throw new ReferenceError(e)
        }
        let i = n.get(o)
        if ((i || (Zs(o, null, t), (i = n.get(o))), !i || void 0 === i.res))
          throw new ReferenceError("This should not happen: Alias anchor was not resolved?")
        if (a >= 0 && ((i.count += 1), 0 === i.aliasCount && (i.aliasCount = Ws(r, o, n)), i.count * i.aliasCount > a))
          throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack")
        return i.res
      }
      toString(e, t, n) {
        const r = `*${this.source}`
        if (e) {
          if ((Us(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source))) {
            const e = `Unresolved alias (the anchor must be set before the alias): ${this.source}`
            throw new Error(e)
          }
          if (e.implicitKey) return `${r} `
        }
        return r
      }
    }
    function Ws(e, t, n) {
      if (Ss(t)) {
        const r = t.resolve(e),
          a = n && r && n.get(r)
        return a ? a.count * a.aliasCount : 0
      }
      if (Ds(t)) {
        let r = 0
        for (const a of t.items) {
          const t = Ws(e, a, n)
          t > r && (r = t)
        }
        return r
      }
      if (As(t)) {
        const r = Ws(e, t.key, n),
          a = Ws(e, t.value, n)
        return Math.max(r, a)
      }
      return 1
    }
    const Xs = (e) => !e || ("function" != typeof e && "object" != typeof e)
    class Ys extends Hs {
      constructor(e) {
        super(xs), (this.value = e)
      }
      toJSON(e, t) {
        return (null == t ? void 0 : t.keep) ? this.value : Zs(this.value, e, t)
      }
      toString() {
        return String(this.value)
      }
    }
    ;(Ys.BLOCK_FOLDED = "BLOCK_FOLDED"),
      (Ys.BLOCK_LITERAL = "BLOCK_LITERAL"),
      (Ys.PLAIN = "PLAIN"),
      (Ys.QUOTE_DOUBLE = "QUOTE_DOUBLE"),
      (Ys.QUOTE_SINGLE = "QUOTE_SINGLE")
    const Gs = "tag:yaml.org,2002:"
    function Ks(e, t, n) {
      var r, a, o
      if ((Es(e) && (e = e.contents), Rs(e))) return e
      if (As(e)) {
        const t = null == (a = (r = n.schema[Os]).createNode) ? void 0 : a.call(r, n.schema, null, n)
        return t.items.push(e), t
      }
      ;(e instanceof String ||
        e instanceof Number ||
        e instanceof Boolean ||
        ("undefined" != typeof BigInt && e instanceof BigInt)) &&
        (e = e.valueOf())
      const { aliasDuplicateObjects: i, onAnchor: s, onTagObj: l, schema: c, sourceObjects: d } = n
      let u
      if (i && e && "object" == typeof e) {
        if (((u = d.get(e)), u)) return u.anchor || (u.anchor = s(e)), new Vs(u.anchor)
        ;(u = { anchor: null, node: null }), d.set(e, u)
      }
      ;(null == t ? void 0 : t.startsWith("!!")) && (t = Gs + t.slice(2))
      let p = (function (e, t, n) {
        if (t) {
          const e = n.filter((e) => e.tag === t),
            r = e.find((e) => !e.format) ?? e[0]
          if (!r) throw new Error(`Tag ${t} not found`)
          return r
        }
        return n.find((t) => {
          var n
          return (null == (n = t.identify) ? void 0 : n.call(t, e)) && !t.format
        })
      })(e, t, c.tags)
      if (!p) {
        if ((e && "function" == typeof e.toJSON && (e = e.toJSON()), !e || "object" != typeof e)) {
          const t = new Ys(e)
          return u && (u.node = t), t
        }
        p = e instanceof Map ? c[Os] : Symbol.iterator in Object(e) ? c[ks] : c[Os]
      }
      l && (l(p), delete n.onTagObj)
      const h = (null == p ? void 0 : p.createNode)
        ? p.createNode(n.schema, e, n)
        : "function" == typeof (null == (o = null == p ? void 0 : p.nodeClass) ? void 0 : o.from)
          ? p.nodeClass.from(n.schema, e, n)
          : new Ys(e)
      return t ? (h.tag = t) : p.default || (h.tag = p.tag), u && (u.node = h), h
    }
    function Js(e, t, n) {
      let r = n
      for (let e = t.length - 1; e >= 0; --e) {
        const n = t[e]
        if ("number" == typeof n && Number.isInteger(n) && n >= 0) {
          const e = []
          ;(e[n] = r), (r = e)
        } else r = new Map([[n, r]])
      }
      return Ks(r, void 0, {
        aliasDuplicateObjects: !1,
        keepUndefined: !1,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.")
        },
        schema: e,
        sourceObjects: new Map(),
      })
    }
    const el = (e) => null == e || ("object" == typeof e && !!e[Symbol.iterator]().next().done)
    class tl extends Hs {
      constructor(e, t) {
        super(e), Object.defineProperty(this, "schema", { value: t, configurable: !0, enumerable: !1, writable: !0 })
      }
      clone(e) {
        const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this))
        return (
          e && (t.schema = e),
          (t.items = t.items.map((t) => (Rs(t) || As(t) ? t.clone(e) : t))),
          this.range && (t.range = this.range.slice()),
          t
        )
      }
      addIn(e, t) {
        if (el(e)) this.add(t)
        else {
          const [n, ...r] = e,
            a = this.get(n, !0)
          if (Ds(a)) a.addIn(r, t)
          else {
            if (void 0 !== a || !this.schema) throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`)
            this.set(n, Js(this.schema, r, t))
          }
        }
      }
      deleteIn(e) {
        const [t, ...n] = e
        if (0 === n.length) return this.delete(t)
        const r = this.get(t, !0)
        if (Ds(r)) return r.deleteIn(n)
        throw new Error(`Expected YAML collection at ${t}. Remaining path: ${n}`)
      }
      getIn(e, t) {
        const [n, ...r] = e,
          a = this.get(n, !0)
        return 0 === r.length ? (!t && Cs(a) ? a.value : a) : Ds(a) ? a.getIn(r, t) : void 0
      }
      hasAllNullValues(e) {
        return this.items.every((t) => {
          if (!As(t)) return !1
          const n = t.value
          return null == n || (e && Cs(n) && null == n.value && !n.commentBefore && !n.comment && !n.tag)
        })
      }
      hasIn(e) {
        const [t, ...n] = e
        if (0 === n.length) return this.has(t)
        const r = this.get(t, !0)
        return !!Ds(r) && r.hasIn(n)
      }
      setIn(e, t) {
        const [n, ...r] = e
        if (0 === r.length) this.set(n, t)
        else {
          const e = this.get(n, !0)
          if (Ds(e)) e.setIn(r, t)
          else {
            if (void 0 !== e || !this.schema) throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`)
            this.set(n, Js(this.schema, r, t))
          }
        }
      }
    }
    tl.maxFlowStringSingleLineLength = 60
    const nl = (e) => e.replace(/^(?!$)(?: $)?/gm, "#")
    function rl(e, t) {
      return /^\n+$/.test(e) ? e.substring(1) : t ? e.replace(/^(?! *$)/gm, t) : e
    }
    const al = (e, t, n) =>
        e.endsWith("\n") ? rl(n, t) : n.includes("\n") ? "\n" + rl(n, t) : (e.endsWith(" ") ? "" : " ") + n,
      ol = "flow",
      il = "block",
      sl = "quoted"
    function ll(
      e,
      t,
      n = "flow",
      { indentAtStart: r, lineWidth: a = 80, minContentWidth: o = 20, onFold: i, onOverflow: s } = {},
    ) {
      if (!a || a < 0) return e
      const l = Math.max(1 + o, 1 + a - t.length)
      if (e.length <= l) return e
      const c = [],
        d = {}
      let u,
        p,
        h = a - t.length
      "number" == typeof r && (r > a - Math.max(2, o) ? c.push(0) : (h = a - r))
      let f = !1,
        m = -1,
        g = -1,
        b = -1
      n === il && ((m = cl(e, m, t.length)), -1 !== m && (h = m + l))
      for (let r; (r = e[(m += 1)]); ) {
        if (n === sl && "\\" === r) {
          switch (((g = m), e[m + 1])) {
            case "x":
              m += 3
              break
            case "u":
              m += 5
              break
            case "U":
              m += 9
              break
            default:
              m += 1
          }
          b = m
        }
        if ("\n" === r) n === il && (m = cl(e, m, t.length)), (h = m + t.length + l), (u = void 0)
        else {
          if (" " === r && p && " " !== p && "\n" !== p && "\t" !== p) {
            const t = e[m + 1]
            t && " " !== t && "\n" !== t && "\t" !== t && (u = m)
          }
          if (m >= h)
            if (u) c.push(u), (h = u + l), (u = void 0)
            else if (n === sl) {
              for (; " " === p || "\t" === p; ) (p = r), (r = e[(m += 1)]), (f = !0)
              const t = m > b + 1 ? m - 2 : g - 1
              if (d[t]) return e
              c.push(t), (d[t] = !0), (h = t + l), (u = void 0)
            } else f = !0
        }
        p = r
      }
      if ((f && s && s(), 0 === c.length)) return e
      i && i()
      let v = e.slice(0, c[0])
      for (let r = 0; r < c.length; ++r) {
        const a = c[r],
          o = c[r + 1] || e.length
        0 === a
          ? (v = `\n${t}${e.slice(0, o)}`)
          : (n === sl && d[a] && (v += `${e[a]}\\`), (v += `\n${t}${e.slice(a + 1, o)}`))
      }
      return v
    }
    function cl(e, t, n) {
      let r = t,
        a = t + 1,
        o = e[a]
      for (; " " === o || "\t" === o; )
        if (t < a + n) o = e[++t]
        else {
          do {
            o = e[++t]
          } while (o && "\n" !== o)
          ;(r = t), (a = t + 1), (o = e[a])
        }
      return r
    }
    const dl = (e, t) => ({
        indentAtStart: t ? e.indent.length : e.indentAtStart,
        lineWidth: e.options.lineWidth,
        minContentWidth: e.options.minContentWidth,
      }),
      ul = (e) => /^(%|---|\.\.\.)/m.test(e)
    function pl(e, t) {
      const n = JSON.stringify(e)
      if (t.options.doubleQuotedAsJSON) return n
      const { implicitKey: r } = t,
        a = t.options.doubleQuotedMinMultiLineLength,
        o = t.indent || (ul(e) ? "  " : "")
      let i = "",
        s = 0
      for (let e = 0, t = n[e]; t; t = n[++e])
        if (
          (" " === t &&
            "\\" === n[e + 1] &&
            "n" === n[e + 2] &&
            ((i += n.slice(s, e) + "\\ "), (e += 1), (s = e), (t = "\\")),
          "\\" === t)
        )
          switch (n[e + 1]) {
            case "u":
              {
                i += n.slice(s, e)
                const t = n.substr(e + 2, 4)
                switch (t) {
                  case "0000":
                    i += "\\0"
                    break
                  case "0007":
                    i += "\\a"
                    break
                  case "000b":
                    i += "\\v"
                    break
                  case "001b":
                    i += "\\e"
                    break
                  case "0085":
                    i += "\\N"
                    break
                  case "00a0":
                    i += "\\_"
                    break
                  case "2028":
                    i += "\\L"
                    break
                  case "2029":
                    i += "\\P"
                    break
                  default:
                    "00" === t.substr(0, 2) ? (i += "\\x" + t.substr(2)) : (i += n.substr(e, 6))
                }
                ;(e += 5), (s = e + 1)
              }
              break
            case "n":
              if (r || '"' === n[e + 2] || n.length < a) e += 1
              else {
                for (i += n.slice(s, e) + "\n\n"; "\\" === n[e + 2] && "n" === n[e + 3] && '"' !== n[e + 4]; )
                  (i += "\n"), (e += 2)
                ;(i += o), " " === n[e + 2] && (i += "\\"), (e += 1), (s = e + 1)
              }
              break
            default:
              e += 1
          }
      return (i = s ? i + n.slice(s) : n), r ? i : ll(i, o, sl, dl(t, !1))
    }
    function hl(e, t) {
      if (!1 === t.options.singleQuote || (t.implicitKey && e.includes("\n")) || /[ \t]\n|\n[ \t]/.test(e))
        return pl(e, t)
      const n = t.indent || (ul(e) ? "  " : ""),
        r = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&\n${n}`) + "'"
      return t.implicitKey ? r : ll(r, n, ol, dl(t, !1))
    }
    function fl(e, t) {
      const { singleQuote: n } = t.options
      let r
      if (!1 === n) r = pl
      else {
        const t = e.includes('"'),
          a = e.includes("'")
        r = t && !a ? hl : a && !t ? pl : n ? hl : pl
      }
      return r(e, t)
    }
    let ml
    try {
      ml = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g")
    } catch {
      ml = /\n+(?!\n|$)/g
    }
    function gl({ comment: e, type: t, value: n }, r, a, o) {
      const { blockQuote: i, commentString: s, lineWidth: l } = r.options
      if (!i || /\n[\t ]+$/.test(n) || /^\s*$/.test(n)) return fl(n, r)
      const c = r.indent || (r.forceBlockIndent || ul(n) ? "  " : ""),
        d =
          "literal" === i ||
          ("folded" !== i &&
            t !== Ys.BLOCK_FOLDED &&
            (t === Ys.BLOCK_LITERAL ||
              !(function (e, t, n) {
                if (!t || t < 0) return !1
                const r = t - n,
                  a = e.length
                if (a <= r) return !1
                for (let t = 0, n = 0; t < a; ++t)
                  if ("\n" === e[t]) {
                    if (t - n > r) return !0
                    if (((n = t + 1), a - n <= r)) return !1
                  }
                return !0
              })(n, l, c.length)))
      if (!n) return d ? "|\n" : ">\n"
      let u, p
      for (p = n.length; p > 0; --p) {
        const e = n[p - 1]
        if ("\n" !== e && "\t" !== e && " " !== e) break
      }
      let h = n.substring(p)
      const f = h.indexOf("\n")
      ;-1 === f ? (u = "-") : n === h || f !== h.length - 1 ? ((u = "+"), o && o()) : (u = ""),
        h &&
          ((n = n.slice(0, -h.length)), "\n" === h[h.length - 1] && (h = h.slice(0, -1)), (h = h.replace(ml, `$&${c}`)))
      let m,
        g = !1,
        b = -1
      for (m = 0; m < n.length; ++m) {
        const e = n[m]
        if (" " === e) g = !0
        else {
          if ("\n" !== e) break
          b = m
        }
      }
      let v = n.substring(0, b < m ? b + 1 : m)
      v && ((n = n.substring(v.length)), (v = v.replace(/\n+/g, `$&${c}`)))
      let y = (d ? "|" : ">") + (g ? (c ? "2" : "1") : "") + u
      return (
        e && ((y += " " + s(e.replace(/ ?[\r\n]+/g, " "))), a && a()),
        d
          ? `${y}\n${c}${v}${(n = n.replace(/\n+/g, `$&${c}`))}${h}`
          : `${y}\n${c}${ll(
              `${v}${(n = n
                .replace(/\n+/g, "\n$&")
                .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2")
                .replace(/\n+/g, `$&${c}`))}${h}`,
              c,
              il,
              dl(r, !0),
            )}`
      )
    }
    function bl(e, t, n, r) {
      const { implicitKey: a, inFlow: o } = t,
        i = "string" == typeof e.value ? e : Object.assign({}, e, { value: String(e.value) })
      let { type: s } = e
      s !== Ys.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(i.value) && (s = Ys.QUOTE_DOUBLE)
      const l = (e) => {
        switch (e) {
          case Ys.BLOCK_FOLDED:
          case Ys.BLOCK_LITERAL:
            return a || o ? fl(i.value, t) : gl(i, t, n, r)
          case Ys.QUOTE_DOUBLE:
            return pl(i.value, t)
          case Ys.QUOTE_SINGLE:
            return hl(i.value, t)
          case Ys.PLAIN:
            return (function (e, t, n, r) {
              const { type: a, value: o } = e,
                { actualString: i, implicitKey: s, indent: l, indentStep: c, inFlow: d } = t
              if ((s && o.includes("\n")) || (d && /[[\]{},]/.test(o))) return fl(o, t)
              if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
                return s || d || !o.includes("\n") ? fl(o, t) : gl(e, t, n, r)
              if (!s && !d && a !== Ys.PLAIN && o.includes("\n")) return gl(e, t, n, r)
              if (ul(o)) {
                if ("" === l) return (t.forceBlockIndent = !0), gl(e, t, n, r)
                if (s && l === c) return fl(o, t)
              }
              const u = o.replace(/\n+/g, `$&\n${l}`)
              if (i) {
                const e = (e) => {
                    var t
                    return e.default && "tag:yaml.org,2002:str" !== e.tag && (null == (t = e.test) ? void 0 : t.test(u))
                  },
                  { compat: n, tags: r } = t.doc.schema
                if (r.some(e) || (null == n ? void 0 : n.some(e))) return fl(o, t)
              }
              return s ? u : ll(u, l, ol, dl(t, !1))
            })(i, t, n, r)
          default:
            return null
        }
      }
      let c = l(s)
      if (null === c) {
        const { defaultKeyType: e, defaultStringType: n } = t.options,
          r = (a && e) || n
        if (((c = l(r)), null === c)) throw new Error(`Unsupported default string type ${r}`)
      }
      return c
    }
    function vl(e, t) {
      const n = Object.assign(
        {
          blockQuote: !0,
          commentString: nl,
          defaultKeyType: null,
          defaultStringType: "PLAIN",
          directives: null,
          doubleQuotedAsJSON: !1,
          doubleQuotedMinMultiLineLength: 40,
          falseStr: "false",
          flowCollectionPadding: !0,
          indentSeq: !0,
          lineWidth: 80,
          minContentWidth: 20,
          nullStr: "null",
          simpleKeys: !1,
          singleQuote: null,
          trueStr: "true",
          verifyAliasOrder: !0,
        },
        e.schema.toStringOptions,
        t,
      )
      let r
      switch (n.collectionStyle) {
        case "block":
          r = !1
          break
        case "flow":
          r = !0
          break
        default:
          r = null
      }
      return {
        anchors: new Set(),
        doc: e,
        flowCollectionPadding: n.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: "number" == typeof n.indent ? " ".repeat(n.indent) : "  ",
        inFlow: r,
        options: n,
      }
    }
    function yl(e, t, n, r) {
      var a
      if (As(e)) return e.toString(t, n, r)
      if (Ss(e)) {
        if (t.doc.directives) return e.toString(t)
        if (null == (a = t.resolvedAliases) ? void 0 : a.has(e))
          throw new TypeError("Cannot stringify circular structure without alias nodes")
        t.resolvedAliases ? t.resolvedAliases.add(e) : (t.resolvedAliases = new Set([e])), (e = e.resolve(t.doc))
      }
      let o
      const i = Rs(e) ? e : t.doc.createNode(e, { onTagObj: (e) => (o = e) })
      o ||
        (o = (function (e, t) {
          var n
          if (t.tag) {
            const n = e.filter((e) => e.tag === t.tag)
            if (n.length > 0) return n.find((e) => e.format === t.format) ?? n[0]
          }
          let r, a
          if (Cs(t)) {
            a = t.value
            const n = e.filter((e) => {
              var t
              return null == (t = e.identify) ? void 0 : t.call(e, a)
            })
            r = n.find((e) => e.format === t.format) ?? n.find((e) => !e.format)
          } else (a = t), (r = e.find((e) => e.nodeClass && a instanceof e.nodeClass))
          if (!r) {
            const e = (null == (n = null == a ? void 0 : a.constructor) ? void 0 : n.name) ?? typeof a
            throw new Error(`Tag not resolved for ${e} value`)
          }
          return r
        })(t.doc.schema.tags, i))
      const s = (function (e, t, { anchors: n, doc: r }) {
        if (!r.directives) return ""
        const a = [],
          o = (Cs(e) || Ds(e)) && e.anchor
        o && Us(o) && (n.add(o), a.push(`&${o}`))
        const i = e.tag ? e.tag : t.default ? null : t.tag
        return i && a.push(r.directives.tagString(i)), a.join(" ")
      })(i, o, t)
      s.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + s.length + 1)
      const l =
        "function" == typeof o.stringify ? o.stringify(i, t, n, r) : Cs(i) ? bl(i, t, n, r) : i.toString(t, n, r)
      return s ? (Cs(i) || "{" === l[0] || "[" === l[0] ? `${s} ${l}` : `${s}\n${t.indent}${l}`) : l
    }
    function Ol(e, t) {
      ;("debug" !== e && "warn" !== e) ||
        ("undefined" != typeof process && process.emitWarning ? process.emitWarning(t) : console.warn(t))
    }
    function wl(e, t, { key: n, value: r }) {
      if ((null == e ? void 0 : e.doc.schema.merge) && xl(n))
        if (((r = Ss(r) ? r.resolve(e.doc) : r), Ps(r))) for (const n of r.items) kl(e, t, n)
        else if (Array.isArray(r)) for (const n of r) kl(e, t, n)
        else kl(e, t, r)
      else {
        const a = Zs(n, "", e)
        if (t instanceof Map) t.set(a, Zs(r, a, e))
        else if (t instanceof Set) t.add(a)
        else {
          const o = (function (e, t, n) {
              if (null === t) return ""
              if ("object" != typeof t) return String(t)
              if (Rs(e) && (null == n ? void 0 : n.doc)) {
                const t = vl(n.doc, {})
                t.anchors = new Set()
                for (const e of n.anchors.keys()) t.anchors.add(e.anchor)
                ;(t.inFlow = !0), (t.inStringifyKey = !0)
                const r = e.toString(t)
                if (!n.mapKeyWarned) {
                  let e = JSON.stringify(r)
                  e.length > 40 && (e = e.substring(0, 36) + '..."'),
                    Ol(
                      n.doc.options.logLevel,
                      `Keys with collection values will be stringified due to JS Object restrictions: ${e}. Set mapAsMap: true to use object keys.`,
                    ),
                    (n.mapKeyWarned = !0)
                }
                return r
              }
              return JSON.stringify(t)
            })(n, a, e),
            i = Zs(r, o, e)
          o in t
            ? Object.defineProperty(t, o, { value: i, writable: !0, enumerable: !0, configurable: !0 })
            : (t[o] = i)
        }
      }
      return t
    }
    const xl = (e) => "<<" === e || (Cs(e) && "<<" === e.value && (!e.type || e.type === Ys.PLAIN))
    function kl(e, t, n) {
      const r = e && Ss(n) ? n.resolve(e.doc) : n
      if (!Ts(r)) throw new Error("Merge sources must be maps or map aliases")
      const a = r.toJSON(null, e, Map)
      for (const [e, n] of a)
        t instanceof Map
          ? t.has(e) || t.set(e, n)
          : t instanceof Set
            ? t.add(e)
            : Object.prototype.hasOwnProperty.call(t, e) ||
              Object.defineProperty(t, e, { value: n, writable: !0, enumerable: !0, configurable: !0 })
      return t
    }
    function _l(e, t, n) {
      const r = Ks(e, void 0, n),
        a = Ks(t, void 0, n)
      return new Sl(r, a)
    }
    class Sl {
      constructor(e, t = null) {
        Object.defineProperty(this, _s, { value: ws }), (this.key = e), (this.value = t)
      }
      clone(e) {
        let { key: t, value: n } = this
        return Rs(t) && (t = t.clone(e)), Rs(n) && (n = n.clone(e)), new Sl(t, n)
      }
      toJSON(e, t) {
        return wl(t, (null == t ? void 0 : t.mapAsMap) ? new Map() : {}, this)
      }
      toString(e, t, n) {
        return (null == e ? void 0 : e.doc)
          ? (function ({ key: e, value: t }, n, r, a) {
              const {
                allNullValues: o,
                doc: i,
                indent: s,
                indentStep: l,
                options: { commentString: c, indentSeq: d, simpleKeys: u },
              } = n
              let p = (Rs(e) && e.comment) || null
              if (u) {
                if (p) throw new Error("With simple keys, key nodes cannot have comments")
                if (Ds(e) || (!Rs(e) && "object" == typeof e))
                  throw new Error("With simple keys, collection cannot be used as a key value")
              }
              let h =
                !u &&
                (!e ||
                  (p && null == t && !n.inFlow) ||
                  Ds(e) ||
                  (Cs(e) ? e.type === Ys.BLOCK_FOLDED || e.type === Ys.BLOCK_LITERAL : "object" == typeof e))
              n = Object.assign({}, n, { allNullValues: !1, implicitKey: !h && (u || !o), indent: s + l })
              let f,
                m,
                g,
                b = !1,
                v = !1,
                y = yl(
                  e,
                  n,
                  () => (b = !0),
                  () => (v = !0),
                )
              if (!h && !n.inFlow && y.length > 1024) {
                if (u) throw new Error("With simple keys, single line scalar must not span more than 1024 characters")
                h = !0
              }
              if (n.inFlow) {
                if (o || null == t) return b && r && r(), "" === y ? "?" : h ? `? ${y}` : y
              } else if ((o && !u) || (null == t && h))
                return (y = `? ${y}`), p && !b ? (y += al(y, n.indent, c(p))) : v && a && a(), y
              b && (p = null),
                h
                  ? (p && (y += al(y, n.indent, c(p))), (y = `? ${y}\n${s}:`))
                  : ((y = `${y}:`), p && (y += al(y, n.indent, c(p)))),
                Rs(t)
                  ? ((f = !!t.spaceBefore), (m = t.commentBefore), (g = t.comment))
                  : ((f = !1), (m = null), (g = null), t && "object" == typeof t && (t = i.createNode(t))),
                (n.implicitKey = !1),
                h || p || !Cs(t) || (n.indentAtStart = y.length + 1),
                (v = !1),
                d ||
                  !(l.length >= 2) ||
                  n.inFlow ||
                  h ||
                  !Ps(t) ||
                  t.flow ||
                  t.tag ||
                  t.anchor ||
                  (n.indent = n.indent.substring(2))
              let O = !1
              const w = yl(
                t,
                n,
                () => (O = !0),
                () => (v = !0),
              )
              let x = " "
              if (p || f || m)
                (x = f ? "\n" : ""),
                  m && (x += `\n${rl(c(m), n.indent)}`),
                  "" !== w || n.inFlow ? (x += `\n${n.indent}`) : "\n" === x && (x = "\n\n")
              else if (!h && Ds(t)) {
                const e = w[0],
                  r = w.indexOf("\n"),
                  a = -1 !== r,
                  o = n.inFlow ?? t.flow ?? 0 === t.items.length
                if (a || !o) {
                  let t = !1
                  if (a && ("&" === e || "!" === e)) {
                    let n = w.indexOf(" ")
                    "&" === e && -1 !== n && n < r && "!" === w[n + 1] && (n = w.indexOf(" ", n + 1)),
                      (-1 === n || r < n) && (t = !0)
                  }
                  t || (x = `\n${n.indent}`)
                }
              } else ("" !== w && "\n" !== w[0]) || (x = "")
              return (y += x + w), n.inFlow ? O && r && r() : g && !O ? (y += al(y, n.indent, c(g))) : v && a && a(), y
            })(this, e, t, n)
          : JSON.stringify(this)
      }
    }
    function El(e, t, n) {
      return ((t.inFlow ?? e.flow) ? Al : Tl)(e, t, n)
    }
    function Tl(
      { comment: e, items: t },
      n,
      { blockItemPrefix: r, flowChars: a, itemIndent: o, onChompKeep: i, onComment: s },
    ) {
      const {
          indent: l,
          options: { commentString: c },
        } = n,
        d = Object.assign({}, n, { indent: o, type: null })
      let u = !1
      const p = []
      for (let e = 0; e < t.length; ++e) {
        const a = t[e]
        let i = null
        if (Rs(a)) !u && a.spaceBefore && p.push(""), Cl(n, p, a.commentBefore, u), a.comment && (i = a.comment)
        else if (As(a)) {
          const e = Rs(a.key) ? a.key : null
          e && (!u && e.spaceBefore && p.push(""), Cl(n, p, e.commentBefore, u))
        }
        u = !1
        let s = yl(
          a,
          d,
          () => (i = null),
          () => (u = !0),
        )
        i && (s += al(s, o, c(i))), u && i && (u = !1), p.push(r + s)
      }
      let h
      if (0 === p.length) h = a.start + a.end
      else {
        h = p[0]
        for (let e = 1; e < p.length; ++e) {
          const t = p[e]
          h += t ? `\n${l}${t}` : "\n"
        }
      }
      return e ? ((h += "\n" + rl(c(e), l)), s && s()) : u && i && i(), h
    }
    function Al({ items: e }, t, { flowChars: n, itemIndent: r }) {
      const {
        indent: a,
        indentStep: o,
        flowCollectionPadding: i,
        options: { commentString: s },
      } = t
      r += o
      const l = Object.assign({}, t, { indent: r, inFlow: !0, type: null })
      let c = !1,
        d = 0
      const u = []
      for (let n = 0; n < e.length; ++n) {
        const a = e[n]
        let o = null
        if (Rs(a)) a.spaceBefore && u.push(""), Cl(t, u, a.commentBefore, !1), a.comment && (o = a.comment)
        else if (As(a)) {
          const e = Rs(a.key) ? a.key : null
          e && (e.spaceBefore && u.push(""), Cl(t, u, e.commentBefore, !1), e.comment && (c = !0))
          const n = Rs(a.value) ? a.value : null
          n
            ? (n.comment && (o = n.comment), n.commentBefore && (c = !0))
            : null == a.value && (null == e ? void 0 : e.comment) && (o = e.comment)
        }
        o && (c = !0)
        let i = yl(a, l, () => (o = null))
        n < e.length - 1 && (i += ","),
          o && (i += al(i, r, s(o))),
          !c && (u.length > d || i.includes("\n")) && (c = !0),
          u.push(i),
          (d = u.length)
      }
      const { start: p, end: h } = n
      if (0 === u.length) return p + h
      if (!c) {
        const e = u.reduce((e, t) => e + t.length + 2, 2)
        c = t.options.lineWidth > 0 && e > t.options.lineWidth
      }
      if (c) {
        let e = p
        for (const t of u) e += t ? `\n${o}${a}${t}` : "\n"
        return `${e}\n${a}${h}`
      }
      return `${p}${i}${u.join(" ")}${i}${h}`
    }
    function Cl({ indent: e, options: { commentString: t } }, n, r, a) {
      if ((r && a && (r = r.replace(/^\n+/, "")), r)) {
        const a = rl(t(r), e)
        n.push(a.trimStart())
      }
    }
    function Pl(e, t) {
      const n = Cs(t) ? t.value : t
      for (const r of e)
        if (As(r)) {
          if (r.key === t || r.key === n) return r
          if (Cs(r.key) && r.key.value === n) return r
        }
    }
    class Dl extends tl {
      static get tagName() {
        return "tag:yaml.org,2002:map"
      }
      constructor(e) {
        super(Os, e), (this.items = [])
      }
      static from(e, t, n) {
        const { keepUndefined: r, replacer: a } = n,
          o = new this(e),
          i = (e, i) => {
            if ("function" == typeof a) i = a.call(t, e, i)
            else if (Array.isArray(a) && !a.includes(e)) return
            ;(void 0 !== i || r) && o.items.push(_l(e, i, n))
          }
        if (t instanceof Map) for (const [e, n] of t) i(e, n)
        else if (t && "object" == typeof t) for (const e of Object.keys(t)) i(e, t[e])
        return "function" == typeof e.sortMapEntries && o.items.sort(e.sortMapEntries), o
      }
      add(e, t) {
        var n
        let r
        r = As(e)
          ? e
          : e && "object" == typeof e && "key" in e
            ? new Sl(e.key, e.value)
            : new Sl(e, null == e ? void 0 : e.value)
        const a = Pl(this.items, r.key),
          o = null == (n = this.schema) ? void 0 : n.sortMapEntries
        if (a) {
          if (!t) throw new Error(`Key ${r.key} already set`)
          Cs(a.value) && Xs(r.value) ? (a.value.value = r.value) : (a.value = r.value)
        } else if (o) {
          const e = this.items.findIndex((e) => o(r, e) < 0)
          ;-1 === e ? this.items.push(r) : this.items.splice(e, 0, r)
        } else this.items.push(r)
      }
      delete(e) {
        const t = Pl(this.items, e)
        return !!t && this.items.splice(this.items.indexOf(t), 1).length > 0
      }
      get(e, t) {
        const n = Pl(this.items, e),
          r = null == n ? void 0 : n.value
        return (!t && Cs(r) ? r.value : r) ?? void 0
      }
      has(e) {
        return !!Pl(this.items, e)
      }
      set(e, t) {
        this.add(new Sl(e, t), !0)
      }
      toJSON(e, t, n) {
        const r = n ? new n() : (null == t ? void 0 : t.mapAsMap) ? new Map() : {}
        ;(null == t ? void 0 : t.onCreate) && t.onCreate(r)
        for (const e of this.items) wl(t, r, e)
        return r
      }
      toString(e, t, n) {
        if (!e) return JSON.stringify(this)
        for (const e of this.items)
          if (!As(e)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(e)} instead`)
        return (
          !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })),
          El(this, e, {
            blockItemPrefix: "",
            flowChars: { start: "{", end: "}" },
            itemIndent: e.indent || "",
            onChompKeep: n,
            onComment: t,
          })
        )
      }
    }
    const Rl = {
      collection: "map",
      default: !0,
      nodeClass: Dl,
      tag: "tag:yaml.org,2002:map",
      resolve: (e, t) => (Ts(e) || t("Expected a mapping for this tag"), e),
      createNode: (e, t, n) => Dl.from(e, t, n),
    }
    class Nl extends tl {
      static get tagName() {
        return "tag:yaml.org,2002:seq"
      }
      constructor(e) {
        super(ks, e), (this.items = [])
      }
      add(e) {
        this.items.push(e)
      }
      delete(e) {
        const t = $l(e)
        return "number" == typeof t && this.items.splice(t, 1).length > 0
      }
      get(e, t) {
        const n = $l(e)
        if ("number" != typeof n) return
        const r = this.items[n]
        return !t && Cs(r) ? r.value : r
      }
      has(e) {
        const t = $l(e)
        return "number" == typeof t && t < this.items.length
      }
      set(e, t) {
        const n = $l(e)
        if ("number" != typeof n) throw new Error(`Expected a valid index, not ${e}.`)
        const r = this.items[n]
        Cs(r) && Xs(t) ? (r.value = t) : (this.items[n] = t)
      }
      toJSON(e, t) {
        const n = []
        ;(null == t ? void 0 : t.onCreate) && t.onCreate(n)
        let r = 0
        for (const e of this.items) n.push(Zs(e, String(r++), t))
        return n
      }
      toString(e, t, n) {
        return e
          ? El(this, e, {
              blockItemPrefix: "- ",
              flowChars: { start: "[", end: "]" },
              itemIndent: (e.indent || "") + "  ",
              onChompKeep: n,
              onComment: t,
            })
          : JSON.stringify(this)
      }
      static from(e, t, n) {
        const { replacer: r } = n,
          a = new this(e)
        if (t && Symbol.iterator in Object(t)) {
          let e = 0
          for (let o of t) {
            if ("function" == typeof r) {
              const n = t instanceof Set ? o : String(e++)
              o = r.call(t, n, o)
            }
            a.items.push(Ks(o, void 0, n))
          }
        }
        return a
      }
    }
    function $l(e) {
      let t = Cs(e) ? e.value : e
      return (
        t && "string" == typeof t && (t = Number(t)), "number" == typeof t && Number.isInteger(t) && t >= 0 ? t : null
      )
    }
    const Il = {
        collection: "seq",
        default: !0,
        nodeClass: Nl,
        tag: "tag:yaml.org,2002:seq",
        resolve: (e, t) => (Ps(e) || t("Expected a sequence for this tag"), e),
        createNode: (e, t, n) => Nl.from(e, t, n),
      },
      Ml = {
        identify: (e) => "string" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: (e) => e,
        stringify: (e, t, n, r) => bl(e, (t = Object.assign({ actualString: !0 }, t)), n, r),
      },
      Ll = {
        identify: (e) => null == e,
        createNode: () => new Ys(null),
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: () => new Ys(null),
        stringify: ({ source: e }, t) => ("string" == typeof e && Ll.test.test(e) ? e : t.options.nullStr),
      },
      Ql = {
        identify: (e) => "boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: (e) => new Ys("t" === e[0] || "T" === e[0]),
        stringify: ({ source: e, value: t }, n) =>
          e && Ql.test.test(e) && t === ("t" === e[0] || "T" === e[0]) ? e : t ? n.options.trueStr : n.options.falseStr,
      }
    function Bl({ format: e, minFractionDigits: t, tag: n, value: r }) {
      if ("bigint" == typeof r) return String(r)
      const a = "number" == typeof r ? r : Number(r)
      if (!isFinite(a)) return isNaN(a) ? ".nan" : a < 0 ? "-.inf" : ".inf"
      let o = JSON.stringify(r)
      if (!e && t && (!n || "tag:yaml.org,2002:float" === n) && /^\d/.test(o)) {
        let e = o.indexOf(".")
        e < 0 && ((e = o.length), (o += "."))
        let n = t - (o.length - e - 1)
        for (; n-- > 0; ) o += "0"
      }
      return o
    }
    const jl = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: (e) =>
          "nan" === e.slice(-3).toLowerCase()
            ? NaN
            : "-" === e[0]
              ? Number.NEGATIVE_INFINITY
              : Number.POSITIVE_INFINITY,
        stringify: Bl,
      },
      Ul = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: (e) => parseFloat(e),
        stringify(e) {
          const t = Number(e.value)
          return isFinite(t) ? t.toExponential() : Bl(e)
        },
      },
      Fl = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
        resolve(e) {
          const t = new Ys(parseFloat(e)),
            n = e.indexOf(".")
          return -1 !== n && "0" === e[e.length - 1] && (t.minFractionDigits = e.length - n - 1), t
        },
        stringify: Bl,
      },
      zl = (e) => "bigint" == typeof e || Number.isInteger(e),
      ql = (e, t, n, { intAsBigInt: r }) => (r ? BigInt(e) : parseInt(e.substring(t), n))
    function Zl(e, t, n) {
      const { value: r } = e
      return zl(r) && r >= 0 ? n + r.toString(t) : Bl(e)
    }
    const Hl = {
        identify: (e) => zl(e) && e >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^0o[0-7]+$/,
        resolve: (e, t, n) => ql(e, 2, 8, n),
        stringify: (e) => Zl(e, 8, "0o"),
      },
      Vl = {
        identify: zl,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9]+$/,
        resolve: (e, t, n) => ql(e, 0, 10, n),
        stringify: Bl,
      },
      Wl = {
        identify: (e) => zl(e) && e >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^0x[0-9a-fA-F]+$/,
        resolve: (e, t, n) => ql(e, 2, 16, n),
        stringify: (e) => Zl(e, 16, "0x"),
      },
      Xl = [Rl, Il, Ml, Ll, Ql, Hl, Vl, Wl, jl, Ul, Fl]
    function Yl(e) {
      return "bigint" == typeof e || Number.isInteger(e)
    }
    const Gl = ({ value: e }) => JSON.stringify(e),
      Kl = [Rl, Il].concat(
        [
          {
            identify: (e) => "string" == typeof e,
            default: !0,
            tag: "tag:yaml.org,2002:str",
            resolve: (e) => e,
            stringify: Gl,
          },
          {
            identify: (e) => null == e,
            createNode: () => new Ys(null),
            default: !0,
            tag: "tag:yaml.org,2002:null",
            test: /^null$/,
            resolve: () => null,
            stringify: Gl,
          },
          {
            identify: (e) => "boolean" == typeof e,
            default: !0,
            tag: "tag:yaml.org,2002:bool",
            test: /^true|false$/,
            resolve: (e) => "true" === e,
            stringify: Gl,
          },
          {
            identify: Yl,
            default: !0,
            tag: "tag:yaml.org,2002:int",
            test: /^-?(?:0|[1-9][0-9]*)$/,
            resolve: (e, t, { intAsBigInt: n }) => (n ? BigInt(e) : parseInt(e, 10)),
            stringify: ({ value: e }) => (Yl(e) ? e.toString() : JSON.stringify(e)),
          },
          {
            identify: (e) => "number" == typeof e,
            default: !0,
            tag: "tag:yaml.org,2002:float",
            test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
            resolve: (e) => parseFloat(e),
            stringify: Gl,
          },
        ],
        { default: !0, tag: "", test: /^/, resolve: (e, t) => (t(`Unresolved plain scalar ${JSON.stringify(e)}`), e) },
      ),
      Jl = {
        identify: (e) => e instanceof Uint8Array,
        default: !1,
        tag: "tag:yaml.org,2002:binary",
        resolve(e, t) {
          if ("function" == typeof Buffer) return Buffer.from(e, "base64")
          if ("function" == typeof atob) {
            const t = atob(e.replace(/[\n\r]/g, "")),
              n = new Uint8Array(t.length)
            for (let e = 0; e < t.length; ++e) n[e] = t.charCodeAt(e)
            return n
          }
          return t("This environment does not support reading binary tags; either Buffer or atob is required"), e
        },
        stringify({ comment: e, type: t, value: n }, r, a, o) {
          const i = n
          let s
          if ("function" == typeof Buffer)
            s = i instanceof Buffer ? i.toString("base64") : Buffer.from(i.buffer).toString("base64")
          else {
            if ("function" != typeof btoa)
              throw new Error(
                "This environment does not support writing binary tags; either Buffer or btoa is required",
              )
            {
              let e = ""
              for (let t = 0; t < i.length; ++t) e += String.fromCharCode(i[t])
              s = btoa(e)
            }
          }
          if ((t || (t = Ys.BLOCK_LITERAL), t !== Ys.QUOTE_DOUBLE)) {
            const e = Math.max(r.options.lineWidth - r.indent.length, r.options.minContentWidth),
              n = Math.ceil(s.length / e),
              a = new Array(n)
            for (let t = 0, r = 0; t < n; ++t, r += e) a[t] = s.substr(r, e)
            s = a.join(t === Ys.BLOCK_LITERAL ? "\n" : " ")
          }
          return bl({ comment: e, type: t, value: s }, r, a, o)
        },
      }
    function ec(e, t) {
      if (Ps(e))
        for (let n = 0; n < e.items.length; ++n) {
          let r = e.items[n]
          if (!As(r)) {
            if (Ts(r)) {
              r.items.length > 1 && t("Each pair must have its own sequence indicator")
              const e = r.items[0] || new Sl(new Ys(null))
              if (
                (r.commentBefore &&
                  (e.key.commentBefore = e.key.commentBefore
                    ? `${r.commentBefore}\n${e.key.commentBefore}`
                    : r.commentBefore),
                r.comment)
              ) {
                const t = e.value ?? e.key
                t.comment = t.comment ? `${r.comment}\n${t.comment}` : r.comment
              }
              r = e
            }
            e.items[n] = As(r) ? r : new Sl(r)
          }
        }
      else t("Expected a sequence for this tag")
      return e
    }
    function tc(e, t, n) {
      const { replacer: r } = n,
        a = new Nl(e)
      a.tag = "tag:yaml.org,2002:pairs"
      let o = 0
      if (t && Symbol.iterator in Object(t))
        for (let e of t) {
          let i, s
          if (("function" == typeof r && (e = r.call(t, String(o++), e)), Array.isArray(e))) {
            if (2 !== e.length) throw new TypeError(`Expected [key, value] tuple: ${e}`)
            ;(i = e[0]), (s = e[1])
          } else if (e && e instanceof Object) {
            const t = Object.keys(e)
            if (1 !== t.length) throw new TypeError(`Expected tuple with one key, not ${t.length} keys`)
            ;(i = t[0]), (s = e[i])
          } else i = e
          a.items.push(_l(i, s, n))
        }
      return a
    }
    const nc = { collection: "seq", default: !1, tag: "tag:yaml.org,2002:pairs", resolve: ec, createNode: tc }
    class rc extends Nl {
      constructor() {
        super(),
          (this.add = Dl.prototype.add.bind(this)),
          (this.delete = Dl.prototype.delete.bind(this)),
          (this.get = Dl.prototype.get.bind(this)),
          (this.has = Dl.prototype.has.bind(this)),
          (this.set = Dl.prototype.set.bind(this)),
          (this.tag = rc.tag)
      }
      toJSON(e, t) {
        if (!t) return super.toJSON(e)
        const n = new Map()
        ;(null == t ? void 0 : t.onCreate) && t.onCreate(n)
        for (const e of this.items) {
          let r, a
          if ((As(e) ? ((r = Zs(e.key, "", t)), (a = Zs(e.value, r, t))) : (r = Zs(e, "", t)), n.has(r)))
            throw new Error("Ordered maps must not include duplicate keys")
          n.set(r, a)
        }
        return n
      }
      static from(e, t, n) {
        const r = tc(e, t, n),
          a = new this()
        return (a.items = r.items), a
      }
    }
    rc.tag = "tag:yaml.org,2002:omap"
    const ac = {
      collection: "seq",
      identify: (e) => e instanceof Map,
      nodeClass: rc,
      default: !1,
      tag: "tag:yaml.org,2002:omap",
      resolve(e, t) {
        const n = ec(e, t),
          r = []
        for (const { key: e } of n.items)
          Cs(e) &&
            (r.includes(e.value) ? t(`Ordered maps must not include duplicate keys: ${e.value}`) : r.push(e.value))
        return Object.assign(new rc(), n)
      },
      createNode: (e, t, n) => rc.from(e, t, n),
    }
    function oc({ value: e, source: t }, n) {
      return t && (e ? ic : sc).test.test(t) ? t : e ? n.options.trueStr : n.options.falseStr
    }
    const ic = {
        identify: (e) => !0 === e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: () => new Ys(!0),
        stringify: oc,
      },
      sc = {
        identify: (e) => !1 === e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
        resolve: () => new Ys(!1),
        stringify: oc,
      },
      lc = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: (e) =>
          "nan" === e.slice(-3).toLowerCase()
            ? NaN
            : "-" === e[0]
              ? Number.NEGATIVE_INFINITY
              : Number.POSITIVE_INFINITY,
        stringify: Bl,
      },
      cc = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: (e) => parseFloat(e.replace(/_/g, "")),
        stringify(e) {
          const t = Number(e.value)
          return isFinite(t) ? t.toExponential() : Bl(e)
        },
      },
      dc = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
        resolve(e) {
          const t = new Ys(parseFloat(e.replace(/_/g, ""))),
            n = e.indexOf(".")
          if (-1 !== n) {
            const r = e.substring(n + 1).replace(/_/g, "")
            "0" === r[r.length - 1] && (t.minFractionDigits = r.length)
          }
          return t
        },
        stringify: Bl,
      },
      uc = (e) => "bigint" == typeof e || Number.isInteger(e)
    function pc(e, t, n, { intAsBigInt: r }) {
      const a = e[0]
      if ((("-" !== a && "+" !== a) || (t += 1), (e = e.substring(t).replace(/_/g, "")), r)) {
        switch (n) {
          case 2:
            e = `0b${e}`
            break
          case 8:
            e = `0o${e}`
            break
          case 16:
            e = `0x${e}`
        }
        const t = BigInt(e)
        return "-" === a ? BigInt(-1) * t : t
      }
      const o = parseInt(e, n)
      return "-" === a ? -1 * o : o
    }
    function hc(e, t, n) {
      const { value: r } = e
      if (uc(r)) {
        const e = r.toString(t)
        return r < 0 ? "-" + n + e.substr(1) : n + e
      }
      return Bl(e)
    }
    const fc = {
        identify: uc,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "BIN",
        test: /^[-+]?0b[0-1_]+$/,
        resolve: (e, t, n) => pc(e, 2, 2, n),
        stringify: (e) => hc(e, 2, "0b"),
      },
      mc = {
        identify: uc,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^[-+]?0[0-7_]+$/,
        resolve: (e, t, n) => pc(e, 1, 8, n),
        stringify: (e) => hc(e, 8, "0"),
      },
      gc = {
        identify: uc,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9][0-9_]*$/,
        resolve: (e, t, n) => pc(e, 0, 10, n),
        stringify: Bl,
      },
      bc = {
        identify: uc,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^[-+]?0x[0-9a-fA-F_]+$/,
        resolve: (e, t, n) => pc(e, 2, 16, n),
        stringify: (e) => hc(e, 16, "0x"),
      }
    class vc extends Dl {
      constructor(e) {
        super(e), (this.tag = vc.tag)
      }
      add(e) {
        let t
        ;(t = As(e)
          ? e
          : e && "object" == typeof e && "key" in e && "value" in e && null === e.value
            ? new Sl(e.key, null)
            : new Sl(e, null)),
          Pl(this.items, t.key) || this.items.push(t)
      }
      get(e, t) {
        const n = Pl(this.items, e)
        return !t && As(n) ? (Cs(n.key) ? n.key.value : n.key) : n
      }
      set(e, t) {
        if ("boolean" != typeof t)
          throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof t)
        const n = Pl(this.items, e)
        n && !t ? this.items.splice(this.items.indexOf(n), 1) : !n && t && this.items.push(new Sl(e))
      }
      toJSON(e, t) {
        return super.toJSON(e, t, Set)
      }
      toString(e, t, n) {
        if (!e) return JSON.stringify(this)
        if (this.hasAllNullValues(!0)) return super.toString(Object.assign({}, e, { allNullValues: !0 }), t, n)
        throw new Error("Set items must all have null values")
      }
      static from(e, t, n) {
        const { replacer: r } = n,
          a = new this(e)
        if (t && Symbol.iterator in Object(t))
          for (let e of t) "function" == typeof r && (e = r.call(t, e, e)), a.items.push(_l(e, null, n))
        return a
      }
    }
    vc.tag = "tag:yaml.org,2002:set"
    const yc = {
      collection: "map",
      identify: (e) => e instanceof Set,
      nodeClass: vc,
      default: !1,
      tag: "tag:yaml.org,2002:set",
      createNode: (e, t, n) => vc.from(e, t, n),
      resolve(e, t) {
        if (Ts(e)) {
          if (e.hasAllNullValues(!0)) return Object.assign(new vc(), e)
          t("Set items must all have null values")
        } else t("Expected a mapping for this tag")
        return e
      },
    }
    function Oc(e, t) {
      const n = e[0],
        r = "-" === n || "+" === n ? e.substring(1) : e,
        a = (e) => (t ? BigInt(e) : Number(e)),
        o = r
          .replace(/_/g, "")
          .split(":")
          .reduce((e, t) => e * a(60) + a(t), a(0))
      return "-" === n ? a(-1) * o : o
    }
    function wc(e) {
      let { value: t } = e,
        n = (e) => e
      if ("bigint" == typeof t) n = (e) => BigInt(e)
      else if (isNaN(t) || !isFinite(t)) return Bl(e)
      let r = ""
      t < 0 && ((r = "-"), (t *= n(-1)))
      const a = n(60),
        o = [t % a]
      return (
        t < 60
          ? o.unshift(0)
          : ((t = (t - o[0]) / a), o.unshift(t % a), t >= 60 && ((t = (t - o[0]) / a), o.unshift(t))),
        r +
          o
            .map((e) => String(e).padStart(2, "0"))
            .join(":")
            .replace(/000000\d*$/, "")
      )
    }
    const xc = {
        identify: (e) => "bigint" == typeof e || Number.isInteger(e),
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
        resolve: (e, t, { intAsBigInt: n }) => Oc(e, n),
        stringify: wc,
      },
      kc = {
        identify: (e) => "number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
        resolve: (e) => Oc(e, !1),
        stringify: wc,
      },
      _c = {
        identify: (e) => e instanceof Date,
        default: !0,
        tag: "tag:yaml.org,2002:timestamp",
        test: RegExp(
          "^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$",
        ),
        resolve(e) {
          const t = e.match(_c.test)
          if (!t) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd")
          const [, n, r, a, o, i, s] = t.map(Number),
            l = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0
          let c = Date.UTC(n, r - 1, a, o || 0, i || 0, s || 0, l)
          const d = t[8]
          if (d && "Z" !== d) {
            let e = Oc(d, !1)
            Math.abs(e) < 30 && (e *= 60), (c -= 6e4 * e)
          }
          return new Date(c)
        },
        stringify: ({ value: e }) => e.toISOString().replace(/((T00:00)?:00)?\.000Z$/, ""),
      },
      Sc = [Rl, Il, Ml, Ll, ic, sc, fc, mc, gc, bc, lc, cc, dc, Jl, ac, nc, yc, xc, kc, _c],
      Ec = new Map([
        ["core", Xl],
        ["failsafe", [Rl, Il, Ml]],
        ["json", Kl],
        ["yaml11", Sc],
        ["yaml-1.1", Sc],
      ]),
      Tc = {
        binary: Jl,
        bool: Ql,
        float: Fl,
        floatExp: Ul,
        floatNaN: jl,
        floatTime: kc,
        int: Vl,
        intHex: Wl,
        intOct: Hl,
        intTime: xc,
        map: Rl,
        null: Ll,
        omap: ac,
        pairs: nc,
        seq: Il,
        set: yc,
        timestamp: _c,
      },
      Ac = {
        "tag:yaml.org,2002:binary": Jl,
        "tag:yaml.org,2002:omap": ac,
        "tag:yaml.org,2002:pairs": nc,
        "tag:yaml.org,2002:set": yc,
        "tag:yaml.org,2002:timestamp": _c,
      }
    function Cc(e, t) {
      let n = Ec.get(t)
      if (!n) {
        if (!Array.isArray(e)) {
          const e = Array.from(Ec.keys())
            .filter((e) => "yaml11" !== e)
            .map((e) => JSON.stringify(e))
            .join(", ")
          throw new Error(`Unknown schema "${t}"; use one of ${e} or define customTags array`)
        }
        n = []
      }
      if (Array.isArray(e)) for (const t of e) n = n.concat(t)
      else "function" == typeof e && (n = e(n.slice()))
      return n.map((e) => {
        if ("string" != typeof e) return e
        const t = Tc[e]
        if (t) return t
        const n = Object.keys(Tc)
          .map((e) => JSON.stringify(e))
          .join(", ")
        throw new Error(`Unknown custom tag "${e}"; use one of ${n}`)
      })
    }
    const Pc = (e, t) => (e.key < t.key ? -1 : e.key > t.key ? 1 : 0)
    class Dc {
      constructor(e, t, n) {
        ;(this.commentBefore = null),
          (this.comment = null),
          (this.errors = []),
          (this.warnings = []),
          Object.defineProperty(this, _s, { value: ys })
        let r = null
        "function" == typeof t || Array.isArray(t) ? (r = t) : void 0 === n && t && ((n = t), (t = void 0))
        const a = Object.assign(
          {
            intAsBigInt: !1,
            keepSourceTokens: !1,
            logLevel: "warn",
            prettyErrors: !0,
            strict: !0,
            uniqueKeys: !0,
            version: "1.2",
          },
          n,
        )
        this.options = a
        let { version: o } = a
        ;(null == n ? void 0 : n._directives)
          ? ((this.directives = n._directives.atDocument()),
            this.directives.yaml.explicit && (o = this.directives.yaml.version))
          : (this.directives = new js({ version: o })),
          this.setSchema(o, n),
          (this.contents = void 0 === e ? null : this.createNode(e, r, n))
      }
      clone() {
        const e = Object.create(Dc.prototype, { [_s]: { value: ys } })
        return (
          (e.commentBefore = this.commentBefore),
          (e.comment = this.comment),
          (e.errors = this.errors.slice()),
          (e.warnings = this.warnings.slice()),
          (e.options = Object.assign({}, this.options)),
          this.directives && (e.directives = this.directives.clone()),
          (e.schema = this.schema.clone()),
          (e.contents = Rs(this.contents) ? this.contents.clone(e.schema) : this.contents),
          this.range && (e.range = this.range.slice()),
          e
        )
      }
      add(e) {
        Rc(this.contents) && this.contents.add(e)
      }
      addIn(e, t) {
        Rc(this.contents) && this.contents.addIn(e, t)
      }
      createAlias(e, t) {
        if (!e.anchor) {
          const n = Fs(this)
          e.anchor = !t || n.has(t) ? zs(t || "a", n) : t
        }
        return new Vs(e.anchor)
      }
      createNode(e, t, n) {
        let r
        if ("function" == typeof t) (e = t.call({ "": e }, "", e)), (r = t)
        else if (Array.isArray(t)) {
          const e = (e) => "number" == typeof e || e instanceof String || e instanceof Number,
            n = t.filter(e).map(String)
          n.length > 0 && (t = t.concat(n)), (r = t)
        } else void 0 === n && t && ((n = t), (t = void 0))
        const { aliasDuplicateObjects: a, anchorPrefix: o, flow: i, keepUndefined: s, onTagObj: l, tag: c } = n ?? {},
          {
            onAnchor: d,
            setAnchors: u,
            sourceObjects: p,
          } = (function (e, t) {
            const n = [],
              r = new Map()
            let a = null
            return {
              onAnchor: (r) => {
                n.push(r), a || (a = Fs(e))
                const o = zs(t, a)
                return a.add(o), o
              },
              setAnchors: () => {
                for (const e of n) {
                  const t = r.get(e)
                  if ("object" != typeof t || !t.anchor || (!Cs(t.node) && !Ds(t.node))) {
                    const t = new Error("Failed to resolve repeated object (this should not happen)")
                    throw ((t.source = e), t)
                  }
                  t.node.anchor = t.anchor
                }
              },
              sourceObjects: r,
            }
          })(this, o || "a"),
          h = Ks(e, c, {
            aliasDuplicateObjects: a ?? !0,
            keepUndefined: s ?? !1,
            onAnchor: d,
            onTagObj: l,
            replacer: r,
            schema: this.schema,
            sourceObjects: p,
          })
        return i && Ds(h) && (h.flow = !0), u(), h
      }
      createPair(e, t, n = {}) {
        const r = this.createNode(e, null, n),
          a = this.createNode(t, null, n)
        return new Sl(r, a)
      }
      delete(e) {
        return !!Rc(this.contents) && this.contents.delete(e)
      }
      deleteIn(e) {
        return el(e)
          ? null != this.contents && ((this.contents = null), !0)
          : !!Rc(this.contents) && this.contents.deleteIn(e)
      }
      get(e, t) {
        return Ds(this.contents) ? this.contents.get(e, t) : void 0
      }
      getIn(e, t) {
        return el(e)
          ? !t && Cs(this.contents)
            ? this.contents.value
            : this.contents
          : Ds(this.contents)
            ? this.contents.getIn(e, t)
            : void 0
      }
      has(e) {
        return !!Ds(this.contents) && this.contents.has(e)
      }
      hasIn(e) {
        return el(e) ? void 0 !== this.contents : !!Ds(this.contents) && this.contents.hasIn(e)
      }
      set(e, t) {
        null == this.contents ? (this.contents = Js(this.schema, [e], t)) : Rc(this.contents) && this.contents.set(e, t)
      }
      setIn(e, t) {
        el(e)
          ? (this.contents = t)
          : null == this.contents
            ? (this.contents = Js(this.schema, Array.from(e), t))
            : Rc(this.contents) && this.contents.setIn(e, t)
      }
      setSchema(e, t = {}) {
        let n
        switch (("number" == typeof e && (e = String(e)), e)) {
          case "1.1":
            this.directives ? (this.directives.yaml.version = "1.1") : (this.directives = new js({ version: "1.1" })),
              (n = { merge: !0, resolveKnownTags: !1, schema: "yaml-1.1" })
            break
          case "1.2":
          case "next":
            this.directives ? (this.directives.yaml.version = e) : (this.directives = new js({ version: e })),
              (n = { merge: !1, resolveKnownTags: !0, schema: "core" })
            break
          case null:
            this.directives && delete this.directives, (n = null)
            break
          default: {
            const t = JSON.stringify(e)
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${t}`)
          }
        }
        if (t.schema instanceof Object) this.schema = t.schema
        else {
          if (!n) throw new Error("With a null YAML version, the { schema: Schema } option is required")
          this.schema = new (class e {
            constructor({
              compat: e,
              customTags: t,
              merge: n,
              resolveKnownTags: r,
              schema: a,
              sortMapEntries: o,
              toStringDefaults: i,
            }) {
              ;(this.compat = Array.isArray(e) ? Cc(e, "compat") : e ? Cc(null, e) : null),
                (this.merge = !!n),
                (this.name = ("string" == typeof a && a) || "core"),
                (this.knownTags = r ? Ac : {}),
                (this.tags = Cc(t, this.name)),
                (this.toStringOptions = i ?? null),
                Object.defineProperty(this, Os, { value: Rl }),
                Object.defineProperty(this, xs, { value: Ml }),
                Object.defineProperty(this, ks, { value: Il }),
                (this.sortMapEntries = "function" == typeof o ? o : !0 === o ? Pc : null)
            }
            clone() {
              const t = Object.create(e.prototype, Object.getOwnPropertyDescriptors(this))
              return (t.tags = this.tags.slice()), t
            }
          })(Object.assign(n, t))
        }
      }
      toJS({ json: e, jsonArg: t, mapAsMap: n, maxAliasCount: r, onAnchor: a, reviver: o } = {}) {
        const i = {
            anchors: new Map(),
            doc: this,
            keep: !e,
            mapAsMap: !0 === n,
            mapKeyWarned: !1,
            maxAliasCount: "number" == typeof r ? r : 100,
          },
          s = Zs(this.contents, t ?? "", i)
        if ("function" == typeof a) for (const { count: e, res: t } of i.anchors.values()) a(t, e)
        return "function" == typeof o ? qs(o, { "": s }, "", s) : s
      }
      toJSON(e, t) {
        return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: t })
      }
      toString(e = {}) {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified")
        if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
          const t = JSON.stringify(e.indent)
          throw new Error(`"indent" option must be a positive integer, not ${t}`)
        }
        return (function (e, t) {
          var n
          const r = []
          let a = !0 === t.directives
          if (!1 !== t.directives && e.directives) {
            const t = e.directives.toString(e)
            t ? (r.push(t), (a = !0)) : e.directives.docStart && (a = !0)
          }
          a && r.push("---")
          const o = vl(e, t),
            { commentString: i } = o.options
          if (e.commentBefore) {
            1 !== r.length && r.unshift("")
            const t = i(e.commentBefore)
            r.unshift(rl(t, ""))
          }
          let s = !1,
            l = null
          if (e.contents) {
            if (Rs(e.contents)) {
              if ((e.contents.spaceBefore && a && r.push(""), e.contents.commentBefore)) {
                const t = i(e.contents.commentBefore)
                r.push(rl(t, ""))
              }
              ;(o.forceBlockIndent = !!e.comment), (l = e.contents.comment)
            }
            const t = l ? void 0 : () => (s = !0)
            let n = yl(e.contents, o, () => (l = null), t)
            l && (n += al(n, "", i(l))),
              ("|" !== n[0] && ">" !== n[0]) || "---" !== r[r.length - 1] ? r.push(n) : (r[r.length - 1] = `--- ${n}`)
          } else r.push(yl(e.contents, o))
          if (null == (n = e.directives) ? void 0 : n.docEnd)
            if (e.comment) {
              const t = i(e.comment)
              t.includes("\n") ? (r.push("..."), r.push(rl(t, ""))) : r.push(`... ${t}`)
            } else r.push("...")
          else {
            let t = e.comment
            t && s && (t = t.replace(/^\n+/, "")),
              t && ((s && !l) || "" === r[r.length - 1] || r.push(""), r.push(rl(i(t), "")))
          }
          return r.join("\n") + "\n"
        })(this, e)
      }
    }
    function Rc(e) {
      if (Ds(e)) return !0
      throw new Error("Expected a YAML collection as document contents")
    }
    class Nc extends Error {
      constructor(e, t, n, r) {
        super(), (this.name = e), (this.code = n), (this.message = r), (this.pos = t)
      }
    }
    class $c extends Nc {
      constructor(e, t, n) {
        super("YAMLParseError", e, t, n)
      }
    }
    class Ic extends Nc {
      constructor(e, t, n) {
        super("YAMLWarning", e, t, n)
      }
    }
    const Mc = (e, t) => (n) => {
      if (-1 === n.pos[0]) return
      n.linePos = n.pos.map((e) => t.linePos(e))
      const { line: r, col: a } = n.linePos[0]
      n.message += ` at line ${r}, column ${a}`
      let o = a - 1,
        i = e.substring(t.lineStarts[r - 1], t.lineStarts[r]).replace(/[\n\r]+$/, "")
      if (o >= 60 && i.length > 80) {
        const e = Math.min(o - 39, i.length - 79)
        ;(i = "" + i.substring(e)), (o -= e - 1)
      }
      if ((i.length > 80 && (i = i.substring(0, 79) + ""), r > 1 && /^ *$/.test(i.substring(0, o)))) {
        let n = e.substring(t.lineStarts[r - 2], t.lineStarts[r - 1])
        n.length > 80 && (n = n.substring(0, 79) + "\n"), (i = n + i)
      }
      if (/[^ ]/.test(i)) {
        let e = 1
        const t = n.linePos[1]
        t && t.line === r && t.col > a && (e = Math.max(1, Math.min(t.col - a, 80 - o)))
        const s = " ".repeat(o) + "^".repeat(e)
        n.message += `:\n\n${i}\n${s}\n`
      }
    }
    function Lc(e, { flow: t, indicator: n, next: r, offset: a, onError: o, parentIndent: i, startOnNewline: s }) {
      let l = !1,
        c = s,
        d = s,
        u = "",
        p = "",
        h = !1,
        f = !1,
        m = !1,
        g = null,
        b = null,
        v = null,
        y = null,
        O = null,
        w = null
      for (const a of e)
        switch (
          (m &&
            ("space" !== a.type &&
              "newline" !== a.type &&
              "comma" !== a.type &&
              o(a.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"),
            (m = !1)),
          g &&
            (c &&
              "comment" !== a.type &&
              "newline" !== a.type &&
              o(g, "TAB_AS_INDENT", "Tabs are not allowed as indentation"),
            (g = null)),
          a.type)
        ) {
          case "space":
            t ||
              ("doc-start" === n && "flow-collection" === (null == r ? void 0 : r.type)) ||
              !a.source.includes("\t") ||
              (g = a),
              (d = !0)
            break
          case "comment": {
            d || o(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters")
            const e = a.source.substring(1) || " "
            u ? (u += p + e) : (u = e), (p = ""), (c = !1)
            break
          }
          case "newline":
            c ? (u ? (u += a.source) : (l = !0)) : (p += a.source), (c = !0), (h = !0), (b || v) && (f = !0), (d = !0)
            break
          case "anchor":
            b && o(a, "MULTIPLE_ANCHORS", "A node can have at most one anchor"),
              a.source.endsWith(":") &&
                o(a.offset + a.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0),
              (b = a),
              null === w && (w = a.offset),
              (c = !1),
              (d = !1),
              (m = !0)
            break
          case "tag":
            v && o(a, "MULTIPLE_TAGS", "A node can have at most one tag"),
              (v = a),
              null === w && (w = a.offset),
              (c = !1),
              (d = !1),
              (m = !0)
            break
          case n:
            ;(b || v) && o(a, "BAD_PROP_ORDER", `Anchors and tags must be after the ${a.source} indicator`),
              O && o(a, "UNEXPECTED_TOKEN", `Unexpected ${a.source} in ${t ?? "collection"}`),
              (O = a),
              (c = "seq-item-ind" === n || "explicit-key-ind" === n),
              (d = !1)
            break
          case "comma":
            if (t) {
              y && o(a, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`), (y = a), (c = !1), (d = !1)
              break
            }
          default:
            o(a, "UNEXPECTED_TOKEN", `Unexpected ${a.type} token`), (c = !1), (d = !1)
        }
      const x = e[e.length - 1],
        k = x ? x.offset + x.source.length : a
      return (
        m &&
          r &&
          "space" !== r.type &&
          "newline" !== r.type &&
          "comma" !== r.type &&
          ("scalar" !== r.type || "" !== r.source) &&
          o(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"),
        g &&
          ((c && g.indent <= i) ||
            "block-map" === (null == r ? void 0 : r.type) ||
            "block-seq" === (null == r ? void 0 : r.type)) &&
          o(g, "TAB_AS_INDENT", "Tabs are not allowed as indentation"),
        {
          comma: y,
          found: O,
          spaceBefore: l,
          comment: u,
          hasNewline: h,
          hasNewlineAfterProp: f,
          anchor: b,
          tag: v,
          end: k,
          start: w ?? k,
        }
      )
    }
    function Qc(e) {
      if (!e) return null
      switch (e.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (e.source.includes("\n")) return !0
          if (e.end) for (const t of e.end) if ("newline" === t.type) return !0
          return !1
        case "flow-collection":
          for (const t of e.items) {
            for (const e of t.start) if ("newline" === e.type) return !0
            if (t.sep) for (const e of t.sep) if ("newline" === e.type) return !0
            if (Qc(t.key) || Qc(t.value)) return !0
          }
          return !1
        default:
          return !0
      }
    }
    function Bc(e, t, n) {
      if ("flow-collection" === (null == t ? void 0 : t.type)) {
        const r = t.end[0]
        r.indent !== e ||
          ("]" !== r.source && "}" !== r.source) ||
          !Qc(t) ||
          n(r, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0)
      }
    }
    function jc(e, t, n) {
      const { uniqueKeys: r } = e.options
      if (!1 === r) return !1
      const a =
        "function" == typeof r
          ? r
          : (t, n) => t === n || (Cs(t) && Cs(n) && t.value === n.value && !("<<" === t.value && e.schema.merge))
      return t.some((e) => a(e.key, n))
    }
    const Uc = "All mapping items must start at the same column"
    function Fc(e, t, n, r) {
      let a = ""
      if (e) {
        let o = !1,
          i = ""
        for (const s of e) {
          const { source: e, type: l } = s
          switch (l) {
            case "space":
              o = !0
              break
            case "comment": {
              n && !o && r(s, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters")
              const t = e.substring(1) || " "
              a ? (a += i + t) : (a = t), (i = "")
              break
            }
            case "newline":
              a && (i += e), (o = !0)
              break
            default:
              r(s, "UNEXPECTED_TOKEN", `Unexpected ${l} at node end`)
          }
          t += e.length
        }
      }
      return { comment: a, offset: t }
    }
    const zc = "Block collections are not allowed within flow collections",
      qc = (e) => e && ("block-map" === e.type || "block-seq" === e.type)
    function Zc(e, t, n, r, a, o) {
      const i =
          "block-map" === n.type
            ? (function ({ composeNode: e, composeEmptyNode: t }, n, r, a, o) {
                var i
                const s = new ((null == o ? void 0 : o.nodeClass) ?? Dl)(n.schema)
                n.atRoot && (n.atRoot = !1)
                let l = r.offset,
                  c = null
                for (const o of r.items) {
                  const { start: d, key: u, sep: p, value: h } = o,
                    f = Lc(d, {
                      indicator: "explicit-key-ind",
                      next: u ?? (null == p ? void 0 : p[0]),
                      offset: l,
                      onError: a,
                      parentIndent: r.indent,
                      startOnNewline: !0,
                    }),
                    m = !f.found
                  if (m) {
                    if (
                      (u &&
                        ("block-seq" === u.type
                          ? a(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key")
                          : "indent" in u && u.indent !== r.indent && a(l, "BAD_INDENT", Uc)),
                      !f.anchor && !f.tag && !p)
                    ) {
                      ;(c = f.end), f.comment && (s.comment ? (s.comment += "\n" + f.comment) : (s.comment = f.comment))
                      continue
                    }
                    ;(f.hasNewlineAfterProp || Qc(u)) &&
                      a(u ?? d[d.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line")
                  } else (null == (i = f.found) ? void 0 : i.indent) !== r.indent && a(l, "BAD_INDENT", Uc)
                  const g = f.end,
                    b = u ? e(n, u, f, a) : t(n, g, d, null, f, a)
                  n.schema.compat && Bc(r.indent, u, a),
                    jc(n, s.items, b) && a(g, "DUPLICATE_KEY", "Map keys must be unique")
                  const v = Lc(p ?? [], {
                    indicator: "map-value-ind",
                    next: h,
                    offset: b.range[2],
                    onError: a,
                    parentIndent: r.indent,
                    startOnNewline: !u || "block-scalar" === u.type,
                  })
                  if (((l = v.end), v.found)) {
                    m &&
                      ("block-map" !== (null == h ? void 0 : h.type) ||
                        v.hasNewline ||
                        a(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"),
                      n.options.strict &&
                        f.start < v.found.offset - 1024 &&
                        a(
                          b.range,
                          "KEY_OVER_1024_CHARS",
                          "The : indicator must be at most 1024 chars after the start of an implicit block mapping key",
                        ))
                    const i = h ? e(n, h, v, a) : t(n, l, p, null, v, a)
                    n.schema.compat && Bc(r.indent, h, a), (l = i.range[2])
                    const c = new Sl(b, i)
                    n.options.keepSourceTokens && (c.srcToken = o), s.items.push(c)
                  } else {
                    m && a(b.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"),
                      v.comment && (b.comment ? (b.comment += "\n" + v.comment) : (b.comment = v.comment))
                    const e = new Sl(b)
                    n.options.keepSourceTokens && (e.srcToken = o), s.items.push(e)
                  }
                }
                return (
                  c && c < l && a(c, "IMPOSSIBLE", "Map comment with trailing content"),
                  (s.range = [r.offset, l, c ?? l]),
                  s
                )
              })(e, t, n, r, o)
            : "block-seq" === n.type
              ? (function ({ composeNode: e, composeEmptyNode: t }, n, r, a, o) {
                  const i = new ((null == o ? void 0 : o.nodeClass) ?? Nl)(n.schema)
                  n.atRoot && (n.atRoot = !1)
                  let s = r.offset,
                    l = null
                  for (const { start: o, value: c } of r.items) {
                    const d = Lc(o, {
                      indicator: "seq-item-ind",
                      next: c,
                      offset: s,
                      onError: a,
                      parentIndent: r.indent,
                      startOnNewline: !0,
                    })
                    if (!d.found) {
                      if (!(d.anchor || d.tag || c)) {
                        ;(l = d.end), d.comment && (i.comment = d.comment)
                        continue
                      }
                      c && "block-seq" === c.type
                        ? a(d.end, "BAD_INDENT", "All sequence items must start at the same column")
                        : a(s, "MISSING_CHAR", "Sequence item without - indicator")
                    }
                    const u = c ? e(n, c, d, a) : t(n, d.end, o, null, d, a)
                    n.schema.compat && Bc(r.indent, c, a), (s = u.range[2]), i.items.push(u)
                  }
                  return (i.range = [r.offset, s, l ?? s]), i
                })(e, t, n, r, o)
              : (function ({ composeNode: e, composeEmptyNode: t }, n, r, a, o) {
                  const i = "{" === r.start.source,
                    s = i ? "flow map" : "flow sequence",
                    l = new ((null == o ? void 0 : o.nodeClass) ?? (i ? Dl : Nl))(n.schema)
                  l.flow = !0
                  const c = n.atRoot
                  c && (n.atRoot = !1)
                  let d = r.offset + r.start.source.length
                  for (let o = 0; o < r.items.length; ++o) {
                    const c = r.items[o],
                      { start: u, key: p, sep: h, value: f } = c,
                      m = Lc(u, {
                        flow: s,
                        indicator: "explicit-key-ind",
                        next: p ?? (null == h ? void 0 : h[0]),
                        offset: d,
                        onError: a,
                        parentIndent: r.indent,
                        startOnNewline: !1,
                      })
                    if (!m.found) {
                      if (!(m.anchor || m.tag || h || f)) {
                        0 === o && m.comma
                          ? a(m.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${s}`)
                          : o < r.items.length - 1 && a(m.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${s}`),
                          m.comment && (l.comment ? (l.comment += "\n" + m.comment) : (l.comment = m.comment)),
                          (d = m.end)
                        continue
                      }
                      !i &&
                        n.options.strict &&
                        Qc(p) &&
                        a(
                          p,
                          "MULTILINE_IMPLICIT_KEY",
                          "Implicit keys of flow sequence pairs need to be on a single line",
                        )
                    }
                    if (0 === o) m.comma && a(m.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${s}`)
                    else if ((m.comma || a(m.start, "MISSING_CHAR", `Missing , between ${s} items`), m.comment)) {
                      let e = ""
                      e: for (const t of u)
                        switch (t.type) {
                          case "comma":
                          case "space":
                            break
                          case "comment":
                            e = t.source.substring(1)
                            break e
                          default:
                            break e
                        }
                      if (e) {
                        let t = l.items[l.items.length - 1]
                        As(t) && (t = t.value ?? t.key),
                          t.comment ? (t.comment += "\n" + e) : (t.comment = e),
                          (m.comment = m.comment.substring(e.length + 1))
                      }
                    }
                    if (i || h || m.found) {
                      const o = m.end,
                        g = p ? e(n, p, m, a) : t(n, o, u, null, m, a)
                      qc(p) && a(g.range, "BLOCK_IN_FLOW", zc)
                      const b = Lc(h ?? [], {
                        flow: s,
                        indicator: "map-value-ind",
                        next: f,
                        offset: g.range[2],
                        onError: a,
                        parentIndent: r.indent,
                        startOnNewline: !1,
                      })
                      if (b.found) {
                        if (!i && !m.found && n.options.strict) {
                          if (h)
                            for (const e of h) {
                              if (e === b.found) break
                              if ("newline" === e.type) {
                                a(
                                  e,
                                  "MULTILINE_IMPLICIT_KEY",
                                  "Implicit keys of flow sequence pairs need to be on a single line",
                                )
                                break
                              }
                            }
                          m.start < b.found.offset - 1024 &&
                            a(
                              b.found,
                              "KEY_OVER_1024_CHARS",
                              "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key",
                            )
                        }
                      } else
                        f &&
                          ("source" in f && f.source && ":" === f.source[0]
                            ? a(f, "MISSING_CHAR", `Missing space after : in ${s}`)
                            : a(b.start, "MISSING_CHAR", `Missing , or : between ${s} items`))
                      const v = f ? e(n, f, b, a) : b.found ? t(n, b.end, h, null, b, a) : null
                      v
                        ? qc(f) && a(v.range, "BLOCK_IN_FLOW", zc)
                        : b.comment && (g.comment ? (g.comment += "\n" + b.comment) : (g.comment = b.comment))
                      const y = new Sl(g, v)
                      if ((n.options.keepSourceTokens && (y.srcToken = c), i)) {
                        const e = l
                        jc(n, e.items, g) && a(o, "DUPLICATE_KEY", "Map keys must be unique"), e.items.push(y)
                      } else {
                        const e = new Dl(n.schema)
                        ;(e.flow = !0), e.items.push(y), l.items.push(e)
                      }
                      d = v ? v.range[2] : b.end
                    } else {
                      const r = f ? e(n, f, m, a) : t(n, m.end, h, null, m, a)
                      l.items.push(r), (d = r.range[2]), qc(f) && a(r.range, "BLOCK_IN_FLOW", zc)
                    }
                  }
                  const u = i ? "}" : "]",
                    [p, ...h] = r.end
                  let f = d
                  if (p && p.source === u) f = p.offset + p.source.length
                  else {
                    const e = s[0].toUpperCase() + s.substring(1)
                    a(
                      d,
                      c ? "MISSING_CHAR" : "BAD_INDENT",
                      c
                        ? `${e} must end with a ${u}`
                        : `${e} in block collection must be sufficiently indented and end with a ${u}`,
                    ),
                      p && 1 !== p.source.length && h.unshift(p)
                  }
                  if (h.length > 0) {
                    const e = Fc(h, f, n.options.strict, a)
                    e.comment && (l.comment ? (l.comment += "\n" + e.comment) : (l.comment = e.comment)),
                      (l.range = [r.offset, f, e.offset])
                  } else l.range = [r.offset, f, f]
                  return l
                })(e, t, n, r, o),
        s = i.constructor
      return "!" === a || a === s.tagName ? ((i.tag = s.tagName), i) : (a && (i.tag = a), i)
    }
    function Hc(e) {
      let t, n
      try {
        ;(t = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy")),
          (n = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy"))
      } catch (e) {
        ;(t = /(.*?)[ \t]*\r?\n/sy), (n = /[ \t]*(.*?)[ \t]*\r?\n/sy)
      }
      let r = t.exec(e)
      if (!r) return e
      let a = r[1],
        o = " ",
        i = t.lastIndex
      for (n.lastIndex = i; (r = n.exec(e)); )
        "" === r[1] ? ("\n" === o ? (a += o) : (o = "\n")) : ((a += o + r[1]), (o = " ")), (i = n.lastIndex)
      const s = /[ \t]*(.*)/sy
      return (s.lastIndex = i), (r = s.exec(e)), a + o + ((null == r ? void 0 : r[1]) ?? "")
    }
    function Vc(e, t) {
      let n = "",
        r = e[t + 1]
      for (; !((" " !== r && "\t" !== r && "\n" !== r && "\r" !== r) || ("\r" === r && "\n" !== e[t + 2])); )
        "\n" === r && (n += "\n"), (r = e[(t += 1) + 1])
      return n || (n = " "), { fold: n, offset: t }
    }
    const Wc = {
      0: "\0",
      a: "",
      b: "\b",
      e: "",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "\t",
      v: "\v",
      N: "",
      _: "",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "\t": "\t",
    }
    function Xc(e, t, n, r) {
      const a = e.substr(t, n),
        o = a.length === n && /^[0-9a-fA-F]+$/.test(a) ? parseInt(a, 16) : NaN
      if (isNaN(o)) {
        const a = e.substr(t - 2, n + 2)
        return r(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), a
      }
      return String.fromCodePoint(o)
    }
    function Yc(e, t, n, r) {
      const {
          value: a,
          type: o,
          comment: i,
          range: s,
        } = "block-scalar" === t.type
          ? (function (e, t, n) {
              const r = t.offset,
                a = (function ({ offset: e, props: t }, n, r) {
                  if ("block-scalar-header" !== t[0].type)
                    return r(t[0], "IMPOSSIBLE", "Block scalar header not found"), null
                  const { source: a } = t[0],
                    o = a[0]
                  let i = 0,
                    s = "",
                    l = -1
                  for (let t = 1; t < a.length; ++t) {
                    const n = a[t]
                    if (s || ("-" !== n && "+" !== n)) {
                      const r = Number(n)
                      !i && r ? (i = r) : -1 === l && (l = e + t)
                    } else s = n
                  }
                  ;-1 !== l && r(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${a}`)
                  let c = !1,
                    d = "",
                    u = a.length
                  for (let e = 1; e < t.length; ++e) {
                    const a = t[e]
                    switch (a.type) {
                      case "space":
                        c = !0
                      case "newline":
                        u += a.source.length
                        break
                      case "comment":
                        n &&
                          !c &&
                          r(
                            a,
                            "MISSING_CHAR",
                            "Comments must be separated from other tokens by white space characters",
                          ),
                          (u += a.source.length),
                          (d = a.source.substring(1))
                        break
                      case "error":
                        r(a, "UNEXPECTED_TOKEN", a.message), (u += a.source.length)
                        break
                      default: {
                        r(a, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${a.type}`)
                        const e = a.source
                        e && "string" == typeof e && (u += e.length)
                      }
                    }
                  }
                  return { mode: o, indent: i, chomp: s, comment: d, length: u }
                })(t, e.options.strict, n)
              if (!a) return { value: "", type: null, comment: "", range: [r, r, r] }
              const o = ">" === a.mode ? Ys.BLOCK_FOLDED : Ys.BLOCK_LITERAL,
                i = t.source
                  ? (function (e) {
                      const t = e.split(/\n( *)/),
                        n = t[0],
                        r = n.match(/^( *)/),
                        a = [(null == r ? void 0 : r[1]) ? [r[1], n.slice(r[1].length)] : ["", n]]
                      for (let e = 1; e < t.length; e += 2) a.push([t[e], t[e + 1]])
                      return a
                    })(t.source)
                  : []
              let s = i.length
              for (let e = i.length - 1; e >= 0; --e) {
                const t = i[e][1]
                if ("" !== t && "\r" !== t) break
                s = e
              }
              if (0 === s) {
                const e = "+" === a.chomp && i.length > 0 ? "\n".repeat(Math.max(1, i.length - 1)) : ""
                let n = r + a.length
                return t.source && (n += t.source.length), { value: e, type: o, comment: a.comment, range: [r, n, n] }
              }
              let l = t.indent + a.indent,
                c = t.offset + a.length,
                d = 0
              for (let t = 0; t < s; ++t) {
                const [r, o] = i[t]
                if ("" !== o && "\r" !== o) {
                  if (r.length < l) {
                    const e =
                      "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"
                    n(c + r.length, "MISSING_CHAR", e)
                  }
                  0 === a.indent && (l = r.length),
                    (d = t),
                    0 !== l || e.atRoot || n(c, "BAD_INDENT", "Block scalar values in collections must be indented")
                  break
                }
                0 === a.indent && r.length > l && (l = r.length), (c += r.length + o.length + 1)
              }
              for (let e = i.length - 1; e >= s; --e) i[e][0].length > l && (s = e + 1)
              let u = "",
                p = "",
                h = !1
              for (let e = 0; e < d; ++e) u += i[e][0].slice(l) + "\n"
              for (let e = d; e < s; ++e) {
                let [t, r] = i[e]
                c += t.length + r.length + 1
                const s = "\r" === r[r.length - 1]
                if ((s && (r = r.slice(0, -1)), r && t.length < l)) {
                  const e =
                    "Block scalar lines must not be less indented than their " +
                    (a.indent ? "explicit indentation indicator" : "first line")
                  n(c - r.length - (s ? 2 : 1), "BAD_INDENT", e), (t = "")
                }
                o === Ys.BLOCK_LITERAL
                  ? ((u += p + t.slice(l) + r), (p = "\n"))
                  : t.length > l || "\t" === r[0]
                    ? (" " === p ? (p = "\n") : h || "\n" !== p || (p = "\n\n"),
                      (u += p + t.slice(l) + r),
                      (p = "\n"),
                      (h = !0))
                    : "" === r
                      ? "\n" === p
                        ? (u += "\n")
                        : (p = "\n")
                      : ((u += p + r), (p = " "), (h = !1))
              }
              switch (a.chomp) {
                case "-":
                  break
                case "+":
                  for (let e = s; e < i.length; ++e) u += "\n" + i[e][0].slice(l)
                  "\n" !== u[u.length - 1] && (u += "\n")
                  break
                default:
                  u += "\n"
              }
              const f = r + a.length + t.source.length
              return { value: u, type: o, comment: a.comment, range: [r, f, f] }
            })(e, t, r)
          : (function (e, t, n) {
              const { offset: r, type: a, source: o, end: i } = e
              let s, l
              const c = (e, t, a) => n(r + e, t, a)
              switch (a) {
                case "scalar":
                  ;(s = Ys.PLAIN),
                    (l = (function (e, t) {
                      let n = ""
                      switch (e[0]) {
                        case "\t":
                          n = "a tab character"
                          break
                        case ",":
                          n = "flow indicator character ,"
                          break
                        case "%":
                          n = "directive indicator character %"
                          break
                        case "|":
                        case ">":
                          n = `block scalar indicator ${e[0]}`
                          break
                        case "@":
                        case "`":
                          n = `reserved character ${e[0]}`
                      }
                      return n && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${n}`), Hc(e)
                    })(o, c))
                  break
                case "single-quoted-scalar":
                  ;(s = Ys.QUOTE_SINGLE),
                    (l = (function (e, t) {
                      return (
                        ("'" === e[e.length - 1] && 1 !== e.length) ||
                          t(e.length, "MISSING_CHAR", "Missing closing 'quote"),
                        Hc(e.slice(1, -1)).replace(/''/g, "'")
                      )
                    })(o, c))
                  break
                case "double-quoted-scalar":
                  ;(s = Ys.QUOTE_DOUBLE),
                    (l = (function (e, t) {
                      let n = ""
                      for (let r = 1; r < e.length - 1; ++r) {
                        const a = e[r]
                        if ("\r" !== a || "\n" !== e[r + 1])
                          if ("\n" === a) {
                            const { fold: t, offset: a } = Vc(e, r)
                            ;(n += t), (r = a)
                          } else if ("\\" === a) {
                            let a = e[++r]
                            const o = Wc[a]
                            if (o) n += o
                            else if ("\n" === a) for (a = e[r + 1]; " " === a || "\t" === a; ) a = e[1 + ++r]
                            else if ("\r" === a && "\n" === e[r + 1])
                              for (a = e[1 + ++r]; " " === a || "\t" === a; ) a = e[1 + ++r]
                            else if ("x" === a || "u" === a || "U" === a) {
                              const o = { x: 2, u: 4, U: 8 }[a]
                              ;(n += Xc(e, r + 1, o, t)), (r += o)
                            } else {
                              const a = e.substr(r - 1, 2)
                              t(r - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), (n += a)
                            }
                          } else if (" " === a || "\t" === a) {
                            const t = r
                            let o = e[r + 1]
                            for (; " " === o || "\t" === o; ) o = e[1 + ++r]
                            "\n" === o || ("\r" === o && "\n" === e[r + 2]) || (n += r > t ? e.slice(t, r + 1) : a)
                          } else n += a
                      }
                      return (
                        ('"' === e[e.length - 1] && 1 !== e.length) ||
                          t(e.length, "MISSING_CHAR", 'Missing closing "quote'),
                        n
                      )
                    })(o, c))
                  break
                default:
                  return (
                    n(e, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${a}`),
                    { value: "", type: null, comment: "", range: [r, r + o.length, r + o.length] }
                  )
              }
              const d = r + o.length,
                u = Fc(i, d, t, n)
              return { value: l, type: s, comment: u.comment, range: [r, d, u.offset] }
            })(t, e.options.strict, r),
        l = n ? e.directives.tagName(n.source, (e) => r(n, "TAG_RESOLVE_FAILED", e)) : null,
        c =
          n && l
            ? (function (e, t, n, r, a) {
                var o
                if ("!" === n) return e[xs]
                const i = []
                for (const t of e.tags)
                  if (!t.collection && t.tag === n) {
                    if (!t.default || !t.test) return t
                    i.push(t)
                  }
                for (const e of i) if (null == (o = e.test) ? void 0 : o.test(t)) return e
                const s = e.knownTags[n]
                return s && !s.collection
                  ? (e.tags.push(Object.assign({}, s, { default: !1, test: void 0 })), s)
                  : (a(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${n}`, "tag:yaml.org,2002:str" !== n), e[xs])
              })(e.schema, a, l, n, r)
            : "scalar" === t.type
              ? (function ({ directives: e, schema: t }, n, r, a) {
                  const o =
                    t.tags.find((e) => {
                      var t
                      return e.default && (null == (t = e.test) ? void 0 : t.test(n))
                    }) || t[xs]
                  if (t.compat) {
                    const i =
                      t.compat.find((e) => {
                        var t
                        return e.default && (null == (t = e.test) ? void 0 : t.test(n))
                      }) ?? t[xs]
                    o.tag !== i.tag &&
                      a(
                        r,
                        "TAG_RESOLVE_FAILED",
                        `Value may be parsed as either ${e.tagString(o.tag)} or ${e.tagString(i.tag)}`,
                        !0,
                      )
                  }
                  return o
                })(e, a, t, r)
              : e.schema[xs]
      let d
      try {
        const o = c.resolve(a, (e) => r(n ?? t, "TAG_RESOLVE_FAILED", e), e.options)
        d = Cs(o) ? o : new Ys(o)
      } catch (e) {
        const o = e instanceof Error ? e.message : String(e)
        r(n ?? t, "TAG_RESOLVE_FAILED", o), (d = new Ys(a))
      }
      return (
        (d.range = s),
        (d.source = a),
        o && (d.type = o),
        l && (d.tag = l),
        c.format && (d.format = c.format),
        i && (d.comment = i),
        d
      )
    }
    function Gc(e, t, n) {
      if (t) {
        null === n && (n = t.length)
        for (let r = n - 1; r >= 0; --r) {
          let n = t[r]
          switch (n.type) {
            case "space":
            case "comment":
            case "newline":
              e -= n.source.length
              continue
          }
          for (n = t[++r]; "space" === (null == n ? void 0 : n.type); ) (e += n.source.length), (n = t[++r])
          break
        }
      }
      return e
    }
    const Kc = { composeNode: Jc, composeEmptyNode: ed }
    function Jc(e, t, n, r) {
      const { spaceBefore: a, comment: o, anchor: i, tag: s } = n
      let l,
        c = !0
      switch (t.type) {
        case "alias":
          ;(l = (function ({ options: e }, { offset: t, source: n, end: r }, a) {
            const o = new Vs(n.substring(1))
            "" === o.source && a(t, "BAD_ALIAS", "Alias cannot be an empty string"),
              o.source.endsWith(":") && a(t + n.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0)
            const i = t + n.length,
              s = Fc(r, i, e.strict, a)
            return (o.range = [t, i, s.offset]), s.comment && (o.comment = s.comment), o
          })(e, t, r)),
            (i || s) && r(t, "ALIAS_PROPS", "An alias node must not specify any properties")
          break
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          ;(l = Yc(e, t, s, r)), i && (l.anchor = i.source.substring(1))
          break
        case "block-map":
        case "block-seq":
        case "flow-collection":
          ;(l = (function (e, t, n, r, a) {
            var o
            const i = r ? t.directives.tagName(r.source, (e) => a(r, "TAG_RESOLVE_FAILED", e)) : null,
              s =
                "block-map" === n.type ? "map" : "block-seq" === n.type ? "seq" : "{" === n.start.source ? "map" : "seq"
            if (!r || !i || "!" === i || (i === Dl.tagName && "map" === s) || (i === Nl.tagName && "seq" === s) || !s)
              return Zc(e, t, n, a, i)
            let l = t.schema.tags.find((e) => e.tag === i && e.collection === s)
            if (!l) {
              const o = t.schema.knownTags[i]
              if (!o || o.collection !== s)
                return (
                  (null == o ? void 0 : o.collection)
                    ? a(r, "BAD_COLLECTION_TYPE", `${o.tag} used for ${s} collection, but expects ${o.collection}`, !0)
                    : a(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${i}`, !0),
                  Zc(e, t, n, a, i)
                )
              t.schema.tags.push(Object.assign({}, o, { default: !1 })), (l = o)
            }
            const c = Zc(e, t, n, a, i, l),
              d =
                (null == (o = l.resolve) ? void 0 : o.call(l, c, (e) => a(r, "TAG_RESOLVE_FAILED", e), t.options)) ?? c,
              u = Rs(d) ? d : new Ys(d)
            return (u.range = c.range), (u.tag = i), (null == l ? void 0 : l.format) && (u.format = l.format), u
          })(Kc, e, t, s, r)),
            i && (l.anchor = i.source.substring(1))
          break
        default:
          r(t, "UNEXPECTED_TOKEN", "error" === t.type ? t.message : `Unsupported token (type: ${t.type})`),
            (l = ed(e, t.offset, void 0, null, n, r)),
            (c = !1)
      }
      return (
        i && "" === l.anchor && r(i, "BAD_ALIAS", "Anchor cannot be an empty string"),
        a && (l.spaceBefore = !0),
        o && ("scalar" === t.type && "" === t.source ? (l.comment = o) : (l.commentBefore = o)),
        e.options.keepSourceTokens && c && (l.srcToken = t),
        l
      )
    }
    function ed(e, t, n, r, { spaceBefore: a, comment: o, anchor: i, tag: s, end: l }, c) {
      const d = Yc(e, { type: "scalar", offset: Gc(t, n, r), indent: -1, source: "" }, s, c)
      return (
        i &&
          ((d.anchor = i.source.substring(1)),
          "" === d.anchor && c(i, "BAD_ALIAS", "Anchor cannot be an empty string")),
        a && (d.spaceBefore = !0),
        o && ((d.comment = o), (d.range[2] = l)),
        d
      )
    }
    function td(e) {
      if ("number" == typeof e) return [e, e + 1]
      if (Array.isArray(e)) return 2 === e.length ? e : [e[0], e[1]]
      const { offset: t, source: n } = e
      return [t, t + ("string" == typeof n ? n.length : 1)]
    }
    function nd(e) {
      var t
      let n = "",
        r = !1,
        a = !1
      for (let o = 0; o < e.length; ++o) {
        const i = e[o]
        switch (i[0]) {
          case "#":
            ;(n += ("" === n ? "" : a ? "\n\n" : "\n") + (i.substring(1) || " ")), (r = !0), (a = !1)
            break
          case "%":
            "#" !== (null == (t = e[o + 1]) ? void 0 : t[0]) && (o += 1), (r = !1)
            break
          default:
            r || (a = !0), (r = !1)
        }
      }
      return { comment: n, afterEmptyLine: a }
    }
    class rd {
      constructor(e = {}) {
        ;(this.doc = null),
          (this.atDirectives = !1),
          (this.prelude = []),
          (this.errors = []),
          (this.warnings = []),
          (this.onError = (e, t, n, r) => {
            const a = td(e)
            r ? this.warnings.push(new Ic(a, t, n)) : this.errors.push(new $c(a, t, n))
          }),
          (this.directives = new js({ version: e.version || "1.2" })),
          (this.options = e)
      }
      decorate(e, t) {
        const { comment: n, afterEmptyLine: r } = nd(this.prelude)
        if (n) {
          const a = e.contents
          if (t) e.comment = e.comment ? `${e.comment}\n${n}` : n
          else if (r || e.directives.docStart || !a) e.commentBefore = n
          else if (Ds(a) && !a.flow && a.items.length > 0) {
            let e = a.items[0]
            As(e) && (e = e.key)
            const t = e.commentBefore
            e.commentBefore = t ? `${n}\n${t}` : n
          } else {
            const e = a.commentBefore
            a.commentBefore = e ? `${n}\n${e}` : n
          }
        }
        t
          ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings))
          : ((e.errors = this.errors), (e.warnings = this.warnings)),
          (this.prelude = []),
          (this.errors = []),
          (this.warnings = [])
      }
      streamInfo() {
        return {
          comment: nd(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings,
        }
      }
      *compose(e, t = !1, n = -1) {
        for (const t of e) yield* this.next(t)
        yield* this.end(t, n)
      }
      *next(e) {
        switch (e.type) {
          case "directive":
            this.directives.add(e.source, (t, n, r) => {
              const a = td(e)
              ;(a[0] += t), this.onError(a, "BAD_DIRECTIVE", n, r)
            }),
              this.prelude.push(e.source),
              (this.atDirectives = !0)
            break
          case "document": {
            const t = (function (e, t, { offset: n, start: r, value: a, end: o }, i) {
              const s = Object.assign({ _directives: t }, e),
                l = new Dc(void 0, s),
                c = { atRoot: !0, directives: l.directives, options: l.options, schema: l.schema },
                d = Lc(r, {
                  indicator: "doc-start",
                  next: a ?? (null == o ? void 0 : o[0]),
                  offset: n,
                  onError: i,
                  parentIndent: 0,
                  startOnNewline: !0,
                })
              d.found &&
                ((l.directives.docStart = !0),
                !a ||
                  ("block-map" !== a.type && "block-seq" !== a.type) ||
                  d.hasNewline ||
                  i(d.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")),
                (l.contents = a ? Jc(c, a, d, i) : ed(c, d.end, r, null, d, i))
              const u = l.contents.range[2],
                p = Fc(o, u, !1, i)
              return p.comment && (l.comment = p.comment), (l.range = [n, u, p.offset]), l
            })(this.options, this.directives, e, this.onError)
            this.atDirectives &&
              !t.directives.docStart &&
              this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"),
              this.decorate(t, !1),
              this.doc && (yield this.doc),
              (this.doc = t),
              (this.atDirectives = !1)
            break
          }
          case "byte-order-mark":
          case "space":
            break
          case "comment":
          case "newline":
            this.prelude.push(e.source)
            break
          case "error": {
            const t = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message,
              n = new $c(td(e), "UNEXPECTED_TOKEN", t)
            this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n)
            break
          }
          case "doc-end": {
            if (!this.doc) {
              const t = "Unexpected doc-end without preceding document"
              this.errors.push(new $c(td(e), "UNEXPECTED_TOKEN", t))
              break
            }
            this.doc.directives.docEnd = !0
            const t = Fc(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError)
            if ((this.decorate(this.doc, !0), t.comment)) {
              const e = this.doc.comment
              this.doc.comment = e ? `${e}\n${t.comment}` : t.comment
            }
            this.doc.range[2] = t.offset
            break
          }
          default:
            this.errors.push(new $c(td(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`))
        }
      }
      *end(e = !1, t = -1) {
        if (this.doc) this.decorate(this.doc, !0), yield this.doc, (this.doc = null)
        else if (e) {
          const e = Object.assign({ _directives: this.directives }, this.options),
            n = new Dc(void 0, e)
          this.atDirectives && this.onError(t, "MISSING_CHAR", "Missing directives-end indicator line"),
            (n.range = [0, t, t]),
            this.decorate(n, !1),
            yield n
        }
      }
    }
    function ad(e) {
      switch (e) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "\t":
          return !0
        default:
          return !1
      }
    }
    const od = new Set("0123456789ABCDEFabcdef"),
      id = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"),
      sd = new Set(",[]{}"),
      ld = new Set(" ,[]{}\n\r\t"),
      cd = (e) => !e || ld.has(e)
    class dd {
      constructor() {
        ;(this.atEnd = !1),
          (this.blockScalarIndent = -1),
          (this.blockScalarKeep = !1),
          (this.buffer = ""),
          (this.flowKey = !1),
          (this.flowLevel = 0),
          (this.indentNext = 0),
          (this.indentValue = 0),
          (this.lineEndPos = null),
          (this.next = null),
          (this.pos = 0)
      }
      *lex(e, t = !1) {
        if (e) {
          if ("string" != typeof e) throw TypeError("source is not a string")
          ;(this.buffer = this.buffer ? this.buffer + e : e), (this.lineEndPos = null)
        }
        this.atEnd = !t
        let n = this.next ?? "stream"
        for (; n && (t || this.hasChars(1)); ) n = yield* this.parseNext(n)
      }
      atLineEnd() {
        let e = this.pos,
          t = this.buffer[e]
        for (; " " === t || "\t" === t; ) t = this.buffer[++e]
        return !t || "#" === t || "\n" === t || ("\r" === t && "\n" === this.buffer[e + 1])
      }
      charAt(e) {
        return this.buffer[this.pos + e]
      }
      continueScalar(e) {
        let t = this.buffer[e]
        if (this.indentNext > 0) {
          let n = 0
          for (; " " === t; ) t = this.buffer[++n + e]
          if ("\r" === t) {
            const t = this.buffer[n + e + 1]
            if ("\n" === t || (!t && !this.atEnd)) return e + n + 1
          }
          return "\n" === t || n >= this.indentNext || (!t && !this.atEnd) ? e + n : -1
        }
        if ("-" === t || "." === t) {
          const t = this.buffer.substr(e, 3)
          if (("---" === t || "..." === t) && ad(this.buffer[e + 3])) return -1
        }
        return e
      }
      getLine() {
        let e = this.lineEndPos
        return (
          ("number" != typeof e || (-1 !== e && e < this.pos)) &&
            ((e = this.buffer.indexOf("\n", this.pos)), (this.lineEndPos = e)),
          -1 === e
            ? this.atEnd
              ? this.buffer.substring(this.pos)
              : null
            : ("\r" === this.buffer[e - 1] && (e -= 1), this.buffer.substring(this.pos, e))
        )
      }
      hasChars(e) {
        return this.pos + e <= this.buffer.length
      }
      setNext(e) {
        return (
          (this.buffer = this.buffer.substring(this.pos)),
          (this.pos = 0),
          (this.lineEndPos = null),
          (this.next = e),
          null
        )
      }
      peek(e) {
        return this.buffer.substr(this.pos, e)
      }
      *parseNext(e) {
        switch (e) {
          case "stream":
            return yield* this.parseStream()
          case "line-start":
            return yield* this.parseLineStart()
          case "block-start":
            return yield* this.parseBlockStart()
          case "doc":
            return yield* this.parseDocument()
          case "flow":
            return yield* this.parseFlowCollection()
          case "quoted-scalar":
            return yield* this.parseQuotedScalar()
          case "block-scalar":
            return yield* this.parseBlockScalar()
          case "plain-scalar":
            return yield* this.parsePlainScalar()
        }
      }
      *parseStream() {
        let e = this.getLine()
        if (null === e) return this.setNext("stream")
        if (("\ufeff" === e[0] && (yield* this.pushCount(1), (e = e.substring(1))), "%" === e[0])) {
          let t = e.length,
            n = e.indexOf("#")
          for (; -1 !== n; ) {
            const r = e[n - 1]
            if (" " === r || "\t" === r) {
              t = n - 1
              break
            }
            n = e.indexOf("#", n + 1)
          }
          for (;;) {
            const n = e[t - 1]
            if (" " !== n && "\t" !== n) break
            t -= 1
          }
          const r = (yield* this.pushCount(t)) + (yield* this.pushSpaces(!0))
          return yield* this.pushCount(e.length - r), this.pushNewline(), "stream"
        }
        if (this.atLineEnd()) {
          const t = yield* this.pushSpaces(!0)
          return yield* this.pushCount(e.length - t), yield* this.pushNewline(), "stream"
        }
        return yield "", yield* this.parseLineStart()
      }
      *parseLineStart() {
        const e = this.charAt(0)
        if (!e && !this.atEnd) return this.setNext("line-start")
        if ("-" === e || "." === e) {
          if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start")
          const e = this.peek(3)
          if ("---" === e && ad(this.charAt(3)))
            return yield* this.pushCount(3), (this.indentValue = 0), (this.indentNext = 0), "doc"
          if ("..." === e && ad(this.charAt(3))) return yield* this.pushCount(3), "stream"
        }
        return (
          (this.indentValue = yield* this.pushSpaces(!1)),
          this.indentNext > this.indentValue && !ad(this.charAt(1)) && (this.indentNext = this.indentValue),
          yield* this.parseBlockStart()
        )
      }
      *parseBlockStart() {
        const [e, t] = this.peek(2)
        if (!t && !this.atEnd) return this.setNext("block-start")
        if (("-" === e || "?" === e || ":" === e) && ad(t)) {
          const e = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0))
          return (this.indentNext = this.indentValue + 1), (this.indentValue += e), yield* this.parseBlockStart()
        }
        return "doc"
      }
      *parseDocument() {
        yield* this.pushSpaces(!0)
        const e = this.getLine()
        if (null === e) return this.setNext("doc")
        let t = yield* this.pushIndicators()
        switch (e[t]) {
          case "#":
            yield* this.pushCount(e.length - t)
          case void 0:
            return yield* this.pushNewline(), yield* this.parseLineStart()
          case "{":
          case "[":
            return yield* this.pushCount(1), (this.flowKey = !1), (this.flowLevel = 1), "flow"
          case "}":
          case "]":
            return yield* this.pushCount(1), "doc"
          case "*":
            return yield* this.pushUntil(cd), "doc"
          case '"':
          case "'":
            return yield* this.parseQuotedScalar()
          case "|":
          case ">":
            return (
              (t += yield* this.parseBlockScalarHeader()),
              (t += yield* this.pushSpaces(!0)),
              yield* this.pushCount(e.length - t),
              yield* this.pushNewline(),
              yield* this.parseBlockScalar()
            )
          default:
            return yield* this.parsePlainScalar()
        }
      }
      *parseFlowCollection() {
        let e,
          t,
          n = -1
        do {
          ;(e = yield* this.pushNewline()),
            e > 0 ? ((t = yield* this.pushSpaces(!1)), (this.indentValue = n = t)) : (t = 0),
            (t += yield* this.pushSpaces(!0))
        } while (e + t > 0)
        const r = this.getLine()
        if (null === r) return this.setNext("flow")
        if (
          ((-1 !== n && n < this.indentNext && "#" !== r[0]) ||
            (0 === n && (r.startsWith("---") || r.startsWith("...")) && ad(r[3]))) &&
          (n !== this.indentNext - 1 || 1 !== this.flowLevel || ("]" !== r[0] && "}" !== r[0]))
        )
          return (this.flowLevel = 0), yield "", yield* this.parseLineStart()
        let a = 0
        for (; "," === r[a]; ) (a += yield* this.pushCount(1)), (a += yield* this.pushSpaces(!0)), (this.flowKey = !1)
        switch (((a += yield* this.pushIndicators()), r[a])) {
          case void 0:
            return "flow"
          case "#":
            return yield* this.pushCount(r.length - a), "flow"
          case "{":
          case "[":
            return yield* this.pushCount(1), (this.flowKey = !1), (this.flowLevel += 1), "flow"
          case "}":
          case "]":
            return yield* this.pushCount(1), (this.flowKey = !0), (this.flowLevel -= 1), this.flowLevel ? "flow" : "doc"
          case "*":
            return yield* this.pushUntil(cd), "flow"
          case '"':
          case "'":
            return (this.flowKey = !0), yield* this.parseQuotedScalar()
          case ":": {
            const e = this.charAt(1)
            if (this.flowKey || ad(e) || "," === e)
              return (this.flowKey = !1), yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow"
          }
          default:
            return (this.flowKey = !1), yield* this.parsePlainScalar()
        }
      }
      *parseQuotedScalar() {
        const e = this.charAt(0)
        let t = this.buffer.indexOf(e, this.pos + 1)
        if ("'" === e) for (; -1 !== t && "'" === this.buffer[t + 1]; ) t = this.buffer.indexOf("'", t + 2)
        else
          for (; -1 !== t; ) {
            let e = 0
            for (; "\\" === this.buffer[t - 1 - e]; ) e += 1
            if (e % 2 == 0) break
            t = this.buffer.indexOf('"', t + 1)
          }
        const n = this.buffer.substring(0, t)
        let r = n.indexOf("\n", this.pos)
        if (-1 !== r) {
          for (; -1 !== r; ) {
            const e = this.continueScalar(r + 1)
            if (-1 === e) break
            r = n.indexOf("\n", e)
          }
          ;-1 !== r && (t = r - ("\r" === n[r - 1] ? 2 : 1))
        }
        if (-1 === t) {
          if (!this.atEnd) return this.setNext("quoted-scalar")
          t = this.buffer.length
        }
        return yield* this.pushToIndex(t + 1, !1), this.flowLevel ? "flow" : "doc"
      }
      *parseBlockScalarHeader() {
        ;(this.blockScalarIndent = -1), (this.blockScalarKeep = !1)
        let e = this.pos
        for (;;) {
          const t = this.buffer[++e]
          if ("+" === t) this.blockScalarKeep = !0
          else if (t > "0" && t <= "9") this.blockScalarIndent = Number(t) - 1
          else if ("-" !== t) break
        }
        return yield* this.pushUntil((e) => ad(e) || "#" === e)
      }
      *parseBlockScalar() {
        let e,
          t = this.pos - 1,
          n = 0
        e: for (let r = this.pos; (e = this.buffer[r]); ++r)
          switch (e) {
            case " ":
              n += 1
              break
            case "\n":
              ;(t = r), (n = 0)
              break
            case "\r": {
              const e = this.buffer[r + 1]
              if (!e && !this.atEnd) return this.setNext("block-scalar")
              if ("\n" === e) break
            }
            default:
              break e
          }
        if (!e && !this.atEnd) return this.setNext("block-scalar")
        if (n >= this.indentNext) {
          ;-1 === this.blockScalarIndent
            ? (this.indentNext = n)
            : (this.indentNext = this.blockScalarIndent + (0 === this.indentNext ? 1 : this.indentNext))
          do {
            const e = this.continueScalar(t + 1)
            if (-1 === e) break
            t = this.buffer.indexOf("\n", e)
          } while (-1 !== t)
          if (-1 === t) {
            if (!this.atEnd) return this.setNext("block-scalar")
            t = this.buffer.length
          }
        }
        let r = t + 1
        for (e = this.buffer[r]; " " === e; ) e = this.buffer[++r]
        if ("\t" === e) {
          for (; "\t" === e || " " === e || "\r" === e || "\n" === e; ) e = this.buffer[++r]
          t = r - 1
        } else if (!this.blockScalarKeep)
          for (;;) {
            let e = t - 1,
              r = this.buffer[e]
            "\r" === r && (r = this.buffer[--e])
            const a = e
            for (; " " === r; ) r = this.buffer[--e]
            if (!("\n" === r && e >= this.pos && e + 1 + n > a)) break
            t = e
          }
        return yield "", yield* this.pushToIndex(t + 1, !0), yield* this.parseLineStart()
      }
      *parsePlainScalar() {
        const e = this.flowLevel > 0
        let t,
          n = this.pos - 1,
          r = this.pos - 1
        for (; (t = this.buffer[++r]); )
          if (":" === t) {
            const t = this.buffer[r + 1]
            if (ad(t) || (e && sd.has(t))) break
            n = r
          } else if (ad(t)) {
            let a = this.buffer[r + 1]
            if (
              ("\r" === t && ("\n" === a ? ((r += 1), (t = "\n"), (a = this.buffer[r + 1])) : (n = r)),
              "#" === a || (e && sd.has(a)))
            )
              break
            if ("\n" === t) {
              const e = this.continueScalar(r + 1)
              if (-1 === e) break
              r = Math.max(r, e - 2)
            }
          } else {
            if (e && sd.has(t)) break
            n = r
          }
        return t || this.atEnd
          ? (yield "", yield* this.pushToIndex(n + 1, !0), e ? "flow" : "doc")
          : this.setNext("plain-scalar")
      }
      *pushCount(e) {
        return e > 0 ? (yield this.buffer.substr(this.pos, e), (this.pos += e), e) : 0
      }
      *pushToIndex(e, t) {
        const n = this.buffer.slice(this.pos, e)
        return n ? (yield n, (this.pos += n.length), n.length) : (t && (yield ""), 0)
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators())
          case "&":
            return (yield* this.pushUntil(cd)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators())
          case "-":
          case "?":
          case ":": {
            const e = this.flowLevel > 0,
              t = this.charAt(1)
            if (ad(t) || (e && sd.has(t)))
              return (
                e ? this.flowKey && (this.flowKey = !1) : (this.indentNext = this.indentValue + 1),
                (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators())
              )
          }
        }
        return 0
      }
      *pushTag() {
        if ("<" === this.charAt(1)) {
          let e = this.pos + 2,
            t = this.buffer[e]
          for (; !ad(t) && ">" !== t; ) t = this.buffer[++e]
          return yield* this.pushToIndex(">" === t ? e + 1 : e, !1)
        }
        {
          let e = this.pos + 1,
            t = this.buffer[e]
          for (; t; )
            if (id.has(t)) t = this.buffer[++e]
            else {
              if ("%" !== t || !od.has(this.buffer[e + 1]) || !od.has(this.buffer[e + 2])) break
              t = this.buffer[(e += 3)]
            }
          return yield* this.pushToIndex(e, !1)
        }
      }
      *pushNewline() {
        const e = this.buffer[this.pos]
        return "\n" === e
          ? yield* this.pushCount(1)
          : "\r" === e && "\n" === this.charAt(1)
            ? yield* this.pushCount(2)
            : 0
      }
      *pushSpaces(e) {
        let t,
          n = this.pos - 1
        do {
          t = this.buffer[++n]
        } while (" " === t || (e && "\t" === t))
        const r = n - this.pos
        return r > 0 && (yield this.buffer.substr(this.pos, r), (this.pos = n)), r
      }
      *pushUntil(e) {
        let t = this.pos,
          n = this.buffer[t]
        for (; !e(n); ) n = this.buffer[++t]
        return yield* this.pushToIndex(t, !1)
      }
    }
    class ud {
      constructor() {
        ;(this.lineStarts = []),
          (this.addNewLine = (e) => this.lineStarts.push(e)),
          (this.linePos = (e) => {
            let t = 0,
              n = this.lineStarts.length
            for (; t < n; ) {
              const r = (t + n) >> 1
              this.lineStarts[r] < e ? (t = r + 1) : (n = r)
            }
            return this.lineStarts[t] === e
              ? { line: t + 1, col: 1 }
              : 0 === t
                ? { line: 0, col: e }
                : { line: t, col: e - this.lineStarts[t - 1] + 1 }
          })
      }
    }
    function pd(e, t) {
      for (let n = 0; n < e.length; ++n) if (e[n].type === t) return !0
      return !1
    }
    function hd(e) {
      for (let t = 0; t < e.length; ++t)
        switch (e[t].type) {
          case "space":
          case "comment":
          case "newline":
            break
          default:
            return t
        }
      return -1
    }
    function fd(e) {
      switch (null == e ? void 0 : e.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return !0
        default:
          return !1
      }
    }
    function md(e) {
      switch (e.type) {
        case "document":
          return e.start
        case "block-map": {
          const t = e.items[e.items.length - 1]
          return t.sep ?? t.start
        }
        case "block-seq":
          return e.items[e.items.length - 1].start
        default:
          return []
      }
    }
    function gd(e) {
      var t
      if (0 === e.length) return []
      let n = e.length
      e: for (; --n >= 0; )
        switch (e[n].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break e
        }
      for (; "space" === (null == (t = e[++n]) ? void 0 : t.type); );
      return e.splice(n, e.length)
    }
    function bd(e) {
      if ("flow-seq-start" === e.start.type)
        for (const t of e.items)
          !t.sep ||
            t.value ||
            pd(t.start, "explicit-key-ind") ||
            pd(t.sep, "map-value-ind") ||
            (t.key && (t.value = t.key),
            delete t.key,
            fd(t.value)
              ? t.value.end
                ? Array.prototype.push.apply(t.value.end, t.sep)
                : (t.value.end = t.sep)
              : Array.prototype.push.apply(t.start, t.sep),
            delete t.sep)
    }
    let vd = class {
      constructor(e) {
        ;(this.atNewLine = !0),
          (this.atScalar = !1),
          (this.indent = 0),
          (this.offset = 0),
          (this.onKeyLine = !1),
          (this.stack = []),
          (this.source = ""),
          (this.type = ""),
          (this.lexer = new dd()),
          (this.onNewLine = e)
      }
      *parse(e, t = !1) {
        this.onNewLine && 0 === this.offset && this.onNewLine(0)
        for (const n of this.lexer.lex(e, t)) yield* this.next(n)
        t || (yield* this.end())
      }
      *next(e) {
        if (((this.source = e), this.atScalar))
          return (this.atScalar = !1), yield* this.step(), void (this.offset += e.length)
        const t = (function (e) {
          switch (e) {
            case "\ufeff":
              return "byte-order-mark"
            case "":
              return "doc-mode"
            case "":
              return "flow-error-end"
            case "":
              return "scalar"
            case "---":
              return "doc-start"
            case "...":
              return "doc-end"
            case "":
            case "\n":
            case "\r\n":
              return "newline"
            case "-":
              return "seq-item-ind"
            case "?":
              return "explicit-key-ind"
            case ":":
              return "map-value-ind"
            case "{":
              return "flow-map-start"
            case "}":
              return "flow-map-end"
            case "[":
              return "flow-seq-start"
            case "]":
              return "flow-seq-end"
            case ",":
              return "comma"
          }
          switch (e[0]) {
            case " ":
            case "\t":
              return "space"
            case "#":
              return "comment"
            case "%":
              return "directive-line"
            case "*":
              return "alias"
            case "&":
              return "anchor"
            case "!":
              return "tag"
            case "'":
              return "single-quoted-scalar"
            case '"':
              return "double-quoted-scalar"
            case "|":
            case ">":
              return "block-scalar-header"
          }
          return null
        })(e)
        if (t)
          if ("scalar" === t) (this.atNewLine = !1), (this.atScalar = !0), (this.type = "scalar")
          else {
            switch (((this.type = t), yield* this.step(), t)) {
              case "newline":
                ;(this.atNewLine = !0), (this.indent = 0), this.onNewLine && this.onNewLine(this.offset + e.length)
                break
              case "space":
                this.atNewLine && " " === e[0] && (this.indent += e.length)
                break
              case "explicit-key-ind":
              case "map-value-ind":
              case "seq-item-ind":
                this.atNewLine && (this.indent += e.length)
                break
              case "doc-mode":
              case "flow-error-end":
                return
              default:
                this.atNewLine = !1
            }
            this.offset += e.length
          }
        else {
          const t = `Not a YAML token: ${e}`
          yield* this.pop({ type: "error", offset: this.offset, message: t, source: e }), (this.offset += e.length)
        }
      }
      *end() {
        for (; this.stack.length > 0; ) yield* this.pop()
      }
      get sourceToken() {
        return { type: this.type, offset: this.offset, indent: this.indent, source: this.source }
      }
      *step() {
        const e = this.peek(1)
        if ("doc-end" !== this.type || (e && "doc-end" === e.type)) {
          if (!e) return yield* this.stream()
          switch (e.type) {
            case "document":
              return yield* this.document(e)
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
              return yield* this.scalar(e)
            case "block-scalar":
              return yield* this.blockScalar(e)
            case "block-map":
              return yield* this.blockMap(e)
            case "block-seq":
              return yield* this.blockSequence(e)
            case "flow-collection":
              return yield* this.flowCollection(e)
            case "doc-end":
              return yield* this.documentEnd(e)
          }
          yield* this.pop()
        } else {
          for (; this.stack.length > 0; ) yield* this.pop()
          this.stack.push({ type: "doc-end", offset: this.offset, source: this.source })
        }
      }
      peek(e) {
        return this.stack[this.stack.length - e]
      }
      *pop(e) {
        const t = e ?? this.stack.pop()
        if (t)
          if (0 === this.stack.length) yield t
          else {
            const e = this.peek(1)
            switch (
              ("block-scalar" === t.type
                ? (t.indent = "indent" in e ? e.indent : 0)
                : "flow-collection" === t.type && "document" === e.type && (t.indent = 0),
              "flow-collection" === t.type && bd(t),
              e.type)
            ) {
              case "document":
                e.value = t
                break
              case "block-scalar":
                e.props.push(t)
                break
              case "block-map": {
                const n = e.items[e.items.length - 1]
                if (n.value) return e.items.push({ start: [], key: t, sep: [] }), void (this.onKeyLine = !0)
                if (!n.sep) return Object.assign(n, { key: t, sep: [] }), void (this.onKeyLine = !n.explicitKey)
                n.value = t
                break
              }
              case "block-seq": {
                const n = e.items[e.items.length - 1]
                n.value ? e.items.push({ start: [], value: t }) : (n.value = t)
                break
              }
              case "flow-collection": {
                const n = e.items[e.items.length - 1]
                return void (!n || n.value
                  ? e.items.push({ start: [], key: t, sep: [] })
                  : n.sep
                    ? (n.value = t)
                    : Object.assign(n, { key: t, sep: [] }))
              }
              default:
                yield* this.pop(), yield* this.pop(t)
            }
            if (
              !(
                ("document" !== e.type && "block-map" !== e.type && "block-seq" !== e.type) ||
                ("block-map" !== t.type && "block-seq" !== t.type)
              )
            ) {
              const n = t.items[t.items.length - 1]
              n &&
                !n.sep &&
                !n.value &&
                n.start.length > 0 &&
                -1 === hd(n.start) &&
                (0 === t.indent || n.start.every((e) => "comment" !== e.type || e.indent < t.indent)) &&
                ("document" === e.type ? (e.end = n.start) : e.items.push({ start: n.start }), t.items.splice(-1, 1))
            }
          }
        else {
          const e = "Tried to pop an empty stack"
          yield { type: "error", offset: this.offset, source: "", message: e }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            return void (yield { type: "directive", offset: this.offset, source: this.source })
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            return void (yield this.sourceToken)
          case "doc-mode":
          case "doc-start": {
            const e = { type: "document", offset: this.offset, start: [] }
            return "doc-start" === this.type && e.start.push(this.sourceToken), void this.stack.push(e)
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source,
        }
      }
      *document(e) {
        if (e.value) return yield* this.lineEnd(e)
        switch (this.type) {
          case "doc-start":
            return void (-1 !== hd(e.start) ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken))
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            return void e.start.push(this.sourceToken)
        }
        const t = this.startBlockValue(e)
        t
          ? this.stack.push(t)
          : yield {
              type: "error",
              offset: this.offset,
              message: `Unexpected ${this.type} token in YAML document`,
              source: this.source,
            }
      }
      *scalar(e) {
        if ("map-value-ind" === this.type) {
          const t = gd(md(this.peek(2)))
          let n
          e.end ? ((n = e.end), n.push(this.sourceToken), delete e.end) : (n = [this.sourceToken])
          const r = { type: "block-map", offset: e.offset, indent: e.indent, items: [{ start: t, key: e, sep: n }] }
          ;(this.onKeyLine = !0), (this.stack[this.stack.length - 1] = r)
        } else yield* this.lineEnd(e)
      }
      *blockScalar(e) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            return void e.props.push(this.sourceToken)
          case "scalar":
            if (((e.source = this.source), (this.atNewLine = !0), (this.indent = 0), this.onNewLine)) {
              let e = this.source.indexOf("\n") + 1
              for (; 0 !== e; ) this.onNewLine(this.offset + e), (e = this.source.indexOf("\n", e) + 1)
            }
            yield* this.pop()
            break
          default:
            yield* this.pop(), yield* this.step()
        }
      }
      *blockMap(e) {
        var t
        const n = e.items[e.items.length - 1]
        switch (this.type) {
          case "newline":
            if (((this.onKeyLine = !1), n.value)) {
              const t = "end" in n.value ? n.value.end : void 0,
                r = Array.isArray(t) ? t[t.length - 1] : void 0
              "comment" === (null == r ? void 0 : r.type)
                ? null == t || t.push(this.sourceToken)
                : e.items.push({ start: [this.sourceToken] })
            } else n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken)
            return
          case "space":
          case "comment":
            if (n.value) e.items.push({ start: [this.sourceToken] })
            else if (n.sep) n.sep.push(this.sourceToken)
            else {
              if (this.atIndentedComment(n.start, e.indent)) {
                const r = e.items[e.items.length - 2],
                  a = null == (t = null == r ? void 0 : r.value) ? void 0 : t.end
                if (Array.isArray(a))
                  return Array.prototype.push.apply(a, n.start), a.push(this.sourceToken), void e.items.pop()
              }
              n.start.push(this.sourceToken)
            }
            return
        }
        if (this.indent >= e.indent) {
          const t = !this.onKeyLine && this.indent === e.indent,
            r = t && (n.sep || n.explicitKey) && "seq-item-ind" !== this.type
          let a = []
          if (r && n.sep && !n.value) {
            const t = []
            for (let r = 0; r < n.sep.length; ++r) {
              const a = n.sep[r]
              switch (a.type) {
                case "newline":
                  t.push(r)
                  break
                case "space":
                  break
                case "comment":
                  a.indent > e.indent && (t.length = 0)
                  break
                default:
                  t.length = 0
              }
            }
            t.length >= 2 && (a = n.sep.splice(t[1]))
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              return void (r || n.value
                ? (a.push(this.sourceToken), e.items.push({ start: a }), (this.onKeyLine = !0))
                : n.sep
                  ? n.sep.push(this.sourceToken)
                  : n.start.push(this.sourceToken))
            case "explicit-key-ind":
              return (
                n.sep || n.explicitKey
                  ? r || n.value
                    ? (a.push(this.sourceToken), e.items.push({ start: a, explicitKey: !0 }))
                    : this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [{ start: [this.sourceToken], explicitKey: !0 }],
                      })
                  : (n.start.push(this.sourceToken), (n.explicitKey = !0)),
                void (this.onKeyLine = !0)
              )
            case "map-value-ind":
              if (n.explicitKey)
                if (n.sep)
                  if (n.value) e.items.push({ start: [], key: null, sep: [this.sourceToken] })
                  else if (pd(n.sep, "map-value-ind"))
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: a, key: null, sep: [this.sourceToken] }],
                    })
                  else if (fd(n.key) && !pd(n.sep, "newline")) {
                    const e = gd(n.start),
                      t = n.key,
                      r = n.sep
                    r.push(this.sourceToken),
                      delete n.key,
                      delete n.sep,
                      this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [{ start: e, key: t, sep: r }],
                      })
                  } else a.length > 0 ? (n.sep = n.sep.concat(a, this.sourceToken)) : n.sep.push(this.sourceToken)
                else if (pd(n.start, "newline")) Object.assign(n, { key: null, sep: [this.sourceToken] })
                else {
                  const e = gd(n.start)
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: e, key: null, sep: [this.sourceToken] }],
                  })
                }
              else
                n.sep
                  ? n.value || r
                    ? e.items.push({ start: a, key: null, sep: [this.sourceToken] })
                    : pd(n.sep, "map-value-ind")
                      ? this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [{ start: [], key: null, sep: [this.sourceToken] }],
                        })
                      : n.sep.push(this.sourceToken)
                  : Object.assign(n, { key: null, sep: [this.sourceToken] })
              return void (this.onKeyLine = !0)
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const t = this.flowScalar(this.type)
              return void (r || n.value
                ? (e.items.push({ start: a, key: t, sep: [] }), (this.onKeyLine = !0))
                : n.sep
                  ? this.stack.push(t)
                  : (Object.assign(n, { key: t, sep: [] }), (this.onKeyLine = !0)))
            }
            default: {
              const n = this.startBlockValue(e)
              if (n) return t && "block-seq" !== n.type && e.items.push({ start: a }), void this.stack.push(n)
            }
          }
        }
        yield* this.pop(), yield* this.step()
      }
      *blockSequence(e) {
        var t
        const n = e.items[e.items.length - 1]
        switch (this.type) {
          case "newline":
            if (n.value) {
              const t = "end" in n.value ? n.value.end : void 0,
                r = Array.isArray(t) ? t[t.length - 1] : void 0
              "comment" === (null == r ? void 0 : r.type)
                ? null == t || t.push(this.sourceToken)
                : e.items.push({ start: [this.sourceToken] })
            } else n.start.push(this.sourceToken)
            return
          case "space":
          case "comment":
            if (n.value) e.items.push({ start: [this.sourceToken] })
            else {
              if (this.atIndentedComment(n.start, e.indent)) {
                const r = e.items[e.items.length - 2],
                  a = null == (t = null == r ? void 0 : r.value) ? void 0 : t.end
                if (Array.isArray(a))
                  return Array.prototype.push.apply(a, n.start), a.push(this.sourceToken), void e.items.pop()
              }
              n.start.push(this.sourceToken)
            }
            return
          case "anchor":
          case "tag":
            if (n.value || this.indent <= e.indent) break
            return void n.start.push(this.sourceToken)
          case "seq-item-ind":
            if (this.indent !== e.indent) break
            return void (n.value || pd(n.start, "seq-item-ind")
              ? e.items.push({ start: [this.sourceToken] })
              : n.start.push(this.sourceToken))
        }
        if (this.indent > e.indent) {
          const t = this.startBlockValue(e)
          if (t) return void this.stack.push(t)
        }
        yield* this.pop(), yield* this.step()
      }
      *flowCollection(e) {
        const t = e.items[e.items.length - 1]
        if ("flow-error-end" === this.type) {
          let e
          do {
            yield* this.pop(), (e = this.peek(1))
          } while (e && "flow-collection" === e.type)
        } else if (0 === e.end.length) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              return void (!t || t.sep ? e.items.push({ start: [this.sourceToken] }) : t.start.push(this.sourceToken))
            case "map-value-ind":
              return void (!t || t.value
                ? e.items.push({ start: [], key: null, sep: [this.sourceToken] })
                : t.sep
                  ? t.sep.push(this.sourceToken)
                  : Object.assign(t, { key: null, sep: [this.sourceToken] }))
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              return void (!t || t.value
                ? e.items.push({ start: [this.sourceToken] })
                : t.sep
                  ? t.sep.push(this.sourceToken)
                  : t.start.push(this.sourceToken))
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const n = this.flowScalar(this.type)
              return void (!t || t.value
                ? e.items.push({ start: [], key: n, sep: [] })
                : t.sep
                  ? this.stack.push(n)
                  : Object.assign(t, { key: n, sep: [] }))
            }
            case "flow-map-end":
            case "flow-seq-end":
              return void e.end.push(this.sourceToken)
          }
          const n = this.startBlockValue(e)
          n ? this.stack.push(n) : (yield* this.pop(), yield* this.step())
        } else {
          const t = this.peek(2)
          if (
            "block-map" === t.type &&
            (("map-value-ind" === this.type && t.indent === e.indent) ||
              ("newline" === this.type && !t.items[t.items.length - 1].sep))
          )
            yield* this.pop(), yield* this.step()
          else if ("map-value-ind" === this.type && "flow-collection" !== t.type) {
            const n = gd(md(t))
            bd(e)
            const r = e.end.splice(1, e.end.length)
            r.push(this.sourceToken)
            const a = { type: "block-map", offset: e.offset, indent: e.indent, items: [{ start: n, key: e, sep: r }] }
            ;(this.onKeyLine = !0), (this.stack[this.stack.length - 1] = a)
          } else yield* this.lineEnd(e)
        }
      }
      flowScalar(e) {
        if (this.onNewLine) {
          let e = this.source.indexOf("\n") + 1
          for (; 0 !== e; ) this.onNewLine(this.offset + e), (e = this.source.indexOf("\n", e) + 1)
        }
        return { type: e, offset: this.offset, indent: this.indent, source: this.source }
      }
      startBlockValue(e) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type)
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: "",
            }
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: [],
            }
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }],
            }
          case "explicit-key-ind": {
            this.onKeyLine = !0
            const t = gd(md(e))
            return (
              t.push(this.sourceToken),
              { type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: t, explicitKey: !0 }] }
            )
          }
          case "map-value-ind": {
            this.onKeyLine = !0
            const t = gd(md(e))
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: t, key: null, sep: [this.sourceToken] }],
            }
          }
        }
        return null
      }
      atIndentedComment(e, t) {
        return (
          "comment" === this.type && !(this.indent <= t) && e.every((e) => "newline" === e.type || "space" === e.type)
        )
      }
      *documentEnd(e) {
        "doc-mode" !== this.type &&
          (e.end ? e.end.push(this.sourceToken) : (e.end = [this.sourceToken]),
          "newline" === this.type && (yield* this.pop()))
      }
      *lineEnd(e) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop(), yield* this.step()
            break
          case "newline":
            this.onKeyLine = !1
          default:
            e.end ? e.end.push(this.sourceToken) : (e.end = [this.sourceToken]),
              "newline" === this.type && (yield* this.pop())
        }
      }
    }
    function yd(e, t, n) {
      let r
      "function" == typeof t ? (r = t) : void 0 === n && t && "object" == typeof t && (n = t)
      const a = (function (e, t = {}) {
        const { lineCounter: n, prettyErrors: r } = (function (e) {
            const t = !1 !== e.prettyErrors
            return { lineCounter: e.lineCounter || (t && new ud()) || null, prettyErrors: t }
          })(t),
          a = new vd(null == n ? void 0 : n.addNewLine),
          o = new rd(t)
        let i = null
        for (const t of o.compose(a.parse(e), !0, e.length))
          if (i) {
            if ("silent" !== i.options.logLevel) {
              i.errors.push(
                new $c(
                  t.range.slice(0, 2),
                  "MULTIPLE_DOCS",
                  "Source contains multiple documents; please use YAML.parseAllDocuments()",
                ),
              )
              break
            }
          } else i = t
        return r && n && (i.errors.forEach(Mc(e, n)), i.warnings.forEach(Mc(e, n))), i
      })(e, n)
      if (!a) return null
      if ((a.warnings.forEach((e) => Ol(a.options.logLevel, e)), a.errors.length > 0)) {
        if ("silent" !== a.options.logLevel) throw a.errors[0]
        a.errors = []
      }
      return a.toJS(Object.assign({ reviver: r }, n))
    }
    const Od = {
        parse: (e) => {
          const t = yd(e)
          if ("object" != typeof t) throw Error("Invalid YAML object")
          return t
        },
        parseSafe(e, t) {
          try {
            return Od.parse(e)
          } catch (e) {
            return "function" == typeof t ? t(e) : t
          }
        },
        stringify: function (e, t, n) {
          let r = null
          if (
            ("function" == typeof t || Array.isArray(t) ? (r = t) : void 0 === n && t && (n = t),
            "string" == typeof n && (n = n.length),
            "number" == typeof n)
          ) {
            const e = Math.round(n)
            n = e < 1 ? void 0 : e > 8 ? { indent: 8 } : { indent: e }
          }
          if (void 0 === e) {
            const { keepUndefined: e } = n ?? t ?? {}
            if (!e) return
          }
          return new Dc(e, r, n).toString(n)
        },
      },
      wd = {
        parse: (e) => {
          const t = JSON.parse(e)
          if ("object" != typeof t) throw Error("Invalid JSON object")
          return t
        },
        parseSafe(e, t) {
          try {
            return wd.parse(e)
          } catch (e) {
            return "function" == typeof t ? t(e) : t
          }
        },
        stringify: (e) => JSON.stringify(e),
      },
      xd = (e) => "string" == typeof e && !!wd.parseSafe(e, !1),
      kd = "https://api.scalar.com/request-proxy",
      _d = "https://proxy.scalar.com"
    async function Sd(e, t) {
      t === kd && (t = _d)
      const n = await fetch(t ? gs(t, e) : e)
      return (
        200 !== n.status &&
          (console.error(`[fetchSpecFromUrl] Failed to fetch the specification at ${e} (Status: ${n.status})`),
          t ||
            console.warn(
              `[fetchSpecFromUrl] Tried to fetch the specification (url: ${e}) without a proxy. Are the CORS headers configured to allow cross-domain requests? https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS`,
            )),
        (function (e) {
          if ("{" !== e.trim()[0]) return e
          try {
            return JSON.stringify(JSON.parse(e), null, 2)
          } catch {
            return e
          }
        })(await n.text())
      )
    }
    const Ed = {
        CONNECT: { short: "CONN", color: "text-c-2", backgroundColor: "bg-c-2" },
        DELETE: { short: "DEL", color: "text-red", backgroundColor: "bg-red" },
        GET: { short: "GET", color: "text-blue", backgroundColor: "bg-blue" },
        HEAD: { short: "HEAD", color: "text-scalar-c-2", backgroundColor: "bg-c-2" },
        OPTIONS: { short: "OPTS", color: "text-purple", backgroundColor: "bg-purple" },
        PATCH: { short: "PATCH", color: "text-yellow", backgroundColor: "bg-yellow" },
        POST: { short: "POST", color: "text-green", backgroundColor: "bg-green" },
        PUT: { short: "PUT", color: "text-orange", backgroundColor: "bg-orange" },
        TRACE: { short: "TRACE", color: "text-c-2", backgroundColor: "bg-c-2" },
      },
      Td = {
        100: { name: "Continue", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100" },
        101: { name: "Switching Protocols", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101" },
        102: { name: "Processing", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/102" },
        103: { name: "Early Hints", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103" },
        200: { name: "OK", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200" },
        201: { name: "Created", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201" },
        202: { name: "Accepted", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202" },
        203: {
          name: "Non-Authoritative Information",
          url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203",
        },
        204: { name: "No Content", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204" },
        205: { name: "Reset Content", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205" },
        206: { name: "Partial Content", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206" },
        207: { name: "Multi-Status", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/207" },
        208: { name: "Already Reported", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208" },
        226: { name: "IM Used", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226" },
        300: { name: "Multiple Choices", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300" },
        301: { name: "Moved Permanently", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301" },
        302: { name: "Found", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302" },
        303: { name: "See Other", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303" },
        304: { name: "Not Modified", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304" },
        305: { name: "Use Proxy", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/305" },
        306: { name: "(Unused)", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/306" },
        307: { name: "Temporary Redirect", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307" },
        308: { name: "Permanent Redirect", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308" },
        400: { name: "Bad Request", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400" },
        401: { name: "Unauthorized", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" },
        402: { name: "Payment Required", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402" },
        403: { name: "Forbidden", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" },
        404: { name: "Not Found", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404" },
        405: { name: "Method Not Allowed", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405" },
        406: { name: "Not Acceptable", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406" },
        407: {
          name: "Proxy Authentication Required",
          url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407",
        },
        408: { name: "Request Timeout", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408" },
        409: { name: "Conflict", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409" },
        410: { name: "Gone", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410" },
        411: { name: "Length Required", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411" },
        412: { name: "Precondition Failed", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412" },
        413: { name: "Content Too Large", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413" },
        414: { name: "URI Too Long", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414" },
        415: { name: "Unsupported Media Type", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415" },
        416: { name: "Range Not Satisfiable", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416" },
        417: { name: "Expectation Failed", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417" },
        421: { name: "Misdirected Request", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/421" },
        422: { name: "Unprocessable Content", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422" },
        423: { name: "Locked", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/423" },
        424: { name: "Failed Dependency", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/424" },
        425: { name: "Too Early", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/425" },
        426: { name: "Upgrade Required", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426" },
        428: { name: "Precondition Required", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428" },
        429: { name: "Too Many Requests", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429" },
        431: {
          name: "Request Header Fields Too Large",
          url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431",
        },
        451: {
          name: "Unavailable For Legal Reasons",
          url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451",
        },
        500: { name: "Internal Server Error", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500" },
        501: { name: "Not Implemented", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501" },
        502: { name: "Bad Gateway", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502" },
        503: { name: "Service Unavailable", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503" },
        504: { name: "Gateway Timeout", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504" },
        505: {
          name: "HTTP Version Not Supported",
          url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505",
        },
        506: { name: "Variant Also Negotiates", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506" },
        507: { name: "Insufficient Storage", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507" },
        508: { name: "Loop Detected", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508" },
        510: { name: "Not Extended", url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510" },
        511: {
          name: "Network Authentication Required",
          url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511",
        },
      },
      Ad = (e, t, n = " #") => {
        if (!t(e)) return e
        const r = e.split(n),
          a = r.length > 1 ? `${r.slice(0, -1).join()}${n}${Number(r.at(-1)) + 1}` : `${r.join()}${n}2`
        return Ad(a, t, n)
      }
    function Cd(e) {
      if (!e) return e
      const t = { ...e }
      return (
        Object.keys(t).forEach((e) => {
          const n = (function (e) {
            if ("string" == typeof e)
              return e
                .replace(/;.*$/, "")
                .replace(/\/.+\+/, "/")
                .trim()
          })(e)
          void 0 !== n && ((t[n] = t[e]), e !== n && delete t[e])
        }),
        t
      )
    }
    function Pd(e, t) {
      return (
        Object.keys(e).forEach((n) => {
          Object.hasOwn(t, n) || delete e[n]
        }),
        Object.assign(e, t),
        e
      )
    }
    const Dd = (e) => {
      if ("string" == typeof e) return xd(e) ? JSON.stringify(JSON.parse(e), null, 2) : e
      if ("object" == typeof e)
        try {
          return JSON.stringify(e, null, 2)
        } catch {
          return (function (e) {
            const t = new Set()
            return JSON.stringify(
              e,
              (e, n) => {
                if ("object" == typeof n && null !== n) {
                  if (t.has(n)) return "[Circular]"
                  t.add(n)
                }
                return n
              },
              2,
            )
          })(e)
        }
      return e.toString()
    }
    function Rd(e, t) {
      const n = (e, n) => {
        var r
        return "function" == typeof t ? t(n) : null == (r = t[n]) ? void 0 : r.toString()
      }
      return e.replace(/{{\s*([\w.-]+)\s*}}/g, n).replace(/{\s*([\w.-]+)\s*}/g, n)
    }
    const Nd = "undefined" != typeof window ? (window.__SCALAR__ ?? {}) : {}
    function $d(e) {
      var t
      const n = null == (t = null == e ? void 0 : e.servers) ? void 0 : t[e.selectedServer ?? 0]
      return "string" == typeof (null == n ? void 0 : n.url)
        ? Rd(null == n ? void 0 : n.url, e.variables)
        : null == n
          ? void 0
          : n.url
    }
    const Id = "GET",
      Md = (e) => {
        if ("string" != typeof e) return console.warn(`Request method is not a string. Using ${Id} as the default.`), Id
        const t = e.trim().toUpperCase()
        return (
          (n = t),
          ls.includes(n) ? t : (console.warn(`${e} is not a valid request method. Using ${Id} as the default.`), Id)
        )
        var n
      },
      Ld = mn({ showApiClient: !1, activeApiClientEndpointId: "", activeItem: {}, snippetType: "javascript" })
    function Qd(e, t = !1) {
      ;(Ld.showApiClient = !!t || !Ld.showApiClient), e && (Ld.activeItem = e)
    }
    function Bd() {
      Ld.showApiClient = !1
    }
    function jd(e) {
      Ld.activeApiClientEndpointId = e
    }
    function Ud(e) {
      Ld.snippetType = e
    }
    const Fd = () => ({
        state: bn(Ld),
        toggleApiClient: Qd,
        setActiveApiClientEndpointId: jd,
        setSnippetType: Ud,
        hideApiClient: Bd,
      }),
      zd = mn(
        Nd["useGlobalStore-authentication"] ?? {
          preferredSecurityScheme: null,
          customSecurity: !1,
          http: { basic: { username: "", password: "" }, bearer: { token: "" } },
          apiKey: { token: "" },
          oAuth2: { username: "", password: "", clientId: "", scopes: [], accessToken: "", state: "" },
        },
      ),
      qd = (e) => Object.assign(zd, e),
      Zd = () => ({ authentication: zd, setAuthentication: qd }),
      Hd = mn({ operation: {}, globalSecurity: [] }),
      Vd = (e) => {
        Object.assign(Hd, { ...Hd, operation: e })
      },
      Wd = (e) => {
        Object.assign(Hd, { ...Hd, globalSecurity: e })
      },
      Xd = () => ({ openApi: Hd, setOperation: Vd, setGlobalSecurity: Wd }),
      Yd = mn({}),
      Gd = Dn([]),
      Kd = Dn(""),
      Jd = mn({
        name: "",
        url: "",
        type: "GET",
        path: "",
        variables: [],
        headers: [],
        query: [],
        body: "",
        formData: [],
      }),
      eu = ii(() => {
        var e
        return Kd.value ? (null == (e = Yd[Kd.value ?? ""]) ? void 0 : e.response) : null
      }),
      tu = Dn(!0),
      nu = mn({ selectedServer: null, servers: [], variables: {} }),
      ru = (e) => {
        Object.assign(nu, { ...nu, ...e })
      },
      au = () => ({ server: nu, setServer: ru }),
      ou =
        "/* basic theme */\n.light-mode {\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f6f6f6;\n  --scalar-background-3: #e7e7e7;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: #0099ff;\n  --scalar-border-color: rgba(0, 0, 0, 0.1);\n}\n.dark-mode {\n  --scalar-background-1: #0f0f0f;\n  --scalar-background-2: #1a1a1a;\n  --scalar-background-3: #272727;\n\n  --scalar-color-1: rgba(255, 255, 255, 0.9);\n  --scalar-color-2: rgba(255, 255, 255, 0.62);\n  --scalar-color-3: rgba(255, 255, 255, 0.44);\n\n  --scalar-color-accent: #3ea6ff;\n  --scalar-background-accent: #3ea6ff1f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-2);\n  --scalar-sidebar-color-active: var(--scalar-color-1);\n\n  --scalar-sidebar-search-background: transparent;\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n}\n\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n",
      iu = [
        ["--theme-", "--scalar-"],
        ["--sidebar-", "--scalar-sidebar-"],
      ],
      su = iu.map(([e]) => e),
      lu = {
        default: "Default",
        alternate: "Alternate",
        moon: "Moon",
        purple: "Purple",
        solarized: "Solarized",
        bluePlanet: "Blue Planet",
        saturn: "Saturn",
        kepler: "Kepler-11e",
        mars: "Mars",
        deepSpace: "Deep Space",
        none: "",
      },
      cu = {
        alternate:
          "/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode,\n.light-mode .dark-mode {\n  --scalar-background-1: #f9f9f9;\n  --scalar-background-2: #f1f1f1;\n  --scalar-background-3: #e7e7e7;\n  --scalar-background-card: #fff;\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: var(--scalar-background-3);\n\n  --scalar-border-color: rgba(0, 0, 0, 0.1);\n}\n.dark-mode {\n  --scalar-background-1: #131313;\n  --scalar-background-2: #1d1d1d;\n  --scalar-background-3: #272727;\n  --scalar-background-card: #1d1d1d;\n\n  --scalar-color-1: rgba(255, 255, 255, 0.9);\n  --scalar-color-2: rgba(255, 255, 255, 0.62);\n  --scalar-color-3: rgba(255, 255, 255, 0.44);\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: var(--scalar-background-3);\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: transparent;\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);\n  --scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);\n  --scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color);\n}\n/* advanced */\n.light-mode .dark-mode,\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dd2f2c;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n\n.scalar-api-client__item,\n.scalar-card,\n.dark-mode .dark-mode.scalar-card {\n  --scalar-background-1: var(--scalar-background-card);\n  --scalar-background-2: var(--scalar-background-1);\n  --scalar-background-3: var(--scalar-background-1);\n}\n.dark-mode .dark-mode.scalar-card {\n  --scalar-background-3: var(--scalar-background-3);\n}\n.t-doc__sidebar {\n  --scalar-color-green: var(--scalar-color-1);\n  --scalar-color-red: var(--scalar-color-1);\n  --scalar-color-yellow: var(--scalar-color-1);\n  --scalar-color-blue: var(--scalar-color-1);\n  --scalar-color-orange: var(--scalar-color-1);\n  --scalar-color-purple: var(--scalar-color-1);\n}\n",
        default: ou,
        moon: ".light-mode {\n  color-scheme: light;\n  --scalar-color-1: #000000;\n  --scalar-color-2: #000000;\n  --scalar-color-3: #000000;\n  --scalar-color-accent: #645b0f;\n  --scalar-background-1: #ccc9b3;\n  --scalar-background-2: #c2bfaa;\n  --scalar-background-3: #b8b5a1;\n  --scalar-background-accent: #000000;\n\n  --scalar-border-color: rgba(0, 0, 0, 0.2);\n  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);\n  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);\n  --scalar-lifted-brightness: 1;\n  --scalar-backdrop-brightness: 1;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,\n    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, var(--scalar-border-color) 0px 0 0 1px;\n\n  --scalar-button-1: rgb(49 53 56);\n  --scalar-button-1-color: #fff;\n  --scalar-button-1-hover: rgb(28 31 33);\n\n  --scalar-color-red: #b91c1c;\n  --scalar-color-orange: #a16207;\n  --scalar-color-green: #047857;\n  --scalar-color-blue: #1d4ed8;\n  --scalar-color-orange: #c2410c;\n  --scalar-color-purple: #6d28d9;\n}\n\n.dark-mode {\n  color-scheme: dark;\n  --scalar-color-1: #fffef3;\n  --scalar-color-2: #fffef3;\n  --scalar-color-3: #fffef3;\n  --scalar-color-accent: #c3b531;\n  --scalar-background-1: #313332;\n  --scalar-background-2: #393b3a;\n  --scalar-background-3: #414342;\n  --scalar-background-accent: #fffef3;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);\n  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);\n  --scalar-lifted-brightness: 1.45;\n  --scalar-backdrop-brightness: 0.5;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,\n    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);\n\n  --scalar-button-1: #f6f6f6;\n  --scalar-button-1-color: #000;\n  --scalar-button-1-hover: #e7e7e7;\n\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n}\n\n/* Sidebar */\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-sidebar-background-1);\n  --scalar-sidebar-search-background: var(--scalar-background-3);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n\n.dark-mode .sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-sidebar-background-1);\n  --scalar-sidebar-search-background: var(--scalar-background-3);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n",
        purple:
          "/* basic theme */\n.light-mode {\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f5f6f8;\n  --scalar-background-3: #eceef1;\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: #5469d4;\n  --scalar-background-accent: #5469d41f;\n\n  --scalar-border-color: rgba(215, 215, 206, 0.5);\n}\n.dark-mode {\n  --scalar-background-1: #15171c;\n  --scalar-background-2: #1c1e24;\n  --scalar-background-3: #22252b;\n\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: #c9ced8;\n  --scalar-color-3: #8c99ad;\n\n  --scalar-color-accent: #5469d4;\n  --scalar-background-accent: #5469d41f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-3);\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: var(--scalar-background-1);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n}\n\n/* advanced */\n.light-mode {\n  --scalar-color-green: #17803d;\n  --scalar-color-red: #e10909;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #1763a6;\n  --scalar-color-orange: #e25b09;\n  --scalar-color-purple: #5c3993;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #30a159;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #eec644;\n  --scalar-color-blue: #2b7abf;\n  --scalar-color-orange: #f07528;\n  --scalar-color-purple: #7a59b1;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n",
        solarized:
          ".light-mode {\n  color-scheme: light;\n  --scalar-color-1: #584c27;\n  --scalar-color-2: #616161;\n  --scalar-color-3: #a89f84;\n  --scalar-color-accent: #b58900;\n  --scalar-background-1: #fdf6e3;\n  --scalar-background-2: #eee8d5;\n  --scalar-background-3: #ddd6c1;\n  --scalar-background-accent: #b589001f;\n\n  --scalar-border-color: #ded8c8;\n  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);\n  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);\n  --scalar-lifted-brightness: 1;\n  --scalar-backdrop-brightness: 1;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,\n    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;\n\n  --scalar-button-1: rgb(49 53 56);\n  --scalar-button-1-color: #fff;\n  --scalar-button-1-hover: rgb(28 31 33);\n\n  --scalar-color-red: #b91c1c;\n  --scalar-color-orange: #a16207;\n  --scalar-color-green: #047857;\n  --scalar-color-blue: #1d4ed8;\n  --scalar-color-orange: #c2410c;\n  --scalar-color-purple: #6d28d9;\n}\n\n.dark-mode {\n  color-scheme: dark;\n  --scalar-color-1: #fff;\n  --scalar-color-2: #cccccc;\n  --scalar-color-3: #6d8890;\n  --scalar-color-accent: #007acc;\n  --scalar-background-1: #00212b;\n  --scalar-background-2: #012b36;\n  --scalar-background-3: #004052;\n  --scalar-background-accent: #015a6f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);\n  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);\n  --scalar-lifted-brightness: 1.45;\n  --scalar-backdrop-brightness: 0.5;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);\n  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,\n    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);\n\n  --scalar-button-1: #f6f6f6;\n  --scalar-button-1-color: #000;\n  --scalar-button-1-hover: #e7e7e7;\n\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n}\n\n/* Sidebar */\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n  --scalar-sidebar-search-background: var(--scalar-background-2);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n\n.dark-mode .sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-sidebar-color-1);\n  --scalar-sidebar-search-background: var(--scalar-background-2);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n",
        bluePlanet:
          "/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode {\n  --scalar-background-1: #f0f2f5;\n  --scalar-background-2: #eaecf0;\n  --scalar-background-3: #e0e2e6;\n  --scalar-border-color: rgb(228, 228, 231);\n\n  --scalar-color-1: rgb(9, 9, 11);\n  --scalar-color-2: rgb(113, 113, 122);\n  --scalar-color-3: rgba(25, 25, 28, 0.5);\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.light-mode .scalar-card.dark-mode,\n.dark-mode {\n  --scalar-background-1: #000e23;\n  --scalar-background-2: #01132e;\n  --scalar-background-3: #03193b;\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: rgb(161, 161, 170);\n  --scalar-color-3: rgba(255, 255, 255, 0.533);\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  z-index: 1;\n}\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-search-background: white;\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: rgba(69, 255, 165, 0.823);\n  --scalar-color-red: #ff8589;\n  --scalar-color-yellow: #ffcc4d;\n  --scalar-color-blue: #6bc1fe;\n  --scalar-color-orange: #f98943;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom theme */\n/* Document header */\n@keyframes headerbackground {\n  from {\n    background: transparent;\n    backdrop-filter: none;\n  }\n  to {\n    background: var(--header-background-1);\n    backdrop-filter: blur(12px);\n  }\n}\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n/* Hero Section Flare */\n.section-flare-item:nth-of-type(1) {\n  --c1: #ffffff;\n  --c2: #babfd8;\n  --c3: #2e8bb2;\n  --c4: #1a8593;\n  --c5: #0a143e;\n  --c6: #0a0f52;\n  --c7: #2341b8;\n\n  --solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6),\n    var(--c7);\n  --solid-wrap: var(--solid), var(--c1);\n  --trans: var(--c1), transparent, var(--c2), transparent, var(--c3),\n    transparent, var(--c4), transparent, var(--c5), transparent, var(--c6),\n    transparent, var(--c7);\n  --trans-wrap: var(--trans), transparent, var(--c1);\n\n  background: radial-gradient(circle, var(--trans)),\n    conic-gradient(from 180deg, var(--trans-wrap)),\n    radial-gradient(circle, var(--trans)), conic-gradient(var(--solid-wrap));\n  width: 70vw;\n  height: 700px;\n  border-radius: 50%;\n  filter: blur(100px);\n  z-index: 0;\n  right: 0;\n  position: absolute;\n  transform: rotate(-45deg);\n  top: -300px;\n  opacity: 0.3;\n}\n.section-flare-item:nth-of-type(3) {\n  --star-color: #6b9acc;\n  --star-color2: #446b8d;\n  --star-color3: #3e5879;\n  background-image: radial-gradient(\n      2px 2px at 20px 30px,\n      var(--star-color2),\n      rgba(0, 0, 0, 0)\n    ),\n    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(\n      2px 2px at 160px 120px,\n      var(--star-color3),\n      rgba(0, 0, 0, 0)\n    );\n  background-repeat: repeat;\n  background-size: 200px 200px;\n  width: 100%;\n  height: 100%;\n  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);\n}\n.section-flare {\n  top: -150px !important;\n  height: 100vh;\n  background: linear-gradient(#000, var(--scalar-background-1));\n  width: 100vw;\n}\n.light-mode .section-flare {\n  display: none;\n}\n.light-mode .scalar-card {\n  --scalar-background-1: #fff;\n  --scalar-background-2: #fff;\n  --scalar-background-3: #fff;\n}\n",
        deepSpace:
          "/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode {\n  --scalar-color-1: rgb(9, 9, 11);\n  --scalar-color-2: rgb(113, 113, 122);\n  --scalar-color-3: rgba(25, 25, 28, 0.5);\n  --scalar-color-accent: var(--scalar-color-1);\n\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f4f4f5;\n  --scalar-background-3: #e3e3e6;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-border-color: rgb(228, 228, 231);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.dark-mode {\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: rgb(161, 161, 170);\n  --scalar-color-3: rgba(255, 255, 255, 0.533);\n  --scalar-color-accent: var(--scalar-color-1);\n\n  --scalar-background-1: #09090b;\n  --scalar-background-2: #18181b;\n  --scalar-background-3: #2c2c30;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: transparent;\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n}\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-item-active-background: var(--scalar-background-2);\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: rgba(69, 255, 165, 0.823);\n  --scalar-color-red: #ff8589;\n  --scalar-color-yellow: #ffcc4d;\n  --scalar-color-blue: #6bc1fe;\n  --scalar-color-orange: #f98943;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom theme */\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.examples .scalar-card-footer {\n  --scalar-background-3: transparent;\n  padding-top: 0;\n}\n/* Hero section flare */\n.section-flare {\n  width: 100vw;\n  height: 550px;\n  position: relative;\n}\n.section-flare-item:nth-of-type(1) {\n  position: absolute;\n  width: 100vw;\n  height: 550px;\n  --stripesDark: repeating-linear-gradient(\n    100deg,\n    #000 0%,\n    #000 7%,\n    transparent 10%,\n    transparent 12%,\n    #000 16%\n  );\n  --rainbow: repeating-linear-gradient(\n    100deg,\n    #fff 10%,\n    #fff 16%,\n    #fff 22%,\n    #fff 30%\n  );\n  background-image: var(--stripesDark), var(--rainbow);\n  background-size: 300%, 200%;\n  background-position:\n    50% 50%,\n    50% 50%;\n  filter: invert(100%);\n  -webkit-mask-image: radial-gradient(\n    ellipse at 100% 0%,\n    black 40%,\n    transparent 70%\n  );\n  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);\n  pointer-events: none;\n  opacity: 0.07;\n}\n.dark-mode .section-flare-item:nth-of-type(1) {\n  background-image: var(--stripesDark), var(--rainbow);\n  filter: opacity(50%) saturate(200%);\n  opacity: 0.25;\n  height: 350px;\n}\n.section-flare-item:nth-of-type(1):after {\n  content: '';\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-image: var(--stripesDark), var(--rainbow);\n  background-size: 200%, 100%;\n  background-attachment: fixed;\n  mix-blend-mode: difference;\n}\n.dark-mode .section-flare:after {\n  background-image: var(--stripesDark), var(--rainbow);\n}\n.section-flare-item:nth-of-type(2) {\n  --star-color: #fff;\n  --star-color2: #fff;\n  --star-color3: #fff;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-image: radial-gradient(\n      2px 2px at 20px 30px,\n      var(--star-color2),\n      rgba(0, 0, 0, 0)\n    ),\n    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(\n      2px 2px at 160px 120px,\n      var(--star-color3),\n      rgba(0, 0, 0, 0)\n    );\n  background-repeat: repeat;\n  background-size: 200px 200px;\n  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);\n  opacity: 0.2;\n}\n",
        saturn:
          "/* basic theme */\n.light-mode {\n  --scalar-background-1: #f3f3ee;\n  --scalar-background-2: #e8e8e3;\n  --scalar-background-3: #e4e4df;\n  --scalar-border-color: rgba(215, 215, 206, 0.5);\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: #1763a6;\n  --scalar-background-accent: #1f648e1f;\n}\n.dark-mode {\n  --scalar-background-1: #09090b;\n  --scalar-background-2: #18181b;\n  --scalar-background-3: #2c2c30;\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: rgb(161, 161, 170);\n  --scalar-color-3: rgba(255, 255, 255, 0.533);\n\n  --scalar-color-accent: #4eb3ec;\n  --scalar-background-accent: #8ab4f81f;\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-1);\n\n  --scalar-sidebar-search-background: var(--scalar-background-1);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n}\n\n/* advanced */\n.light-mode {\n  --scalar-color-green: #17803d;\n  --scalar-color-red: #e10909;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #1763a6;\n  --scalar-color-orange: #e25b09;\n  --scalar-color-purple: #5c3993;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #30a159;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #eec644;\n  --scalar-color-blue: #2b7abf;\n  --scalar-color-orange: #f07528;\n  --scalar-color-purple: #7a59b1;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n",
        kepler:
          "/* basic theme */\n.light-mode {\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n  --scalar-color-accent: #7070ff;\n\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f6f6f6;\n  --scalar-background-3: #e7e7e7;\n  --scalar-background-accent: #7070ff1f;\n\n  --scalar-border-color: rgba(0, 0, 0, 0.1);\n\n  --scalar-code-language-color-supersede: var(--scalar-color-3);\n}\n.dark-mode {\n  --scalar-color-1: #f7f8f8;\n  --scalar-color-2: rgb(180, 188, 208);\n  --scalar-color-3: #b4bcd099;\n  --scalar-color-accent: #828fff;\n\n  --scalar-background-1: #000212;\n  --scalar-background-2: #0d0f1e;\n  --scalar-background-3: #232533;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-border-color: #242537;\n  --scalar-code-language-color-supersede: var(--scalar-color-3);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n  --scalar-sidebar-search-background: rgba(0, 0, 0, 0.05);\n  --scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, 0.05);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-background-2: rgba(0, 0, 0, 0.03);\n}\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, 0.05);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom Theme */\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.sidebar-search {\n  backdrop-filter: blur(12px);\n}\n@keyframes headerbackground {\n  from {\n    background: transparent;\n    backdrop-filter: none;\n  }\n  to {\n    background: var(--header-background-1);\n    backdrop-filter: blur(12px);\n  }\n}\n.dark-mode .scalar-card {\n  background: rgba(255, 255, 255, 0.05) !important;\n}\n.dark-mode .scalar-card * {\n  --scalar-background-2: transparent !important;\n  --scalar-background-1: transparent !important;\n}\n.light-mode .dark-mode.scalar-card *,\n.light-mode .dark-mode.scalar-card {\n  --scalar-background-1: #0d0f1e !important;\n  --scalar-background-2: #0d0f1e !important;\n  --scalar-background-3: #191b29 !important;\n}\n.light-mode .dark-mode.scalar-card {\n  background: #191b29 !important;\n}\n.badge {\n  box-shadow: 0 0 0 1px var(--scalar-border-color);\n  margin-right: 6px;\n}\n\n.table-row.required-parameter .table-row-item:nth-of-type(2):after {\n  background: transparent;\n  box-shadow: none;\n}\n/* Hero Section Flare */\n.section-flare {\n  width: 100vw;\n  background: radial-gradient(\n    ellipse 80% 50% at 50% -20%,\n    rgba(120, 119, 198, 0.3),\n    transparent\n  );\n  height: 100vh;\n}\n",
        mars: "/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode {\n  --scalar-background-1: #f9f6f0;\n  --scalar-background-2: #f2efe8;\n  --scalar-background-3: #e9e7e2;\n  --scalar-border-color: rgba(203, 165, 156, 0.6);\n\n  --scalar-color-1: #c75549;\n  --scalar-color-2: #c75549;\n  --scalar-color-3: #c75549;\n\n  --scalar-color-accent: #c75549;\n  --scalar-background-accent: #dcbfa81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.dark-mode {\n  --scalar-background-1: #140507;\n  --scalar-background-2: #20090c;\n  --scalar-background-3: #321116;\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n\n  --scalar-color-1: rgba(255, 255, 255, 0.9);\n  --scalar-color-2: rgba(255, 255, 255, 0.62);\n  --scalar-color-3: rgba(255, 255, 255, 0.44);\n\n  --scalar-color-accent: rgba(255, 255, 255, 0.9);\n  --scalar-background-accent: #441313;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  z-index: 1;\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #09533a;\n  --scalar-color-red: #aa181d;\n  --scalar-color-yellow: #ab8d2b;\n  --scalar-color-blue: #19689a;\n  --scalar-color-orange: #b26c34;\n  --scalar-color-purple: #4c2191;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: rgba(69, 255, 165, 0.823);\n  --scalar-color-red: #ff8589;\n  --scalar-color-yellow: #ffcc4d;\n  --scalar-color-blue: #6bc1fe;\n  --scalar-color-orange: #f98943;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom Theme */\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-search-background: white;\n}\n.examples .scalar-card-footer {\n  --scalar-background-3: transparent;\n  padding-top: 0;\n}\n/* Hero section flare */\n.section-flare-item:nth-of-type(1) {\n  background: #d25019;\n  width: 80vw;\n  height: 500px;\n  margin-top: -150px;\n  border-radius: 50%;\n  filter: blur(100px);\n  z-index: 0;\n}\n.light-mode .section-flare {\n  display: none;\n}\n.section-flare {\n  top: -150px !important;\n  height: 100vh;\n  right: -400px !important;\n  left: initial;\n}\n",
      },
      du = (e) => ("none" === e ? "" : (cu[e || "default"] ?? ou))
    var uu = Object.defineProperty,
      pu = (e, t, n) => (
        ((e, t, n) => {
          t in e ? uu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)
        })(e, "symbol" != typeof t ? t + "" : t, n),
        n
      )
    !(function (e) {
      if (typeof document > "u") return
      let t = document.head || document.getElementsByTagName("head")[0],
        n = document.createElement("style")
      ;(n.type = "text/css"),
        t.appendChild(n),
        n.styleSheet ? (n.styleSheet.cssText = e) : n.appendChild(document.createTextNode(e))
    })(
      "[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999}[data-sonner-toaster][data-x-position=right]{right:max(var(--offset),env(safe-area-inset-right))}[data-sonner-toaster][data-x-position=left]{left:max(var(--offset),env(safe-area-inset-left))}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:max(var(--offset),env(safe-area-inset-top))}[data-sonner-toaster][data-y-position=bottom]{bottom:max(var(--offset),env(safe-area-inset-bottom))}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;will-change:transform,opacity,height;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast] [data-description]{font-weight:400;line-height:1.4;color:inherit}[data-sonner-toast] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast] [data-icon]>*{flex-shrink:0}[data-sonner-toast] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast] [data-content]{display:flex;flex-direction:column;gap:2px;transform:translateZ(0)}[data-sonner-toast] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toast][data-theme=dark] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]:before{content:'';position:absolute;left:0;right:0;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]:before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]:before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]:before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]:after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]:before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount,0));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{from{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;--mobile-offset:16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - 32px)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 91%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 91%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 91%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 100%, 12%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 12%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-rich-colors=true] [data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}",
    )
    let hu = 0
    const fu = new (class {
        constructor() {
          pu(this, "subscribers"),
            pu(this, "toasts"),
            pu(
              this,
              "subscribe",
              (e) => (
                this.subscribers.push(e),
                () => {
                  const t = this.subscribers.indexOf(e)
                  this.subscribers.splice(t, 1)
                }
              ),
            ),
            pu(this, "publish", (e) => {
              this.subscribers.forEach((t) => t(e))
            }),
            pu(this, "addToast", (e) => {
              this.publish(e), (this.toasts = [...this.toasts, e])
            }),
            pu(this, "create", (e) => {
              var t
              const { message: n, ...r } = e,
                a = "number" == typeof e.id || (e.id && (null == (t = e.id) ? void 0 : t.length) > 0) ? e.id : hu++,
                o = this.toasts.find((e) => e.id === a),
                i = void 0 === e.dismissible || e.dismissible
              return (
                o
                  ? (this.toasts = this.toasts.map((t) =>
                      t.id === a
                        ? (this.publish({ ...t, ...e, id: a, title: n }),
                          { ...t, ...e, id: a, dismissible: i, title: n })
                        : t,
                    ))
                  : this.addToast({ title: n, ...r, dismissible: i, id: a }),
                a
              )
            }),
            pu(
              this,
              "dismiss",
              (e) => (
                e ||
                  this.toasts.forEach((e) => {
                    this.subscribers.forEach((t) => t({ id: e.id, dismiss: !0 }))
                  }),
                this.subscribers.forEach((t) => t({ id: e, dismiss: !0 })),
                e
              ),
            ),
            pu(this, "message", (e, t) => this.create({ ...t, message: e, type: "default" })),
            pu(this, "error", (e, t) => this.create({ ...t, type: "error", message: e })),
            pu(this, "success", (e, t) => this.create({ ...t, type: "success", message: e })),
            pu(this, "info", (e, t) => this.create({ ...t, type: "info", message: e })),
            pu(this, "warning", (e, t) => this.create({ ...t, type: "warning", message: e })),
            pu(this, "loading", (e, t) => this.create({ ...t, type: "loading", message: e })),
            pu(this, "promise", (e, t) => {
              if (!t) return
              let n
              void 0 !== t.loading &&
                (n = this.create({
                  ...t,
                  promise: e,
                  type: "loading",
                  message: t.loading,
                  description: "function" != typeof t.description ? t.description : void 0,
                }))
              const r = e instanceof Promise ? e : e()
              let a = void 0 !== n
              return (
                r
                  .then((e) => {
                    if (e && "boolean" == typeof e.ok && !e.ok) {
                      a = !1
                      const e =
                          "function" == typeof t.error ? t.error(`HTTP error! status: ${response.status}`) : t.error,
                        r =
                          "function" == typeof t.description
                            ? t.description(`HTTP error! status: ${response.status}`)
                            : t.description
                      this.create({ id: n, type: "error", message: e, description: r })
                    } else if (void 0 !== t.success) {
                      a = !1
                      const r = "function" == typeof t.success ? t.success(e) : t.success,
                        o = "function" == typeof t.description ? t.description(e) : t.description
                      this.create({ id: n, type: "success", message: r, description: o })
                    }
                  })
                  .catch((e) => {
                    if (void 0 !== t.error) {
                      a = !1
                      const r = "function" == typeof t.error ? t.error(e) : t.error,
                        o = "function" == typeof t.description ? t.description(e) : t.description
                      this.create({ id: n, type: "error", message: r, description: o })
                    }
                  })
                  .finally(() => {
                    var e
                    a && (this.dismiss(n), (n = void 0)), null == (e = t.finally) || e.call(t)
                  }),
                n
              )
            }),
            pu(this, "custom", (e, t) => {
              const n = (null == t ? void 0 : t.id) || hu++
              return this.publish({ component: e, id: n, ...t }), n
            }),
            (this.subscribers = []),
            (this.toasts = [])
        }
      })(),
      mu = Object.assign(
        (e, t) => {
          const n = (null == t ? void 0 : t.id) || hu++
          return fu.create({ message: e, id: n, type: "default", ...t }), n
        },
        {
          success: fu.success,
          info: fu.info,
          warning: fu.warning,
          error: fu.error,
          custom: fu.custom,
          message: fu.message,
          promise: fu.promise,
          dismiss: fu.dismiss,
          loading: fu.loading,
        },
      ),
      gu = (e, t) => {
        const n = e.__vccOpts || e
        for (const [e, r] of t) n[e] = r
        return n
      },
      bu = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stoke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
      },
      vu = [
        Ro("line", { x1: "18", y1: "6", x2: "6", y2: "18" }, null, -1),
        Ro("line", { x1: "6", y1: "6", x2: "18", y2: "18" }, null, -1),
      ],
      yu = gu({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("svg", bu, vu)
          },
        ],
      ]),
      Ou = [
        "aria-live",
        "data-styled",
        "data-mounted",
        "data-promise",
        "data-removed",
        "data-visible",
        "data-y-position",
        "data-x-position",
        "data-index",
        "data-front",
        "data-swiping",
        "data-dismissible",
        "data-type",
        "data-invert",
        "data-swipe-out",
        "data-expanded",
      ],
      wu = ["aria-label", "data-disabled"],
      xu = { key: 0, "data-icon": "" },
      ku = { "data-content": "" },
      _u = Hr({
        __name: "Toast",
        props: {
          toast: {},
          toasts: {},
          index: {},
          expanded: { type: Boolean },
          invert: { type: Boolean },
          heights: {},
          gap: {},
          position: {},
          visibleToasts: {},
          expandByDefault: { type: Boolean },
          closeButton: { type: Boolean },
          interacting: { type: Boolean },
          duration: {},
          descriptionClass: {},
          style: {},
          cancelButtonStyle: {},
          actionButtonStyle: {},
          unstyled: { type: Boolean },
          loadingIcon: {},
          class: {},
          classes: {},
          icons: {},
          closeButtonAriaLabel: {},
          pauseWhenPageIsHidden: { type: Boolean },
          cn: { type: Function },
        },
        emits: ["update:heights", "removeToast"],
        setup(e, { emit: t }) {
          const n = t,
            r = e,
            a = Dn(!1),
            o = Dn(!1),
            i = Dn(!1),
            s = Dn(!1),
            l = Dn(0),
            c = Dn(0),
            d = Dn(null),
            u = Dn(null),
            p = ii(() => 0 === r.index),
            h = ii(() => r.index + 1 <= r.visibleToasts),
            f = ii(() => r.toast.type),
            m = ii(() => !1 !== r.toast.dismissible),
            g = ii(() => {
              var e, t, n, a, o, i, s
              return r.cn(
                null == (e = r.classes) ? void 0 : e.toast,
                null == (n = null == (t = r.toast) ? void 0 : t.classes) ? void 0 : n.toast,
                null == (a = r.classes) ? void 0 : a.default,
                null == (o = r.classes) ? void 0 : o[r.toast.type || "default"],
                null == (s = null == (i = r.toast) ? void 0 : i.classes) ? void 0 : s[r.toast.type || "default"],
              )
            }),
            b = r.toast.style || {},
            v = ii(() => r.heights.findIndex((e) => e.toastId === r.toast.id) || 0),
            y = ii(() => r.toast.closeButton ?? r.closeButton),
            O = ii(() => r.toast.duration || r.duration || 4e3),
            w = Dn(0),
            x = Dn(0),
            k = Dn(O.value),
            _ = Dn(0),
            S = Dn(null),
            E = ii(() => r.position.split("-")),
            T = ii(() => E.value[0]),
            A = ii(() => E.value[1]),
            C = "string" != typeof r.toast.title,
            P = "string" != typeof r.toast.description,
            D = ii(() => r.heights.reduce((e, t, n) => (n >= v.value ? e : e + t.height), 0)),
            R = (() => {
              const e = Dn(!1)
              return (
                Wa(() => {
                  const t = () => {
                    e.value = document.hidden
                  }
                  return (
                    document.addEventListener("visibilitychange", t),
                    () => window.removeEventListener("visibilitychange", t)
                  )
                }),
                { isDocumentHidden: e }
              )
            })(),
            N = ii(() => r.toast.invert || r.invert),
            $ = ii(() => "loading" === f.value)
          Nr(() => {
            if (!a.value) return
            const e = u.value,
              t = null == e ? void 0 : e.style.height
            e.style.height = "auto"
            const o = e.getBoundingClientRect().height
            let i
            ;(e.style.height = t),
              (c.value = o),
              (i = r.heights.find((e) => e.toastId === r.toast.id)
                ? r.heights.map((e) => (e.toastId === r.toast.id ? { ...e, height: o } : e))
                : [{ toastId: r.toast.id, height: o, position: r.toast.position }, ...r.heights]),
              n("update:heights", i)
          })
          const I = () => {
              ;(o.value = !0), (l.value = x.value)
              const e = r.heights.filter((e) => e.toastId !== r.toast.id)
              n("update:heights", e),
                setTimeout(() => {
                  n("removeToast", r.toast)
                }, 200)
            },
            M = () => {
              var e, t
              $.value || !m.value || (I(), null == (t = (e = r.toast).onDismiss) || t.call(e, r.toast))
            },
            L = (e) => {
              $.value ||
                !m.value ||
                ((d.value = new Date()),
                (l.value = x.value),
                e.target.setPointerCapture(e.pointerId),
                "BUTTON" !== e.target.tagName && ((i.value = !0), (S.value = { x: e.clientX, y: e.clientY })))
            },
            Q = (e) => {
              var t, n, a, o
              if (s.value) return
              S.value = null
              const c = Number(
                  (null == (t = u.value) ? void 0 : t.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0,
                ),
                p = new Date().getTime() - d.value.getTime(),
                h = Math.abs(c) / p
              if (Math.abs(c) >= 20 || h > 0.11)
                return (
                  (l.value = x.value),
                  null == (a = (n = r.toast).onDismiss) || a.call(n, r.toast),
                  I(),
                  void (s.value = !0)
                )
              null == (o = u.value) || o.style.setProperty("--swipe-amount", "0px"), (i.value = !1)
            },
            B = (e) => {
              var t
              if (!S.value) return
              const n = e.clientY - S.value.y,
                r = e.clientX - S.value.x,
                a = ("top" === E.value[0] ? Math.min : Math.max)(0, n),
                o = "touch" === e.pointerType ? 10 : 2
              Math.abs(a) > o
                ? null == (t = u.value) || t.style.setProperty("--swipe-amount", `${n}px`)
                : Math.abs(r) > o && (S.value = null)
            }
          return (
            Wa(() => {
              x.value = 14 * v.value + D.value
            }),
            Wa((e) => {
              if (
                (r.toast.promise && "loading" === f.value) ||
                r.toast.duration === 1 / 0 ||
                "loading" === r.toast.type
              )
                return
              let t
              r.expanded || r.interacting || (r.pauseWhenPageIsHidden && R)
                ? (() => {
                    if (_.value < w.value) {
                      const e = new Date().getTime() - w.value
                      k.value = k.value - e
                    }
                    _.value = new Date().getTime()
                  })()
                : ((w.value = new Date().getTime()),
                  (t = setTimeout(() => {
                    var e, t
                    null == (t = (e = r.toast).onAutoClose) || t.call(e, r.toast), I()
                  }, k.value))),
                e(() => {
                  clearTimeout(t)
                })
            }),
            Wa(() => {
              r.toast.delete && I()
            }),
            Nr(() => {
              if (u.value) {
                const e = u.value.getBoundingClientRect().height
                c.value = e
                const t = [{ toastId: r.toast.id, height: e, position: r.toast.position }, ...r.heights]
                n("update:heights", t)
              }
              a.value = !0
            }),
            Lr(() => {
              if (u.value) {
                const e = r.heights.filter((e) => e.toastId !== r.toast.id)
                n("update:heights", e)
              }
            }),
            (e, t) => {
              var n, r, d, v, O, w, k, _, S, E, D, R
              return (
                xo(),
                Eo(
                  "li",
                  {
                    "aria-live": e.toast.important ? "assertive" : "polite",
                    "aria-atomic": "true",
                    role: "status",
                    tabindex: "0",
                    ref_key: "toastRef",
                    ref: u,
                    "data-sonner-toast": "",
                    class: Ge(g.value),
                    "data-styled": !(e.toast.component || (null != (n = e.toast) && n.unstyled) || e.unstyled),
                    "data-mounted": a.value,
                    "data-promise": !!e.toast.promise,
                    "data-removed": o.value,
                    "data-visible": h.value,
                    "data-y-position": T.value,
                    "data-x-position": A.value,
                    "data-index": e.index,
                    "data-front": p.value,
                    "data-swiping": i.value,
                    "data-dismissible": m.value,
                    "data-type": f.value,
                    "data-invert": N.value,
                    "data-swipe-out": s.value,
                    "data-expanded": !!(e.expanded || (e.expandByDefault && a.value)),
                    style: He({
                      "--index": e.index,
                      "--toasts-before": e.index,
                      "--z-index": e.toasts.length - e.index,
                      "--offset": `${o.value ? l.value : x.value}px`,
                      "--initial-height": e.expandByDefault ? "auto" : `${c.value}px`,
                      ...e.style,
                      ...In(b),
                    }),
                    onPointerdown: L,
                    onPointerup: Q,
                    onPointermove: B,
                  },
                  [
                    y.value && !e.toast.component
                      ? (xo(),
                        Eo(
                          "button",
                          {
                            key: 0,
                            "aria-label": e.closeButtonAriaLabel || "Close toast",
                            "data-disabled": $.value,
                            "data-close-button": "",
                            class: Ge(
                              e.cn(
                                null == (r = e.classes) ? void 0 : r.closeButton,
                                null == (v = null == (d = e.toast) ? void 0 : d.classes) ? void 0 : v.closeButton,
                              ),
                            ),
                            onClick: M,
                          },
                          [No(yu)],
                          10,
                          wu,
                        ))
                      : Qo("", !0),
                    e.toast.component
                      ? (xo(),
                        To(
                          Tr(e.toast.component),
                          Fo({ key: 1 }, e.toast.componentProps, { onCloseToast: I }),
                          null,
                          16,
                        ))
                      : (xo(),
                        Eo(
                          go,
                          { key: 2 },
                          [
                            "default" !== f.value || e.toast.icon || e.toast.promise
                              ? (xo(),
                                Eo("div", xu, [
                                  (!e.toast.promise && "loading" !== f.value) || e.toast.icon
                                    ? Qo("", !0)
                                    : Xr(e.$slots, "loading-icon", { key: 0 }),
                                  e.toast.icon
                                    ? (xo(), To(Tr(e.toast.icon), { key: 1 }))
                                    : (xo(),
                                      Eo(
                                        go,
                                        { key: 2 },
                                        [
                                          "success" === f.value
                                            ? Xr(e.$slots, "success-icon", { key: 0 })
                                            : "error" === f.value
                                              ? Xr(e.$slots, "error-icon", { key: 1 })
                                              : "warning" === f.value
                                                ? Xr(e.$slots, "warning-icon", { key: 2 })
                                                : "info" === f.value
                                                  ? Xr(e.$slots, "info-icon", { key: 3 })
                                                  : Qo("", !0),
                                        ],
                                        64,
                                      )),
                                ]))
                              : Qo("", !0),
                            Ro("div", ku, [
                              Ro(
                                "div",
                                {
                                  "data-title": "",
                                  class: Ge(
                                    e.cn(
                                      null == (O = e.classes) ? void 0 : O.title,
                                      null == (w = e.toast.classes) ? void 0 : w.title,
                                    ),
                                  ),
                                },
                                [
                                  C
                                    ? (xo(),
                                      To(Tr(e.toast.title), Ke(Fo({ key: 0 }, e.toast.componentProps)), null, 16))
                                    : (xo(), Eo(go, { key: 1 }, [Mo(at(e.toast.title), 1)], 64)),
                                ],
                                2,
                              ),
                              e.toast.description
                                ? (xo(),
                                  Eo(
                                    "div",
                                    {
                                      key: 0,
                                      "data-description": "",
                                      class: Ge(
                                        e.cn(
                                          e.descriptionClass,
                                          e.toast.descriptionClass,
                                          null == (k = e.classes) ? void 0 : k.description,
                                          null == (_ = e.toast.classes) ? void 0 : _.description,
                                        ),
                                      ),
                                    },
                                    [
                                      P
                                        ? (xo(),
                                          To(
                                            Tr(e.toast.description),
                                            Ke(Fo({ key: 0 }, e.toast.componentProps)),
                                            null,
                                            16,
                                          ))
                                        : (xo(), Eo(go, { key: 1 }, [Mo(at(e.toast.description), 1)], 64)),
                                    ],
                                    2,
                                  ))
                                : Qo("", !0),
                            ]),
                            e.toast.cancel
                              ? (xo(),
                                Eo(
                                  "button",
                                  {
                                    key: 1,
                                    class: Ge(
                                      e.cn(
                                        null == (S = e.classes) ? void 0 : S.cancelButton,
                                        null == (E = e.toast.classes) ? void 0 : E.cancelButton,
                                      ),
                                    ),
                                    "data-button": "",
                                    "data-cancel": "",
                                    onClick:
                                      t[0] ||
                                      (t[0] = () => {
                                        var t
                                        I(), null != (t = e.toast.cancel) && t.onClick && e.toast.cancel.onClick()
                                      }),
                                  },
                                  at(e.toast.cancel.label),
                                  3,
                                ))
                              : Qo("", !0),
                            e.toast.action
                              ? (xo(),
                                Eo(
                                  "button",
                                  {
                                    key: 2,
                                    class: Ge(
                                      e.cn(
                                        null == (D = e.classes) ? void 0 : D.actionButton,
                                        null == (R = e.toast.classes) ? void 0 : R.actionButton,
                                      ),
                                    ),
                                    "data-button": "",
                                    onClick:
                                      t[1] ||
                                      (t[1] = (t) => {
                                        var n
                                        null == (n = e.toast.action) || n.onClick(t), !t.defaultPrevented && I()
                                      }),
                                  },
                                  at(e.toast.action.label),
                                  3,
                                ))
                              : Qo("", !0),
                          ],
                          64,
                        )),
                  ],
                  46,
                  Ou,
                )
              )
            }
          )
        },
      }),
      Su = ["data-visible"],
      Eu = { class: "sonner-spinner" },
      Tu = Hr({
        __name: "Loader",
        props: { visible: { type: Boolean } },
        setup(e) {
          const t = Array(12).fill(0)
          return (e, n) => (
            xo(),
            Eo(
              "div",
              { class: "sonner-loading-wrapper", "data-visible": e.visible },
              [
                Ro("div", Eu, [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(In(t), (e) => (xo(), Eo("div", { key: `spinner-bar-${e}`, class: "sonner-loading-bar" }))),
                    128,
                  )),
                ]),
              ],
              8,
              Su,
            )
          )
        },
      }),
      Au = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20",
      },
      Cu = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ],
      Pu = gu({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("svg", Au, Cu)
          },
        ],
      ]),
      Du = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20",
      },
      Ru = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ],
      Nu = gu({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("svg", Du, Ru)
          },
        ],
      ]),
      $u = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        height: "20",
        width: "20",
      },
      Iu = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ],
      Mu = gu({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("svg", $u, Iu)
          },
        ],
      ]),
      Lu = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20",
      },
      Qu = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ],
      Bu = gu({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("svg", Lu, Qu)
          },
        ],
      ]),
      ju = ["aria-label"],
      Uu = ["dir", "data-theme", "data-rich-colors", "data-y-position", "data-x-position"],
      Fu = "32px",
      zu = typeof window < "u" && typeof document < "u",
      qu = Hr({
        name: "Toaster",
        inheritAttrs: !1,
        __name: "Toaster",
        props: {
          invert: { type: Boolean, default: !1 },
          theme: { default: "light" },
          position: { default: "bottom-right" },
          hotkey: { default: () => ["altKey", "KeyT"] },
          richColors: { type: Boolean, default: !1 },
          expand: { type: Boolean, default: !1 },
          duration: { default: 4e3 },
          gap: { default: 14 },
          visibleToasts: { default: 3 },
          closeButton: { type: Boolean, default: !1 },
          toastOptions: { default: () => ({}) },
          class: { default: "" },
          style: { default: () => ({}) },
          offset: { default: Fu },
          dir: { default: "auto" },
          icons: {},
          containerAriaLabel: { default: "Notifications" },
          pauseWhenPageIsHidden: { type: Boolean, default: !1 },
          cn: {},
        },
        setup(e) {
          function t(...e) {
            return e.filter(Boolean).join(" ")
          }
          function n() {
            if (typeof window > "u" || typeof document > "u") return "ltr"
            const e = document.documentElement.getAttribute("dir")
            return "auto" !== e && e ? e : window.getComputedStyle(document.documentElement).direction
          }
          const r = e,
            a = ra(),
            o = Dn([]),
            i = ii(() => {
              const e = o.value.filter((e) => e.position).map((e) => e.position)
              return e.length > 0 ? Array.from(new Set([r.position].concat(e))) : [r.position]
            }),
            s = Dn([]),
            l = Dn(!1),
            c = Dn(!1),
            d = Dn(
              "system" !== r.theme
                ? r.theme
                : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
                  ? "dark"
                  : "light",
            ),
            u = ii(() => r.cn || t),
            p = Dn(null),
            h = Dn(null),
            f = Dn(!1),
            m = r.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "")
          function g(e) {
            o.value = o.value.filter(({ id: t }) => t !== e.id)
          }
          const b = (e) => {
              var t, n
              f.value &&
                (null == (n = null == (t = e.currentTarget) ? void 0 : t.contains) || !n.call(t, e.relatedTarget)) &&
                ((f.value = !1), h.value && (h.value.focus({ preventScroll: !0 }), (h.value = null)))
            },
            v = (e) => {
              ;(e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible) ||
                f.value ||
                ((f.value = !0), (h.value = e.relatedTarget))
            },
            y = (e) => {
              ;(e.target && e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible) ||
                (c.value = !1)
            }
          return (
            Wa((e) => {
              const t = fu.subscribe((e) => {
                e.dismiss
                  ? (o.value = o.value.map((t) => (t.id === e.id ? { ...t, delete: !0 } : t)))
                  : rr(() => {
                      const t = o.value.findIndex((t) => t.id === e.id)
                      ;-1 !== t ? o.value.splice(t, 1, e) : (o.value = [e, ...o.value])
                    })
              })
              e(() => {
                t()
              })
            }),
            Ya(
              () => r.theme,
              (e) => {
                "system" === e
                  ? ("system" === e &&
                      (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
                        ? (d.value = "dark")
                        : (d.value = "light")),
                    !(typeof window > "u") &&
                      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: e }) => {
                        d.value = e ? "dark" : "light"
                      }))
                  : (d.value = e)
              },
            ),
            Ya(
              () => p.value,
              () => {
                if (p.value)
                  return () => {
                    h.value && (h.value.focus({ preventScroll: !0 }), (h.value = null), (f.value = !1))
                  }
              },
            ),
            Wa(() => {
              o.value.length <= 1 && (l.value = !1)
            }),
            Wa((e) => {
              function t(e) {
                const t = r.hotkey.every((t) => e[t] || e.code === t),
                  n = Array.isArray(p.value) ? p.value[0] : p.value
                t && ((l.value = !0), null == n || n.focus())
                const a =
                  document.activeElement === p.value || (null == n ? void 0 : n.contains(document.activeElement))
                "Escape" === e.code && a && (l.value = !1)
              }
              zu &&
                (document.addEventListener("keydown", t),
                e(() => {
                  document.removeEventListener("keydown", t)
                }))
            }),
            (e, t) => (
              xo(),
              Eo(
                "section",
                { "aria-label": `${e.containerAriaLabel} ${In(m)}`, tabIndex: -1 },
                [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(i.value, (r, i) => {
                      var d
                      return (
                        xo(),
                        Eo(
                          "ol",
                          Fo(
                            {
                              key: r,
                              ref_for: !0,
                              ref_key: "listRef",
                              ref: p,
                              "data-sonner-toaster": "",
                              class: e.class,
                              dir: "auto" === e.dir ? n() : e.dir,
                              tabIndex: -1,
                              "data-theme": e.theme,
                              "data-rich-colors": e.richColors,
                              "data-y-position": r.split("-")[0],
                              "data-x-position": r.split("-")[1],
                              style: {
                                "--front-toast-height": `${null == (d = s.value[0]) ? void 0 : d.height}px`,
                                "--offset": "number" == typeof e.offset ? `${e.offset}px` : e.offset || Fu,
                                "--width": "356px",
                                "--gap": "14px",
                                ...e.style,
                                ...In(a).style,
                              },
                              onBlur: b,
                              onFocus: v,
                              onMouseenter: t[1] || (t[1] = (e) => (l.value = !0)),
                              onMousemove: t[2] || (t[2] = (e) => (l.value = !0)),
                              onMouseleave:
                                t[3] ||
                                (t[3] = () => {
                                  c.value || (l.value = !1)
                                }),
                              onPointerdown: y,
                              onPointerup: t[4] || (t[4] = (e) => (c.value = !1)),
                            },
                            e.$attrs,
                          ),
                          [
                            (xo(!0),
                            Eo(
                              go,
                              null,
                              qr(
                                o.value.filter((t) => (!t.position && 0 === i) || t.position === e.position),
                                (n, r) => {
                                  var a, i, d, p, h, f, m, b, v
                                  return (
                                    xo(),
                                    To(
                                      _u,
                                      {
                                        key: n.id,
                                        index: r,
                                        toast: n,
                                        duration: (null == (a = e.toastOptions) ? void 0 : a.duration) ?? e.duration,
                                        class: Ge(null == (i = e.toastOptions) ? void 0 : i.class),
                                        descriptionClass: null == (d = e.toastOptions) ? void 0 : d.descriptionClass,
                                        invert: e.invert,
                                        visibleToasts: e.visibleToasts,
                                        closeButton:
                                          (null == (p = e.toastOptions) ? void 0 : p.closeButton) ?? e.closeButton,
                                        interacting: c.value,
                                        position: e.position,
                                        style: He(null == (h = e.toastOptions) ? void 0 : h.style),
                                        unstyled: null == (f = e.toastOptions) ? void 0 : f.unstyled,
                                        classes: null == (m = e.toastOptions) ? void 0 : m.classes,
                                        cancelButtonStyle: null == (b = e.toastOptions) ? void 0 : b.cancelButtonStyle,
                                        actionButtonStyle: null == (v = e.toastOptions) ? void 0 : v.actionButtonStyle,
                                        toasts: o.value,
                                        expandByDefault: e.expand,
                                        gap: e.gap,
                                        expanded: l.value,
                                        pauseWhenPageIsHidden: e.pauseWhenPageIsHidden,
                                        cn: u.value,
                                        heights: s.value,
                                        "onUpdate:heights": t[0] || (t[0] = (e) => (s.value = e)),
                                        onRemoveToast: g,
                                      },
                                      {
                                        "loading-icon": yr(() => [
                                          Xr(e.$slots, "loading-icon", {}, () => [
                                            No(Tu, { visible: "loading" === n.type }, null, 8, ["visible"]),
                                          ]),
                                        ]),
                                        "success-icon": yr(() => [Xr(e.$slots, "success-icon", {}, () => [No(Pu)])]),
                                        "error-icon": yr(() => [Xr(e.$slots, "error-icon", {}, () => [No(Bu)])]),
                                        "warning-icon": yr(() => [Xr(e.$slots, "warning-icon", {}, () => [No(Mu)])]),
                                        "info-icon": yr(() => [Xr(e.$slots, "info-icon", {}, () => [No(Nu)])]),
                                        _: 2,
                                      },
                                      1032,
                                      [
                                        "index",
                                        "toast",
                                        "duration",
                                        "class",
                                        "descriptionClass",
                                        "invert",
                                        "visibleToasts",
                                        "closeButton",
                                        "interacting",
                                        "position",
                                        "style",
                                        "unstyled",
                                        "classes",
                                        "cancelButtonStyle",
                                        "actionButtonStyle",
                                        "toasts",
                                        "expandByDefault",
                                        "gap",
                                        "expanded",
                                        "pauseWhenPageIsHidden",
                                        "cn",
                                        "heights",
                                      ],
                                    )
                                  )
                                },
                              ),
                              128,
                            )),
                          ],
                          16,
                          Uu,
                        )
                      )
                    }),
                    128,
                  )),
                ],
                8,
                ju,
              )
            )
          )
        },
      }),
      Zu = { toast: () => null }
    function Hu(e) {
      Zu.toast = e
    }
    function Vu() {
      return {
        initializeToasts: Hu,
        toast: (e, t = "info", n = { timeout: 3e3 }) => {
          Zu.toast(e, t, n)
        },
      }
    }
    const Wu = Hr({
      __name: "ScalarToasts",
      setup(e) {
        const t = Dn(!1)
        Nr(() => (t.value = !0))
        const n = { success: mu.success, error: mu.error, warn: mu.warning, info: mu },
          { initializeToasts: r } = Vu()
        return (
          r((e, t = "info", r = {}) => {
            ;(n[t] || n.info)(e, { duration: r.timeout || 3e3, description: r.description })
          }),
          (e, n) => (t.value ? (xo(), To(In(qu), { key: 0, toastOptions: { class: "toaster" } })) : Qo("", !0))
        )
      },
    })
    !(function () {
      try {
        if (typeof document < "u") {
          var e = document.createElement("style")
          e.appendChild(
            document.createTextNode(
              ".toaster[data-sonner-toast][data-styled=true]{background:var(--scalar-background-1);color:var(--scalar-color-1);padding:18px;border:none;border-radius:var(--scalar-radius-lg);font-size:var(--scalar-font-size-3);font-weight:var(--scalar-font-medium);box-shadow:var(--scalar-shadow-2)}.toaster[data-sonner-toast] [data-icon]{align-self:start}.toaster[data-sonner-toast][data-styled=true][data-expanded=true]{height:auto}.toaster[data-sonner-toast][data-type=error]{background:var(--scalar-background-1)}.toaster[data-sonner-toast][data-type=error] [data-icon]{color:color-mix(in srgb,var(--scalar-color-red) 75%,var(--scalar-color-1))}.toaster[data-sonner-toast][data-type=warning]{background:var(--scalar-background-1)}.toaster[data-sonner-toast][data-type=warning] [data-icon]{color:color-mix(in srgb,var(--scalar-color-orange) 90%,var(--scalar-color-1))}",
            ),
          ),
            document.head.appendChild(e)
        }
      } catch (e) {
        console.error("vite-plugin-css-injected-by-js", e)
      }
    })()
    const Xu = () => {
        const { toast: e } = Vu()
        return {
          copyToClipboard: (t) => {
            navigator.clipboard.writeText(t).then(() => {
              e("Copied to the clipboard", "info")
            })
          },
        }
      },
      Yu = Dn(!1),
      Gu = "https://api.scalar.com/request-proxy",
      Ku = "https://proxy.scalar.com",
      Ju =
        /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g,
      ep = Object.hasOwnProperty
    class tp {
      constructor() {
        this.occurrences, this.reset()
      }
      slug(e, t) {
        const n = this
        let r = np(e, !0 === t)
        const a = r
        for (; ep.call(n.occurrences, r); ) n.occurrences[a]++, (r = a + "-" + n.occurrences[a])
        return (n.occurrences[r] = 0), r
      }
      reset() {
        this.occurrences = Object.create(null)
      }
    }
    function np(e, t) {
      return "string" != typeof e ? "" : (t || (e = e.toLowerCase()), e.replace(Ju, "").replace(/ /g, "-"))
    }
    const rp = Dn(Nd.hash ?? ""),
      ap = Dn(),
      op = Dn(!1),
      ip = (e) => (e.slug ? `description/${e.slug}` : ""),
      sp = (e) => {
        var t
        if (!ap.value) return ""
        const n = new RegExp("^" + (null == (t = ap.value) ? void 0 : t.basePath) + "/?")
        return decodeURIComponent(e.replace(n, ""))
      },
      lp = (e, t) => {
        if (!e) return "webhooks"
        const n = np(e)
        return `webhook/${t}/${encodeURIComponent(n)}`
      },
      cp = (e) => {
        if (!e) return "models"
        const t = np(e)
        return `model/${encodeURIComponent(t)}`
      },
      dp = (e, t) => `${up(t)}/${e.httpVerb}${e.path}`,
      up = ({ name: e }) => {
        const t = np(e)
        return `tag/${encodeURIComponent(t)}`
      },
      pp = (e = rp.value) => {
        var t
        const n = null == (t = e.match(/(tag\/[^/]+)/)) ? void 0 : t[0],
          r = e.startsWith("model") ? "models" : "",
          a = e.startsWith("webhook") ? "webhooks" : ""
        return n || r || a
      },
      hp = () => {
        rp.value = ap.value ? sp(window.location.pathname) : decodeURIComponent(window.location.hash.replace(/^#/, ""))
      },
      fp = () => ({
        hash: rp,
        getWebhookId: lp,
        getModelId: cp,
        getHeadingId: ip,
        getOperationId: dp,
        getPathRoutingId: sp,
        getSectionId: pp,
        getTagId: up,
        isIntersectionEnabled: op,
        pathRouting: ap,
        updateHash: hp,
      })
    function mp(e) {
      return {
        parameterMap: ii(() => {
          var t
          const n = (null == (t = e.operation.information) ? void 0 : t.parameters) ?? [],
            r = { path: [], query: [], header: [], body: [], formData: [] }
          return (
            e.operation.pathParameters &&
              e.operation.pathParameters.forEach((e) => {
                "path" === e.in
                  ? r.path.push(e)
                  : "query" === e.in
                    ? r.query.push(e)
                    : "header" === e.in
                      ? r.header.push(e)
                      : "body" === e.in
                        ? r.body.push(e)
                        : "formData" === e.in && r.formData.push(e)
              }),
            n &&
              n.forEach((e) => {
                "path" === e.in
                  ? r.path.push(e)
                  : "query" === e.in
                    ? r.query.push(e)
                    : "header" === e.in
                      ? r.header.push(e)
                      : "body" === e.in
                        ? r.body.push(e)
                        : "formData" === e.in && r.formData.push(e)
              }),
            r
          )
        }),
      }
    }
    function gp(e, t) {
      for (const [n, r] of Object.entries(e))
        null !== r && "object" == typeof r
          ? (t[n] ?? (t[n] = new r.__proto__.constructor()), gp(r, t[n]))
          : void 0 !== r && (t[n] = r)
      return t
    }
    function bp(e) {
      return gp(e ?? {}, {
        info: {
          title: "",
          description: "",
          termsOfService: "",
          version: "",
          license: { name: "", url: "" },
          contact: { email: "" },
        },
        externalDocs: { description: "", url: "" },
        servers: [],
        tags: [],
      })
    }
    function vp(e, t = "") {
      return (
        {
          "date-time": new Date().toISOString(),
          date: new Date().toISOString().split("T")[0],
          email: "hello@example.com",
          hostname: "example.com",
          "idn-email": "jane.doe@example.com",
          "idn-hostname": "example.com",
          ipv4: "127.0.0.1",
          ipv6: "51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998",
          "iri-reference": "/entitiy/1",
          iri: "https://example.com/entity/123",
          "json-pointer": "/nested/objects",
          password: "super-secret",
          regex: "/[a-z]/",
          "relative-json-pointer": "1/nested/objects",
          time: new Date().toISOString().split("T")[1].split(".")[0],
          "uri-reference": "../folder",
          "uri-template": "https://example.com/{id}",
          uri: "https://example.com",
          uuid: "123e4567-e89b-12d3-a456-426614174000",
        }[e.format] ?? t
      )
    }
    const yp = (e, t, n = 0, r, a) => {
      var o, i, s, l, c, d
      if (n > 5) return null
      const u = !!(null == t ? void 0 : t.emptyString)
      if ("write" === (null == t ? void 0 : t.mode) && e.readOnly) return
      if ("read" === (null == t ? void 0 : t.mode) && e.writeOnly) return
      if (e["x-variable"]) {
        const n = null == (o = null == t ? void 0 : t.variables) ? void 0 : o[e["x-variable"]]
        if (void 0 !== n) return "number" === e.type || "integer" === e.type ? parseInt(n, 10) : n
      }
      if (Array.isArray(e.examples) && e.examples.length > 0) return e.examples[0]
      if (void 0 !== e.example) return e.example
      if (void 0 !== e.default) return e.default
      if (void 0 !== e.enum) return e.enum[0]
      if (
        "object" !== e.type &&
        "array" !== e.type &&
        !0 === (null == t ? void 0 : t.omitEmptyAndOptionalProperties) &&
        !0 !== e.required &&
        !0 !== (null == r ? void 0 : r.required) &&
        !(null == (i = null == r ? void 0 : r.required) ? void 0 : i.includes(a ?? e.name))
      )
        return
      if ("object" === e.type || void 0 !== e.properties) {
        const r = {}
        if (
          (void 0 !== e.properties &&
            Object.keys(e.properties).forEach((a) => {
              var o
              const i = e.properties[a],
                s = (null == t ? void 0 : t.xml) ? (null == (o = i.xml) ? void 0 : o.name) : void 0
              ;(r[s ?? a] = yp(i, t, n + 1, e, a)), void 0 === r[s ?? a] && delete r[s ?? a]
            }),
          void 0 !== e.anyOf
            ? Object.assign(r, yp(e.anyOf[0]), t, n + 1)
            : void 0 !== e.oneOf
              ? Object.assign(r, yp(e.oneOf[0]), t, n + 1)
              : void 0 !== e.allOf &&
                Object.assign(r, ...e.allOf.map((r) => yp(r, t, n + 1, e)).filter((e) => void 0 !== e)),
          void 0 !== e.additionalProperties && !1 !== e.additionalProperties)
        ) {
          const a = yp(e.additionalProperties, t, n + 1)
          if (a && "object" == typeof a && !Array.isArray(a)) return { ...r, ...yp(e.additionalProperties, t, n + 1) }
          if (null === a) return null
          const o = yp(e.additionalProperties, { ...t, omitEmptyAndOptionalProperties: !1 }, n + 1)
          return { ...r, ...(void 0 === o ? {} : { "{{key}}": o }) }
        }
        return r
      }
      if ("array" === e.type || void 0 !== e.items) {
        const r = null == (l = null == (s = null == e ? void 0 : e.items) ? void 0 : s.xml) ? void 0 : l.name,
          a = !!((null == t ? void 0 : t.xml) && (null == (c = e.xml) ? void 0 : c.wrapped) && r)
        if (void 0 !== e.example) return a ? { [r]: e.example } : e.example
        if (e.items) {
          const o = ["anyOf", "oneOf", "allOf"]
          for (const i of o) {
            if (!e.items[i]) continue
            const o = (["anyOf", "oneOf"].includes(i) ? e.items[i].slice(0, 1) : e.items[i])
              .map((r) => yp(r, t, n + 1, e))
              .filter((e) => void 0 !== e)
            return a ? [{ [r]: o }] : o
          }
        }
        if (null == (d = e.items) ? void 0 : d.type) {
          const o = yp(e.items, t, n + 1)
          return a ? [{ [r]: o }] : [o]
        }
        return []
      }
      const p = {
        string: u ? vp(e, null == t ? void 0 : t.emptyString) : "",
        boolean: !0,
        integer: e.min ?? 1,
        number: e.min ?? 1,
        array: [],
      }
      if (void 0 !== e.type && void 0 !== p[e.type]) return p[e.type]
      if (Array.isArray(e.oneOf) && e.oneOf.length > 0) {
        const r = e.oneOf[0]
        return yp(r, t, n + 1)
      }
      if (Array.isArray(e.allOf)) {
        let r = null
        return (
          e.allOf.forEach((e) => {
            const a = yp(e, t, n + 1)
            r =
              "object" == typeof a && "object" == typeof r
                ? { ...(r ?? {}), ...a }
                : Array.isArray(a) && Array.isArray(r)
                  ? [...(r ?? {}), ...a]
                  : a
          }),
          r
        )
      }
      if (Array.isArray(e.type)) {
        if (e.type.includes("null")) return null
        const t = p[e.type[0]]
        if (void 0 !== t) return t
      }
      return console.warn(`[getExampleFromSchema] Unknown property type "${e.type}".`), null
    }
    function Op(e, t, n = !0) {
      var r
      return [...(e.pathParameters || []), ...((null == (r = e.information) ? void 0 : r.parameters) || [])]
        .filter((e) => e.in === t)
        .filter((e) => (n && e.required) || !n)
        .map((e) => ({
          name: e.name,
          description: e.description ?? null,
          value: e.example ? e.example : e.schema ? yp(e.schema, { mode: "write" }) : "",
          required: e.required ?? !1,
          enabled: e.required ?? !1,
        }))
        .sort((e, t) => (e.required && !t.required ? -1 : !e.required && t.required ? 1 : 0))
    }
    function wp(e, t) {
      const n = function (e, t, r) {
        let a = ""
        if (e instanceof Array) for (let o = 0, i = e.length; o < i; o++) a += r + n(e[o], t, r + "\t") + "\n"
        else if ("object" == typeof e) {
          let o = !1
          a += r + "<" + t
          for (const t in e) "@" == t.charAt(0) ? (a += " " + t.substr(1) + '="' + e[t].toString() + '"') : (o = !0)
          if (((a += o ? ">" : "/>"), o)) {
            for (const t in e)
              "#text" == t
                ? (a += e[t])
                : "#cdata" == t
                  ? (a += "<![CDATA[" + e[t] + "]]>")
                  : "@" != t.charAt(0) && (a += n(e[t], t, r + "\t"))
            a += ("\n" == a.charAt(a.length - 1) ? r : "") + "</" + t + ">"
          }
        } else a += r + "<" + t + ">" + e.toString() + "</" + t + ">"
        return a
      }
      let r = ""
      for (const t in e) r += n(e[t], t, "")
      return t ? r.replace(/\t/g, t) : r.replace(/\t|\n/g, "")
    }
    function xp(e, t) {
      var n, r, a, o
      const i = Cd(null == (r = null == (n = e.information) ? void 0 : n.requestBody) ? void 0 : r.content),
        s = [
          "application/json",
          "application/octet-stream",
          "application/x-www-form-urlencoded",
          "application/xml",
          "multipart/form-data",
          "text/plain",
        ].find((e) => !!(null == i ? void 0 : i[e])),
        l = null == (a = null == i ? void 0 : i["application/json"]) ? void 0 : a.examples,
        c = null == (o = l ?? {}) ? void 0 : o[t ?? Object.keys(l ?? {})[0]]
      if (c) return { postData: { mimeType: "application/json", text: Dd(null == c ? void 0 : c.value) } }
      const d = Op(e, "body", !1)
      if (d.length > 0) return { postData: { mimeType: "application/json", text: Dd(d[0].value) } }
      const u = Op(e, "formData", !1)
      if (u.length > 0)
        return {
          postData: {
            mimeType: "application/x-www-form-urlencoded",
            params: u.map((e) => ({ name: e.name, value: e.value })),
          },
        }
      if (!s) return { postData: void 0 }
      const p = null == i ? void 0 : i[s],
        h = [{ name: "Content-Type", value: s }],
        f = (null == p ? void 0 : p.example) ? (null == p ? void 0 : p.example) : void 0
      if ("application/json" === s) {
        const e = (null == p ? void 0 : p.schema)
            ? yp(null == p ? void 0 : p.schema, { mode: "write", omitEmptyAndOptionalProperties: !0 })
            : null,
          t = f ?? e
        return { headers: h, postData: { mimeType: s, text: "string" == typeof t ? t : JSON.stringify(t, null, 2) } }
      }
      if ("application/xml" === s) {
        const e = (null == p ? void 0 : p.schema)
          ? yp(null == p ? void 0 : p.schema, { xml: !0, mode: "write", omitEmptyAndOptionalProperties: !0 })
          : null
        return { headers: h, postData: { mimeType: s, text: f ?? wp(e, "  ") } }
      }
      if ("application/octet-stream" === s) return { headers: h, postData: { mimeType: s, text: "BINARY" } }
      if ("text/plain" === s) {
        const e = (null == p ? void 0 : p.schema)
          ? yp(null == p ? void 0 : p.schema, { xml: !0, mode: "write", omitEmptyAndOptionalProperties: !0 })
          : null
        return { headers: h, postData: { mimeType: s, text: f ?? e ?? "" } }
      }
      return "application/x-www-form-urlencoded" === s || "multipart/form-data" === s
        ? { headers: h, postData: { mimeType: s } }
        : void 0
    }
    const kp = (e, t, n) => {
      let r = e.path
      const a = Op(e, "path", !1)
      if (a.length) {
        const e = r.match(/{(.*?)}/g)
        e &&
          e.forEach((e) => {
            const t = e.replace(/{|}/g, "")
            if (a) {
              const n = a.find((e) => e.name === t)
              ;(null == n ? void 0 : n.value) && (r = r.replace(e, n.value.toString()))
            }
          })
      }
      if (!0 === (null == t ? void 0 : t.replaceVariables)) {
        const e = r.match(/{(.*?)}/g)
        e &&
          e.forEach((e) => {
            const t = e.replace(/{|}/g, "")
            r = r.replace(e, `__${t.toUpperCase()}__`)
          })
      }
      const o = xp(e, n)
      return {
        method: e.httpVerb.toUpperCase(),
        path: r,
        headers: [...Op(e, "header", null == t ? void 0 : t.requiredOnly), ...((null == o ? void 0 : o.headers) ?? [])],
        postData: null == o ? void 0 : o.postData,
        queryString: Op(e, "query", null == t ? void 0 : t.requiredOnly),
        cookies: Op(e, "cookie", null == t ? void 0 : t.requiredOnly),
      }
    }
    function _p({ serverState: e, authenticationState: t, operation: n, globalSecurity: r }) {
      var a, o
      const i = Qf(
          { url: $d(e) },
          kp(n, { requiredOnly: !1 }),
          t ? cs(t, (null == (a = n.information) ? void 0 : a.security) ?? r ?? []) : {},
        ),
        s = kp(n, { requiredOnly: !1 }),
        l = Op(n, "path", !1)
      return {
        id: n.operationId,
        name: n.name,
        type: i.method,
        path: s.path ?? "",
        variables: l,
        cookies: Sp(i.cookies),
        query: i.queryString.map((e) => {
          const t = e
          return { ...e, enabled: t.required ?? !0 }
        }),
        headers: Sp(i.headers),
        url: $d(e) ?? "",
        body: null == (o = i.postData) ? void 0 : o.text,
      }
    }
    function Sp(e) {
      return (e ?? []).map((e) => ({ ...e, enabled: !0 }))
    }
    function Ep(e, t) {
      return function () {
        return e.apply(t, arguments)
      }
    }
    const { toString: Tp } = Object.prototype,
      { getPrototypeOf: Ap } = Object,
      Cp = ((e) => (t) => {
        const n = Tp.call(t)
        return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
      })(Object.create(null)),
      Pp = (e) => ((e = e.toLowerCase()), (t) => Cp(t) === e),
      Dp = (e) => (t) => typeof t === e,
      { isArray: Rp } = Array,
      Np = Dp("undefined"),
      $p = Pp("ArrayBuffer"),
      Ip = Dp("string"),
      Mp = Dp("function"),
      Lp = Dp("number"),
      Qp = (e) => null !== e && "object" == typeof e,
      Bp = (e) => {
        if ("object" !== Cp(e)) return !1
        const t = Ap(e)
        return !(
          (null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t)) ||
          Symbol.toStringTag in e ||
          Symbol.iterator in e
        )
      },
      jp = Pp("Date"),
      Up = Pp("File"),
      Fp = Pp("Blob"),
      zp = Pp("FileList"),
      qp = Pp("URLSearchParams"),
      [Zp, Hp, Vp, Wp] = ["ReadableStream", "Request", "Response", "Headers"].map(Pp)
    function Xp(e, t, { allOwnKeys: n = !1 } = {}) {
      if (null == e) return
      let r, a
      if (("object" != typeof e && (e = [e]), Rp(e))) for (r = 0, a = e.length; r < a; r++) t.call(null, e[r], r, e)
      else {
        const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e),
          o = a.length
        let i
        for (r = 0; r < o; r++) (i = a[r]), t.call(null, e[i], i, e)
      }
    }
    function Yp(e, t) {
      t = t.toLowerCase()
      const n = Object.keys(e)
      let r,
        a = n.length
      for (; a-- > 0; ) if (((r = n[a]), t === r.toLowerCase())) return r
      return null
    }
    const Gp =
        "undefined" != typeof globalThis
          ? globalThis
          : "undefined" != typeof self
            ? self
            : "undefined" != typeof window
              ? window
              : global,
      Kp = (e) => !Np(e) && e !== Gp,
      Jp = (
        (e) => (t) =>
          e && t instanceof e
      )("undefined" != typeof Uint8Array && Ap(Uint8Array)),
      eh = Pp("HTMLFormElement"),
      th = (
        ({ hasOwnProperty: e }) =>
        (t, n) =>
          e.call(t, n)
      )(Object.prototype),
      nh = Pp("RegExp"),
      rh = (e, t) => {
        const n = Object.getOwnPropertyDescriptors(e),
          r = {}
        Xp(n, (n, a) => {
          let o
          !1 !== (o = t(n, a, e)) && (r[a] = o || n)
        }),
          Object.defineProperties(e, r)
      },
      ah = "abcdefghijklmnopqrstuvwxyz",
      oh = "0123456789",
      ih = { DIGIT: oh, ALPHA: ah, ALPHA_DIGIT: ah + ah.toUpperCase() + oh },
      sh = Pp("AsyncFunction"),
      lh = {
        isArray: Rp,
        isArrayBuffer: $p,
        isBuffer: function (e) {
          return (
            null !== e &&
            !Np(e) &&
            null !== e.constructor &&
            !Np(e.constructor) &&
            Mp(e.constructor.isBuffer) &&
            e.constructor.isBuffer(e)
          )
        },
        isFormData: (e) => {
          let t
          return (
            e &&
            (("function" == typeof FormData && e instanceof FormData) ||
              (Mp(e.append) &&
                ("formdata" === (t = Cp(e)) ||
                  ("object" === t && Mp(e.toString) && "[object FormData]" === e.toString()))))
          )
        },
        isArrayBufferView: function (e) {
          let t
          return (
            (t =
              "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
                ? ArrayBuffer.isView(e)
                : e && e.buffer && $p(e.buffer)),
            t
          )
        },
        isString: Ip,
        isNumber: Lp,
        isBoolean: (e) => !0 === e || !1 === e,
        isObject: Qp,
        isPlainObject: Bp,
        isReadableStream: Zp,
        isRequest: Hp,
        isResponse: Vp,
        isHeaders: Wp,
        isUndefined: Np,
        isDate: jp,
        isFile: Up,
        isBlob: Fp,
        isRegExp: nh,
        isFunction: Mp,
        isStream: (e) => Qp(e) && Mp(e.pipe),
        isURLSearchParams: qp,
        isTypedArray: Jp,
        isFileList: zp,
        forEach: Xp,
        merge: function e() {
          const { caseless: t } = (Kp(this) && this) || {},
            n = {},
            r = (r, a) => {
              const o = (t && Yp(n, a)) || a
              Bp(n[o]) && Bp(r)
                ? (n[o] = e(n[o], r))
                : Bp(r)
                  ? (n[o] = e({}, r))
                  : Rp(r)
                    ? (n[o] = r.slice())
                    : (n[o] = r)
            }
          for (let e = 0, t = arguments.length; e < t; e++) arguments[e] && Xp(arguments[e], r)
          return n
        },
        extend: (e, t, n, { allOwnKeys: r } = {}) => (
          Xp(
            t,
            (t, r) => {
              n && Mp(t) ? (e[r] = Ep(t, n)) : (e[r] = t)
            },
            { allOwnKeys: r },
          ),
          e
        ),
        trim: (e) => (e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")),
        stripBOM: (e) => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
        inherits: (e, t, n, r) => {
          ;(e.prototype = Object.create(t.prototype, r)),
            (e.prototype.constructor = e),
            Object.defineProperty(e, "super", { value: t.prototype }),
            n && Object.assign(e.prototype, n)
        },
        toFlatObject: (e, t, n, r) => {
          let a, o, i
          const s = {}
          if (((t = t || {}), null == e)) return t
          do {
            for (a = Object.getOwnPropertyNames(e), o = a.length; o-- > 0; )
              (i = a[o]), (r && !r(i, e, t)) || s[i] || ((t[i] = e[i]), (s[i] = !0))
            e = !1 !== n && Ap(e)
          } while (e && (!n || n(e, t)) && e !== Object.prototype)
          return t
        },
        kindOf: Cp,
        kindOfTest: Pp,
        endsWith: (e, t, n) => {
          ;(e = String(e)), (void 0 === n || n > e.length) && (n = e.length), (n -= t.length)
          const r = e.indexOf(t, n)
          return -1 !== r && r === n
        },
        toArray: (e) => {
          if (!e) return null
          if (Rp(e)) return e
          let t = e.length
          if (!Lp(t)) return null
          const n = new Array(t)
          for (; t-- > 0; ) n[t] = e[t]
          return n
        },
        forEachEntry: (e, t) => {
          const n = (e && e[Symbol.iterator]).call(e)
          let r
          for (; (r = n.next()) && !r.done; ) {
            const n = r.value
            t.call(e, n[0], n[1])
          }
        },
        matchAll: (e, t) => {
          let n
          const r = []
          for (; null !== (n = e.exec(t)); ) r.push(n)
          return r
        },
        isHTMLForm: eh,
        hasOwnProperty: th,
        hasOwnProp: th,
        reduceDescriptors: rh,
        freezeMethods: (e) => {
          rh(e, (t, n) => {
            if (Mp(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1
            const r = e[n]
            Mp(r) &&
              ((t.enumerable = !1),
              "writable" in t
                ? (t.writable = !1)
                : t.set ||
                  (t.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'")
                  }))
          })
        },
        toObjectSet: (e, t) => {
          const n = {},
            r = (e) => {
              e.forEach((e) => {
                n[e] = !0
              })
            }
          return Rp(e) ? r(e) : r(String(e).split(t)), n
        },
        toCamelCase: (e) =>
          e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (e, t, n) {
            return t.toUpperCase() + n
          }),
        noop: () => {},
        toFiniteNumber: (e, t) => (null != e && Number.isFinite((e = +e)) ? e : t),
        findKey: Yp,
        global: Gp,
        isContextDefined: Kp,
        ALPHABET: ih,
        generateString: (e = 16, t = ih.ALPHA_DIGIT) => {
          let n = ""
          const { length: r } = t
          for (; e--; ) n += t[(Math.random() * r) | 0]
          return n
        },
        isSpecCompliantForm: function (e) {
          return !!(e && Mp(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
        },
        toJSONObject: (e) => {
          const t = new Array(10),
            n = (e, r) => {
              if (Qp(e)) {
                if (t.indexOf(e) >= 0) return
                if (!("toJSON" in e)) {
                  t[r] = e
                  const a = Rp(e) ? [] : {}
                  return (
                    Xp(e, (e, t) => {
                      const o = n(e, r + 1)
                      !Np(o) && (a[t] = o)
                    }),
                    (t[r] = void 0),
                    a
                  )
                }
              }
              return e
            }
          return n(e, 0)
        },
        isAsyncFn: sh,
        isThenable: (e) => e && (Qp(e) || Mp(e)) && Mp(e.then) && Mp(e.catch),
      }
    function ch(e, t, n, r, a) {
      Error.call(this),
        Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack),
        (this.message = e),
        (this.name = "AxiosError"),
        t && (this.code = t),
        n && (this.config = n),
        r && (this.request = r),
        a && (this.response = a)
    }
    lh.inherits(ch, Error, {
      toJSON: function () {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: lh.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null,
        }
      },
    })
    const dh = ch.prototype,
      uh = {}
    function ph(e) {
      return lh.isPlainObject(e) || lh.isArray(e)
    }
    function hh(e) {
      return lh.endsWith(e, "[]") ? e.slice(0, -2) : e
    }
    function fh(e, t, n) {
      return e
        ? e
            .concat(t)
            .map(function (e, t) {
              return (e = hh(e)), !n && t ? "[" + e + "]" : e
            })
            .join(n ? "." : "")
        : t
    }
    ;[
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL",
    ].forEach((e) => {
      uh[e] = { value: e }
    }),
      Object.defineProperties(ch, uh),
      Object.defineProperty(dh, "isAxiosError", { value: !0 }),
      (ch.from = (e, t, n, r, a, o) => {
        const i = Object.create(dh)
        return (
          lh.toFlatObject(
            e,
            i,
            function (e) {
              return e !== Error.prototype
            },
            (e) => "isAxiosError" !== e,
          ),
          ch.call(i, e.message, t, n, r, a),
          (i.cause = e),
          (i.name = e.name),
          o && Object.assign(i, o),
          i
        )
      })
    const mh = lh.toFlatObject(lh, {}, null, function (e) {
      return /^is[A-Z]/.test(e)
    })
    function gh(e, t, n) {
      if (!lh.isObject(e)) throw new TypeError("target must be an object")
      t = t || new FormData()
      const r = (n = lh.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (e, t) {
          return !lh.isUndefined(t[e])
        })).metaTokens,
        a = n.visitor || c,
        o = n.dots,
        i = n.indexes,
        s = (n.Blob || ("undefined" != typeof Blob && Blob)) && lh.isSpecCompliantForm(t)
      if (!lh.isFunction(a)) throw new TypeError("visitor must be a function")
      function l(e) {
        if (null === e) return ""
        if (lh.isDate(e)) return e.toISOString()
        if (!s && lh.isBlob(e)) throw new ch("Blob is not supported. Use a Buffer instead.")
        return lh.isArrayBuffer(e) || lh.isTypedArray(e)
          ? s && "function" == typeof Blob
            ? new Blob([e])
            : Buffer.from(e)
          : e
      }
      function c(e, n, a) {
        let s = e
        if (e && !a && "object" == typeof e)
          if (lh.endsWith(n, "{}")) (n = r ? n : n.slice(0, -2)), (e = JSON.stringify(e))
          else if (
            (lh.isArray(e) &&
              (function (e) {
                return lh.isArray(e) && !e.some(ph)
              })(e)) ||
            ((lh.isFileList(e) || lh.endsWith(n, "[]")) && (s = lh.toArray(e)))
          )
            return (
              (n = hh(n)),
              s.forEach(function (e, r) {
                !lh.isUndefined(e) && null !== e && t.append(!0 === i ? fh([n], r, o) : null === i ? n : n + "[]", l(e))
              }),
              !1
            )
        return !!ph(e) || (t.append(fh(a, n, o), l(e)), !1)
      }
      const d = [],
        u = Object.assign(mh, { defaultVisitor: c, convertValue: l, isVisitable: ph })
      if (!lh.isObject(e)) throw new TypeError("data must be an object")
      return (
        (function e(n, r) {
          if (!lh.isUndefined(n)) {
            if (-1 !== d.indexOf(n)) throw Error("Circular reference detected in " + r.join("."))
            d.push(n),
              lh.forEach(n, function (n, o) {
                !0 === (!(lh.isUndefined(n) || null === n) && a.call(t, n, lh.isString(o) ? o.trim() : o, r, u)) &&
                  e(n, r ? r.concat(o) : [o])
              }),
              d.pop()
          }
        })(e),
        t
      )
    }
    function bh(e) {
      const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }
      return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) {
        return t[e]
      })
    }
    function vh(e, t) {
      ;(this._pairs = []), e && gh(e, this, t)
    }
    const yh = vh.prototype
    function Oh(e) {
      return encodeURIComponent(e)
        .replace(/%3A/gi, ":")
        .replace(/%24/g, "$")
        .replace(/%2C/gi, ",")
        .replace(/%20/g, "+")
        .replace(/%5B/gi, "[")
        .replace(/%5D/gi, "]")
    }
    function wh(e, t, n) {
      if (!t) return e
      const r = (n && n.encode) || Oh,
        a = n && n.serialize
      let o
      if (((o = a ? a(t, n) : lh.isURLSearchParams(t) ? t.toString() : new vh(t, n).toString(r)), o)) {
        const t = e.indexOf("#")
        ;-1 !== t && (e = e.slice(0, t)), (e += (-1 === e.indexOf("?") ? "?" : "&") + o)
      }
      return e
    }
    ;(yh.append = function (e, t) {
      this._pairs.push([e, t])
    }),
      (yh.toString = function (e) {
        const t = e
          ? function (t) {
              return e.call(this, t, bh)
            }
          : bh
        return this._pairs
          .map(function (e) {
            return t(e[0]) + "=" + t(e[1])
          }, "")
          .join("&")
      })
    class xh {
      constructor() {
        this.handlers = []
      }
      use(e, t, n) {
        return (
          this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null,
          }),
          this.handlers.length - 1
        )
      }
      eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
      }
      clear() {
        this.handlers && (this.handlers = [])
      }
      forEach(e) {
        lh.forEach(this.handlers, function (t) {
          null !== t && e(t)
        })
      }
    }
    const kh = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
      _h = {
        isBrowser: !0,
        classes: {
          URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : vh,
          FormData: "undefined" != typeof FormData ? FormData : null,
          Blob: "undefined" != typeof Blob ? Blob : null,
        },
        protocols: ["http", "https", "file", "blob", "url", "data"],
      },
      Sh = "undefined" != typeof window && "undefined" != typeof document,
      Eh =
        ((Th = "undefined" != typeof navigator && navigator.product),
        Sh && ["ReactNative", "NativeScript", "NS"].indexOf(Th) < 0)
    var Th
    const Ah =
        "undefined" != typeof WorkerGlobalScope &&
        self instanceof WorkerGlobalScope &&
        "function" == typeof self.importScripts,
      Ch = (Sh && window.location.href) || "http://localhost",
      Ph = {
        ...Object.freeze(
          Object.defineProperty(
            {
              __proto__: null,
              hasBrowserEnv: Sh,
              hasStandardBrowserEnv: Eh,
              hasStandardBrowserWebWorkerEnv: Ah,
              origin: Ch,
            },
            Symbol.toStringTag,
            { value: "Module" },
          ),
        ),
        ..._h,
      }
    function Dh(e) {
      function t(e, n, r, a) {
        let o = e[a++]
        if ("__proto__" === o) return !0
        const i = Number.isFinite(+o),
          s = a >= e.length
        return (
          (o = !o && lh.isArray(r) ? r.length : o),
          s
            ? (lh.hasOwnProp(r, o) ? (r[o] = [r[o], n]) : (r[o] = n), !i)
            : ((r[o] && lh.isObject(r[o])) || (r[o] = []),
              t(e, n, r[o], a) &&
                lh.isArray(r[o]) &&
                (r[o] = (function (e) {
                  const t = {},
                    n = Object.keys(e)
                  let r
                  const a = n.length
                  let o
                  for (r = 0; r < a; r++) (o = n[r]), (t[o] = e[o])
                  return t
                })(r[o])),
              !i)
        )
      }
      if (lh.isFormData(e) && lh.isFunction(e.entries)) {
        const n = {}
        return (
          lh.forEachEntry(e, (e, r) => {
            t(
              (function (e) {
                return lh.matchAll(/\w+|\[(\w*)]/g, e).map((e) => ("[]" === e[0] ? "" : e[1] || e[0]))
              })(e),
              r,
              n,
              0,
            )
          }),
          n
        )
      }
      return null
    }
    const Rh = {
      transitional: kh,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [
        function (e, t) {
          const n = t.getContentType() || "",
            r = n.indexOf("application/json") > -1,
            a = lh.isObject(e)
          if ((a && lh.isHTMLForm(e) && (e = new FormData(e)), lh.isFormData(e))) return r ? JSON.stringify(Dh(e)) : e
          if (
            lh.isArrayBuffer(e) ||
            lh.isBuffer(e) ||
            lh.isStream(e) ||
            lh.isFile(e) ||
            lh.isBlob(e) ||
            lh.isReadableStream(e)
          )
            return e
          if (lh.isArrayBufferView(e)) return e.buffer
          if (lh.isURLSearchParams(e))
            return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString()
          let o
          if (a) {
            if (n.indexOf("application/x-www-form-urlencoded") > -1)
              return (function (e, t) {
                return gh(
                  e,
                  new Ph.classes.URLSearchParams(),
                  Object.assign(
                    {
                      visitor: function (e, t, n, r) {
                        return Ph.isNode && lh.isBuffer(e)
                          ? (this.append(t, e.toString("base64")), !1)
                          : r.defaultVisitor.apply(this, arguments)
                      },
                    },
                    t,
                  ),
                )
              })(e, this.formSerializer).toString()
            if ((o = lh.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
              const t = this.env && this.env.FormData
              return gh(o ? { "files[]": e } : e, t && new t(), this.formSerializer)
            }
          }
          return a || r
            ? (t.setContentType("application/json", !1),
              (function (e, t, n) {
                if (lh.isString(e))
                  try {
                    return (0, JSON.parse)(e), lh.trim(e)
                  } catch (e) {
                    if ("SyntaxError" !== e.name) throw e
                  }
                return (0, JSON.stringify)(e)
              })(e))
            : e
        },
      ],
      transformResponse: [
        function (e) {
          const t = this.transitional || Rh.transitional,
            n = t && t.forcedJSONParsing,
            r = "json" === this.responseType
          if (lh.isResponse(e) || lh.isReadableStream(e)) return e
          if (e && lh.isString(e) && ((n && !this.responseType) || r)) {
            const n = !(t && t.silentJSONParsing) && r
            try {
              return JSON.parse(e)
            } catch (e) {
              if (n) {
                if ("SyntaxError" === e.name) throw ch.from(e, ch.ERR_BAD_RESPONSE, this, null, this.response)
                throw e
              }
            }
          }
          return e
        },
      ],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: { FormData: Ph.classes.FormData, Blob: Ph.classes.Blob },
      validateStatus: function (e) {
        return e >= 200 && e < 300
      },
      headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } },
    }
    lh.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
      Rh.headers[e] = {}
    })
    const Nh = lh.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent",
      ]),
      $h = Symbol("internals")
    function Ih(e) {
      return e && String(e).trim().toLowerCase()
    }
    function Mh(e) {
      return !1 === e || null == e ? e : lh.isArray(e) ? e.map(Mh) : String(e)
    }
    function Lh(e, t, n, r, a) {
      return lh.isFunction(r)
        ? r.call(this, t, n)
        : (a && (t = n),
          lh.isString(t) ? (lh.isString(r) ? -1 !== t.indexOf(r) : lh.isRegExp(r) ? r.test(t) : void 0) : void 0)
    }
    let Qh = class {
      constructor(e) {
        e && this.set(e)
      }
      set(e, t, n) {
        const r = this
        function a(e, t, n) {
          const a = Ih(t)
          if (!a) throw new Error("header name must be a non-empty string")
          const o = lh.findKey(r, a)
          ;(!o || void 0 === r[o] || !0 === n || (void 0 === n && !1 !== r[o])) && (r[o || t] = Mh(e))
        }
        const o = (e, t) => lh.forEach(e, (e, n) => a(e, n, t))
        if (lh.isPlainObject(e) || e instanceof this.constructor) o(e, t)
        else if (lh.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))
          o(
            ((e) => {
              const t = {}
              let n, r, a
              return (
                e &&
                  e.split("\n").forEach(function (e) {
                    ;(a = e.indexOf(":")),
                      (n = e.substring(0, a).trim().toLowerCase()),
                      (r = e.substring(a + 1).trim()),
                      !n ||
                        (t[n] && Nh[n]) ||
                        ("set-cookie" === n
                          ? t[n]
                            ? t[n].push(r)
                            : (t[n] = [r])
                          : (t[n] = t[n] ? t[n] + ", " + r : r))
                  }),
                t
              )
            })(e),
            t,
          )
        else if (lh.isHeaders(e)) for (const [t, r] of e.entries()) a(r, t, n)
        else null != e && a(t, e, n)
        return this
      }
      get(e, t) {
        if ((e = Ih(e))) {
          const n = lh.findKey(this, e)
          if (n) {
            const e = this[n]
            if (!t) return e
            if (!0 === t)
              return (function (e) {
                const t = Object.create(null),
                  n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
                let r
                for (; (r = n.exec(e)); ) t[r[1]] = r[2]
                return t
              })(e)
            if (lh.isFunction(t)) return t.call(this, e, n)
            if (lh.isRegExp(t)) return t.exec(e)
            throw new TypeError("parser must be boolean|regexp|function")
          }
        }
      }
      has(e, t) {
        if ((e = Ih(e))) {
          const n = lh.findKey(this, e)
          return !(!n || void 0 === this[n] || (t && !Lh(0, this[n], n, t)))
        }
        return !1
      }
      delete(e, t) {
        const n = this
        let r = !1
        function a(e) {
          if ((e = Ih(e))) {
            const a = lh.findKey(n, e)
            !a || (t && !Lh(0, n[a], a, t)) || (delete n[a], (r = !0))
          }
        }
        return lh.isArray(e) ? e.forEach(a) : a(e), r
      }
      clear(e) {
        const t = Object.keys(this)
        let n = t.length,
          r = !1
        for (; n--; ) {
          const a = t[n]
          ;(e && !Lh(0, this[a], a, e, !0)) || (delete this[a], (r = !0))
        }
        return r
      }
      normalize(e) {
        const t = this,
          n = {}
        return (
          lh.forEach(this, (r, a) => {
            const o = lh.findKey(n, a)
            if (o) return (t[o] = Mh(r)), void delete t[a]
            const i = e
              ? (function (e) {
                  return e
                    .trim()
                    .toLowerCase()
                    .replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n)
                })(a)
              : String(a).trim()
            i !== a && delete t[a], (t[i] = Mh(r)), (n[i] = !0)
          }),
          this
        )
      }
      concat(...e) {
        return this.constructor.concat(this, ...e)
      }
      toJSON(e) {
        const t = Object.create(null)
        return (
          lh.forEach(this, (n, r) => {
            null != n && !1 !== n && (t[r] = e && lh.isArray(n) ? n.join(", ") : n)
          }),
          t
        )
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
      }
      toString() {
        return Object.entries(this.toJSON())
          .map(([e, t]) => e + ": " + t)
          .join("\n")
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders"
      }
      static from(e) {
        return e instanceof this ? e : new this(e)
      }
      static concat(e, ...t) {
        const n = new this(e)
        return t.forEach((e) => n.set(e)), n
      }
      static accessor(e) {
        const t = (this[$h] = this[$h] = { accessors: {} }).accessors,
          n = this.prototype
        function r(e) {
          const r = Ih(e)
          t[r] ||
            ((function (e, t) {
              const n = lh.toCamelCase(" " + t)
              ;["get", "set", "has"].forEach((r) => {
                Object.defineProperty(e, r + n, {
                  value: function (e, n, a) {
                    return this[r].call(this, t, e, n, a)
                  },
                  configurable: !0,
                })
              })
            })(n, e),
            (t[r] = !0))
        }
        return lh.isArray(e) ? e.forEach(r) : r(e), this
      }
    }
    function Bh(e, t) {
      const n = this || Rh,
        r = t || n,
        a = Qh.from(r.headers)
      let o = r.data
      return (
        lh.forEach(e, function (e) {
          o = e.call(n, o, a.normalize(), t ? t.status : void 0)
        }),
        a.normalize(),
        o
      )
    }
    function jh(e) {
      return !(!e || !e.__CANCEL__)
    }
    function Uh(e, t, n) {
      ch.call(this, null == e ? "canceled" : e, ch.ERR_CANCELED, t, n), (this.name = "CanceledError")
    }
    function Fh(e, t, n) {
      const r = n.config.validateStatus
      n.status && r && !r(n.status)
        ? t(
            new ch(
              "Request failed with status code " + n.status,
              [ch.ERR_BAD_REQUEST, ch.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
              n.config,
              n.request,
              n,
            ),
          )
        : e(n)
    }
    Qh.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
      lh.reduceDescriptors(Qh.prototype, ({ value: e }, t) => {
        let n = t[0].toUpperCase() + t.slice(1)
        return {
          get: () => e,
          set(e) {
            this[n] = e
          },
        }
      }),
      lh.freezeMethods(Qh),
      lh.inherits(Uh, ch, { __CANCEL__: !0 })
    const zh = (e, t, n = 3) => {
        let r = 0
        const a = (function (e, t) {
          e = e || 10
          const n = new Array(e),
            r = new Array(e)
          let a,
            o = 0,
            i = 0
          return (
            (t = void 0 !== t ? t : 1e3),
            function (s) {
              const l = Date.now(),
                c = r[i]
              a || (a = l), (n[o] = s), (r[o] = l)
              let d = i,
                u = 0
              for (; d !== o; ) (u += n[d++]), (d %= e)
              if (((o = (o + 1) % e), o === i && (i = (i + 1) % e), l - a < t)) return
              const p = c && l - c
              return p ? Math.round((1e3 * u) / p) : void 0
            }
          )
        })(50, 250)
        return (function (e, t) {
          let n = 0
          const r = 1e3 / t
          let a = null
          return function () {
            const t = !0 === this,
              o = Date.now()
            if (t || o - n > r) return a && (clearTimeout(a), (a = null)), (n = o), e.apply(null, arguments)
            a || (a = setTimeout(() => ((a = null), (n = Date.now()), e.apply(null, arguments)), r - (o - n)))
          }
        })((n) => {
          const o = n.loaded,
            i = n.lengthComputable ? n.total : void 0,
            s = o - r,
            l = a(s)
          r = o
          const c = {
            loaded: o,
            total: i,
            progress: i ? o / i : void 0,
            bytes: s,
            rate: l || void 0,
            estimated: l && i && o <= i ? (i - o) / l : void 0,
            event: n,
            lengthComputable: null != i,
          }
          ;(c[t ? "download" : "upload"] = !0), e(c)
        }, n)
      },
      qh = Ph.hasStandardBrowserEnv
        ? (function () {
            const e = /(msie|trident)/i.test(navigator.userAgent),
              t = document.createElement("a")
            let n
            function r(n) {
              let r = n
              return (
                e && (t.setAttribute("href", r), (r = t.href)),
                t.setAttribute("href", r),
                {
                  href: t.href,
                  protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
                  host: t.host,
                  search: t.search ? t.search.replace(/^\?/, "") : "",
                  hash: t.hash ? t.hash.replace(/^#/, "") : "",
                  hostname: t.hostname,
                  port: t.port,
                  pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname,
                }
              )
            }
            return (
              (n = r(window.location.href)),
              function (e) {
                const t = lh.isString(e) ? r(e) : e
                return t.protocol === n.protocol && t.host === n.host
              }
            )
          })()
        : function () {
            return !0
          },
      Zh = Ph.hasStandardBrowserEnv
        ? {
            write(e, t, n, r, a, o) {
              const i = [e + "=" + encodeURIComponent(t)]
              lh.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()),
                lh.isString(r) && i.push("path=" + r),
                lh.isString(a) && i.push("domain=" + a),
                !0 === o && i.push("secure"),
                (document.cookie = i.join("; "))
            },
            read(e) {
              const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"))
              return t ? decodeURIComponent(t[3]) : null
            },
            remove(e) {
              this.write(e, "", Date.now() - 864e5)
            },
          }
        : { write() {}, read: () => null, remove() {} }
    function Hh(e, t) {
      return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
        ? (function (e, t) {
            return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
          })(e, t)
        : t
    }
    const Vh = (e) => (e instanceof Qh ? { ...e } : e)
    function Wh(e, t) {
      t = t || {}
      const n = {}
      function r(e, t, n) {
        return lh.isPlainObject(e) && lh.isPlainObject(t)
          ? lh.merge.call({ caseless: n }, e, t)
          : lh.isPlainObject(t)
            ? lh.merge({}, t)
            : lh.isArray(t)
              ? t.slice()
              : t
      }
      function a(e, t, n) {
        return lh.isUndefined(t) ? (lh.isUndefined(e) ? void 0 : r(void 0, e, n)) : r(e, t, n)
      }
      function o(e, t) {
        if (!lh.isUndefined(t)) return r(void 0, t)
      }
      function i(e, t) {
        return lh.isUndefined(t) ? (lh.isUndefined(e) ? void 0 : r(void 0, e)) : r(void 0, t)
      }
      function s(n, a, o) {
        return o in t ? r(n, a) : o in e ? r(void 0, n) : void 0
      }
      const l = {
        url: o,
        method: o,
        data: o,
        baseURL: i,
        transformRequest: i,
        transformResponse: i,
        paramsSerializer: i,
        timeout: i,
        timeoutMessage: i,
        withCredentials: i,
        withXSRFToken: i,
        adapter: i,
        responseType: i,
        xsrfCookieName: i,
        xsrfHeaderName: i,
        onUploadProgress: i,
        onDownloadProgress: i,
        decompress: i,
        maxContentLength: i,
        maxBodyLength: i,
        beforeRedirect: i,
        transport: i,
        httpAgent: i,
        httpsAgent: i,
        cancelToken: i,
        socketPath: i,
        responseEncoding: i,
        validateStatus: s,
        headers: (e, t) => a(Vh(e), Vh(t), !0),
      }
      return (
        lh.forEach(Object.keys(Object.assign({}, e, t)), function (r) {
          const o = l[r] || a,
            i = o(e[r], t[r], r)
          ;(lh.isUndefined(i) && o !== s) || (n[r] = i)
        }),
        n
      )
    }
    const Xh = (e) => {
        const t = Wh({}, e)
        let n,
          { data: r, withXSRFToken: a, xsrfHeaderName: o, xsrfCookieName: i, headers: s, auth: l } = t
        if (
          ((t.headers = s = Qh.from(s)),
          (t.url = wh(Hh(t.baseURL, t.url), e.params, e.paramsSerializer)),
          l &&
            s.set(
              "Authorization",
              "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : "")),
            ),
          lh.isFormData(r))
        )
          if (Ph.hasStandardBrowserEnv || Ph.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0)
          else if (!1 !== (n = s.getContentType())) {
            const [e, ...t] = n
              ? n
                  .split(";")
                  .map((e) => e.trim())
                  .filter(Boolean)
              : []
            s.setContentType([e || "multipart/form-data", ...t].join("; "))
          }
        if (Ph.hasStandardBrowserEnv && (a && lh.isFunction(a) && (a = a(t)), a || (!1 !== a && qh(t.url)))) {
          const e = o && i && Zh.read(i)
          e && s.set(o, e)
        }
        return t
      },
      Yh =
        "undefined" != typeof XMLHttpRequest &&
        function (e) {
          return new Promise(function (t, n) {
            const r = Xh(e)
            let a = r.data
            const o = Qh.from(r.headers).normalize()
            let i,
              { responseType: s } = r
            function l() {
              r.cancelToken && r.cancelToken.unsubscribe(i), r.signal && r.signal.removeEventListener("abort", i)
            }
            let c = new XMLHttpRequest()
            function d() {
              if (!c) return
              const r = Qh.from("getAllResponseHeaders" in c && c.getAllResponseHeaders())
              Fh(
                function (e) {
                  t(e), l()
                },
                function (e) {
                  n(e), l()
                },
                {
                  data: s && "text" !== s && "json" !== s ? c.response : c.responseText,
                  status: c.status,
                  statusText: c.statusText,
                  headers: r,
                  config: e,
                  request: c,
                },
              ),
                (c = null)
            }
            c.open(r.method.toUpperCase(), r.url, !0),
              (c.timeout = r.timeout),
              "onloadend" in c
                ? (c.onloadend = d)
                : (c.onreadystatechange = function () {
                    c &&
                      4 === c.readyState &&
                      (0 !== c.status || (c.responseURL && 0 === c.responseURL.indexOf("file:"))) &&
                      setTimeout(d)
                  }),
              (c.onabort = function () {
                c && (n(new ch("Request aborted", ch.ECONNABORTED, r, c)), (c = null))
              }),
              (c.onerror = function () {
                n(new ch("Network Error", ch.ERR_NETWORK, r, c)), (c = null)
              }),
              (c.ontimeout = function () {
                let e = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"
                const t = r.transitional || kh
                r.timeoutErrorMessage && (e = r.timeoutErrorMessage),
                  n(new ch(e, t.clarifyTimeoutError ? ch.ETIMEDOUT : ch.ECONNABORTED, r, c)),
                  (c = null)
              }),
              void 0 === a && o.setContentType(null),
              "setRequestHeader" in c &&
                lh.forEach(o.toJSON(), function (e, t) {
                  c.setRequestHeader(t, e)
                }),
              lh.isUndefined(r.withCredentials) || (c.withCredentials = !!r.withCredentials),
              s && "json" !== s && (c.responseType = r.responseType),
              "function" == typeof r.onDownloadProgress && c.addEventListener("progress", zh(r.onDownloadProgress, !0)),
              "function" == typeof r.onUploadProgress &&
                c.upload &&
                c.upload.addEventListener("progress", zh(r.onUploadProgress)),
              (r.cancelToken || r.signal) &&
                ((i = (t) => {
                  c && (n(!t || t.type ? new Uh(null, e, c) : t), c.abort(), (c = null))
                }),
                r.cancelToken && r.cancelToken.subscribe(i),
                r.signal && (r.signal.aborted ? i() : r.signal.addEventListener("abort", i)))
            const u = (function (e) {
              const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e)
              return (t && t[1]) || ""
            })(r.url)
            u && -1 === Ph.protocols.indexOf(u)
              ? n(new ch("Unsupported protocol " + u + ":", ch.ERR_BAD_REQUEST, e))
              : c.send(a || null)
          })
        },
      Gh = (e, t) => {
        let n,
          r = new AbortController()
        const a = function (e) {
          if (!n) {
            ;(n = !0), i()
            const t = e instanceof Error ? e : this.reason
            r.abort(t instanceof ch ? t : new Uh(t instanceof Error ? t.message : t))
          }
        }
        let o =
          t &&
          setTimeout(() => {
            a(new ch(`timeout ${t} of ms exceeded`, ch.ETIMEDOUT))
          }, t)
        const i = () => {
          e &&
            (o && clearTimeout(o),
            (o = null),
            e.forEach((e) => {
              e && (e.removeEventListener ? e.removeEventListener("abort", a) : e.unsubscribe(a))
            }),
            (e = null))
        }
        e.forEach((e) => e && e.addEventListener && e.addEventListener("abort", a))
        const { signal: s } = r
        return (
          (s.unsubscribe = i),
          [
            s,
            () => {
              o && clearTimeout(o), (o = null)
            },
          ]
        )
      },
      Kh = function* (e, t) {
        let n = e.byteLength
        if (!t || n < t) return void (yield e)
        let r,
          a = 0
        for (; a < n; ) (r = a + t), yield e.slice(a, r), (a = r)
      },
      Jh = (e, t, n, r, a) => {
        const o = (async function* (e, t, n) {
          for await (const r of e) yield* Kh(ArrayBuffer.isView(r) ? r : await n(String(r)), t)
        })(e, t, a)
        let i = 0
        return new ReadableStream(
          {
            type: "bytes",
            async pull(e) {
              const { done: t, value: a } = await o.next()
              if (t) return e.close(), void r()
              let s = a.byteLength
              n && n((i += s)), e.enqueue(new Uint8Array(a))
            },
            cancel: (e) => (r(e), o.return()),
          },
          { highWaterMark: 2 },
        )
      },
      ef = (e, t) => {
        const n = null != e
        return (r) => setTimeout(() => t({ lengthComputable: n, total: e, loaded: r }))
      },
      tf = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response,
      nf = tf && "function" == typeof ReadableStream,
      rf =
        tf &&
        ("function" == typeof TextEncoder
          ? (
              (e) => (t) =>
                e.encode(t)
            )(new TextEncoder())
          : async (e) => new Uint8Array(await new Response(e).arrayBuffer())),
      af =
        nf &&
        (() => {
          let e = !1
          const t = new Request(Ph.origin, {
            body: new ReadableStream(),
            method: "POST",
            get duplex() {
              return (e = !0), "half"
            },
          }).headers.has("Content-Type")
          return e && !t
        })(),
      of =
        nf &&
        !!(() => {
          try {
            return lh.isReadableStream(new Response("").body)
          } catch (e) {}
        })(),
      sf = { stream: of && ((e) => e.body) }
    var lf
    tf &&
      ((lf = new Response()),
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
        !sf[e] &&
          (sf[e] = lh.isFunction(lf[e])
            ? (t) => t[e]()
            : (t, n) => {
                throw new ch(`Response type '${e}' is not supported`, ch.ERR_NOT_SUPPORT, n)
              })
      }))
    const cf = {
      http: null,
      xhr: Yh,
      fetch:
        tf &&
        (async (e) => {
          let {
            url: t,
            method: n,
            data: r,
            signal: a,
            cancelToken: o,
            timeout: i,
            onDownloadProgress: s,
            onUploadProgress: l,
            responseType: c,
            headers: d,
            withCredentials: u = "same-origin",
            fetchOptions: p,
          } = Xh(e)
          c = c ? (c + "").toLowerCase() : "text"
          let h,
            f,
            [m, g] = a || o || i ? Gh([a, o], i) : []
          const b = () => {
            !h &&
              setTimeout(() => {
                m && m.unsubscribe()
              }),
              (h = !0)
          }
          let v
          try {
            if (
              l &&
              af &&
              "get" !== n &&
              "head" !== n &&
              0 !==
                (v = await (async (e, t) => {
                  const n = lh.toFiniteNumber(e.getContentLength())
                  return null == n
                    ? (async (e) =>
                        null == e
                          ? 0
                          : lh.isBlob(e)
                            ? e.size
                            : lh.isSpecCompliantForm(e)
                              ? (await new Request(e).arrayBuffer()).byteLength
                              : lh.isArrayBufferView(e)
                                ? e.byteLength
                                : (lh.isURLSearchParams(e) && (e += ""),
                                  lh.isString(e) ? (await rf(e)).byteLength : void 0))(t)
                    : n
                })(d, r))
            ) {
              let e,
                n = new Request(t, { method: "POST", body: r, duplex: "half" })
              lh.isFormData(r) && (e = n.headers.get("content-type")) && d.setContentType(e),
                n.body && (r = Jh(n.body, 65536, ef(v, zh(l)), null, rf))
            }
            lh.isString(u) || (u = u ? "cors" : "omit"),
              (f = new Request(t, {
                ...p,
                signal: m,
                method: n.toUpperCase(),
                headers: d.normalize().toJSON(),
                body: r,
                duplex: "half",
                withCredentials: u,
              }))
            let a = await fetch(f)
            const o = of && ("stream" === c || "response" === c)
            if (of && (s || o)) {
              const e = {}
              ;["status", "statusText", "headers"].forEach((t) => {
                e[t] = a[t]
              })
              const t = lh.toFiniteNumber(a.headers.get("content-length"))
              a = new Response(Jh(a.body, 65536, s && ef(t, zh(s, !0)), o && b, rf), e)
            }
            c = c || "text"
            let i = await sf[lh.findKey(sf, c) || "text"](a, e)
            return (
              !o && b(),
              g && g(),
              await new Promise((t, n) => {
                Fh(t, n, {
                  data: i,
                  headers: Qh.from(a.headers),
                  status: a.status,
                  statusText: a.statusText,
                  config: e,
                  request: f,
                })
              })
            )
          } catch (t) {
            if ((b(), t && "TypeError" === t.name && /fetch/i.test(t.message)))
              throw Object.assign(new ch("Network Error", ch.ERR_NETWORK, e, f), { cause: t.cause || t })
            throw ch.from(t, t && t.code, e, f)
          }
        }),
    }
    lh.forEach(cf, (e, t) => {
      if (e) {
        try {
          Object.defineProperty(e, "name", { value: t })
        } catch (e) {}
        Object.defineProperty(e, "adapterName", { value: t })
      }
    })
    const df = (e) => `- ${e}`,
      uf = (e) => lh.isFunction(e) || null === e || !1 === e,
      pf = (e) => {
        e = lh.isArray(e) ? e : [e]
        const { length: t } = e
        let n, r
        const a = {}
        for (let o = 0; o < t; o++) {
          let t
          if (((n = e[o]), (r = n), !uf(n) && ((r = cf[(t = String(n)).toLowerCase()]), void 0 === r)))
            throw new ch(`Unknown adapter '${t}'`)
          if (r) break
          a[t || "#" + o] = r
        }
        if (!r) {
          const e = Object.entries(a).map(
            ([e, t]) =>
              `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"),
          )
          throw new ch(
            "There is no suitable adapter to dispatch the request " +
              (t ? (e.length > 1 ? "since :\n" + e.map(df).join("\n") : " " + df(e[0])) : "as no adapter specified"),
            "ERR_NOT_SUPPORT",
          )
        }
        return r
      }
    function hf(e) {
      if ((e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)) throw new Uh(null, e)
    }
    function ff(e) {
      return (
        hf(e),
        (e.headers = Qh.from(e.headers)),
        (e.data = Bh.call(e, e.transformRequest)),
        -1 !== ["post", "put", "patch"].indexOf(e.method) &&
          e.headers.setContentType("application/x-www-form-urlencoded", !1),
        pf(e.adapter || Rh.adapter)(e).then(
          function (t) {
            return hf(e), (t.data = Bh.call(e, e.transformResponse, t)), (t.headers = Qh.from(t.headers)), t
          },
          function (t) {
            return (
              jh(t) ||
                (hf(e),
                t &&
                  t.response &&
                  ((t.response.data = Bh.call(e, e.transformResponse, t.response)),
                  (t.response.headers = Qh.from(t.response.headers)))),
              Promise.reject(t)
            )
          },
        )
      )
    }
    const mf = {}
    ;["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
      mf[e] = function (n) {
        return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
      }
    })
    const gf = {}
    mf.transitional = function (e, t, n) {
      function r(e, t) {
        return "[Axios v1.7.2] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
      }
      return (n, a, o) => {
        if (!1 === e) throw new ch(r(a, " has been removed" + (t ? " in " + t : "")), ch.ERR_DEPRECATED)
        return (
          t &&
            !gf[a] &&
            ((gf[a] = !0),
            console.warn(r(a, " has been deprecated since v" + t + " and will be removed in the near future"))),
          !e || e(n, a, o)
        )
      }
    }
    const bf = {
        assertOptions: function (e, t, n) {
          if ("object" != typeof e) throw new ch("options must be an object", ch.ERR_BAD_OPTION_VALUE)
          const r = Object.keys(e)
          let a = r.length
          for (; a-- > 0; ) {
            const o = r[a],
              i = t[o]
            if (i) {
              const t = e[o],
                n = void 0 === t || i(t, o, e)
              if (!0 !== n) throw new ch("option " + o + " must be " + n, ch.ERR_BAD_OPTION_VALUE)
            } else if (!0 !== n) throw new ch("Unknown option " + o, ch.ERR_BAD_OPTION)
          }
        },
        validators: mf,
      },
      vf = bf.validators
    let yf = class {
      constructor(e) {
        ;(this.defaults = e), (this.interceptors = { request: new xh(), response: new xh() })
      }
      async request(e, t) {
        try {
          return await this._request(e, t)
        } catch (e) {
          if (e instanceof Error) {
            let t
            Error.captureStackTrace ? Error.captureStackTrace((t = {})) : (t = new Error())
            const n = t.stack ? t.stack.replace(/^.+\n/, "") : ""
            try {
              e.stack
                ? n && !String(e.stack).endsWith(n.replace(/^.+\n.+\n/, "")) && (e.stack += "\n" + n)
                : (e.stack = n)
            } catch (e) {}
          }
          throw e
        }
      }
      _request(e, t) {
        "string" == typeof e ? ((t = t || {}).url = e) : (t = e || {}), (t = Wh(this.defaults, t))
        const { transitional: n, paramsSerializer: r, headers: a } = t
        void 0 !== n &&
          bf.assertOptions(
            n,
            {
              silentJSONParsing: vf.transitional(vf.boolean),
              forcedJSONParsing: vf.transitional(vf.boolean),
              clarifyTimeoutError: vf.transitional(vf.boolean),
            },
            !1,
          ),
          null != r &&
            (lh.isFunction(r)
              ? (t.paramsSerializer = { serialize: r })
              : bf.assertOptions(r, { encode: vf.function, serialize: vf.function }, !0)),
          (t.method = (t.method || this.defaults.method || "get").toLowerCase())
        let o = a && lh.merge(a.common, a[t.method])
        a &&
          lh.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e) => {
            delete a[e]
          }),
          (t.headers = Qh.concat(o, a))
        const i = []
        let s = !0
        this.interceptors.request.forEach(function (e) {
          ;("function" == typeof e.runWhen && !1 === e.runWhen(t)) ||
            ((s = s && e.synchronous), i.unshift(e.fulfilled, e.rejected))
        })
        const l = []
        let c
        this.interceptors.response.forEach(function (e) {
          l.push(e.fulfilled, e.rejected)
        })
        let d,
          u = 0
        if (!s) {
          const e = [ff.bind(this), void 0]
          for (e.unshift.apply(e, i), e.push.apply(e, l), d = e.length, c = Promise.resolve(t); u < d; )
            c = c.then(e[u++], e[u++])
          return c
        }
        d = i.length
        let p = t
        for (u = 0; u < d; ) {
          const e = i[u++],
            t = i[u++]
          try {
            p = e(p)
          } catch (e) {
            t.call(this, e)
            break
          }
        }
        try {
          c = ff.call(this, p)
        } catch (e) {
          return Promise.reject(e)
        }
        for (u = 0, d = l.length; u < d; ) c = c.then(l[u++], l[u++])
        return c
      }
      getUri(e) {
        return wh(Hh((e = Wh(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
      }
    }
    lh.forEach(["delete", "get", "head", "options"], function (e) {
      yf.prototype[e] = function (t, n) {
        return this.request(Wh(n || {}, { method: e, url: t, data: (n || {}).data }))
      }
    }),
      lh.forEach(["post", "put", "patch"], function (e) {
        function t(t) {
          return function (n, r, a) {
            return this.request(
              Wh(a || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r }),
            )
          }
        }
        ;(yf.prototype[e] = t()), (yf.prototype[e + "Form"] = t(!0))
      })
    const Of = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
    }
    Object.entries(Of).forEach(([e, t]) => {
      Of[t] = e
    })
    const wf = (function e(t) {
      const n = new yf(t),
        r = Ep(yf.prototype.request, n)
      return (
        lh.extend(r, yf.prototype, n, { allOwnKeys: !0 }),
        lh.extend(r, n, null, { allOwnKeys: !0 }),
        (r.create = function (n) {
          return e(Wh(t, n))
        }),
        r
      )
    })(Rh)
    ;(wf.Axios = yf),
      (wf.CanceledError = Uh),
      (wf.CancelToken = class e {
        constructor(e) {
          if ("function" != typeof e) throw new TypeError("executor must be a function.")
          let t
          this.promise = new Promise(function (e) {
            t = e
          })
          const n = this
          this.promise.then((e) => {
            if (!n._listeners) return
            let t = n._listeners.length
            for (; t-- > 0; ) n._listeners[t](e)
            n._listeners = null
          }),
            (this.promise.then = (e) => {
              let t
              const r = new Promise((e) => {
                n.subscribe(e), (t = e)
              }).then(e)
              return (
                (r.cancel = function () {
                  n.unsubscribe(t)
                }),
                r
              )
            }),
            e(function (e, r, a) {
              n.reason || ((n.reason = new Uh(e, r, a)), t(n.reason))
            })
        }
        throwIfRequested() {
          if (this.reason) throw this.reason
        }
        subscribe(e) {
          this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : (this._listeners = [e])
        }
        unsubscribe(e) {
          if (!this._listeners) return
          const t = this._listeners.indexOf(e)
          ;-1 !== t && this._listeners.splice(t, 1)
        }
        static source() {
          let t
          return {
            token: new e(function (e) {
              t = e
            }),
            cancel: t,
          }
        }
      }),
      (wf.isCancel = jh),
      (wf.VERSION = "1.7.2"),
      (wf.toFormData = gh),
      (wf.AxiosError = ch),
      (wf.Cancel = wf.CanceledError),
      (wf.all = function (e) {
        return Promise.all(e)
      }),
      (wf.spread = function (e) {
        return function (t) {
          return e.apply(null, t)
        }
      }),
      (wf.isAxiosError = function (e) {
        return lh.isObject(e) && !0 === e.isAxiosError
      }),
      (wf.mergeConfig = Wh),
      (wf.AxiosHeaders = Qh),
      (wf.formToJSON = (e) => Dh(lh.isHTMLForm(e) ? new FormData(e) : e)),
      (wf.getAdapter = pf),
      (wf.HttpStatusCode = Of),
      (wf.default = wf)
    const {
        Axios: xf,
        AxiosError: kf,
        CanceledError: _f,
        isCancel: Sf,
        CancelToken: Ef,
        VERSION: Tf,
        all: Af,
        Cancel: Cf,
        isAxiosError: Pf,
        spread: Df,
        toFormData: Rf,
        AxiosHeaders: Nf,
        HttpStatusCode: $f,
        formToJSON: If,
        getAdapter: Mf,
        mergeConfig: Lf,
      } = wf,
      Qf = (...e) => {
        let t = {
          httpVersion: "1.1",
          method: "GET",
          url: "",
          path: "",
          headers: [],
          headersSize: -1,
          queryString: [],
          cookies: [],
          bodySize: -1,
        }
        e.forEach((e) => {
          t = {
            ...t,
            ...e,
            headers: [...t.headers, ...(e.headers ?? [])],
            queryString: [...t.queryString, ...(e.queryString ?? [])],
            cookies: [...t.cookies, ...(e.cookies ?? [])],
          }
        })
        const n = t.headers.reduce((e, { name: t, value: n }) => ((e[t] = n), e), {}),
          r = Nf.from(n).normalize(!0)
        t.headers = Object.entries(r).map(([e, t]) => ({ name: e, value: t }))
        const { path: a, ...o } = t
        return a ? { ...o, url: `${t.url}${a}` } : o
      }
    function Bf(e) {
      const t = new tp(),
        n = new RegExp("^(#{1,6}) (?!#)(.*)", "gm")
      return ((e, t) => e.map((e) => ({ ...e, slug: t.slug(e.value) })))(
        [...e.matchAll(n)].map((e) => ({ value: e[2], depth: e[1].length })),
        t,
      )
    }
    const jf = (e) => {
      const t = Math.min(...e.map((e) => e.depth))
      return t >= 1 && t <= 6 ? t : 1
    }
    function Uf(e) {
      var t, n
      if (!e) return {}
      const r = Object.keys((null == (t = null == e ? void 0 : e.components) ? void 0 : t.schemas) ?? {}).length
        ? null == (n = null == e ? void 0 : e.components)
          ? void 0
          : n.schemas
        : Object.keys((null == e ? void 0 : e.definitions) ?? {}).length
          ? null == e
            ? void 0
            : e.definitions
          : {}
      return (
        Object.keys(r ?? {}).forEach((e) => {
          var t
          !0 === (null == (t = r[e]) ? void 0 : t["x-internal"]) && delete r[e]
        }),
        r
      )
    }
    const Ff = (e) => !!e && !!Object.keys(Uf(e) ?? {}).length,
      zf = (e) => {
        var t
        return !!Object.keys((null == (t = null == e ? void 0 : e.components) ? void 0 : t.securitySchemes) ?? {})
          .length
      },
      qf = (e, t) => e.replace(/\/$/, "") + "/" + t.replace(/^\//, ""),
      { server: Zf } = au(),
      { setOperation: Hf, setGlobalSecurity: Vf } = Xd(),
      { toggleApiClient: Wf } = Fd(),
      { setActiveRequest: Xf, resetActiveResponse: Yf } = {
        readOnly: tu,
        activeRequest: Jd,
        activeResponse: eu,
        requestHistory: Yd,
        requestHistoryOrder: Gd,
        activeRequestId: Kd,
        setActiveResponse: (e) => {
          var t
          Kd.value = e
          const n = null == (t = Yd[e]) ? void 0 : t.request,
            r = JSON.parse(JSON.stringify(n))
          ;(r.body = JSON.stringify((null == n ? void 0 : n.body) ?? "", null, 2)), Object.assign(Jd, r)
        },
        resetActiveResponse: () => {
          Kd.value = ""
        },
        addRequestToHistory: (e) => {
          ;(Yd[e.responseId] = e), (Kd.value = e.responseId), Gd.value.unshift(e.responseId)
        },
        setActiveRequest: (e) => {
          Object.assign(Jd, e)
        },
      }
    function Gf(e, t) {
      const n = _p({ serverState: Zf, operation: e, authenticationState: null, globalSecurity: null })
      Yf(), Xf(n), Hf(e), Vf(t), Wf(n, !0)
    }
    const Kf = Object.keys({
        "2.0": {
          title: "A JSON Schema for Swagger 2.0 API.",
          id: "http://swagger.io/v2/schema.json#",
          $schema: "http://json-schema.org/draft-04/schema#",
          type: "object",
          required: ["swagger", "info", "paths"],
          additionalProperties: !1,
          patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
          properties: {
            swagger: { type: "string", enum: ["2.0"], description: "The Swagger version of this document." },
            info: { $ref: "#/definitions/info" },
            host: {
              type: "string",
              pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
              description: "The host (name or ip) of the API. Example: 'swagger.io'",
            },
            basePath: { type: "string", pattern: "^/", description: "The base path to the API. Example: '/api'." },
            schemes: { $ref: "#/definitions/schemesList" },
            consumes: {
              description: "A list of MIME types accepted by the API.",
              allOf: [{ $ref: "#/definitions/mediaTypeList" }],
            },
            produces: {
              description: "A list of MIME types the API can produce.",
              allOf: [{ $ref: "#/definitions/mediaTypeList" }],
            },
            paths: { $ref: "#/definitions/paths" },
            definitions: { $ref: "#/definitions/definitions" },
            parameters: { $ref: "#/definitions/parameterDefinitions" },
            responses: { $ref: "#/definitions/responseDefinitions" },
            security: { $ref: "#/definitions/security" },
            securityDefinitions: { $ref: "#/definitions/securityDefinitions" },
            tags: { type: "array", items: { $ref: "#/definitions/tag" }, uniqueItems: !0 },
            externalDocs: { $ref: "#/definitions/externalDocs" },
          },
          definitions: {
            info: {
              type: "object",
              description: "General information about the API.",
              required: ["version", "title"],
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                title: { type: "string", description: "A unique and precise title of the API." },
                version: { type: "string", description: "A semantic version number of the API." },
                description: {
                  type: "string",
                  description:
                    "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.",
                },
                termsOfService: { type: "string", description: "The terms of service for the API." },
                contact: { $ref: "#/definitions/contact" },
                license: { $ref: "#/definitions/license" },
              },
            },
            contact: {
              type: "object",
              description: "Contact information for the owners of the API.",
              additionalProperties: !1,
              properties: {
                name: { type: "string", description: "The identifying name of the contact person/organization." },
                url: { type: "string", description: "The URL pointing to the contact information.", format: "uri" },
                email: {
                  type: "string",
                  description: "The email address of the contact person/organization.",
                  format: "email",
                },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            license: {
              type: "object",
              required: ["name"],
              additionalProperties: !1,
              properties: {
                name: {
                  type: "string",
                  description: "The name of the license type. It's encouraged to use an OSI compatible license.",
                },
                url: { type: "string", description: "The URL pointing to the license.", format: "uri" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            paths: {
              type: "object",
              description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
              patternProperties: {
                "^x-": { $ref: "#/definitions/vendorExtension" },
                "^/": { $ref: "#/definitions/pathItem" },
              },
              additionalProperties: !1,
            },
            definitions: {
              type: "object",
              additionalProperties: { $ref: "#/definitions/schema" },
              description: "One or more JSON objects describing the schemas being consumed and produced by the API.",
            },
            parameterDefinitions: {
              type: "object",
              additionalProperties: { $ref: "#/definitions/parameter" },
              description: "One or more JSON representations for parameters",
            },
            responseDefinitions: {
              type: "object",
              additionalProperties: { $ref: "#/definitions/response" },
              description: "One or more JSON representations for responses",
            },
            externalDocs: {
              type: "object",
              additionalProperties: !1,
              description: "information about external documentation",
              required: ["url"],
              properties: { description: { type: "string" }, url: { type: "string", format: "uri" } },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            examples: { type: "object", additionalProperties: !0 },
            mimeType: { type: "string", description: "The MIME type of the HTTP message." },
            operation: {
              type: "object",
              required: ["responses"],
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                tags: { type: "array", items: { type: "string" }, uniqueItems: !0 },
                summary: { type: "string", description: "A brief summary of the operation." },
                description: {
                  type: "string",
                  description: "A longer description of the operation, GitHub Flavored Markdown is allowed.",
                },
                externalDocs: { $ref: "#/definitions/externalDocs" },
                operationId: { type: "string", description: "A unique identifier of the operation." },
                produces: {
                  description: "A list of MIME types the API can produce.",
                  allOf: [{ $ref: "#/definitions/mediaTypeList" }],
                },
                consumes: {
                  description: "A list of MIME types the API can consume.",
                  allOf: [{ $ref: "#/definitions/mediaTypeList" }],
                },
                parameters: { $ref: "#/definitions/parametersList" },
                responses: { $ref: "#/definitions/responses" },
                schemes: { $ref: "#/definitions/schemesList" },
                deprecated: { type: "boolean", default: !1 },
                security: { $ref: "#/definitions/security" },
              },
            },
            pathItem: {
              type: "object",
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                $ref: { type: "string" },
                get: { $ref: "#/definitions/operation" },
                put: { $ref: "#/definitions/operation" },
                post: { $ref: "#/definitions/operation" },
                delete: { $ref: "#/definitions/operation" },
                options: { $ref: "#/definitions/operation" },
                head: { $ref: "#/definitions/operation" },
                patch: { $ref: "#/definitions/operation" },
                parameters: { $ref: "#/definitions/parametersList" },
              },
            },
            responses: {
              type: "object",
              description: "Response objects names can either be any valid HTTP status code or 'default'.",
              minProperties: 1,
              additionalProperties: !1,
              patternProperties: {
                "^([0-9]{3})$|^(default)$": { $ref: "#/definitions/responseValue" },
                "^x-": { $ref: "#/definitions/vendorExtension" },
              },
              not: {
                type: "object",
                additionalProperties: !1,
                patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              },
            },
            responseValue: { oneOf: [{ $ref: "#/definitions/response" }, { $ref: "#/definitions/jsonReference" }] },
            response: {
              type: "object",
              required: ["description"],
              properties: {
                description: { type: "string" },
                schema: { oneOf: [{ $ref: "#/definitions/schema" }, { $ref: "#/definitions/fileSchema" }] },
                headers: { $ref: "#/definitions/headers" },
                examples: { $ref: "#/definitions/examples" },
              },
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            headers: { type: "object", additionalProperties: { $ref: "#/definitions/header" } },
            header: {
              type: "object",
              additionalProperties: !1,
              required: ["type"],
              properties: {
                type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
                format: { type: "string" },
                items: { $ref: "#/definitions/primitivesItems" },
                collectionFormat: { $ref: "#/definitions/collectionFormat" },
                default: { $ref: "#/definitions/default" },
                maximum: { $ref: "#/definitions/maximum" },
                exclusiveMaximum: { $ref: "#/definitions/exclusiveMaximum" },
                minimum: { $ref: "#/definitions/minimum" },
                exclusiveMinimum: { $ref: "#/definitions/exclusiveMinimum" },
                maxLength: { $ref: "#/definitions/maxLength" },
                minLength: { $ref: "#/definitions/minLength" },
                pattern: { $ref: "#/definitions/pattern" },
                maxItems: { $ref: "#/definitions/maxItems" },
                minItems: { $ref: "#/definitions/minItems" },
                uniqueItems: { $ref: "#/definitions/uniqueItems" },
                enum: { $ref: "#/definitions/enum" },
                multipleOf: { $ref: "#/definitions/multipleOf" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            vendorExtension: {
              description: "Any property starting with x- is valid.",
              additionalProperties: !0,
              additionalItems: !0,
            },
            bodyParameter: {
              type: "object",
              required: ["name", "in", "schema"],
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: { type: "string", description: "The name of the parameter." },
                in: { type: "string", description: "Determines the location of the parameter.", enum: ["body"] },
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: !1,
                },
                schema: { $ref: "#/definitions/schema" },
              },
              additionalProperties: !1,
            },
            headerParameterSubSchema: {
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: !1,
                },
                in: { type: "string", description: "Determines the location of the parameter.", enum: ["header"] },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: { type: "string", description: "The name of the parameter." },
                type: { type: "string", enum: ["string", "number", "boolean", "integer", "array"] },
                format: { type: "string" },
                items: { $ref: "#/definitions/primitivesItems" },
                collectionFormat: { $ref: "#/definitions/collectionFormat" },
                default: { $ref: "#/definitions/default" },
                maximum: { $ref: "#/definitions/maximum" },
                exclusiveMaximum: { $ref: "#/definitions/exclusiveMaximum" },
                minimum: { $ref: "#/definitions/minimum" },
                exclusiveMinimum: { $ref: "#/definitions/exclusiveMinimum" },
                maxLength: { $ref: "#/definitions/maxLength" },
                minLength: { $ref: "#/definitions/minLength" },
                pattern: { $ref: "#/definitions/pattern" },
                maxItems: { $ref: "#/definitions/maxItems" },
                minItems: { $ref: "#/definitions/minItems" },
                uniqueItems: { $ref: "#/definitions/uniqueItems" },
                enum: { $ref: "#/definitions/enum" },
                multipleOf: { $ref: "#/definitions/multipleOf" },
              },
            },
            queryParameterSubSchema: {
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: !1,
                },
                in: { type: "string", description: "Determines the location of the parameter.", enum: ["query"] },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: { type: "string", description: "The name of the parameter." },
                allowEmptyValue: {
                  type: "boolean",
                  default: !1,
                  description: "allows sending a parameter by name only or with an empty value.",
                },
                type: { type: "string", enum: ["string", "number", "boolean", "integer", "array"] },
                format: { type: "string" },
                items: { $ref: "#/definitions/primitivesItems" },
                collectionFormat: { $ref: "#/definitions/collectionFormatWithMulti" },
                default: { $ref: "#/definitions/default" },
                maximum: { $ref: "#/definitions/maximum" },
                exclusiveMaximum: { $ref: "#/definitions/exclusiveMaximum" },
                minimum: { $ref: "#/definitions/minimum" },
                exclusiveMinimum: { $ref: "#/definitions/exclusiveMinimum" },
                maxLength: { $ref: "#/definitions/maxLength" },
                minLength: { $ref: "#/definitions/minLength" },
                pattern: { $ref: "#/definitions/pattern" },
                maxItems: { $ref: "#/definitions/maxItems" },
                minItems: { $ref: "#/definitions/minItems" },
                uniqueItems: { $ref: "#/definitions/uniqueItems" },
                enum: { $ref: "#/definitions/enum" },
                multipleOf: { $ref: "#/definitions/multipleOf" },
              },
            },
            formDataParameterSubSchema: {
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                required: {
                  type: "boolean",
                  description: "Determines whether or not this parameter is required or optional.",
                  default: !1,
                },
                in: { type: "string", description: "Determines the location of the parameter.", enum: ["formData"] },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: { type: "string", description: "The name of the parameter." },
                allowEmptyValue: {
                  type: "boolean",
                  default: !1,
                  description: "allows sending a parameter by name only or with an empty value.",
                },
                type: { type: "string", enum: ["string", "number", "boolean", "integer", "array", "file"] },
                format: { type: "string" },
                items: { $ref: "#/definitions/primitivesItems" },
                collectionFormat: { $ref: "#/definitions/collectionFormatWithMulti" },
                default: { $ref: "#/definitions/default" },
                maximum: { $ref: "#/definitions/maximum" },
                exclusiveMaximum: { $ref: "#/definitions/exclusiveMaximum" },
                minimum: { $ref: "#/definitions/minimum" },
                exclusiveMinimum: { $ref: "#/definitions/exclusiveMinimum" },
                maxLength: { $ref: "#/definitions/maxLength" },
                minLength: { $ref: "#/definitions/minLength" },
                pattern: { $ref: "#/definitions/pattern" },
                maxItems: { $ref: "#/definitions/maxItems" },
                minItems: { $ref: "#/definitions/minItems" },
                uniqueItems: { $ref: "#/definitions/uniqueItems" },
                enum: { $ref: "#/definitions/enum" },
                multipleOf: { $ref: "#/definitions/multipleOf" },
              },
            },
            pathParameterSubSchema: {
              additionalProperties: !1,
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              required: ["required"],
              properties: {
                required: {
                  type: "boolean",
                  enum: [!0],
                  description: "Determines whether or not this parameter is required or optional.",
                },
                in: { type: "string", description: "Determines the location of the parameter.", enum: ["path"] },
                description: {
                  type: "string",
                  description:
                    "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.",
                },
                name: { type: "string", description: "The name of the parameter." },
                type: { type: "string", enum: ["string", "number", "boolean", "integer", "array"] },
                format: { type: "string" },
                items: { $ref: "#/definitions/primitivesItems" },
                collectionFormat: { $ref: "#/definitions/collectionFormat" },
                default: { $ref: "#/definitions/default" },
                maximum: { $ref: "#/definitions/maximum" },
                exclusiveMaximum: { $ref: "#/definitions/exclusiveMaximum" },
                minimum: { $ref: "#/definitions/minimum" },
                exclusiveMinimum: { $ref: "#/definitions/exclusiveMinimum" },
                maxLength: { $ref: "#/definitions/maxLength" },
                minLength: { $ref: "#/definitions/minLength" },
                pattern: { $ref: "#/definitions/pattern" },
                maxItems: { $ref: "#/definitions/maxItems" },
                minItems: { $ref: "#/definitions/minItems" },
                uniqueItems: { $ref: "#/definitions/uniqueItems" },
                enum: { $ref: "#/definitions/enum" },
                multipleOf: { $ref: "#/definitions/multipleOf" },
              },
            },
            nonBodyParameter: {
              type: "object",
              required: ["name", "in", "type"],
              oneOf: [
                { $ref: "#/definitions/headerParameterSubSchema" },
                { $ref: "#/definitions/formDataParameterSubSchema" },
                { $ref: "#/definitions/queryParameterSubSchema" },
                { $ref: "#/definitions/pathParameterSubSchema" },
              ],
            },
            parameter: { oneOf: [{ $ref: "#/definitions/bodyParameter" }, { $ref: "#/definitions/nonBodyParameter" }] },
            schema: {
              type: "object",
              description: "A deterministic version of a JSON Schema object.",
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              properties: {
                $ref: { type: "string" },
                format: { type: "string" },
                title: { $ref: "http://json-schema.org/draft-04/schema#/properties/title" },
                description: { $ref: "http://json-schema.org/draft-04/schema#/properties/description" },
                default: { $ref: "http://json-schema.org/draft-04/schema#/properties/default" },
                multipleOf: { $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf" },
                maximum: { $ref: "http://json-schema.org/draft-04/schema#/properties/maximum" },
                exclusiveMaximum: { $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum" },
                minimum: { $ref: "http://json-schema.org/draft-04/schema#/properties/minimum" },
                exclusiveMinimum: { $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum" },
                maxLength: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger" },
                minLength: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0" },
                pattern: { $ref: "http://json-schema.org/draft-04/schema#/properties/pattern" },
                maxItems: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger" },
                minItems: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0" },
                uniqueItems: { $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems" },
                maxProperties: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger" },
                minProperties: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0" },
                required: { $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray" },
                enum: { $ref: "http://json-schema.org/draft-04/schema#/properties/enum" },
                additionalProperties: { anyOf: [{ $ref: "#/definitions/schema" }, { type: "boolean" }], default: {} },
                type: { $ref: "http://json-schema.org/draft-04/schema#/properties/type" },
                items: {
                  anyOf: [
                    { $ref: "#/definitions/schema" },
                    { type: "array", minItems: 1, items: { $ref: "#/definitions/schema" } },
                  ],
                  default: {},
                },
                allOf: { type: "array", minItems: 1, items: { $ref: "#/definitions/schema" } },
                properties: { type: "object", additionalProperties: { $ref: "#/definitions/schema" }, default: {} },
                discriminator: { type: "string" },
                readOnly: { type: "boolean", default: !1 },
                xml: { $ref: "#/definitions/xml" },
                externalDocs: { $ref: "#/definitions/externalDocs" },
                example: {},
              },
              additionalProperties: !1,
            },
            fileSchema: {
              type: "object",
              description: "A deterministic version of a JSON Schema object.",
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
              required: ["type"],
              properties: {
                format: { type: "string" },
                title: { $ref: "http://json-schema.org/draft-04/schema#/properties/title" },
                description: { $ref: "http://json-schema.org/draft-04/schema#/properties/description" },
                default: { $ref: "http://json-schema.org/draft-04/schema#/properties/default" },
                required: { $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray" },
                type: { type: "string", enum: ["file"] },
                readOnly: { type: "boolean", default: !1 },
                externalDocs: { $ref: "#/definitions/externalDocs" },
                example: {},
              },
              additionalProperties: !1,
            },
            primitivesItems: {
              type: "object",
              additionalProperties: !1,
              properties: {
                type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
                format: { type: "string" },
                items: { $ref: "#/definitions/primitivesItems" },
                collectionFormat: { $ref: "#/definitions/collectionFormat" },
                default: { $ref: "#/definitions/default" },
                maximum: { $ref: "#/definitions/maximum" },
                exclusiveMaximum: { $ref: "#/definitions/exclusiveMaximum" },
                minimum: { $ref: "#/definitions/minimum" },
                exclusiveMinimum: { $ref: "#/definitions/exclusiveMinimum" },
                maxLength: { $ref: "#/definitions/maxLength" },
                minLength: { $ref: "#/definitions/minLength" },
                pattern: { $ref: "#/definitions/pattern" },
                maxItems: { $ref: "#/definitions/maxItems" },
                minItems: { $ref: "#/definitions/minItems" },
                uniqueItems: { $ref: "#/definitions/uniqueItems" },
                enum: { $ref: "#/definitions/enum" },
                multipleOf: { $ref: "#/definitions/multipleOf" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            security: { type: "array", items: { $ref: "#/definitions/securityRequirement" }, uniqueItems: !0 },
            securityRequirement: {
              type: "object",
              additionalProperties: { type: "array", items: { type: "string" }, uniqueItems: !0 },
            },
            xml: {
              type: "object",
              additionalProperties: !1,
              properties: {
                name: { type: "string" },
                namespace: { type: "string" },
                prefix: { type: "string" },
                attribute: { type: "boolean", default: !1 },
                wrapped: { type: "boolean", default: !1 },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            tag: {
              type: "object",
              additionalProperties: !1,
              required: ["name"],
              properties: {
                name: { type: "string" },
                description: { type: "string" },
                externalDocs: { $ref: "#/definitions/externalDocs" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            securityDefinitions: {
              type: "object",
              additionalProperties: {
                oneOf: [
                  { $ref: "#/definitions/basicAuthenticationSecurity" },
                  { $ref: "#/definitions/apiKeySecurity" },
                  { $ref: "#/definitions/oauth2ImplicitSecurity" },
                  { $ref: "#/definitions/oauth2PasswordSecurity" },
                  { $ref: "#/definitions/oauth2ApplicationSecurity" },
                  { $ref: "#/definitions/oauth2AccessCodeSecurity" },
                ],
              },
            },
            basicAuthenticationSecurity: {
              type: "object",
              additionalProperties: !1,
              required: ["type"],
              properties: { type: { type: "string", enum: ["basic"] }, description: { type: "string" } },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            apiKeySecurity: {
              type: "object",
              additionalProperties: !1,
              required: ["type", "name", "in"],
              properties: {
                type: { type: "string", enum: ["apiKey"] },
                name: { type: "string" },
                in: { type: "string", enum: ["header", "query"] },
                description: { type: "string" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            oauth2ImplicitSecurity: {
              type: "object",
              additionalProperties: !1,
              required: ["type", "flow", "authorizationUrl"],
              properties: {
                type: { type: "string", enum: ["oauth2"] },
                flow: { type: "string", enum: ["implicit"] },
                scopes: { $ref: "#/definitions/oauth2Scopes" },
                authorizationUrl: { type: "string", format: "uri" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            oauth2PasswordSecurity: {
              type: "object",
              additionalProperties: !1,
              required: ["type", "flow", "tokenUrl"],
              properties: {
                type: { type: "string", enum: ["oauth2"] },
                flow: { type: "string", enum: ["password"] },
                scopes: { $ref: "#/definitions/oauth2Scopes" },
                tokenUrl: { type: "string", format: "uri" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            oauth2ApplicationSecurity: {
              type: "object",
              additionalProperties: !1,
              required: ["type", "flow", "tokenUrl"],
              properties: {
                type: { type: "string", enum: ["oauth2"] },
                flow: { type: "string", enum: ["application"] },
                scopes: { $ref: "#/definitions/oauth2Scopes" },
                tokenUrl: { type: "string", format: "uri" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            oauth2AccessCodeSecurity: {
              type: "object",
              additionalProperties: !1,
              required: ["type", "flow", "authorizationUrl", "tokenUrl"],
              properties: {
                type: { type: "string", enum: ["oauth2"] },
                flow: { type: "string", enum: ["accessCode"] },
                scopes: { $ref: "#/definitions/oauth2Scopes" },
                authorizationUrl: { type: "string", format: "uri" },
                tokenUrl: { type: "string", format: "uri" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": { $ref: "#/definitions/vendorExtension" } },
            },
            oauth2Scopes: { type: "object", additionalProperties: { type: "string" } },
            mediaTypeList: { type: "array", items: { $ref: "#/definitions/mimeType" }, uniqueItems: !0 },
            parametersList: {
              type: "array",
              description: "The parameters needed to send a valid API call.",
              additionalItems: !1,
              items: { oneOf: [{ $ref: "#/definitions/parameter" }, { $ref: "#/definitions/jsonReference" }] },
              uniqueItems: !0,
            },
            schemesList: {
              type: "array",
              description: "The transfer protocol of the API.",
              items: { type: "string", enum: ["http", "https", "ws", "wss"] },
              uniqueItems: !0,
            },
            collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes"], default: "csv" },
            collectionFormatWithMulti: {
              type: "string",
              enum: ["csv", "ssv", "tsv", "pipes", "multi"],
              default: "csv",
            },
            title: { $ref: "http://json-schema.org/draft-04/schema#/properties/title" },
            description: { $ref: "http://json-schema.org/draft-04/schema#/properties/description" },
            default: { $ref: "http://json-schema.org/draft-04/schema#/properties/default" },
            multipleOf: { $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf" },
            maximum: { $ref: "http://json-schema.org/draft-04/schema#/properties/maximum" },
            exclusiveMaximum: { $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum" },
            minimum: { $ref: "http://json-schema.org/draft-04/schema#/properties/minimum" },
            exclusiveMinimum: { $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum" },
            maxLength: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger" },
            minLength: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0" },
            pattern: { $ref: "http://json-schema.org/draft-04/schema#/properties/pattern" },
            maxItems: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger" },
            minItems: { $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0" },
            uniqueItems: { $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems" },
            enum: { $ref: "http://json-schema.org/draft-04/schema#/properties/enum" },
            jsonReference: {
              type: "object",
              required: ["$ref"],
              additionalProperties: !1,
              properties: { $ref: { type: "string" } },
            },
          },
        },
        "3.0": {
          id: "https://spec.openapis.org/oas/3.0/schema/2021-09-28",
          $schema: "http://json-schema.org/draft-04/schema#",
          description:
            "The description of OpenAPI v3.0.x documents, as defined by https://spec.openapis.org/oas/v3.0.3",
          type: "object",
          required: ["openapi", "info", "paths"],
          properties: {
            openapi: { type: "string", pattern: "^3\\.0\\.\\d(-.+)?$" },
            info: { $ref: "#/definitions/Info" },
            externalDocs: { $ref: "#/definitions/ExternalDocumentation" },
            servers: { type: "array", items: { $ref: "#/definitions/Server" } },
            security: { type: "array", items: { $ref: "#/definitions/SecurityRequirement" } },
            tags: { type: "array", items: { $ref: "#/definitions/Tag" }, uniqueItems: !0 },
            paths: { $ref: "#/definitions/Paths" },
            components: { $ref: "#/definitions/Components" },
          },
          patternProperties: { "^x-": {} },
          additionalProperties: !1,
          definitions: {
            Reference: {
              type: "object",
              required: ["$ref"],
              patternProperties: { "^\\$ref$": { type: "string", format: "uri-reference" } },
            },
            Info: {
              type: "object",
              required: ["title", "version"],
              properties: {
                title: { type: "string" },
                description: { type: "string" },
                termsOfService: { type: "string", format: "uri-reference" },
                contact: { $ref: "#/definitions/Contact" },
                license: { $ref: "#/definitions/License" },
                version: { type: "string" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Contact: {
              type: "object",
              properties: {
                name: { type: "string" },
                url: { type: "string", format: "uri-reference" },
                email: { type: "string", format: "email" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            License: {
              type: "object",
              required: ["name"],
              properties: { name: { type: "string" }, url: { type: "string", format: "uri-reference" } },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Server: {
              type: "object",
              required: ["url"],
              properties: {
                url: { type: "string" },
                description: { type: "string" },
                variables: { type: "object", additionalProperties: { $ref: "#/definitions/ServerVariable" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            ServerVariable: {
              type: "object",
              required: ["default"],
              properties: {
                enum: { type: "array", items: { type: "string" } },
                default: { type: "string" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Components: {
              type: "object",
              properties: {
                schemas: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }],
                    },
                  },
                },
                responses: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/Response" }],
                    },
                  },
                },
                parameters: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/Parameter" }],
                    },
                  },
                },
                examples: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/Example" }],
                    },
                  },
                },
                requestBodies: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/RequestBody" }],
                    },
                  },
                },
                headers: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/Header" }],
                    },
                  },
                },
                securitySchemes: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/SecurityScheme" }],
                    },
                  },
                },
                links: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/Link" }],
                    },
                  },
                },
                callbacks: {
                  type: "object",
                  patternProperties: {
                    "^[a-zA-Z0-9\\.\\-_]+$": {
                      oneOf: [{ $ref: "#/definitions/Reference" }, { $ref: "#/definitions/Callback" }],
                    },
                  },
                },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Schema: {
              type: "object",
              properties: {
                title: { type: "string" },
                multipleOf: { type: "number", minimum: 0, exclusiveMinimum: !0 },
                maximum: { type: "number" },
                exclusiveMaximum: { type: "boolean", default: !1 },
                minimum: { type: "number" },
                exclusiveMinimum: { type: "boolean", default: !1 },
                maxLength: { type: "integer", minimum: 0 },
                minLength: { type: "integer", minimum: 0, default: 0 },
                pattern: { type: "string", format: "regex" },
                maxItems: { type: "integer", minimum: 0 },
                minItems: { type: "integer", minimum: 0, default: 0 },
                uniqueItems: { type: "boolean", default: !1 },
                maxProperties: { type: "integer", minimum: 0 },
                minProperties: { type: "integer", minimum: 0, default: 0 },
                required: { type: "array", items: { type: "string" }, minItems: 1, uniqueItems: !0 },
                enum: { type: "array", items: {}, minItems: 1, uniqueItems: !1 },
                type: { type: "string", enum: ["array", "boolean", "integer", "number", "object", "string"] },
                not: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                allOf: {
                  type: "array",
                  items: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                },
                oneOf: {
                  type: "array",
                  items: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                },
                anyOf: {
                  type: "array",
                  items: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                },
                items: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                properties: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }],
                  },
                },
                additionalProperties: {
                  oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }, { type: "boolean" }],
                  default: !0,
                },
                description: { type: "string" },
                format: { type: "string" },
                default: {},
                nullable: { type: "boolean", default: !1 },
                discriminator: { $ref: "#/definitions/Discriminator" },
                readOnly: { type: "boolean", default: !1 },
                writeOnly: { type: "boolean", default: !1 },
                example: {},
                externalDocs: { $ref: "#/definitions/ExternalDocumentation" },
                deprecated: { type: "boolean", default: !1 },
                xml: { $ref: "#/definitions/XML" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Discriminator: {
              type: "object",
              required: ["propertyName"],
              properties: {
                propertyName: { type: "string" },
                mapping: { type: "object", additionalProperties: { type: "string" } },
              },
            },
            XML: {
              type: "object",
              properties: {
                name: { type: "string" },
                namespace: { type: "string", format: "uri" },
                prefix: { type: "string" },
                attribute: { type: "boolean", default: !1 },
                wrapped: { type: "boolean", default: !1 },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Response: {
              type: "object",
              required: ["description"],
              properties: {
                description: { type: "string" },
                headers: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Header" }, { $ref: "#/definitions/Reference" }],
                  },
                },
                content: { type: "object", additionalProperties: { $ref: "#/definitions/MediaType" } },
                links: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Link" }, { $ref: "#/definitions/Reference" }],
                  },
                },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            MediaType: {
              type: "object",
              properties: {
                schema: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                example: {},
                examples: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Example" }, { $ref: "#/definitions/Reference" }],
                  },
                },
                encoding: { type: "object", additionalProperties: { $ref: "#/definitions/Encoding" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
              allOf: [{ $ref: "#/definitions/ExampleXORExamples" }],
            },
            Example: {
              type: "object",
              properties: {
                summary: { type: "string" },
                description: { type: "string" },
                value: {},
                externalValue: { type: "string", format: "uri-reference" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Header: {
              type: "object",
              properties: {
                description: { type: "string" },
                required: { type: "boolean", default: !1 },
                deprecated: { type: "boolean", default: !1 },
                allowEmptyValue: { type: "boolean", default: !1 },
                style: { type: "string", enum: ["simple"], default: "simple" },
                explode: { type: "boolean" },
                allowReserved: { type: "boolean", default: !1 },
                schema: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                content: {
                  type: "object",
                  additionalProperties: { $ref: "#/definitions/MediaType" },
                  minProperties: 1,
                  maxProperties: 1,
                },
                example: {},
                examples: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Example" }, { $ref: "#/definitions/Reference" }],
                  },
                },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
              allOf: [{ $ref: "#/definitions/ExampleXORExamples" }, { $ref: "#/definitions/SchemaXORContent" }],
            },
            Paths: {
              type: "object",
              patternProperties: { "^\\/": { $ref: "#/definitions/PathItem" }, "^x-": {} },
              additionalProperties: !1,
            },
            PathItem: {
              type: "object",
              properties: {
                $ref: { type: "string" },
                summary: { type: "string" },
                description: { type: "string" },
                servers: { type: "array", items: { $ref: "#/definitions/Server" } },
                parameters: {
                  type: "array",
                  items: { oneOf: [{ $ref: "#/definitions/Parameter" }, { $ref: "#/definitions/Reference" }] },
                  uniqueItems: !0,
                },
              },
              patternProperties: {
                "^(get|put|post|delete|options|head|patch|trace)$": { $ref: "#/definitions/Operation" },
                "^x-": {},
              },
              additionalProperties: !1,
            },
            Operation: {
              type: "object",
              required: ["responses"],
              properties: {
                tags: { type: "array", items: { type: "string" } },
                summary: { type: "string" },
                description: { type: "string" },
                externalDocs: { $ref: "#/definitions/ExternalDocumentation" },
                operationId: { type: "string" },
                parameters: {
                  type: "array",
                  items: { oneOf: [{ $ref: "#/definitions/Parameter" }, { $ref: "#/definitions/Reference" }] },
                  uniqueItems: !0,
                },
                requestBody: { oneOf: [{ $ref: "#/definitions/RequestBody" }, { $ref: "#/definitions/Reference" }] },
                responses: { $ref: "#/definitions/Responses" },
                callbacks: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Callback" }, { $ref: "#/definitions/Reference" }],
                  },
                },
                deprecated: { type: "boolean", default: !1 },
                security: { type: "array", items: { $ref: "#/definitions/SecurityRequirement" } },
                servers: { type: "array", items: { $ref: "#/definitions/Server" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Responses: {
              type: "object",
              properties: {
                default: { oneOf: [{ $ref: "#/definitions/Response" }, { $ref: "#/definitions/Reference" }] },
              },
              patternProperties: {
                "^[1-5](?:\\d{2}|XX)$": {
                  oneOf: [{ $ref: "#/definitions/Response" }, { $ref: "#/definitions/Reference" }],
                },
                "^x-": {},
              },
              minProperties: 1,
              additionalProperties: !1,
            },
            SecurityRequirement: { type: "object", additionalProperties: { type: "array", items: { type: "string" } } },
            Tag: {
              type: "object",
              required: ["name"],
              properties: {
                name: { type: "string" },
                description: { type: "string" },
                externalDocs: { $ref: "#/definitions/ExternalDocumentation" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            ExternalDocumentation: {
              type: "object",
              required: ["url"],
              properties: { description: { type: "string" }, url: { type: "string", format: "uri-reference" } },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            ExampleXORExamples: {
              description: "Example and examples are mutually exclusive",
              not: { required: ["example", "examples"] },
            },
            SchemaXORContent: {
              description: "Schema and content are mutually exclusive, at least one is required",
              not: { required: ["schema", "content"] },
              oneOf: [
                { required: ["schema"] },
                {
                  required: ["content"],
                  description: "Some properties are not allowed if content is present",
                  allOf: [
                    { not: { required: ["style"] } },
                    { not: { required: ["explode"] } },
                    { not: { required: ["allowReserved"] } },
                    { not: { required: ["example"] } },
                    { not: { required: ["examples"] } },
                  ],
                },
              ],
            },
            Parameter: {
              type: "object",
              properties: {
                name: { type: "string" },
                in: { type: "string" },
                description: { type: "string" },
                required: { type: "boolean", default: !1 },
                deprecated: { type: "boolean", default: !1 },
                allowEmptyValue: { type: "boolean", default: !1 },
                style: { type: "string" },
                explode: { type: "boolean" },
                allowReserved: { type: "boolean", default: !1 },
                schema: { oneOf: [{ $ref: "#/definitions/Schema" }, { $ref: "#/definitions/Reference" }] },
                content: {
                  type: "object",
                  additionalProperties: { $ref: "#/definitions/MediaType" },
                  minProperties: 1,
                  maxProperties: 1,
                },
                example: {},
                examples: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Example" }, { $ref: "#/definitions/Reference" }],
                  },
                },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
              required: ["name", "in"],
              allOf: [
                { $ref: "#/definitions/ExampleXORExamples" },
                { $ref: "#/definitions/SchemaXORContent" },
                { $ref: "#/definitions/ParameterLocation" },
              ],
            },
            ParameterLocation: {
              description: "Parameter location",
              oneOf: [
                {
                  description: "Parameter in path",
                  required: ["required"],
                  properties: {
                    in: { enum: ["path"] },
                    style: { enum: ["matrix", "label", "simple"], default: "simple" },
                    required: { enum: [!0] },
                  },
                },
                {
                  description: "Parameter in query",
                  properties: {
                    in: { enum: ["query"] },
                    style: { enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"], default: "form" },
                  },
                },
                {
                  description: "Parameter in header",
                  properties: { in: { enum: ["header"] }, style: { enum: ["simple"], default: "simple" } },
                },
                {
                  description: "Parameter in cookie",
                  properties: { in: { enum: ["cookie"] }, style: { enum: ["form"], default: "form" } },
                },
              ],
            },
            RequestBody: {
              type: "object",
              required: ["content"],
              properties: {
                description: { type: "string" },
                content: { type: "object", additionalProperties: { $ref: "#/definitions/MediaType" } },
                required: { type: "boolean", default: !1 },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            SecurityScheme: {
              oneOf: [
                { $ref: "#/definitions/APIKeySecurityScheme" },
                { $ref: "#/definitions/HTTPSecurityScheme" },
                { $ref: "#/definitions/OAuth2SecurityScheme" },
                { $ref: "#/definitions/OpenIdConnectSecurityScheme" },
              ],
            },
            APIKeySecurityScheme: {
              type: "object",
              required: ["type", "name", "in"],
              properties: {
                type: { type: "string", enum: ["apiKey"] },
                name: { type: "string" },
                in: { type: "string", enum: ["header", "query", "cookie"] },
                description: { type: "string" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            HTTPSecurityScheme: {
              type: "object",
              required: ["scheme", "type"],
              properties: {
                scheme: { type: "string" },
                bearerFormat: { type: "string" },
                description: { type: "string" },
                type: { type: "string", enum: ["http"] },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
              oneOf: [
                {
                  description: "Bearer",
                  properties: { scheme: { type: "string", pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$" } },
                },
                {
                  description: "Non Bearer",
                  not: { required: ["bearerFormat"] },
                  properties: { scheme: { not: { type: "string", pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$" } } },
                },
              ],
            },
            OAuth2SecurityScheme: {
              type: "object",
              required: ["type", "flows"],
              properties: {
                type: { type: "string", enum: ["oauth2"] },
                flows: { $ref: "#/definitions/OAuthFlows" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            OpenIdConnectSecurityScheme: {
              type: "object",
              required: ["type", "openIdConnectUrl"],
              properties: {
                type: { type: "string", enum: ["openIdConnect"] },
                openIdConnectUrl: { type: "string", format: "uri-reference" },
                description: { type: "string" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            OAuthFlows: {
              type: "object",
              properties: {
                implicit: { $ref: "#/definitions/ImplicitOAuthFlow" },
                password: { $ref: "#/definitions/PasswordOAuthFlow" },
                clientCredentials: { $ref: "#/definitions/ClientCredentialsFlow" },
                authorizationCode: { $ref: "#/definitions/AuthorizationCodeOAuthFlow" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            ImplicitOAuthFlow: {
              type: "object",
              required: ["authorizationUrl", "scopes"],
              properties: {
                authorizationUrl: { type: "string", format: "uri-reference" },
                refreshUrl: { type: "string", format: "uri-reference" },
                scopes: { type: "object", additionalProperties: { type: "string" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            PasswordOAuthFlow: {
              type: "object",
              required: ["tokenUrl", "scopes"],
              properties: {
                tokenUrl: { type: "string", format: "uri-reference" },
                refreshUrl: { type: "string", format: "uri-reference" },
                scopes: { type: "object", additionalProperties: { type: "string" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            ClientCredentialsFlow: {
              type: "object",
              required: ["tokenUrl", "scopes"],
              properties: {
                tokenUrl: { type: "string", format: "uri-reference" },
                refreshUrl: { type: "string", format: "uri-reference" },
                scopes: { type: "object", additionalProperties: { type: "string" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            AuthorizationCodeOAuthFlow: {
              type: "object",
              required: ["authorizationUrl", "tokenUrl", "scopes"],
              properties: {
                authorizationUrl: { type: "string", format: "uri-reference" },
                tokenUrl: { type: "string", format: "uri-reference" },
                refreshUrl: { type: "string", format: "uri-reference" },
                scopes: { type: "object", additionalProperties: { type: "string" } },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
            },
            Link: {
              type: "object",
              properties: {
                operationId: { type: "string" },
                operationRef: { type: "string", format: "uri-reference" },
                parameters: { type: "object", additionalProperties: {} },
                requestBody: {},
                description: { type: "string" },
                server: { $ref: "#/definitions/Server" },
              },
              patternProperties: { "^x-": {} },
              additionalProperties: !1,
              not: {
                description: "Operation Id and Operation Ref are mutually exclusive",
                required: ["operationId", "operationRef"],
              },
            },
            Callback: {
              type: "object",
              additionalProperties: { $ref: "#/definitions/PathItem" },
              patternProperties: { "^x-": {} },
            },
            Encoding: {
              type: "object",
              properties: {
                contentType: { type: "string" },
                headers: {
                  type: "object",
                  additionalProperties: {
                    oneOf: [{ $ref: "#/definitions/Header" }, { $ref: "#/definitions/Reference" }],
                  },
                },
                style: { type: "string", enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"] },
                explode: { type: "boolean" },
                allowReserved: { type: "boolean", default: !1 },
              },
              additionalProperties: !1,
            },
          },
        },
        3.1: {
          $id: "https://spec.openapis.org/oas/3.1/schema/2022-10-07",
          $schema: "https://json-schema.org/draft/2020-12/schema",
          description:
            "The description of OpenAPI v3.1.x documents without schema validation, as defined by https://spec.openapis.org/oas/v3.1.0",
          type: "object",
          properties: {
            openapi: { type: "string", pattern: "^3\\.1\\.\\d+(-.+)?$" },
            info: { $ref: "#/$defs/info" },
            jsonSchemaDialect: {
              type: "string",
              format: "uri",
              default: "https://spec.openapis.org/oas/3.1/dialect/base",
            },
            servers: { type: "array", items: { $ref: "#/$defs/server" }, default: [{ url: "/" }] },
            paths: { $ref: "#/$defs/paths" },
            webhooks: { type: "object", additionalProperties: { $ref: "#/$defs/path-item-or-reference" } },
            components: { $ref: "#/$defs/components" },
            security: { type: "array", items: { $ref: "#/$defs/security-requirement" } },
            tags: { type: "array", items: { $ref: "#/$defs/tag" } },
            externalDocs: { $ref: "#/$defs/external-documentation" },
          },
          required: ["openapi", "info"],
          anyOf: [{ required: ["paths"] }, { required: ["components"] }, { required: ["webhooks"] }],
          $ref: "#/$defs/specification-extensions",
          unevaluatedProperties: !1,
          $defs: {
            info: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#info-object",
              type: "object",
              properties: {
                title: { type: "string" },
                summary: { type: "string" },
                description: { type: "string" },
                termsOfService: { type: "string", format: "uri" },
                contact: { $ref: "#/$defs/contact" },
                license: { $ref: "#/$defs/license" },
                version: { type: "string" },
              },
              required: ["title", "version"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            contact: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#contact-object",
              type: "object",
              properties: {
                name: { type: "string" },
                url: { type: "string", format: "uri" },
                email: { type: "string", format: "email" },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            license: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#license-object",
              type: "object",
              properties: {
                name: { type: "string" },
                identifier: { type: "string" },
                url: { type: "string", format: "uri" },
              },
              required: ["name"],
              dependentSchemas: { identifier: { not: { required: ["url"] } } },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            server: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#server-object",
              type: "object",
              properties: {
                url: { type: "string", format: "uri-reference" },
                description: { type: "string" },
                variables: { type: "object", additionalProperties: { $ref: "#/$defs/server-variable" } },
              },
              required: ["url"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "server-variable": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#server-variable-object",
              type: "object",
              properties: {
                enum: { type: "array", items: { type: "string" }, minItems: 1 },
                default: { type: "string" },
                description: { type: "string" },
              },
              required: ["default"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            components: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#components-object",
              type: "object",
              properties: {
                schemas: { type: "object", additionalProperties: { $ref: "#/$defs/schema" } },
                responses: { type: "object", additionalProperties: { $ref: "#/$defs/response-or-reference" } },
                parameters: { type: "object", additionalProperties: { $ref: "#/$defs/parameter-or-reference" } },
                examples: { type: "object", additionalProperties: { $ref: "#/$defs/example-or-reference" } },
                requestBodies: { type: "object", additionalProperties: { $ref: "#/$defs/request-body-or-reference" } },
                headers: { type: "object", additionalProperties: { $ref: "#/$defs/header-or-reference" } },
                securitySchemes: {
                  type: "object",
                  additionalProperties: { $ref: "#/$defs/security-scheme-or-reference" },
                },
                links: { type: "object", additionalProperties: { $ref: "#/$defs/link-or-reference" } },
                callbacks: { type: "object", additionalProperties: { $ref: "#/$defs/callbacks-or-reference" } },
                pathItems: { type: "object", additionalProperties: { $ref: "#/$defs/path-item-or-reference" } },
              },
              patternProperties: {
                "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$":
                  {
                    $comment:
                      "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
                    propertyNames: { pattern: "^[a-zA-Z0-9._-]+$" },
                  },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            paths: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#paths-object",
              type: "object",
              patternProperties: { "^/": { $ref: "#/$defs/path-item" } },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "path-item": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#path-item-object",
              type: "object",
              properties: {
                summary: { type: "string" },
                description: { type: "string" },
                servers: { type: "array", items: { $ref: "#/$defs/server" } },
                parameters: { type: "array", items: { $ref: "#/$defs/parameter-or-reference" } },
                get: { $ref: "#/$defs/operation" },
                put: { $ref: "#/$defs/operation" },
                post: { $ref: "#/$defs/operation" },
                delete: { $ref: "#/$defs/operation" },
                options: { $ref: "#/$defs/operation" },
                head: { $ref: "#/$defs/operation" },
                patch: { $ref: "#/$defs/operation" },
                trace: { $ref: "#/$defs/operation" },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "path-item-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/path-item" },
            },
            operation: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#operation-object",
              type: "object",
              properties: {
                tags: { type: "array", items: { type: "string" } },
                summary: { type: "string" },
                description: { type: "string" },
                externalDocs: { $ref: "#/$defs/external-documentation" },
                operationId: { type: "string" },
                parameters: { type: "array", items: { $ref: "#/$defs/parameter-or-reference" } },
                requestBody: { $ref: "#/$defs/request-body-or-reference" },
                responses: { $ref: "#/$defs/responses" },
                callbacks: { type: "object", additionalProperties: { $ref: "#/$defs/callbacks-or-reference" } },
                deprecated: { default: !1, type: "boolean" },
                security: { type: "array", items: { $ref: "#/$defs/security-requirement" } },
                servers: { type: "array", items: { $ref: "#/$defs/server" } },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "external-documentation": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#external-documentation-object",
              type: "object",
              properties: { description: { type: "string" }, url: { type: "string", format: "uri" } },
              required: ["url"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            parameter: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#parameter-object",
              type: "object",
              properties: {
                name: { type: "string" },
                in: { enum: ["query", "header", "path", "cookie"] },
                description: { type: "string" },
                required: { default: !1, type: "boolean" },
                deprecated: { default: !1, type: "boolean" },
                schema: { $ref: "#/$defs/schema" },
                content: { $ref: "#/$defs/content", minProperties: 1, maxProperties: 1 },
              },
              required: ["name", "in"],
              oneOf: [{ required: ["schema"] }, { required: ["content"] }],
              if: { properties: { in: { const: "query" } }, required: ["in"] },
              then: { properties: { allowEmptyValue: { default: !1, type: "boolean" } } },
              dependentSchemas: {
                schema: {
                  properties: { style: { type: "string" }, explode: { type: "boolean" } },
                  allOf: [
                    { $ref: "#/$defs/examples" },
                    { $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path" },
                    { $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header" },
                    { $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query" },
                    { $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie" },
                    { $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form" },
                  ],
                  $defs: {
                    "styles-for-path": {
                      if: { properties: { in: { const: "path" } }, required: ["in"] },
                      then: {
                        properties: {
                          name: { pattern: "[^/#?]+$" },
                          style: { default: "simple", enum: ["matrix", "label", "simple"] },
                          required: { const: !0 },
                        },
                        required: ["required"],
                      },
                    },
                    "styles-for-header": {
                      if: { properties: { in: { const: "header" } }, required: ["in"] },
                      then: { properties: { style: { default: "simple", const: "simple" } } },
                    },
                    "styles-for-query": {
                      if: { properties: { in: { const: "query" } }, required: ["in"] },
                      then: {
                        properties: {
                          style: { default: "form", enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"] },
                          allowReserved: { default: !1, type: "boolean" },
                        },
                      },
                    },
                    "styles-for-cookie": {
                      if: { properties: { in: { const: "cookie" } }, required: ["in"] },
                      then: { properties: { style: { default: "form", const: "form" } } },
                    },
                    "styles-for-form": {
                      if: { properties: { style: { const: "form" } }, required: ["style"] },
                      then: { properties: { explode: { default: !0 } } },
                      else: { properties: { explode: { default: !1 } } },
                    },
                  },
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "parameter-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/parameter" },
            },
            "request-body": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#request-body-object",
              type: "object",
              properties: {
                description: { type: "string" },
                content: { $ref: "#/$defs/content" },
                required: { default: !1, type: "boolean" },
              },
              required: ["content"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "request-body-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/request-body" },
            },
            content: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#fixed-fields-10",
              type: "object",
              additionalProperties: { $ref: "#/$defs/media-type" },
              propertyNames: { format: "media-range" },
            },
            "media-type": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#media-type-object",
              type: "object",
              properties: {
                schema: { $ref: "#/$defs/schema" },
                encoding: { type: "object", additionalProperties: { $ref: "#/$defs/encoding" } },
              },
              allOf: [{ $ref: "#/$defs/specification-extensions" }, { $ref: "#/$defs/examples" }],
              unevaluatedProperties: !1,
            },
            encoding: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#encoding-object",
              type: "object",
              properties: {
                contentType: { type: "string", format: "media-range" },
                headers: { type: "object", additionalProperties: { $ref: "#/$defs/header-or-reference" } },
                style: { default: "form", enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"] },
                explode: { type: "boolean" },
                allowReserved: { default: !1, type: "boolean" },
              },
              allOf: [{ $ref: "#/$defs/specification-extensions" }, { $ref: "#/$defs/encoding/$defs/explode-default" }],
              unevaluatedProperties: !1,
              $defs: {
                "explode-default": {
                  if: { properties: { style: { const: "form" } }, required: ["style"] },
                  then: { properties: { explode: { default: !0 } } },
                  else: { properties: { explode: { default: !1 } } },
                },
              },
            },
            responses: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#responses-object",
              type: "object",
              properties: { default: { $ref: "#/$defs/response-or-reference" } },
              patternProperties: { "^[1-5](?:[0-9]{2}|XX)$": { $ref: "#/$defs/response-or-reference" } },
              minProperties: 1,
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            response: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#response-object",
              type: "object",
              properties: {
                description: { type: "string" },
                headers: { type: "object", additionalProperties: { $ref: "#/$defs/header-or-reference" } },
                content: { $ref: "#/$defs/content" },
                links: { type: "object", additionalProperties: { $ref: "#/$defs/link-or-reference" } },
              },
              required: ["description"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "response-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/response" },
            },
            callbacks: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#callback-object",
              type: "object",
              $ref: "#/$defs/specification-extensions",
              additionalProperties: { $ref: "#/$defs/path-item-or-reference" },
            },
            "callbacks-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/callbacks" },
            },
            example: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#example-object",
              type: "object",
              properties: {
                summary: { type: "string" },
                description: { type: "string" },
                value: !0,
                externalValue: { type: "string", format: "uri" },
              },
              not: { required: ["value", "externalValue"] },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "example-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/example" },
            },
            link: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#link-object",
              type: "object",
              properties: {
                operationRef: { type: "string", format: "uri-reference" },
                operationId: { type: "string" },
                parameters: { $ref: "#/$defs/map-of-strings" },
                requestBody: !0,
                description: { type: "string" },
                body: { $ref: "#/$defs/server" },
              },
              oneOf: [{ required: ["operationRef"] }, { required: ["operationId"] }],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "link-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/link" },
            },
            header: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#header-object",
              type: "object",
              properties: {
                description: { type: "string" },
                required: { default: !1, type: "boolean" },
                deprecated: { default: !1, type: "boolean" },
                schema: { $ref: "#/$defs/schema" },
                content: { $ref: "#/$defs/content", minProperties: 1, maxProperties: 1 },
              },
              oneOf: [{ required: ["schema"] }, { required: ["content"] }],
              dependentSchemas: {
                schema: {
                  properties: {
                    style: { default: "simple", const: "simple" },
                    explode: { default: !1, type: "boolean" },
                  },
                  $ref: "#/$defs/examples",
                },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            "header-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/header" },
            },
            tag: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#tag-object",
              type: "object",
              properties: {
                name: { type: "string" },
                description: { type: "string" },
                externalDocs: { $ref: "#/$defs/external-documentation" },
              },
              required: ["name"],
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
            },
            reference: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#reference-object",
              type: "object",
              properties: {
                $ref: { type: "string", format: "uri-reference" },
                summary: { type: "string" },
                description: { type: "string" },
              },
              unevaluatedProperties: !1,
            },
            schema: {
              $comment: "https://spec.openapis.org/oas/v3.1.0#schema-object",
              $dynamicAnchor: "meta",
              type: ["object", "boolean"],
            },
            "security-scheme": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#security-scheme-object",
              type: "object",
              properties: {
                type: { enum: ["apiKey", "http", "mutualTLS", "oauth2", "openIdConnect"] },
                description: { type: "string" },
              },
              required: ["type"],
              allOf: [
                { $ref: "#/$defs/specification-extensions" },
                { $ref: "#/$defs/security-scheme/$defs/type-apikey" },
                { $ref: "#/$defs/security-scheme/$defs/type-http" },
                { $ref: "#/$defs/security-scheme/$defs/type-http-bearer" },
                { $ref: "#/$defs/security-scheme/$defs/type-oauth2" },
                { $ref: "#/$defs/security-scheme/$defs/type-oidc" },
              ],
              unevaluatedProperties: !1,
              $defs: {
                "type-apikey": {
                  if: { properties: { type: { const: "apiKey" } }, required: ["type"] },
                  then: {
                    properties: { name: { type: "string" }, in: { enum: ["query", "header", "cookie"] } },
                    required: ["name", "in"],
                  },
                },
                "type-http": {
                  if: { properties: { type: { const: "http" } }, required: ["type"] },
                  then: { properties: { scheme: { type: "string" } }, required: ["scheme"] },
                },
                "type-http-bearer": {
                  if: {
                    properties: {
                      type: { const: "http" },
                      scheme: { type: "string", pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$" },
                    },
                    required: ["type", "scheme"],
                  },
                  then: { properties: { bearerFormat: { type: "string" } } },
                },
                "type-oauth2": {
                  if: { properties: { type: { const: "oauth2" } }, required: ["type"] },
                  then: { properties: { flows: { $ref: "#/$defs/oauth-flows" } }, required: ["flows"] },
                },
                "type-oidc": {
                  if: { properties: { type: { const: "openIdConnect" } }, required: ["type"] },
                  then: {
                    properties: { openIdConnectUrl: { type: "string", format: "uri" } },
                    required: ["openIdConnectUrl"],
                  },
                },
              },
            },
            "security-scheme-or-reference": {
              if: { type: "object", required: ["$ref"] },
              then: { $ref: "#/$defs/reference" },
              else: { $ref: "#/$defs/security-scheme" },
            },
            "oauth-flows": {
              type: "object",
              properties: {
                implicit: { $ref: "#/$defs/oauth-flows/$defs/implicit" },
                password: { $ref: "#/$defs/oauth-flows/$defs/password" },
                clientCredentials: { $ref: "#/$defs/oauth-flows/$defs/client-credentials" },
                authorizationCode: { $ref: "#/$defs/oauth-flows/$defs/authorization-code" },
              },
              $ref: "#/$defs/specification-extensions",
              unevaluatedProperties: !1,
              $defs: {
                implicit: {
                  type: "object",
                  properties: {
                    authorizationUrl: { type: "string", format: "uri" },
                    refreshUrl: { type: "string", format: "uri" },
                    scopes: { $ref: "#/$defs/map-of-strings" },
                  },
                  required: ["authorizationUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: !1,
                },
                password: {
                  type: "object",
                  properties: {
                    tokenUrl: { type: "string", format: "uri" },
                    refreshUrl: { type: "string", format: "uri" },
                    scopes: { $ref: "#/$defs/map-of-strings" },
                  },
                  required: ["tokenUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: !1,
                },
                "client-credentials": {
                  type: "object",
                  properties: {
                    tokenUrl: { type: "string", format: "uri" },
                    refreshUrl: { type: "string", format: "uri" },
                    scopes: { $ref: "#/$defs/map-of-strings" },
                  },
                  required: ["tokenUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: !1,
                },
                "authorization-code": {
                  type: "object",
                  properties: {
                    authorizationUrl: { type: "string", format: "uri" },
                    tokenUrl: { type: "string", format: "uri" },
                    refreshUrl: { type: "string", format: "uri" },
                    scopes: { $ref: "#/$defs/map-of-strings" },
                  },
                  required: ["authorizationUrl", "tokenUrl", "scopes"],
                  $ref: "#/$defs/specification-extensions",
                  unevaluatedProperties: !1,
                },
              },
            },
            "security-requirement": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#security-requirement-object",
              type: "object",
              additionalProperties: { type: "array", items: { type: "string" } },
            },
            "specification-extensions": {
              $comment: "https://spec.openapis.org/oas/v3.1.0#specification-extensions",
              patternProperties: { "^x-": !0 },
            },
            examples: {
              properties: {
                example: !0,
                examples: { type: "object", additionalProperties: { $ref: "#/$defs/example-or-reference" } },
              },
            },
            "map-of-strings": { type: "object", additionalProperties: { type: "string" } },
          },
        },
      }),
      Jf = {
        EMPTY_OR_INVALID: "Cant find JSON, YAML or filename in data",
        OPENAPI_VERSION_NOT_SUPPORTED:
          "Cant find supported Swagger/OpenAPI version in specification, version must be a string.",
        INVALID_REFERENCE: "Cant resolve reference: %s",
        EXTERNAL_REFERENCE_NOT_FOUND: "Cant resolve external reference: %s",
        FILE_DOES_NOT_EXIST: "File does not exist: %s",
      }
    function em(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }
    function tm(e) {
      for (const t of new Set(Kf)) {
        const n = "2.0" === t ? "swagger" : "openapi",
          r = e[n]
        if ("string" == typeof r && r.startsWith(t))
          return { version: t, specificationType: n, specificationVersion: r }
      }
      return { version: void 0, specificationType: void 0, specificationVersion: void 0 }
    }
    function nm(e) {
      return e.find((e) => e.isEntrypoint)
    }
    function rm(e) {
      return decodeURI(e.replace(/~1/g, "/").replace(/~0/g, "~"))
    }
    function am(e, t) {
      const n = {}
      for (const [r, a] of Object.entries(e))
        Array.isArray(a)
          ? (n[r] = a.map((e) => ("object" == typeof e && null !== e ? am(e, t) : e)))
          : (n[r] = "object" == typeof a && null !== a ? am(a, t) : a)
      return t(n)
    }
    function om(e) {
      const t = []
      return e && "object" == typeof e
        ? (am(
            e,
            (e) => (e.$ref && "string" == typeof e.$ref && !e.$ref.startsWith("#") && t.push(e.$ref.split("#")[0]), e),
          ),
          [...new Set(t)])
        : t
    }
    function im(e) {
      return void 0 !== typeof e && Array.isArray(e) && e.length > 0 && e.some((e) => !0 === e.isEntrypoint)
    }
    function sm(e) {
      if (im(e)) return e
      if ("string" == typeof e)
        try {
          return JSON.parse(e)
        } catch (t) {
          return yd(e, { maxAliasCount: 1e4 })
        }
      return e
    }
    function lm(e, t = {}) {
      if (im(e)) return e
      const n = sm(e)
      return [{ isEntrypoint: !0, specification: n, filename: null, dir: "./", references: om(n), ...t }]
    }
    function cm(e, t, n, r) {
      void 0 === r && (r = [])
      const a = lm(structuredClone(e)),
        o = nm(a)
      return (
        i((null == n ? void 0 : n.specification) ?? o.specification, a, n ?? o),
        i((null == n ? void 0 : n.specification) ?? o.specification, a, n ?? o),
        {
          valid:
            0 ===
            (r = r.filter((e, t, n) => t === n.findIndex((t) => t.message === e.message && t.code === e.code))).length,
          errors: r,
          schema: (n ?? nm(a)).specification,
        }
      )
      function i(e, n, a) {
        let o
        return (
          Object.entries(e ?? {}).forEach(([s, l]) => {
            if (void 0 !== e.$ref) {
              const o = dm(e.$ref, t, a, n, r)
              if (void 0 === o) return
              delete e.$ref,
                "object" == typeof o &&
                  Object.keys(o).forEach((t) => {
                    void 0 === e[t] && (e[t] = o[t])
                  })
            }
            "object" != typeof l ||
              (function (e) {
                try {
                  return JSON.stringify(e), !1
                } catch (e) {
                  return !0
                }
              })(l) ||
              (o = i(l, n, a))
          }),
          { errors: (null == o ? void 0 : o.errors) ?? [] }
        )
      }
    }
    function dm(e, t, n, r, a) {
      if ("string" != typeof e)
        return void a.push({ code: "INVALID_REFERENCE", message: Jf.INVALID_REFERENCE.replace("%s", e) })
      const [o, i] = e.split("#", 2)
      if (o) {
        const e = r.find((e) => e.filename === o)
        if (!e)
          return void a.push({
            code: "EXTERNAL_REFERENCE_NOT_FOUND",
            message: Jf.EXTERNAL_REFERENCE_NOT_FOUND.replace("%s", o),
          })
        const n = cm(r, t, e, a)
        return void 0 === i ? n.schema : dm(`#${i}`, t, e, r, a)
      }
      const s = (function (e) {
        return e.split("/").slice(1).map(rm)
      })(i)
      try {
        return s.reduce((e, t) => e[t], n.specification)
      } catch (t) {
        a.push({ code: "INVALID_REFERENCE", message: Jf.INVALID_REFERENCE.replace("%s", e) })
      }
    }
    async function um(e, t) {
      const n = lm(e),
        r = nm(n),
        a = cm(n, t)
      return { specification: r.specification, errors: a.errors, schema: a.schema, ...tm(r.specification) }
    }
    async function pm(e, t) {
      var n, r
      if ((null == t ? void 0 : t.filesystem) && (null == t ? void 0 : t.filesystem.find((t) => t.filename === e)))
        return { filesystem: t.filesystem }
      const a = null == (n = null == t ? void 0 : t.plugins) ? void 0 : n.find((t) => t.check(e)),
        o = sm(a ? await a.get(e) : e)
      if (void 0 === o) return { filesystem: [] }
      let i = lm(o, { filename: (null == t ? void 0 : t.filename) ?? null })
      const s =
        ((null == t ? void 0 : t.filename) ? i.find((e) => e.filename === (null == t ? void 0 : t.filename)) : nm(i))
          .references ?? om(o)
      if (0 === s.length) return { filesystem: i }
      for (const n of s) {
        const a = null == (r = null == t ? void 0 : t.plugins) ? void 0 : r.find((e) => e.check(n))
        if (!a) continue
        const o = a.check(n) && a.resolvePath ? a.resolvePath(e, n) : n
        if (i.find((e) => e.filename === n)) continue
        const { filesystem: s } = await pm(o, { ...t, filename: n })
        i = [...i, ...s.map((e) => ({ ...e, isEntrypoint: !1 }))]
      }
      return { filesystem: i }
    }
    const hm = { limit: 20 },
      fm = (e) => {
        let t = 0
        const n = { ...hm, ...e }
        return {
          check: (e) => "string" == typeof e && !(!e.startsWith("http://") && !e.startsWith("https://")),
          async get(e) {
            if (!1 !== (null == n ? void 0 : n.limit) && t >= (null == n ? void 0 : n.limit))
              console.warn(
                `[fetchUrls] Maximum number of requests reeached (${null == n ? void 0 : n.limit}), skipping request`,
              )
            else
              try {
                t++
                const r = await ((null == n ? void 0 : n.fetch) ? n.fetch(e) : fetch(e))
                return await r.text()
              } catch (t) {
                console.error("[fetchUrls]", t.message, `(${e})`)
              }
          },
        }
      },
      mm = (e) => {
        let t = {}
        ;(t = e && "object" == typeof e ? structuredClone(e) : bp()), t.tags || (t.tags = []), t.paths || (t.paths = {})
        const n = {}
        return (
          Object.keys(t.webhooks ?? {}).forEach((e) => {
            var r
            Object.keys((null == (r = t.webhooks) ? void 0 : r[e]) ?? {}).forEach((r) => {
              var a, o, i
              const s = null == (a = t.webhooks) ? void 0 : a[e][r]
              !0 !== (null == s ? void 0 : s["x-internal"]) &&
                (void 0 === n[e] && (n[e] = {}),
                (n[e][r] = {
                  httpVerb: Md(r),
                  path: e,
                  operationId: (null == s ? void 0 : s.operationId) || e,
                  name: (null == s ? void 0 : s.summary) || e || "",
                  description: (null == s ? void 0 : s.description) || "",
                  pathParameters: null == (i = null == (o = t.paths) ? void 0 : o[e]) ? void 0 : i.parameters,
                  information: { ...s },
                }))
            })
          }),
          Object.keys(t.paths).forEach((e) => {
            Object.keys(t.paths[e])
              .filter((e) => ls.includes(e.toUpperCase()))
              .forEach((n) => {
                var r, a, o, i, s, l
                const c = t.paths[e][n]
                if (void 0 === c) return
                if (!0 === c["x-internal"]) return
                const d = {
                  httpVerb: Md(n),
                  path: e,
                  operationId: c.operationId || e,
                  name: c.summary || e || "",
                  description: c.description || "",
                  information: { ...c },
                  pathParameters: null == (a = null == (r = t.paths) ? void 0 : r[e]) ? void 0 : a.parameters,
                }
                if (c.tags && 0 !== c.tags.length)
                  c.tags.forEach((e) => {
                    var n, r, a
                    const o = null == (n = t.tags) ? void 0 : n.findIndex((t) => t.name === e)
                    ;-1 === o && (null == (r = t.tags) || r.push({ name: e, description: "" }))
                    const i = -1 !== o ? o : t.tags.length - 1
                    void 0 === (null == (a = t.tags[i]) ? void 0 : a.operations) && (t.tags[i].operations = []),
                      t.tags[i].operations.push(d)
                  })
                else {
                  ;(null == (o = t.tags) ? void 0 : o.find((e) => "default" === e.name)) ||
                    null == (i = t.tags) ||
                    i.push({ name: "default", description: "", operations: [] })
                  const e = null == (s = t.tags) ? void 0 : s.findIndex((e) => "default" === e.name)
                  e >= 0 && (null == (l = t.tags[e]) || l.operations.push(d))
                }
              })
          }),
          { ...t, webhooks: n }
        )
      },
      gm = Symbol(),
      bm = Symbol(),
      vm = async (e) => {
        var t
        null == (t = document.getElementById(e)) || t.scrollIntoView()
      },
      ym = (e) => new Promise((t) => setTimeout(t, e))
    function Om(e) {
      return !!dt() && (ut(e), !0)
    }
    function wm(e) {
      return "function" == typeof e ? e() : In(e)
    }
    const xm = "undefined" != typeof window && "undefined" != typeof document
    "undefined" != typeof WorkerGlobalScope && (globalThis, WorkerGlobalScope)
    const km = (e) => null != e,
      _m = Object.prototype.toString,
      Sm = (e) => "[object Object]" === _m.call(e),
      Em = () => {}
    function Tm(e, t = 200, n = {}) {
      return (function (e, t) {
        return function (...n) {
          return new Promise((r, a) => {
            Promise.resolve(e(() => t.apply(this, n), { fn: t, thisArg: this, args: n }))
              .then(r)
              .catch(a)
          })
        }
      })(
        (function (e, t = {}) {
          let n,
            r,
            a = Em
          const o = (e) => {
            clearTimeout(e), a(), (a = Em)
          }
          return (i) => {
            const s = wm(e),
              l = wm(t.maxWait)
            return (
              n && o(n),
              s <= 0 || (void 0 !== l && l <= 0)
                ? (r && (o(r), (r = null)), Promise.resolve(i()))
                : new Promise((e, c) => {
                    ;(a = t.rejectOnCancel ? c : e),
                      l &&
                        !r &&
                        (r = setTimeout(() => {
                          n && o(n), (r = null), e(i())
                        }, l)),
                      (n = setTimeout(() => {
                        r && o(r), (r = null), e(i())
                      }, s))
                  })
            )
          }
        })(t, n),
        e,
      )
    }
    function Am(e, t, n) {
      return Ya(
        e,
        (e, n, r) => {
          e && t(e, n, r)
        },
        { ...n, once: !1 },
      )
    }
    function Cm(e, t, n) {
      let r
      r = Pn(n) ? { evaluating: n } : {}
      const { lazy: a = !1, evaluating: o, shallow: i = !0, onError: s = Em } = r,
        l = Dn(!a),
        c = i ? Rn(t) : Dn(t)
      let d = 0
      return (
        Wa(async (t) => {
          if (!l.value) return
          d++
          const n = d
          let r = !1
          o &&
            Promise.resolve().then(() => {
              o.value = !0
            })
          try {
            const a = await e((e) => {
              t(() => {
                o && (o.value = !1), r || e()
              })
            })
            n === d && (c.value = a)
          } catch (e) {
            s(e)
          } finally {
            o && n === d && (o.value = !1), (r = !0)
          }
        }),
        a ? ii(() => ((l.value = !0), c.value)) : c
      )
    }
    function Pm(e) {
      var t
      const n = wm(e)
      return null != (t = null == n ? void 0 : n.$el) ? t : n
    }
    const Dm = xm ? window : void 0
    function Rm(...e) {
      let t, n, r, a
      if (("string" == typeof e[0] || Array.isArray(e[0]) ? (([n, r, a] = e), (t = Dm)) : ([t, n, r, a] = e), !t))
        return Em
      Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r])
      const o = [],
        i = () => {
          o.forEach((e) => e()), (o.length = 0)
        },
        s = Ya(
          () => [Pm(t), wm(a)],
          ([e, t]) => {
            if ((i(), !e)) return
            const a = Sm(t) ? { ...t } : t
            o.push(
              ...n.flatMap((t) =>
                r.map((n) =>
                  ((e, t, n, r) => (e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r)))(e, t, n, a),
                ),
              ),
            )
          },
          { immediate: !0, flush: "post" },
        ),
        l = () => {
          s(), i()
        }
      return Om(l), l
    }
    function Nm(e) {
      const t = (function () {
        const e = Dn(!1),
          t = Vo()
        return (
          t &&
            Nr(() => {
              e.value = !0
            }, t),
          e
        )
      })()
      return ii(() => (t.value, Boolean(e())))
    }
    function $m(e, t = {}) {
      const { window: n = Dm } = t,
        r = Nm(() => n && "matchMedia" in n && "function" == typeof n.matchMedia)
      let a
      const o = Dn(!1),
        i = (e) => {
          o.value = e.matches
        },
        s = () => {
          a && ("removeEventListener" in a ? a.removeEventListener("change", i) : a.removeListener(i))
        },
        l = Wa(() => {
          r.value &&
            (s(),
            (a = n.matchMedia(wm(e))),
            "addEventListener" in a ? a.addEventListener("change", i) : a.addListener(i),
            (o.value = a.matches))
        })
      return (
        Om(() => {
          l(), s(), (a = void 0)
        }),
        o
      )
    }
    const Im = new Map()
    function Mm(e) {
      const t = dt()
      function n(n) {
        var a
        const o = Im.get(e) || new Set()
        o.add(n), Im.set(e, o)
        const i = () => r(n)
        return null == (a = null == t ? void 0 : t.cleanups) || a.push(i), i
      }
      function r(t) {
        const n = Im.get(e)
        n && (n.delete(t), n.size || a())
      }
      function a() {
        Im.delete(e)
      }
      return {
        on: n,
        once: function (e) {
          return n(function t(...n) {
            r(t), e(...n)
          })
        },
        off: r,
        emit: function (t, n) {
          var r
          null == (r = Im.get(e)) || r.forEach((e) => e(t, n))
        },
        reset: a,
      }
    }
    const Lm = {
      ctrl: "control",
      command: "meta",
      cmd: "meta",
      option: "alt",
      up: "arrowup",
      down: "arrowdown",
      left: "arrowleft",
      right: "arrowright",
    }
    function Qm(e = {}) {
      const { reactive: t = !1, target: n = Dm, aliasMap: r = Lm, passive: a = !0, onEventFired: o = Em } = e,
        i = mn(new Set()),
        s = { toJSON: () => ({}), current: i },
        l = t ? mn(s) : s,
        c = new Set(),
        d = new Set()
      function u(e, n) {
        e in l && (t ? (l[e] = n) : (l[e].value = n))
      }
      function p() {
        i.clear()
        for (const e of d) u(e, !1)
      }
      function h(e, t) {
        var n, r
        const a = null == (n = e.key) ? void 0 : n.toLowerCase(),
          o = [null == (r = e.code) ? void 0 : r.toLowerCase(), a].filter(Boolean)
        a && (t ? i.add(a) : i.delete(a))
        for (const e of o) d.add(e), u(e, t)
        "meta" !== a || t
          ? "function" == typeof e.getModifierState &&
            e.getModifierState("Meta") &&
            t &&
            [...i, ...o].forEach((e) => c.add(e))
          : (c.forEach((e) => {
              i.delete(e), u(e, !1)
            }),
            c.clear())
      }
      Rm(n, "keydown", (e) => (h(e, !0), o(e)), { passive: a }),
        Rm(n, "keyup", (e) => (h(e, !1), o(e)), { passive: a }),
        Rm("blur", p, { passive: !0 }),
        Rm("focus", p, { passive: !0 })
      const f = new Proxy(l, {
        get(e, n, a) {
          if ("string" != typeof n) return Reflect.get(e, n, a)
          if (((n = n.toLowerCase()) in r && (n = r[n]), !(n in l)))
            if (/[+_-]/.test(n)) {
              const e = n.split(/[+_-]/g).map((e) => e.trim())
              l[n] = ii(() => e.every((e) => wm(f[e])))
            } else l[n] = Dn(!1)
          const o = Reflect.get(e, n, a)
          return t ? wm(o) : o
        },
      })
      return f
    }
    const Bm = Mm(Symbol("downloadSpec"))
    function jm({ specConfig: e, proxy: t }) {
      const n = Dn(""),
        r = mn(bp()),
        a = Dn(null)
      return (
        Ya(
          () => Mn(e),
          async (e) => {
            var r
            if (e) {
              const a =
                null ==
                (r = await (async ({ url: e, content: t }, n) => {
                  if (e)
                    return (function (e) {
                      try {
                        return Boolean(new URL(e))
                      } catch {
                        return !1
                      }
                    })(e)
                      ? await Sd(e, n)
                      : await Sd(e)
                  const r = "function" == typeof t ? t() : t
                  return "string" == typeof r ? r : "object" == typeof r ? Dd(r) : void 0
                })(e, Mn(t)))
                  ? void 0
                  : r.trim()
              "string" == typeof a && (n.value = a)
            }
          },
          { immediate: !0, deep: !0 },
        ),
        Ya(n, () => {
          !(function (e) {
            e
              ? ((e, { proxy: t } = {}) =>
                  new Promise(async (n, r) => {
                    var a
                    try {
                      if (!e) return n(mm(bp()))
                      const o = performance.now(),
                        { filesystem: i } = await pm(e, { plugins: [fm({ fetch: (e) => fetch(t ? gs(t, e) : e) })] }),
                        { schema: s, errors: l } = await um(i),
                        c = performance.now()
                      return (
                        console.log(`dereference: ${Math.round(c - o)} ms`),
                        (null == l ? void 0 : l.length) &&
                          console.warn(
                            "Please open an issue on https://github.com/scalar/scalar\n",
                            "Scalar OpenAPI Parser Warning:\n",
                            l,
                          ),
                        void 0 === s
                          ? (r(
                              (null == (a = null == l ? void 0 : l[0]) ? void 0 : a.message) ??
                                "Failed to parse the OpenAPI file.",
                            ),
                            n(mm(bp())))
                          : n(mm(s))
                      )
                    } catch (e) {
                      r(e)
                    }
                    return n(mm(bp()))
                  }))(e, { proxy: t ? Mn(t) : void 0 })
                  .then((e) => {
                    ;(a.value = null), Object.assign(r, { servers: [], ...e })
                  })
                  .catch((e) => {
                    a.value = e.toString()
                  })
              : Object.assign(r, bp())
          })(n.value)
        }),
        { rawSpec: n, parsedSpec: r, specErrors: a }
      )
    }
    function Um(e) {
      const t = ii(() => {
        if (!e.information) return []
        const { responses: t } = e.information,
          n = []
        return (
          t &&
            Object.keys(t).forEach((e) => {
              n.push({ name: e, description: t[e].description })
            }),
          n
        )
      })
      return { responses: t }
    }
    const {
        getHeadingId: Fm,
        getModelId: zm,
        getOperationId: qm,
        getSectionId: Zm,
        getTagId: Hm,
        getWebhookId: Vm,
        hash: Wm,
      } = fp(),
      Xm = Dn(void 0),
      Ym = mn({})
    function Gm(e) {
      var t, n
      return (
        "alpha" === Ym.tagsSorter
          ? (e.tags = null == (t = e.tags) ? void 0 : t.sort((e, t) => e.name.localeCompare(t.name)))
          : "function" == typeof Ym.tagsSorter && (e.tags = null == (n = e.tags) ? void 0 : n.sort(Ym.tagsSorter)),
        (Xm.value = e)
      )
    }
    const Km = Dn(!1),
      Jm = Dn(!1),
      eg = mn(Nd["useSidebarContent-collapsedSidebarItems"] ?? {})
    function tg(e) {
      eg[e] = !eg[e]
    }
    function ng(e, t) {
      eg[e] = t
    }
    const rg = Dn([]),
      ag = ii(() => {
        var e, t, n, r, a, o, i, s, l, c
        const { state: d } = Fd(),
          u = {},
          {
            openApi: { globalSecurity: p },
          } = Xd(),
          h = []
        let f = null
        rg.value.forEach((e) => {
          var t
          e.depth === jf(rg.value)
            ? ((f = { id: Fm(e), title: e.value, show: !d.showApiClient, children: [] }), h.push(f))
            : f && (null == (t = f.children) || t.push({ id: Fm(e), title: e.value, show: !d.showApiClient }))
        })
        const m = null == (t = null == (e = Xm.value) ? void 0 : e.tags) ? void 0 : t[0],
          g =
            !m ||
            (1 === (null == (b = null == (n = Xm.value) ? void 0 : n.tags) ? void 0 : b.length) &&
              "default" === b[0].name &&
              "" === b[0].description)
              ? null == (o = null == m ? void 0 : m.operations)
                ? void 0
                : o.map((e) => {
                    var t
                    const n = qm(e, m),
                      r = e.name ?? e.path
                    return (
                      (u[n] = r),
                      {
                        id: n,
                        title: r,
                        httpVerb: e.httpVerb,
                        deprecated: (null == (t = e.information) ? void 0 : t.deprecated) ?? !1,
                        show: !0,
                        select: () => {
                          d.showApiClient && Gf(e, p)
                        },
                      }
                    )
                  })
              : null == (a = null == (r = Xm.value) ? void 0 : r.tags)
                ? void 0
                : a
                    .filter((e) => {
                      var t
                      return (null == (t = e.operations) ? void 0 : t.length) > 0
                    })
                    .map((e) => {
                      var t
                      return {
                        id: Hm(e),
                        title: e.name,
                        displayTitle: e["x-displayName"] ?? e.name,
                        show: !0,
                        children:
                          null == (t = e.operations)
                            ? void 0
                            : t.map((t) => {
                                var n
                                const r = qm(t, e),
                                  a = t.name ?? t.path
                                return (
                                  (u[r] = a),
                                  {
                                    id: r,
                                    title: a,
                                    httpVerb: t.httpVerb,
                                    deprecated: (null == (n = t.information) ? void 0 : n.deprecated) ?? !1,
                                    show: !0,
                                    select: () => {
                                      d.showApiClient && Gf(t, p)
                                    },
                                  }
                                )
                              }),
                      }
                    })
        var b
        let v =
            Ff(Xm.value) && !Km.value
              ? [
                  {
                    id: zm(),
                    title: "Models",
                    show: !d.showApiClient,
                    children: Object.keys(Uf(Xm.value) ?? {}).map((e) => {
                      var t
                      const n = zm(e)
                      return (
                        (u[n] = e),
                        {
                          id: n,
                          title: (null == (t = Uf(Xm.value)) ? void 0 : t[e]).title ?? e,
                          show: !d.showApiClient,
                        }
                      )
                    }),
                  },
                ]
              : [],
          y =
            (O = Xm.value) && Object.keys((null == O ? void 0 : O.webhooks) ?? {}).length
              ? [
                  {
                    id: Vm(),
                    title: "Webhooks",
                    show: !d.showApiClient,
                    children: Object.keys((null == (i = Xm.value) ? void 0 : i.webhooks) ?? {})
                      .map((e) => {
                        var t, n
                        const r = Vm(e)
                        return (
                          (u[r] = e),
                          Object.keys(
                            (null == (n = null == (t = Xm.value) ? void 0 : t.webhooks) ? void 0 : n[e]) ?? {},
                          ).map((t) => {
                            var n, r, a
                            return {
                              id: Vm(e, t),
                              title:
                                null ==
                                (a = null == (r = null == (n = Xm.value) ? void 0 : n.webhooks) ? void 0 : r[e][t])
                                  ? void 0
                                  : a.name,
                              httpVerb: t,
                              show: !d.showApiClient,
                            }
                          })
                        )
                      })
                      .flat(),
                  },
                ]
              : []
        var O
        const w = (null == (s = Xm.value) ? void 0 : s["x-tagGroups"])
            ? null == (c = null == (l = Xm.value) ? void 0 : l["x-tagGroups"])
              ? void 0
              : c.map((e) => {
                  var t
                  const n = []
                  return (
                    null == (t = e.tags) ||
                      t.map((e) => {
                        if ("models" === e && v.length > 0) n.push(v[0]), (v = [])
                        else if ("webhooks" === e && y.length > 0) n.push(y[0]), (y = [])
                        else {
                          const t = null == g ? void 0 : g.find((t) => t.title === e)
                          t && n.push(t)
                        }
                      }),
                    { id: e.name, title: e.name, children: n, show: !0, isGroup: !0 }
                  )
                })
            : void 0,
          x = [...h, ...(w ?? g ?? []), ...y, ...v]
        return (
          Jm.value &&
            x.forEach((e) => {
              ng(e.id, !0), (e.show = !0)
            }),
          { entries: x, titles: u }
        )
      }),
      og = Dn(!1),
      ig = ii(() => {
        var e, t
        return (null == (t = null == (e = ag.value) ? void 0 : e.titles) ? void 0 : t[Wm.value]) ?? ""
      })
    function sg(e) {
      return (
        Object.assign(Ym, e),
        (null == e ? void 0 : e.parsedSpec) &&
          (Gm(e.parsedSpec),
          Ya(
            () => {
              var e, t
              return null == (t = null == (e = Xm.value) ? void 0 : e.tags) ? void 0 : t.length
            },
            () => {
              var e, t
              if (Wm.value) {
                const e = Zm(Wm.value)
                e && ng(e, !0)
              } else {
                const n = null == (t = null == (e = Xm.value) ? void 0 : e.tags) ? void 0 : t[0]
                n && ng(Hm(n), !0)
              }
            },
          ),
          Ya(
            () => {
              var e, t
              return null == (t = null == (e = Xm.value) ? void 0 : e.info) ? void 0 : t.description
            },
            async () => {
              var e, t
              const n = null == (t = null == (e = Xm.value) ? void 0 : e.info) ? void 0 : t.description
              return (rg.value = n
                ? await (async (e) => {
                    const t = Bf(e),
                      n = jf(t)
                    return t.filter((e) => e.depth === n || e.depth === n + 1)
                  })(n)
                : [])
            },
          )),
        {
          breadcrumb: ig,
          items: ag,
          isSidebarOpen: og,
          collapsedSidebarItems: eg,
          toggleCollapsedSidebarItem: tg,
          setCollapsedSidebarItem: ng,
          hideModels: Km,
          setParsedSpec: Gm,
          defaultOpenAllTags: Jm,
        }
      )
    }
    const lg = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : window,
      { FormData: cg, Blob: dg, File: ug } = lg,
      pg = "\r\n",
      hg = "-".repeat(2),
      fg = Symbol.toStringTag,
      mg = (e, t, n) => {
        let r = ""
        return (
          (r += `${hg}${e}${pg}`),
          (r += `Content-Disposition: form-data; name="${t}"`),
          "string" != typeof n &&
            "blob" !== n.name &&
            ((r += `; filename="${n.name}"${pg}`), (r += `Content-Type: ${n.type || "application/octet-stream"}`)),
          `${r}${pg.repeat(2)}`
        )
      },
      gg = (e, t) => Object.keys(e).find((e) => e.toLowerCase() === t.toLowerCase()),
      bg = (e, t) => {
        const n = gg(e, t)
        if (n) return e[n]
      },
      vg = (e, t) => Boolean(gg(e, t)),
      yg = ["application/json", "application/x-json", "text/json", "text/x-json", "+json"],
      Og = (e, t) => {
        if (void 0 === t.value) return e
        const n = e[t.name]
        return void 0 === n
          ? ((e[t.name] = t.value), e)
          : Array.isArray(n)
            ? (n.push(t.value), e)
            : ((e[t.name] = [n, t.value]), e)
      }
    function wg(e) {
      return new URLSearchParams(
        Object.entries(e)
          .map(([e, t]) => (Array.isArray(t) ? t.map((t) => [e, t]) : [[e, t]]))
          .flat(1),
      )
    }
    class xg extends URL {
      get path() {
        return this.pathname + this.search
      }
    }
    class kg {
      constructor({ indent: e, join: t } = {}) {
        ;(this.postProcessors = []),
          (this.code = []),
          (this.indentationCharacter = ""),
          (this.lineJoin = "\n"),
          (this.indentLine = (e, t = 0) => `${this.indentationCharacter.repeat(t)}${e}`),
          (this.unshift = (e, t) => {
            const n = this.indentLine(e, t)
            this.code.unshift(n)
          }),
          (this.push = (e, t) => {
            const n = this.indentLine(e, t)
            this.code.push(n)
          }),
          (this.blank = () => {
            this.code.push("")
          }),
          (this.join = () => {
            const e = this.code.join(this.lineJoin)
            return this.postProcessors.reduce((e, t) => t(e), e)
          }),
          (this.addPostProcessor = (e) => {
            this.postProcessors = [...this.postProcessors, e]
          }),
          (this.indentationCharacter = e || ""),
          (this.lineJoin = null != t ? t : "\n")
      }
    }
    function _g(e, t = {}) {
      const { delimiter: n = '"', escapeChar: r = "\\", escapeNewlines: a = !0 } = t
      return [...e.toString()]
        .map((e) =>
          "\b" === e
            ? `${r}b`
            : "\t" === e
              ? `${r}t`
              : "\n" === e
                ? a
                  ? `${r}n`
                  : e
                : "\f" === e
                  ? `${r}f`
                  : "\r" === e
                    ? a
                      ? `${r}r`
                      : e
                    : e === r
                      ? r + r
                      : e === n
                        ? r + n
                        : e < " " || e > "~"
                          ? JSON.stringify(e).slice(1, -1)
                          : e,
        )
        .join("")
    }
    const Sg = (e) => _g(e, { delimiter: "'" }),
      Eg = (e) => _g(e, { delimiter: '"' }),
      Tg = {
        info: { key: "c", title: "C", extname: ".c", default: "libcurl" },
        clientsById: {
          libcurl: {
            info: {
              key: "libcurl",
              title: "Libcurl",
              link: "http://curl.haxx.se/libcurl",
              description: "Simple REST and HTTP API Client for C",
            },
            convert: ({ method: e, fullUrl: t, headersObj: n, allHeaders: r, postData: a }) => {
              const { push: o, blank: i, join: s } = new kg()
              o("CURL *hnd = curl_easy_init();"),
                i(),
                o(`curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "${e.toUpperCase()}");`),
                o(`curl_easy_setopt(hnd, CURLOPT_URL, "${t}");`)
              const l = Object.keys(n)
              return (
                l.length &&
                  (i(),
                  o("struct curl_slist *headers = NULL;"),
                  l.forEach((e) => {
                    o(`headers = curl_slist_append(headers, "${e}: ${Eg(n[e])}");`)
                  }),
                  o("curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);")),
                r.cookie && (i(), o(`curl_easy_setopt(hnd, CURLOPT_COOKIE, "${r.cookie}");`)),
                (null == a ? void 0 : a.text) &&
                  (i(), o(`curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, ${JSON.stringify(a.text)});`)),
                i(),
                o("CURLcode ret = curl_easy_perform(hnd);"),
                s()
              )
            },
          },
        },
      }
    class Ag {
      constructor(e) {
        ;(this.name = ""), (this.toString = () => `:${this.name}`), (this.name = e)
      }
    }
    let Cg = class {
      constructor(e) {
        ;(this.path = ""), (this.toString = () => `(clojure.java.io/file "${this.path}")`), (this.path = e)
      }
    }
    const Pg = (e) => (void 0 === e ? null : null === e ? "null" : e.constructor.name.toLowerCase()),
      Dg = (e) => "object" === Pg(e) && 0 === Object.keys(e).length,
      Rg = (e) => (
        Object.keys(e)
          .filter((t) => Dg(e[t]))
          .forEach((t) => {
            delete e[t]
          }),
        e
      ),
      Ng = (e, t) => {
        const n = " ".repeat(e)
        return t.replace(/\n/g, `\n${n}`)
      },
      $g = (e) => {
        switch (Pg(e)) {
          case "string":
            return `"${e.replace(/"/g, '\\"')}"`
          case "file":
          case "keyword":
          default:
            return e.toString()
          case "null":
            return "nil"
          case "regexp":
            return `#"${e.source}"`
          case "object": {
            const t = Object.keys(e)
              .reduce((t, n) => `${t}:${n} ${Ng(n.length + 2, $g(e[n]))}\n `, "")
              .trim()
            return `{${Ng(1, t)}}`
          }
          case "array": {
            const t = e.reduce((e, t) => `${e} ${$g(t)}`, "").trim()
            return `[${Ng(1, t)}]`
          }
        }
      },
      Ig = {
        info: { key: "clojure", title: "Clojure", extname: ".clj", default: "clj_http" },
        clientsById: {
          clj_http: {
            info: {
              key: "clj_http",
              title: "clj-http",
              link: "https://github.com/dakrone/clj-http",
              description: "An idiomatic clojure http client wrapping the apache client.",
            },
            convert: ({ queryObj: e, method: t, postData: n, url: r, allHeaders: a }, o) => {
              const { push: i, join: s } = new kg({ indent: null == o ? void 0 : o.indent })
              if (((t = t.toLowerCase()), !["get", "post", "put", "delete", "patch", "head", "options"].includes(t)))
                return i("Method not supported"), s()
              const l = { headers: a, "query-params": e }
              switch (null == n ? void 0 : n.mimeType) {
                case "application/json":
                  {
                    ;(l["content-type"] = new Ag("json")), (l["form-params"] = n.jsonObj)
                    const e = gg(l.headers, "content-type")
                    e && delete l.headers[e]
                  }
                  break
                case "application/x-www-form-urlencoded":
                  {
                    l["form-params"] = n.paramsObj
                    const e = gg(l.headers, "content-type")
                    e && delete l.headers[e]
                  }
                  break
                case "text/plain":
                  {
                    l.body = n.text
                    const e = gg(l.headers, "content-type")
                    e && delete l.headers[e]
                  }
                  break
                case "multipart/form-data":
                  if (n.params) {
                    l.multipart = n.params.map((e) =>
                      e.fileName && !e.value
                        ? { name: e.name, content: new Cg(e.fileName) }
                        : { name: e.name, content: e.value },
                    )
                    const e = gg(l.headers, "content-type")
                    e && delete l.headers[e]
                  }
              }
              if ("application/json" === bg(l.headers, "accept")) {
                l.accept = new Ag("json")
                const e = gg(l.headers, "accept")
                e && delete l.headers[e]
              }
              if ((i("(require '[clj-http.client :as client])\n"), Dg(Rg(l)))) i(`(client/${t} "${r}")`)
              else {
                const e = 11 + t.length + r.length
                i(`(client/${t} "${r}" ${Ng(e, $g(Rg(l)))})`)
              }
              return s()
            },
          },
        },
      },
      Mg = {
        info: { key: "csharp", title: "C#", extname: ".cs", default: "restsharp" },
        clientsById: {
          httpclient: {
            info: {
              key: "httpclient",
              title: "HttpClient",
              link: "https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient",
              description: ".NET Standard HTTP Client",
            },
            convert: ({ allHeaders: e, postData: t, method: n, fullUrl: r }, a) => {
              var o, i
              const s = { indent: "    ", ...a },
                { push: l, join: c } = new kg({ indent: s.indent })
              l("using System.Net.Http.Headers;")
              let d = ""
              const u = Boolean(e.cookie),
                p = ((e) => {
                  let t = bg(e, "accept-encoding")
                  if (!t) return []
                  const n = { gzip: "DecompressionMethods.GZip", deflate: "DecompressionMethods.Deflate" },
                    r = []
                  return (
                    "string" == typeof t && (t = [t]),
                    t.forEach((e) => {
                      e.split(",").forEach((e) => {
                        const t = /\s*([^;\s]+)/.exec(e)
                        if (t) {
                          const e = n[t[1]]
                          e && r.push(e)
                        }
                      })
                    }),
                    r
                  )
                })(e)
              ;(u || p.length) &&
                ((d = "clientHandler"),
                l("var clientHandler = new HttpClientHandler"),
                l("{"),
                u && l("UseCookies = false,", 1),
                p.length && l(`AutomaticDecompression = ${p.join(" | ")},`, 1),
                l("};")),
                l(`var client = new HttpClient(${d});`),
                l("var request = new HttpRequestMessage"),
                l("{"),
                (n =
                  (n = n.toUpperCase()) &&
                  ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE"].includes(n)
                    ? `HttpMethod.${n[0]}${n.substring(1).toLowerCase()}`
                    : `new HttpMethod("${n}")`),
                l(`Method = ${n},`, 1),
                l(`RequestUri = new Uri("${r}"),`, 1)
              const h = Object.keys(e).filter((e) => {
                switch (e.toLowerCase()) {
                  case "content-type":
                  case "content-length":
                  case "accept-encoding":
                    return !1
                  default:
                    return !0
                }
              })
              if (
                (h.length &&
                  (l("Headers =", 1),
                  l("{", 1),
                  h.forEach((t) => {
                    l(`{ "${t}", "${Eg(e[t])}" },`, 2)
                  }),
                  l("},", 1)),
                null == t ? void 0 : t.text)
              ) {
                const e = t.mimeType
                switch (e) {
                  case "application/x-www-form-urlencoded":
                    l("Content = new FormUrlEncodedContent(new Dictionary<string, string>", 1),
                      l("{", 1),
                      null === (o = t.params) ||
                        void 0 === o ||
                        o.forEach((e) => {
                          l(`{ "${e.name}", "${e.value}" },`, 2)
                        }),
                      l("}),", 1)
                    break
                  case "multipart/form-data":
                    l("Content = new MultipartFormDataContent", 1),
                      l("{", 1),
                      null === (i = t.params) ||
                        void 0 === i ||
                        i.forEach((e) => {
                          l(`new StringContent(${JSON.stringify(e.value || "")})`, 2),
                            l("{", 2),
                            l("Headers =", 3),
                            l("{", 3),
                            e.contentType && l(`ContentType = new MediaTypeHeaderValue("${e.contentType}"),`, 4),
                            l('ContentDisposition = new ContentDispositionHeaderValue("form-data")', 4),
                            l("{", 4),
                            l(`Name = "${e.name}",`, 5),
                            e.fileName && l(`FileName = "${e.fileName}",`, 5),
                            l("}", 4),
                            l("}", 3),
                            l("},", 2)
                        }),
                      l("},", 1)
                    break
                  default:
                    l(`Content = new StringContent(${JSON.stringify((null == t ? void 0 : t.text) || "")})`, 1),
                      l("{", 1),
                      l("Headers =", 2),
                      l("{", 2),
                      l(`ContentType = new MediaTypeHeaderValue("${e}")`, 3),
                      l("}", 2),
                      l("}", 1)
                }
              }
              return (
                l("};"),
                l("using (var response = await client.SendAsync(request))"),
                l("{"),
                l("response.EnsureSuccessStatusCode();", 1),
                l("var body = await response.Content.ReadAsStringAsync();", 1),
                l("Console.WriteLine(body);", 1),
                l("}"),
                c()
              )
            },
          },
          restsharp: {
            info: {
              key: "restsharp",
              title: "RestSharp",
              link: "http://restsharp.org/",
              description: "Simple REST and HTTP API Client for .NET",
            },
            convert: ({ allHeaders: e, method: t, fullUrl: n, headersObj: r, cookies: a, postData: o }) => {
              const { push: i, join: s } = new kg()
              if (!["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(t.toUpperCase()))
                return "Method not supported"
              if (
                (i(`var client = new RestClient("${n}");`),
                i(`var request = new RestRequest(Method.${t.toUpperCase()});`),
                Object.keys(r).forEach((e) => {
                  i(`request.AddHeader("${e}", "${Eg(r[e])}");`)
                }),
                null == a ||
                  a.forEach(({ name: e, value: t }) => {
                    i(`request.AddCookie("${e}", "${t}");`)
                  }),
                null == o ? void 0 : o.text)
              ) {
                const t = bg(e, "content-type"),
                  n = JSON.stringify(o.text)
                i(`request.AddParameter("${t}", ${n}, ParameterType.RequestBody);`)
              }
              return i("IRestResponse response = client.Execute(request);"), s()
            },
          },
        },
      },
      Lg = {
        info: { key: "go", title: "Go", extname: ".go", default: "native" },
        clientsById: {
          native: {
            info: {
              key: "native",
              title: "NewRequest",
              link: "http://golang.org/pkg/net/http/#NewRequest",
              description: "Golang HTTP client request",
            },
            convert: ({ postData: e, method: t, allHeaders: n, fullUrl: r }, a = {}) => {
              const { blank: o, push: i, join: s } = new kg({ indent: "\t" }),
                {
                  showBoilerplate: l = !0,
                  checkErrors: c = !1,
                  printBody: d = !0,
                  timeout: u = -1,
                  insecureSkipVerify: p = !1,
                } = a,
                h = c ? "err" : "_",
                f = l ? 1 : 0,
                m = () => {
                  c && (i("if err != nil {", f), i("panic(err)", f + 1), i("}", f))
                }
              l &&
                (i("package main"),
                o(),
                i("import ("),
                i('"fmt"', f),
                u > 0 && i('"time"', f),
                p && i('"crypto/tls"', f),
                (null == e ? void 0 : e.text) && i('"strings"', f),
                i('"net/http"', f),
                d && i('"io"', f),
                i(")"),
                o(),
                i("func main() {"),
                o()),
                p &&
                  (i("insecureTransport := http.DefaultTransport.(*http.Transport).Clone()", f),
                  i("insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}", f))
              const g = u > 0,
                b = g || p,
                v = b ? "client" : "http.DefaultClient"
              return (
                b &&
                  (i("client := http.Client{", f),
                  g && i(`Timeout: time.Duration(${u} * time.Second),`, f + 1),
                  p && i("Transport: insecureTransport,", f + 1),
                  i("}", f),
                  o()),
                i(`url := "${r}"`, f),
                o(),
                (null == e ? void 0 : e.text)
                  ? (i(`payload := strings.NewReader(${JSON.stringify(e.text)})`, f),
                    o(),
                    i(`req, ${h} := http.NewRequest("${t}", url, payload)`, f),
                    o())
                  : (i(`req, ${h} := http.NewRequest("${t}", url, nil)`, f), o()),
                m(),
                Object.keys(n).length &&
                  (Object.keys(n).forEach((e) => {
                    i(`req.Header.Add("${e}", "${Eg(n[e])}")`, f)
                  }),
                  o()),
                i(`res, ${h} := ${v}.Do(req)`, f),
                m(),
                d && (o(), i("defer res.Body.Close()", f), i(`body, ${h} := io.ReadAll(res.Body)`, f), m()),
                o(),
                i("fmt.Println(res)", f),
                d && i("fmt.Println(string(body))", f),
                l && (o(), i("}")),
                s()
              )
            },
          },
        },
      },
      Qg = {
        info: { key: "http", title: "HTTP", extname: null, default: "1.1" },
        clientsById: {
          "http1.1": {
            info: {
              key: "http1.1",
              title: "HTTP/1.1",
              link: "https://tools.ietf.org/html/rfc7230",
              description: "HTTP/1.1 request string in accordance with RFC 7230",
            },
            convert: ({ method: e, fullUrl: t, uriObj: n, httpVersion: r, allHeaders: a, postData: o }, i) => {
              const s = { absoluteURI: !1, autoContentLength: !0, autoHost: !0, ...i },
                { blank: l, push: c, join: d } = new kg({ indent: "", join: "\r\n" }),
                u = s.absoluteURI ? t : n.path
              c(`${e} ${u} ${r}`)
              const p = Object.keys(a)
              return (
                p.forEach((e) => {
                  const t = e.toLowerCase().replace(/(^|-)(\w)/g, (e) => e.toUpperCase())
                  c(`${t}: ${a[e]}`)
                }),
                s.autoHost && !p.includes("host") && c(`Host: ${n.host}`),
                s.autoContentLength &&
                  (null == o ? void 0 : o.text) &&
                  !p.includes("content-length") &&
                  c(`Content-Length: ${o.text.length}`),
                l(),
                `${d()}\r\n${(null == o ? void 0 : o.text) || ""}`
              )
            },
          },
        },
      },
      Bg = {
        info: { key: "java", title: "Java", extname: ".java", default: "unirest" },
        clientsById: {
          asynchttp: {
            info: {
              key: "asynchttp",
              title: "AsyncHttp",
              link: "https://github.com/AsyncHttpClient/async-http-client",
              description: "Asynchronous Http and WebSocket Client library for Java",
            },
            convert: ({ method: e, allHeaders: t, postData: n, fullUrl: r }, a) => {
              const o = { indent: "  ", ...a },
                { blank: i, push: s, join: l } = new kg({ indent: o.indent })
              return (
                s("AsyncHttpClient client = new DefaultAsyncHttpClient();"),
                s(`client.prepare("${e.toUpperCase()}", "${r}")`),
                Object.keys(t).forEach((e) => {
                  s(`.setHeader("${e}", "${Eg(t[e])}")`, 1)
                }),
                (null == n ? void 0 : n.text) && s(`.setBody(${JSON.stringify(n.text)})`, 1),
                s(".execute()", 1),
                s(".toCompletableFuture()", 1),
                s(".thenAccept(System.out::println)", 1),
                s(".join();", 1),
                i(),
                s("client.close();"),
                l()
              )
            },
          },
          nethttp: {
            info: {
              key: "nethttp",
              title: "java.net.http",
              link: "https://openjdk.java.net/groups/net/httpclient/intro.html",
              description: "Java Standardized HTTP Client API",
            },
            convert: ({ allHeaders: e, fullUrl: t, method: n, postData: r }, a) => {
              const o = { indent: "  ", ...a },
                { push: i, join: s } = new kg({ indent: o.indent })
              return (
                i("HttpRequest request = HttpRequest.newBuilder()"),
                i(`.uri(URI.create("${t}"))`, 2),
                Object.keys(e).forEach((t) => {
                  i(`.header("${t}", "${Eg(e[t])}")`, 2)
                }),
                (null == r ? void 0 : r.text)
                  ? i(
                      `.method("${n.toUpperCase()}", HttpRequest.BodyPublishers.ofString(${JSON.stringify(r.text)}))`,
                      2,
                    )
                  : i(`.method("${n.toUpperCase()}", HttpRequest.BodyPublishers.noBody())`, 2),
                i(".build();", 2),
                i(
                  "HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());",
                ),
                i("System.out.println(response.body());"),
                s()
              )
            },
          },
          okhttp: {
            info: {
              key: "okhttp",
              title: "OkHttp",
              link: "http://square.github.io/okhttp/",
              description: "An HTTP Request Client Library",
            },
            convert: ({ postData: e, method: t, fullUrl: n, allHeaders: r }, a) => {
              const o = { indent: "  ", ...a },
                { push: i, blank: s, join: l } = new kg({ indent: o.indent })
              return (
                i("OkHttpClient client = new OkHttpClient();"),
                s(),
                (null == e ? void 0 : e.text) &&
                  (e.boundary
                    ? i(`MediaType mediaType = MediaType.parse("${e.mimeType}; boundary=${e.boundary}");`)
                    : i(`MediaType mediaType = MediaType.parse("${e.mimeType}");`),
                  i(`RequestBody body = RequestBody.create(mediaType, ${JSON.stringify(e.text)});`)),
                i("Request request = new Request.Builder()"),
                i(`.url("${n}")`, 1),
                ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"].includes(t.toUpperCase())
                  ? ["POST", "PUT", "DELETE", "PATCH"].includes(t.toUpperCase())
                    ? (null == e ? void 0 : e.text)
                      ? i(`.${t.toLowerCase()}(body)`, 1)
                      : i(`.${t.toLowerCase()}(null)`, 1)
                    : i(`.${t.toLowerCase()}()`, 1)
                  : (null == e ? void 0 : e.text)
                    ? i(`.method("${t.toUpperCase()}", body)`, 1)
                    : i(`.method("${t.toUpperCase()}", null)`, 1),
                Object.keys(r).forEach((e) => {
                  i(`.addHeader("${e}", "${Eg(r[e])}")`, 1)
                }),
                i(".build();", 1),
                s(),
                i("Response response = client.newCall(request).execute();"),
                l()
              )
            },
          },
          unirest: {
            info: {
              key: "unirest",
              title: "Unirest",
              link: "http://unirest.io/java.html",
              description: "Lightweight HTTP Request Client Library",
            },
            convert: ({ method: e, allHeaders: t, postData: n, fullUrl: r }, a) => {
              const o = { indent: "  ", ...a },
                { join: i, push: s } = new kg({ indent: o.indent })
              return (
                ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(e.toUpperCase())
                  ? s(`HttpResponse<String> response = Unirest.${e.toLowerCase()}("${r}")`)
                  : s(`HttpResponse<String> response = Unirest.customMethod("${e.toUpperCase()}","${r}")`),
                Object.keys(t).forEach((e) => {
                  s(`.header("${e}", "${Eg(t[e])}")`, 1)
                }),
                (null == n ? void 0 : n.text) && s(`.body(${JSON.stringify(n.text)})`, 1),
                s(".asString();", 1),
                i()
              )
            },
          },
        },
      }
    var jg = {}
    Object.defineProperty(jg, "__esModule", { value: !0 }),
      (jg.default = (e) =>
        Object.getOwnPropertySymbols(e).filter((t) => Object.prototype.propertyIsEnumerable.call(e, t)))
    const Ug = jg.default
    const Fg = em((e, t, n) => {
        const r = []
        return (function e(t, n, a) {
          let o
          ;((n = n || {}).indent = n.indent || "\t"),
            (a = a || ""),
            (o =
              void 0 === n.inlineCharacterLimit
                ? { newLine: "\n", newLineOrSpace: "\n", pad: a, indent: a + n.indent }
                : {
                    newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
                    newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
                    pad: "@@__STRINGIFY_OBJECT_PAD__@@",
                    indent: "@@__STRINGIFY_OBJECT_INDENT__@@",
                  })
          const i = (e) => {
            if (void 0 === n.inlineCharacterLimit) return e
            const t = e
              .replace(new RegExp(o.newLine, "g"), "")
              .replace(new RegExp(o.newLineOrSpace, "g"), " ")
              .replace(new RegExp(o.pad + "|" + o.indent, "g"), "")
            return t.length <= n.inlineCharacterLimit
              ? t
              : e
                  .replace(new RegExp(o.newLine + "|" + o.newLineOrSpace, "g"), "\n")
                  .replace(new RegExp(o.pad, "g"), a)
                  .replace(new RegExp(o.indent, "g"), a + n.indent)
          }
          if (-1 !== r.indexOf(t)) return '"[Circular]"'
          if (
            null == t ||
            "number" == typeof t ||
            "boolean" == typeof t ||
            "function" == typeof t ||
            "symbol" == typeof t ||
            (function (e) {
              return "[object RegExp]" === Object.prototype.toString.call(e)
            })(t)
          )
            return String(t)
          if (t instanceof Date) return `new Date('${t.toISOString()}')`
          if (Array.isArray(t)) {
            if (0 === t.length) return "[]"
            r.push(t)
            const s =
              "[" +
              o.newLine +
              t
                .map((r, i) => {
                  const s = t.length - 1 === i ? o.newLine : "," + o.newLineOrSpace
                  let l = e(r, n, a + n.indent)
                  return n.transform && (l = n.transform(t, i, l)), o.indent + l + s
                })
                .join("") +
              o.pad +
              "]"
            return r.pop(), i(s)
          }
          if (
            (function (e) {
              var t = typeof e
              return null !== e && ("object" === t || "function" === t)
            })(t)
          ) {
            let s = Object.keys(t).concat(Ug(t))
            if ((n.filter && (s = s.filter((e) => n.filter(t, e))), 0 === s.length)) return "{}"
            r.push(t)
            const l =
              "{" +
              o.newLine +
              s
                .map((r, i) => {
                  const l = s.length - 1 === i ? o.newLine : "," + o.newLineOrSpace,
                    c = "symbol" == typeof r,
                    d = !c && /^[a-z$_][a-z$_0-9]*$/i.test(r),
                    u = c || d ? r : e(r, n)
                  let p = e(t[r], n, a + n.indent)
                  return n.transform && (p = n.transform(t, r, p)), o.indent + String(u) + ": " + p + l
                })
                .join("") +
              o.pad +
              "}"
            return r.pop(), i(l)
          }
          return (
            (t = String(t).replace(/[\r\n]/g, (e) => ("\n" === e ? "\\n" : "\\r"))),
            !1 === n.singleQuotes ? `"${(t = t.replace(/"/g, '\\"'))}"` : `'${(t = t.replace(/\\?'/g, "\\'"))}'`
          )
        })(e, t, n)
      }),
      zg = {
        info: { key: "javascript", title: "JavaScript", extname: ".js", default: "xhr" },
        clientsById: {
          xhr: {
            info: {
              key: "xhr",
              title: "XMLHttpRequest",
              link: "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",
              description: "W3C Standard API that provides scripted client functionality",
            },
            convert: ({ postData: e, allHeaders: t, method: n, fullUrl: r }, a) => {
              var o
              const i = { indent: "  ", cors: !0, ...a },
                { blank: s, push: l, join: c } = new kg({ indent: i.indent })
              switch (null == e ? void 0 : e.mimeType) {
                case "application/json":
                  l(`const data = JSON.stringify(${Fg(e.jsonObj, { indent: i.indent })});`), s()
                  break
                case "multipart/form-data":
                  if (!e.params) break
                  if (
                    (l("const data = new FormData();"),
                    e.params.forEach((e) => {
                      l(`data.append('${e.name}', '${e.value || e.fileName || ""}');`)
                    }),
                    vg(t, "content-type") &&
                      (null === (o = bg(t, "content-type")) || void 0 === o ? void 0 : o.includes("boundary")))
                  ) {
                    const e = gg(t, "content-type")
                    e && delete t[e]
                  }
                  s()
                  break
                default:
                  l(`const data = ${(null == e ? void 0 : e.text) ? `'${e.text}'` : "null"};`), s()
              }
              return (
                l("const xhr = new XMLHttpRequest();"),
                i.cors && l("xhr.withCredentials = true;"),
                s(),
                l("xhr.addEventListener('readystatechange', function () {"),
                l("if (this.readyState === this.DONE) {", 1),
                l("console.log(this.responseText);", 2),
                l("}", 1),
                l("});"),
                s(),
                l(`xhr.open('${n}', '${r}');`),
                Object.keys(t).forEach((e) => {
                  l(`xhr.setRequestHeader('${e}', '${Sg(t[e])}');`)
                }),
                s(),
                l("xhr.send(data);"),
                c()
              )
            },
          },
          axios: {
            info: {
              key: "axios",
              title: "Axios",
              link: "https://github.com/axios/axios",
              description: "Promise based HTTP client for the browser and node.js",
            },
            convert: ({ allHeaders: e, method: t, url: n, queryObj: r, postData: a }, o) => {
              const i = { indent: "  ", ...o },
                { blank: s, push: l, join: c, addPostProcessor: d } = new kg({ indent: i.indent })
              l("import axios from 'axios';"), s()
              const u = { method: t, url: n }
              switch (
                (Object.keys(r).length && (u.params = r),
                Object.keys(e).length && (u.headers = e),
                null == a ? void 0 : a.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  a.params &&
                    (l("const encodedParams = new URLSearchParams();"),
                    a.params.forEach((e) => {
                      l(`encodedParams.set('${e.name}', '${e.value}');`)
                    }),
                    s(),
                    (u.data = "encodedParams,"),
                    d((e) => e.replace(/'encodedParams,'/, "encodedParams,")))
                  break
                case "application/json":
                  a.jsonObj && (u.data = a.jsonObj)
                  break
                case "multipart/form-data":
                  if (!a.params) break
                  l("const form = new FormData();"),
                    a.params.forEach((e) => {
                      l(`form.append('${e.name}', '${e.value || e.fileName || ""}');`)
                    }),
                    s(),
                    (u.data = "[form]")
                  break
                default:
                  ;(null == a ? void 0 : a.text) && (u.data = a.text)
              }
              const p = Fg(u, { indent: "  ", inlineCharacterLimit: 80 }).replace('"[form]"', "form")
              return (
                l(`const options = ${p};`),
                s(),
                l("try {"),
                l("const { data } = await axios.request(options);", 1),
                l("console.log(data);", 1),
                l("} catch (error) {"),
                l("console.error(error);", 1),
                l("}"),
                c()
              )
            },
          },
          fetch: {
            info: {
              key: "fetch",
              title: "fetch",
              link: "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
              description: "Perform asynchronous HTTP requests with the Fetch API",
            },
            convert: ({ method: e, allHeaders: t, postData: n, fullUrl: r }, a) => {
              const o = { indent: "  ", credentials: null, ...a },
                { blank: i, join: s, push: l } = new kg({ indent: o.indent }),
                c = { method: e }
              switch (
                (Object.keys(t).length && (c.headers = t),
                null !== o.credentials && (c.credentials = o.credentials),
                l(`const url = '${r}';`),
                null == n ? void 0 : n.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  c.body = n.paramsObj ? n.paramsObj : n.text
                  break
                case "application/json":
                  c.body = JSON.stringify(n.jsonObj)
                  break
                case "multipart/form-data":
                  if (!n.params) break
                  const e = gg(t, "content-type")
                  e && delete t[e],
                    l("const form = new FormData();"),
                    n.params.forEach((e) => {
                      l(`form.append('${e.name}', '${e.value || e.fileName || ""}');`)
                    }),
                    i()
                  break
                default:
                  ;(null == n ? void 0 : n.text) && (c.body = n.text)
              }
              return (
                c.headers && !Object.keys(c.headers).length && delete c.headers,
                l(
                  `const options = ${Fg(c, { indent: o.indent, inlineCharacterLimit: 80, transform: (e, t, r) => ("body" === t && n && "application/x-www-form-urlencoded" === n.mimeType ? `new URLSearchParams(${r})` : r) })};`,
                ),
                i(),
                (null == n ? void 0 : n.params) &&
                  "multipart/form-data" === n.mimeType &&
                  (l("options.body = form;"), i()),
                l("try {"),
                l("const response = await fetch(url, options);", 1),
                l("const data = await response.json();", 1),
                l("console.log(data);", 1),
                l("} catch (error) {"),
                l("console.error(error);", 1),
                l("}"),
                s()
              )
            },
          },
          jquery: {
            info: {
              key: "jquery",
              title: "jQuery",
              link: "http://api.jquery.com/jquery.ajax/",
              description: "Perform an asynchronous HTTP (Ajax) requests with jQuery",
            },
            convert: ({ fullUrl: e, method: t, allHeaders: n, postData: r }, a) => {
              var o
              const i = { indent: "  ", ...a },
                { blank: s, push: l, join: c } = new kg({ indent: i.indent }),
                d = { async: !0, crossDomain: !0, url: e, method: t, headers: n }
              switch (null == r ? void 0 : r.mimeType) {
                case "application/x-www-form-urlencoded":
                  d.data = r.paramsObj ? r.paramsObj : r.text
                  break
                case "application/json":
                  ;(d.processData = !1), (d.data = r.text)
                  break
                case "multipart/form-data":
                  if (!r.params) break
                  if (
                    (l("const form = new FormData();"),
                    r.params.forEach((e) => {
                      l(`form.append('${e.name}', '${e.value || e.fileName || ""}');`)
                    }),
                    (d.processData = !1),
                    (d.contentType = !1),
                    (d.mimeType = "multipart/form-data"),
                    (d.data = "[form]"),
                    vg(n, "content-type") &&
                      (null === (o = bg(n, "content-type")) || void 0 === o ? void 0 : o.includes("boundary")))
                  ) {
                    const e = gg(n, "content-type")
                    e && delete d.headers[e]
                  }
                  s()
                  break
                default:
                  ;(null == r ? void 0 : r.text) && (d.data = r.text)
              }
              const u = Fg(d, { indent: i.indent }).replace("'[form]'", "form")
              return (
                l(`const settings = ${u};`),
                s(),
                l("$.ajax(settings).done(function (response) {"),
                l("console.log(response);", 1),
                l("});"),
                c()
              )
            },
          },
        },
      },
      qg = {
        info: { key: "kotlin", title: "Kotlin", extname: ".kt", default: "okhttp" },
        clientsById: {
          okhttp: {
            info: {
              key: "okhttp",
              title: "OkHttp",
              link: "http://square.github.io/okhttp/",
              description: "An HTTP Request Client Library",
            },
            convert: ({ postData: e, fullUrl: t, method: n, allHeaders: r }, a) => {
              const o = { indent: "  ", ...a },
                { blank: i, join: s, push: l } = new kg({ indent: o.indent })
              return (
                l("val client = OkHttpClient()"),
                i(),
                (null == e ? void 0 : e.text) &&
                  (e.boundary
                    ? l(`val mediaType = MediaType.parse("${e.mimeType}; boundary=${e.boundary}")`)
                    : l(`val mediaType = MediaType.parse("${e.mimeType}")`),
                  l(`val body = RequestBody.create(mediaType, ${JSON.stringify(e.text)})`)),
                l("val request = Request.Builder()"),
                l(`.url("${t}")`, 1),
                ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"].includes(n.toUpperCase())
                  ? ["POST", "PUT", "DELETE", "PATCH"].includes(n.toUpperCase())
                    ? (null == e ? void 0 : e.text)
                      ? l(`.${n.toLowerCase()}(body)`, 1)
                      : l(`.${n.toLowerCase()}(null)`, 1)
                    : l(`.${n.toLowerCase()}()`, 1)
                  : (null == e ? void 0 : e.text)
                    ? l(`.method("${n.toUpperCase()}", body)`, 1)
                    : l(`.method("${n.toUpperCase()}", null)`, 1),
                Object.keys(r).forEach((e) => {
                  l(`.addHeader("${e}", "${Eg(r[e])}")`, 1)
                }),
                l(".build()", 1),
                i(),
                l("val response = client.newCall(request).execute()"),
                s()
              )
            },
          },
        },
      },
      Zg = {
        info: { key: "node", title: "Node.js", extname: ".js", default: "native" },
        clientsById: {
          native: {
            info: {
              key: "native",
              title: "HTTP",
              link: "http://nodejs.org/api/http.html#http_http_request_options_callback",
              description: "Node.js native HTTP interface",
            },
            convert: ({ uriObj: e, method: t, allHeaders: n, postData: r }, a = {}) => {
              const { indent: o = "  ", insecureSkipVerify: i = !1 } = a,
                { blank: s, join: l, push: c, unshift: d } = new kg({ indent: o }),
                u = {
                  method: t,
                  hostname: e.hostname,
                  port: "" === e.port ? null : e.port,
                  path: e.path,
                  headers: n,
                  ...(i ? { rejectUnauthorized: !1 } : {}),
                }
              switch (
                (c(`const http = require('${e.protocol.replace(":", "")}');`),
                s(),
                c(`const options = ${Fg(u, { indent: o })};`),
                s(),
                c("const req = http.request(options, function (res) {"),
                c("const chunks = [];", 1),
                s(),
                c("res.on('data', function (chunk) {", 1),
                c("chunks.push(chunk);", 2),
                c("});", 1),
                s(),
                c("res.on('end', function () {", 1),
                c("const body = Buffer.concat(chunks);", 2),
                c("console.log(body.toString());", 2),
                c("});", 1),
                c("});"),
                s(),
                null == r ? void 0 : r.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  r.paramsObj &&
                    (d("const qs = require('querystring');"),
                    c(`req.write(qs.stringify(${Fg(r.paramsObj, { indent: "  ", inlineCharacterLimit: 80 })}));`))
                  break
                case "application/json":
                  r.jsonObj &&
                    c(`req.write(JSON.stringify(${Fg(r.jsonObj, { indent: "  ", inlineCharacterLimit: 80 })}));`)
                  break
                default:
                  ;(null == r ? void 0 : r.text) && c(`req.write(${Fg(r.text, { indent: o })});`)
              }
              return c("req.end();"), l()
            },
          },
          request: {
            info: {
              key: "request",
              title: "Request",
              link: "https://github.com/request/request",
              description: "Simplified HTTP request client",
            },
            convert: ({ method: e, url: t, queryObj: n, postData: r, headersObj: a, cookies: o }, i) => {
              const s = { indent: "  ", ...i }
              let l = !1
              const { push: c, blank: d, join: u, unshift: p } = new kg({ indent: s.indent })
              c("const request = require('request');"), d()
              const h = { method: e, url: t }
              switch (
                (Object.keys(n).length && (h.qs = n),
                Object.keys(a).length && (h.headers = a),
                null == r ? void 0 : r.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  h.form = r.paramsObj
                  break
                case "application/json":
                  r.jsonObj && ((h.body = r.jsonObj), (h.json = !0))
                  break
                case "multipart/form-data":
                  if (!r.params) break
                  ;(h.formData = {}),
                    r.params.forEach((e) => {
                      if (!e.fileName && !e.fileName && !e.contentType) return void (h.formData[e.name] = e.value)
                      let t = {}
                      e.fileName
                        ? ((l = !0),
                          (t = {
                            value: `fs.createReadStream(${e.fileName})`,
                            options: { filename: e.fileName, contentType: e.contentType ? e.contentType : null },
                          }))
                        : e.value && (t.value = e.value),
                        (h.formData[e.name] = t)
                    })
                  break
                default:
                  ;(null == r ? void 0 : r.text) && (h.body = r.text)
              }
              return (
                o.length &&
                  ((h.jar = "JAR"),
                  c("const jar = request.jar();"),
                  o.forEach((e) => {
                    c(
                      `jar.setCookie(request.cookie('${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}'), '${t}');`,
                    )
                  }),
                  d()),
                l && p("const fs = require('fs');"),
                c(`const options = ${Fg(h, { indent: "  ", inlineCharacterLimit: 80 })};`),
                d(),
                c("request(options, function (error, response, body) {"),
                c("if (error) throw new Error(error);", 1),
                d(),
                c("console.log(body);", 1),
                c("});"),
                u()
                  .replace("'JAR'", "jar")
                  .replace(/'fs\.createReadStream\((.*)\)'/, "fs.createReadStream('$1')")
              )
            },
          },
          unirest: {
            info: {
              key: "unirest",
              title: "Unirest",
              link: "http://unirest.io/nodejs.html",
              description: "Lightweight HTTP Request Client Library",
            },
            convert: ({ method: e, url: t, cookies: n, queryObj: r, postData: a, headersObj: o }, i) => {
              const s = { indent: "  ", ...i }
              let l = !1
              const { addPostProcessor: c, blank: d, join: u, push: p, unshift: h } = new kg({ indent: s.indent })
              switch (
                (p("const unirest = require('unirest');"),
                d(),
                p(`const req = unirest('${e}', '${t}');`),
                d(),
                n.length &&
                  (p("const CookieJar = unirest.jar();"),
                  n.forEach((e) => {
                    p(`CookieJar.add('${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}', '${t}');`)
                  }),
                  p("req.jar(CookieJar);"),
                  d()),
                Object.keys(r).length && (p(`req.query(${Fg(r, { indent: s.indent })});`), d()),
                Object.keys(o).length && (p(`req.headers(${Fg(o, { indent: s.indent })});`), d()),
                null == a ? void 0 : a.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  a.paramsObj && (p(`req.form(${Fg(a.paramsObj, { indent: s.indent })});`), d())
                  break
                case "application/json":
                  a.jsonObj && (p("req.type('json');"), p(`req.send(${Fg(a.jsonObj, { indent: s.indent })});`), d())
                  break
                case "multipart/form-data": {
                  if (!a.params) break
                  const e = []
                  a.params.forEach((t) => {
                    const n = {}
                    t.fileName && !t.value
                      ? ((l = !0),
                        (n.body = `fs.createReadStream('${t.fileName}')`),
                        c((e) => e.replace(/'fs\.createReadStream\(\\'(.+)\\'\)'/, "fs.createReadStream('$1')")))
                      : t.value && (n.body = t.value),
                      n.body && (t.contentType && (n["content-type"] = t.contentType), e.push(n))
                  }),
                    p(`req.multipart(${Fg(e, { indent: s.indent })});`),
                    d()
                  break
                }
                default:
                  ;(null == a ? void 0 : a.text) && (p(`req.send(${Fg(a.text, { indent: s.indent })});`), d())
              }
              return (
                l && h("const fs = require('fs');"),
                p("req.end(function (res) {"),
                p("if (res.error) throw new Error(res.error);", 1),
                d(),
                p("console.log(res.body);", 1),
                p("});"),
                u()
              )
            },
          },
          axios: {
            info: {
              key: "axios",
              title: "Axios",
              link: "https://github.com/axios/axios",
              description: "Promise based HTTP client for the browser and node.js",
            },
            convert: ({ method: e, url: t, queryObj: n, allHeaders: r, postData: a }, o) => {
              const i = { indent: "  ", ...o },
                { blank: s, join: l, push: c, addPostProcessor: d } = new kg({ indent: i.indent })
              c("const axios = require('axios').default;")
              const u = { method: e, url: t }
              switch (
                (Object.keys(n).length && (u.params = n),
                Object.keys(r).length && (u.headers = r),
                null == a ? void 0 : a.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  a.params &&
                    (c("const { URLSearchParams } = require('url');"),
                    s(),
                    c("const encodedParams = new URLSearchParams();"),
                    a.params.forEach((e) => {
                      c(`encodedParams.set('${e.name}', '${e.value}');`)
                    }),
                    s(),
                    (u.data = "encodedParams,"),
                    d((e) => e.replace(/'encodedParams,'/, "encodedParams,")))
                  break
                case "application/json":
                  s(), a.jsonObj && (u.data = a.jsonObj)
                  break
                default:
                  s(), (null == a ? void 0 : a.text) && (u.data = a.text)
              }
              const p = Fg(u, { indent: "  ", inlineCharacterLimit: 80 })
              return (
                c(`const options = ${p};`),
                s(),
                c("try {"),
                c("const { data } = await axios.request(options);", 1),
                c("console.log(data);", 1),
                c("} catch (error) {"),
                c("console.error(error);", 1),
                c("}"),
                l()
              )
            },
          },
          fetch: {
            info: {
              key: "fetch",
              title: "Fetch",
              link: "https://github.com/bitinn/node-fetch",
              description: "Simplified HTTP node-fetch client",
            },
            convert: ({ method: e, fullUrl: t, postData: n, headersObj: r, cookies: a }, o) => {
              var i
              const s = { indent: "  ", ...o }
              let l = !1
              const { blank: c, push: d, join: u, unshift: p } = new kg({ indent: s.indent })
              d("const fetch = require('node-fetch');"), c()
              const h = { method: e }
              switch ((Object.keys(r).length && (h.headers = r), null == n ? void 0 : n.mimeType)) {
                case "application/x-www-form-urlencoded":
                  p("const { URLSearchParams } = require('url');"),
                    d("const encodedParams = new URLSearchParams();"),
                    null === (i = n.params) ||
                      void 0 === i ||
                      i.forEach((e) => {
                        d(`encodedParams.set('${e.name}', '${e.value}');`)
                      }),
                    c(),
                    (h.body = "encodedParams")
                  break
                case "application/json":
                  n.jsonObj && (h.body = JSON.stringify(n.jsonObj))
                  break
                case "multipart/form-data":
                  if (!n.params) break
                  const e = gg(r, "content-type")
                  e && delete r[e],
                    p("const FormData = require('form-data');"),
                    d("const formData = new FormData();"),
                    n.params.forEach((e) => {
                      e.fileName || e.fileName || e.contentType
                        ? e.fileName &&
                          ((l = !0), d(`formData.append('${e.name}', fs.createReadStream('${e.fileName}'));`))
                        : d(`formData.append('${e.name}', '${e.value}');`)
                    }),
                    c()
                  break
                default:
                  ;(null == n ? void 0 : n.text) && (h.body = n.text)
              }
              if (a.length) {
                const e = a.map((e) => `${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}`).join("; ")
                h.headers || (h.headers = {}), (h.headers.cookie = e)
              }
              d(`const url = '${t}';`), h.headers && !Object.keys(h.headers).length && delete h.headers
              const f = Fg(h, { indent: "  ", inlineCharacterLimit: 80 })
              return (
                d(`const options = ${f};`),
                l && p("const fs = require('fs');"),
                (null == n ? void 0 : n.params) &&
                  "multipart/form-data" === n.mimeType &&
                  d("options.body = formData;"),
                c(),
                d("try {"),
                d("const response = await fetch(url, options);", 1),
                d("const data = await response.json();", 1),
                d("console.log(data);", 1),
                d("} catch (error) {"),
                d("console.error(error);", 1),
                d("}"),
                u()
                  .replace(/'encodedParams'/, "encodedParams")
                  .replace(/"fs\.createReadStream\(\\"(.+)\\"\)"/, 'fs.createReadStream("$1")')
              )
            },
          },
        },
      },
      Hg = (e, t, n, r) => {
        const a = `${e} *${t} = `
        return `${a}${Vg(n, r ? a.length : void 0)};`
      },
      Vg = (e, t) => {
        const n = void 0 === t ? ", " : `,\n   ${" ".repeat(t)}`
        switch (Object.prototype.toString.call(e)) {
          case "[object Number]":
            return `@${e}`
          case "[object Array]":
            return `@[ ${e.map((e) => Vg(e)).join(n)} ]`
          case "[object Object]": {
            const t = []
            for (const n in e) t.push(`@"${n}": ${Vg(e[n])}`)
            return `@{ ${t.join(n)} }`
          }
          case "[object Boolean]":
            return e ? "@YES" : "@NO"
          default:
            return null == e ? "" : `@"${e.toString().replace(/"/g, '\\"')}"`
        }
      },
      Wg = {
        info: { key: "objc", title: "Objective-C", extname: ".m", default: "nsurlsession" },
        clientsById: {
          nsurlsession: {
            info: {
              key: "nsurlsession",
              title: "NSURLSession",
              link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
              description: "Foundation's NSURLSession request",
            },
            convert: ({ allHeaders: e, postData: t, method: n, fullUrl: r }, a) => {
              var o
              const i = { indent: "    ", pretty: !0, timeout: 10, ...a },
                { push: s, join: l, blank: c } = new kg({ indent: i.indent }),
                d = { hasHeaders: !1, hasBody: !1 }
              if (
                (s("#import <Foundation/Foundation.h>"),
                Object.keys(e).length && ((d.hasHeaders = !0), c(), s(Hg("NSDictionary", "headers", e, i.pretty))),
                t && (t.text || t.jsonObj || t.params))
              )
                switch (((d.hasBody = !0), t.mimeType)) {
                  case "application/x-www-form-urlencoded":
                    if (null === (o = t.params) || void 0 === o ? void 0 : o.length) {
                      c()
                      const [e, ...n] = t.params
                      s(
                        `NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"${e.name}=${e.value}" dataUsingEncoding:NSUTF8StringEncoding]];`,
                      ),
                        n.forEach(({ name: e, value: t }) => {
                          s(`[postData appendData:[@"&${e}=${t}" dataUsingEncoding:NSUTF8StringEncoding]];`)
                        })
                    } else d.hasBody = !1
                    break
                  case "application/json":
                    t.jsonObj &&
                      (s(Hg("NSDictionary", "parameters", t.jsonObj, i.pretty)),
                      c(),
                      s("NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];"))
                    break
                  case "multipart/form-data":
                    s(Hg("NSArray", "parameters", t.params || [], i.pretty)),
                      s(`NSString *boundary = @"${t.boundary}";`),
                      c(),
                      s("NSError *error;"),
                      s("NSMutableString *body = [NSMutableString string];"),
                      s("for (NSDictionary *param in parameters) {"),
                      s('[body appendFormat:@"--%@\\r\\n", boundary];', 1),
                      s('if (param[@"fileName"]) {', 1),
                      s(
                        '[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"; filename=\\"%@\\"\\r\\n", param[@"name"], param[@"fileName"]];',
                        2,
                      ),
                      s('[body appendFormat:@"Content-Type: %@\\r\\n\\r\\n", param[@"contentType"]];', 2),
                      s(
                        '[body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"] encoding:NSUTF8StringEncoding error:&error]];',
                        2,
                      ),
                      s("if (error) {", 2),
                      s('NSLog(@"%@", error);', 3),
                      s("}", 2),
                      s("} else {", 1),
                      s(
                        '[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"\\r\\n\\r\\n", param[@"name"]];',
                        2,
                      ),
                      s('[body appendFormat:@"%@", param[@"value"]];', 2),
                      s("}", 1),
                      s("}"),
                      s('[body appendFormat:@"\\r\\n--%@--\\r\\n", boundary];'),
                      s("NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];")
                    break
                  default:
                    c(),
                      s(
                        `NSData *postData = [[NSData alloc] initWithData:[@"${t.text}" dataUsingEncoding:NSUTF8StringEncoding]];`,
                      )
                }
              return (
                c(),
                s(`NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"${r}"]`),
                s(
                  "                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy",
                ),
                s(`                                                   timeoutInterval:${i.timeout.toFixed(1)}];`),
                s(`[request setHTTPMethod:@"${n}"];`),
                d.hasHeaders && s("[request setAllHTTPHeaderFields:headers];"),
                d.hasBody && s("[request setHTTPBody:postData];"),
                c(),
                s("NSURLSession *session = [NSURLSession sharedSession];"),
                s("NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request"),
                s(
                  "                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {",
                ),
                s("                                            if (error) {", 1),
                s('                                            NSLog(@"%@", error);', 2),
                s("                                            } else {", 1),
                s(
                  "                                            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;",
                  2,
                ),
                s('                                            NSLog(@"%@", httpResponse);', 2),
                s("                                            }", 1),
                s("                                            }];"),
                s("[dataTask resume];"),
                l()
              )
            },
          },
        },
      },
      Xg = {
        info: { key: "ocaml", title: "OCaml", extname: ".ml", default: "cohttp" },
        clientsById: {
          cohttp: {
            info: {
              key: "cohttp",
              title: "CoHTTP",
              link: "https://github.com/mirage/ocaml-cohttp",
              description: "Cohttp is a very lightweight HTTP server using Lwt or Async for OCaml",
            },
            convert: ({ fullUrl: e, allHeaders: t, postData: n, method: r }, a) => {
              const o = { indent: "  ", ...a },
                { push: i, blank: s, join: l } = new kg({ indent: o.indent })
              i("open Cohttp_lwt_unix"), i("open Cohttp"), i("open Lwt"), s(), i(`let uri = Uri.of_string "${e}" in`)
              const c = Object.keys(t)
              1 === c.length
                ? i(`let headers = Header.add (Header.init ()) "${c[0]}" "${Eg(t[c[0]])}" in`)
                : c.length > 1 &&
                  (i("let headers = Header.add_list (Header.init ()) ["),
                  c.forEach((e) => {
                    i(`("${e}", "${Eg(t[e])}");`, 1)
                  }),
                  i("] in")),
                (null == n ? void 0 : n.text) && i(`let body = Cohttp_lwt_body.of_string ${JSON.stringify(n.text)} in`),
                s()
              const d = c.length ? "~headers " : "",
                u = (null == n ? void 0 : n.text) ? "~body " : "",
                p = ["get", "post", "head", "delete", "patch", "put", "options"].includes(r.toLowerCase())
                  ? `\`${r.toUpperCase()}`
                  : `(Code.method_of_string "${r}")`
              return (
                i(`Client.call ${d}${u}${p} uri`),
                i(">>= fun (res, body_stream) ->"),
                i("(* Do stuff with the result *)", 1),
                l()
              )
            },
          },
        },
      },
      Yg = (e, t, n) => {
        switch (((n = n || ""), (t = t || ""), Object.prototype.toString.call(e))) {
          case "[object Null]":
          case "[object Undefined]":
          default:
            return "null"
          case "[object String]":
            return `'${_g(e, { delimiter: "'", escapeNewlines: !1 })}'`
          case "[object Number]":
            return e.toString()
          case "[object Array]": {
            const r = e.map((e) => Yg(e, `${t}${t}`, t)).join(`,\n${t}`)
            return `[\n${t}${r}\n${n}]`
          }
          case "[object Object]": {
            const r = []
            for (const n in e)
              Object.prototype.hasOwnProperty.call(e, n) && r.push(`${Yg(n, t)} => ${Yg(e[n], `${t}${t}`, t)}`)
            return `[\n${t}${r.join(`,\n${t}`)}\n${n}]`
          }
        }
      },
      Gg = [
        "ACL",
        "BASELINE_CONTROL",
        "CHECKIN",
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "DELETE",
        "GET",
        "HEAD",
        "LABEL",
        "LOCK",
        "MERGE",
        "MKACTIVITY",
        "MKCOL",
        "MKWORKSPACE",
        "MOVE",
        "OPTIONS",
        "POST",
        "PROPFIND",
        "PROPPATCH",
        "PUT",
        "REPORT",
        "TRACE",
        "UNCHECKOUT",
        "UNLOCK",
        "UPDATE",
        "VERSION_CONTROL",
      ],
      Kg = {
        info: { key: "php", title: "PHP", extname: ".php", default: "curl" },
        clientsById: {
          curl: {
            info: {
              key: "curl",
              title: "cURL",
              link: "http://php.net/manual/en/book.curl.php",
              description: "PHP with ext-curl",
            },
            convert: (
              { uriObj: e, postData: t, fullUrl: n, method: r, httpVersion: a, cookies: o, headersObj: i },
              s = {},
            ) => {
              const {
                  closingTag: l = !1,
                  indent: c = "  ",
                  maxRedirects: d = 10,
                  namedErrors: u = !1,
                  noTags: p = !1,
                  shortTags: h = !1,
                  timeout: f = 30,
                } = s,
                { push: m, blank: g, join: b } = new kg({ indent: c })
              p || (m(h ? "<?" : "<?php"), g()), m("$curl = curl_init();"), g()
              const v = [
                { escape: !0, name: "CURLOPT_PORT", value: "" === e.port ? null : e.port },
                { escape: !0, name: "CURLOPT_URL", value: n },
                { escape: !1, name: "CURLOPT_RETURNTRANSFER", value: "true" },
                { escape: !0, name: "CURLOPT_ENCODING", value: "" },
                { escape: !1, name: "CURLOPT_MAXREDIRS", value: d },
                { escape: !1, name: "CURLOPT_TIMEOUT", value: f },
                {
                  escape: !1,
                  name: "CURLOPT_HTTP_VERSION",
                  value: "HTTP/1.0" === a ? "CURL_HTTP_VERSION_1_0" : "CURL_HTTP_VERSION_1_1",
                },
                { escape: !0, name: "CURLOPT_CUSTOMREQUEST", value: r },
                {
                  escape: !(null == t ? void 0 : t.jsonObj),
                  name: "CURLOPT_POSTFIELDS",
                  value: t ? (t.jsonObj ? `json_encode(${Yg(t.jsonObj, c.repeat(2), c)})` : t.text) : void 0,
                },
              ]
              m("curl_setopt_array($curl, [")
              const y = new kg({ indent: c, join: `\n${c}` })
              v.forEach(({ value: e, name: t, escape: n }) => {
                null != e && y.push(`${t} => ${n ? JSON.stringify(e) : e},`)
              })
              const O = o.map((e) => `${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}`)
              O.length && y.push(`CURLOPT_COOKIE => "${O.join("; ")}",`)
              const w = Object.keys(i)
                .sort()
                .map((e) => `"${e}: ${Eg(i[e])}"`)
              return (
                w.length && (y.push("CURLOPT_HTTPHEADER => ["), y.push(w.join(`,\n${c}${c}`), 1), y.push("],")),
                m(y.join(), 1),
                m("]);"),
                g(),
                m("$response = curl_exec($curl);"),
                m("$err = curl_error($curl);"),
                g(),
                m("curl_close($curl);"),
                g(),
                m("if ($err) {"),
                m(
                  u ? 'echo array_flip(get_defined_constants(true)["curl"])[$err];' : 'echo "cURL Error #:" . $err;',
                  1,
                ),
                m("} else {"),
                m("echo $response;", 1),
                m("}"),
                !p && l && (g(), m("?>")),
                b()
              )
            },
          },
          guzzle: {
            info: {
              key: "guzzle",
              title: "Guzzle",
              link: "http://docs.guzzlephp.org/en/stable/",
              description: "PHP with Guzzle",
            },
            convert: ({ postData: e, fullUrl: t, method: n, cookies: r, headersObj: a }, o) => {
              var i
              const s = { closingTag: !1, indent: "  ", noTags: !1, shortTags: !1, ...o },
                { push: l, blank: c, join: d } = new kg({ indent: s.indent }),
                { code: u, push: p, join: h } = new kg({ indent: s.indent })
              switch ((s.noTags || (l(s.shortTags ? "<?" : "<?php"), c()), null == e ? void 0 : e.mimeType)) {
                case "application/x-www-form-urlencoded":
                  p(`'form_params' => ${Yg(e.paramsObj, s.indent + s.indent, s.indent)},`, 1)
                  break
                case "multipart/form-data": {
                  const t = []
                  if (
                    (e.params &&
                      e.params.forEach(function (e) {
                        if (e.fileName) {
                          const n = { name: e.name, filename: e.fileName, contents: e.value }
                          e.contentType && (n.headers = { "Content-Type": e.contentType }), t.push(n)
                        } else e.value && t.push({ name: e.name, contents: e.value })
                      }),
                    t.length &&
                      (p(`'multipart' => ${Yg(t, s.indent + s.indent, s.indent)}`, 1),
                      vg(a, "content-type") &&
                        (null === (i = bg(a, "content-type")) || void 0 === i ? void 0 : i.indexOf("boundary"))))
                  ) {
                    const e = gg(a, "content-type")
                    e && delete a[e]
                  }
                  break
                }
                default:
                  ;(null == e ? void 0 : e.text) && p(`'body' => ${Yg(e.text)},`, 1)
              }
              const f = Object.keys(a)
                  .sort()
                  .map(function (e) {
                    return `${s.indent}${s.indent}'${e}' => '${Sg(a[e])}',`
                  }),
                m = r.map((e) => `${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}`).join("; ")
              return (
                m.length && f.push(`${s.indent}${s.indent}'cookie' => '${Sg(m)}',`),
                f.length && (p("'headers' => [", 1), p(f.join("\n")), p("],", 1)),
                l("$client = new \\GuzzleHttp\\Client();"),
                c(),
                u.length
                  ? (l(`$response = $client->request('${n}', '${t}', [`), l(h()), l("]);"))
                  : l(`$response = $client->request('${n}', '${t}');`),
                c(),
                l("echo $response->getBody();"),
                !s.noTags && s.closingTag && (c(), l("?>")),
                d()
              )
            },
          },
          http1: {
            info: {
              key: "http1",
              title: "HTTP v1",
              link: "http://php.net/manual/en/book.http.php",
              description: "PHP with pecl/http v1",
            },
            convert: ({ method: e, url: t, postData: n, queryObj: r, headersObj: a, cookiesObj: o }, i = {}) => {
              const { closingTag: s = !1, indent: l = "  ", noTags: c = !1, shortTags: d = !1 } = i,
                { push: u, blank: p, join: h } = new kg({ indent: l })
              switch (
                (c || (u(d ? "<?" : "<?php"), p()),
                Gg.includes(e.toUpperCase()) || u(`HttpRequest::methodRegister('${e}');`),
                u("$request = new HttpRequest();"),
                u(`$request->setUrl(${Yg(t)});`),
                Gg.includes(e.toUpperCase())
                  ? u(`$request->setMethod(HTTP_METH_${e.toUpperCase()});`)
                  : u(`$request->setMethod(HttpRequest::HTTP_METH_${e.toUpperCase()});`),
                p(),
                Object.keys(r).length && (u(`$request->setQueryData(${Yg(r, l)});`), p()),
                Object.keys(a).length && (u(`$request->setHeaders(${Yg(a, l)});`), p()),
                Object.keys(o).length && (u(`$request->setCookies(${Yg(o, l)});`), p()),
                null == n ? void 0 : n.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  u(`$request->setContentType(${Yg(n.mimeType)});`),
                    u(`$request->setPostFields(${Yg(n.paramsObj, l)});`),
                    p()
                  break
                case "application/json":
                  u(`$request->setContentType(${Yg(n.mimeType)});`),
                    u(`$request->setBody(json_encode(${Yg(n.jsonObj, l)}));`),
                    p()
                  break
                default:
                  ;(null == n ? void 0 : n.text) && (u(`$request->setBody(${Yg(n.text)});`), p())
              }
              return (
                u("try {"),
                u("$response = $request->send();", 1),
                p(),
                u("echo $response->getBody();", 1),
                u("} catch (HttpException $ex) {"),
                u("echo $ex;", 1),
                u("}"),
                !c && s && (p(), u("?>")),
                h()
              )
            },
          },
          http2: {
            info: {
              key: "http2",
              title: "HTTP v2",
              link: "http://devel-m6w6.rhcloud.com/mdref/http",
              description: "PHP with pecl/http v2",
            },
            convert: ({ postData: e, headersObj: t, method: n, queryObj: r, cookiesObj: a, url: o }, i = {}) => {
              var s
              const { closingTag: l = !1, indent: c = "  ", noTags: d = !1, shortTags: u = !1 } = i,
                { push: p, blank: h, join: f } = new kg({ indent: c })
              let m = !1
              switch (
                (d || (p(u ? "<?" : "<?php"), h()),
                p("$client = new http\\Client;"),
                p("$request = new http\\Client\\Request;"),
                h(),
                null == e ? void 0 : e.mimeType)
              ) {
                case "application/x-www-form-urlencoded":
                  p("$body = new http\\Message\\Body;"),
                    p(`$body->append(new http\\QueryString(${Yg(e.paramsObj, c)}));`),
                    h(),
                    (m = !0)
                  break
                case "multipart/form-data": {
                  if (!e.params) break
                  const n = [],
                    r = {}
                  e.params.forEach(({ name: e, fileName: t, value: a, contentType: o }) => {
                    t ? n.push({ name: e, type: o, file: t, data: a }) : a && (r[e] = a)
                  })
                  const a = Object.keys(r).length ? Yg(r, c) : "null",
                    o = n.length ? Yg(n, c) : "null"
                  if (
                    (p("$body = new http\\Message\\Body;"),
                    p(`$body->addForm(${a}, ${o});`),
                    vg(t, "content-type") &&
                      (null === (s = bg(t, "content-type")) || void 0 === s ? void 0 : s.indexOf("boundary")))
                  ) {
                    const e = gg(t, "content-type")
                    e && delete t[e]
                  }
                  h(), (m = !0)
                  break
                }
                case "application/json":
                  p("$body = new http\\Message\\Body;"), p(`$body->append(json_encode(${Yg(e.jsonObj, c)}));`), (m = !0)
                  break
                default:
                  ;(null == e ? void 0 : e.text) &&
                    (p("$body = new http\\Message\\Body;"), p(`$body->append(${Yg(e.text)});`), h(), (m = !0))
              }
              return (
                p(`$request->setRequestUrl(${Yg(o)});`),
                p(`$request->setRequestMethod(${Yg(n)});`),
                m && (p("$request->setBody($body);"), h()),
                Object.keys(r).length && (p(`$request->setQuery(new http\\QueryString(${Yg(r, c)}));`), h()),
                Object.keys(t).length && (p(`$request->setHeaders(${Yg(t, c)});`), h()),
                Object.keys(a).length && (h(), p(`$client->setCookies(${Yg(a, c)});`), h()),
                p("$client->enqueue($request)->send();"),
                p("$response = $client->getResponse();"),
                h(),
                p("echo $response->getBody();"),
                !d && l && (h(), p("?>")),
                f()
              )
            },
          },
        },
      },
      Jg =
        (e) =>
        ({ method: t, headersObj: n, cookies: r, uriObj: a, fullUrl: o, postData: i, allHeaders: s }) => {
          const { push: l, join: c } = new kg()
          if (!["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(t.toUpperCase()))
            return "Method not supported"
          const d = [],
            u = Object.keys(n)
          return (
            u.length &&
              (l("$headers=@{}"),
              u.forEach((e) => {
                "connection" !== e && l(`$headers.Add("${e}", "${_g(n[e], { escapeChar: "`" })}")`)
              }),
              d.push("-Headers $headers")),
            r.length &&
              (l("$session = New-Object Microsoft.PowerShell.Commands.WebRequestSession"),
              r.forEach((e) => {
                l("$cookie = New-Object System.Net.Cookie"),
                  l(`$cookie.Name = '${e.name}'`),
                  l(`$cookie.Value = '${e.value}'`),
                  l(`$cookie.Domain = '${a.host}'`),
                  l("$session.Cookies.Add($cookie)")
              }),
              d.push("-WebSession $session")),
            (null == i ? void 0 : i.text) &&
              (d.push(`-ContentType '${_g(bg(s, "content-type"), { delimiter: "'", escapeChar: "`" })}'`),
              d.push(`-Body '${i.text}'`)),
            l(`$response = ${e} -Uri '${o}' -Method ${t} ${d.join(" ")}`),
            c()
          )
        },
      eb = {
        info: {
          key: "restmethod",
          title: "Invoke-RestMethod",
          link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-RestMethod",
          description: "Powershell Invoke-RestMethod client",
        },
        convert: Jg("Invoke-RestMethod"),
      },
      tb = {
        info: {
          key: "webrequest",
          title: "Invoke-WebRequest",
          link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-WebRequest",
          description: "Powershell Invoke-WebRequest client",
        },
        convert: Jg("Invoke-WebRequest"),
      },
      nb = {
        info: {
          key: "python3",
          title: "http.client",
          link: "https://docs.python.org/3/library/http.client.html",
          description: "Python3 HTTP Client",
        },
        convert: ({ uriObj: { path: e, protocol: t, host: n }, postData: r, allHeaders: a, method: o }, i = {}) => {
          const { insecureSkipVerify: s = !1 } = i,
            { push: l, blank: c, join: d } = new kg()
          l("import http.client"),
            s && l("import ssl"),
            c(),
            "https:" === t
              ? (l(
                  `conn = http.client.HTTPSConnection("${n}"${s ? ", context = ssl._create_unverified_context()" : ""})`,
                ),
                c())
              : (l(`conn = http.client.HTTPConnection("${n}")`), c())
          const u = JSON.stringify(null == r ? void 0 : r.text)
          u && (l(`payload = ${u}`), c())
          const p = a,
            h = Object.keys(p).length
          if (1 === h) for (const e in p) l(`headers = { '${e}': "${Eg(p[e])}" }`), c()
          else if (h > 1) {
            let e = 1
            l("headers = {")
            for (const t in p) e++ !== h ? l(`    '${t}': "${Eg(p[t])}",`) : l(`    '${t}': "${Eg(p[t])}"`)
            l("}"), c()
          }
          return (
            l(
              u && h
                ? `conn.request("${o}", "${e}", payload, headers)`
                : u && !h
                  ? `conn.request("${o}", "${e}", payload)`
                  : !u && h
                    ? `conn.request("${o}", "${e}", headers=headers)`
                    : `conn.request("${o}", "${e}")`,
            ),
            c(),
            l("res = conn.getresponse()"),
            l("data = res.read()"),
            c(),
            l('print(data.decode("utf-8"))'),
            d()
          )
        },
      }
    function rb(e, t, n, r, a) {
      const o = r.repeat(a),
        i = r.repeat(a - 1),
        s = n ? `,\n${o}` : ", ",
        l = "object" === e ? "{" : "[",
        c = "object" === e ? "}" : "]"
      return n
        ? `${l}\n${o}${t.join(s)}\n${i}${c}`
        : "object" === e && t.length > 0
          ? `${l} ${t.join(s)} ${c}`
          : `${l}${t.join(s)}${c}`
    }
    const ab = (e, t, n) => {
        switch (((n = void 0 === n ? 1 : n + 1), Object.prototype.toString.call(e))) {
          case "[object Number]":
            return e
          case "[object Array]": {
            let r = !1
            return rb(
              "array",
              e.map(
                (e) => (
                  "[object Object]" === Object.prototype.toString.call(e) && (r = Object.keys(e).length > 1),
                  ab(e, t, n)
                ),
              ),
              r,
              t.indent,
              n,
            )
          }
          case "[object Object]": {
            const r = []
            for (const a in e) r.push(`"${a}": ${ab(e[a], t, n)}`)
            return rb("object", r, t.pretty && r.length > 1, t.indent, n)
          }
          case "[object Null]":
            return "None"
          case "[object Boolean]":
            return e ? "True" : "False"
          default:
            return null == e ? "" : `"${e.toString().replace(/"/g, '\\"')}"`
        }
      },
      ob = ["HEAD", "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      ib = {
        info: {
          key: "requests",
          title: "Requests",
          link: "http://docs.python-requests.org/en/latest/api/#requests.request",
          description: "Requests HTTP library",
        },
        convert: ({ queryObj: e, url: t, postData: n, allHeaders: r, method: a }, o) => {
          const i = { indent: "    ", pretty: !0, ...o },
            { push: s, blank: l, join: c } = new kg({ indent: i.indent })
          let d
          s("import requests"),
            l(),
            s(`url = "${t}"`),
            l(),
            Object.keys(e).length && ((d = `querystring = ${JSON.stringify(e)}`), s(d), l())
          const u = r
          let p = {}
          const h = {}
          let f = !1,
            m = !1,
            g = !1
          switch (null == n ? void 0 : n.mimeType) {
            case "application/json":
              n.jsonObj && (s(`payload = ${ab(n.jsonObj, i)}`), (g = !0), (m = !0))
              break
            case "multipart/form-data":
              if (!n.params) break
              if (
                ((p = {}),
                n.params.forEach((e) => {
                  e.fileName
                    ? ((h[e.name] = `open('${e.fileName}', 'rb')`), (f = !0))
                    : ((p[e.name] = e.value), (m = !0))
                }),
                f)
              ) {
                s(`files = ${ab(h, i)}`), m && s(`payload = ${ab(p, i)}`)
                const e = gg(u, "content-type")
                e && delete u[e]
              } else {
                const e = JSON.stringify(n.text)
                e && (s(`payload = ${e}`), (m = !0))
              }
              break
            default: {
              if (!n) break
              if ("application/x-www-form-urlencoded" === n.mimeType && n.paramsObj) {
                s(`payload = ${ab(n.paramsObj, i)}`), (m = !0)
                break
              }
              const e = JSON.stringify(n.text)
              e && (s(`payload = ${e}`), (m = !0))
            }
          }
          const b = Object.keys(u).length
          if (0 === b && (m || f)) l()
          else if (1 === b) for (const e in u) s(`headers = {"${e}": "${Eg(u[e])}"}`), l()
          else if (b > 1) {
            let e = 1
            s("headers = {")
            for (const t in u) s(e !== b ? `"${t}": "${Eg(u[t])}",` : `"${t}": "${Eg(u[t])}"`, 1), (e += 1)
            s("}"), l()
          }
          let v = ob.includes(a)
            ? `response = requests.${a.toLowerCase()}(url`
            : `response = requests.request("${a}", url`
          return (
            m && (v += g ? ", json=payload" : ", data=payload"),
            f && (v += ", files=files"),
            b > 0 && (v += ", headers=headers"),
            d && (v += ", params=querystring"),
            (v += ")"),
            s(v),
            l(),
            s("print(response.json())"),
            c()
          )
        },
      },
      sb = {
        info: {
          key: "httr",
          title: "httr",
          link: "https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html",
          description: "httr: Tools for Working with URLs and HTTP",
        },
        convert: ({ url: e, queryObj: t, queryString: n, postData: r, allHeaders: a, method: o }, i = {}) => {
          var s, l
          const { push: c, blank: d, join: u } = new kg({ indent: null !== (s = i.indent) && void 0 !== s ? s : "  " })
          c("library(httr)"), d(), c(`url <- "${e}"`), d()
          const p = t
          delete t.key
          const h = Object.entries(p),
            f = h.length
          if (1 === f) {
            const e = h[0]
            c(`queryString <- list(${e[0]} = "${e[1]}")`), d()
          } else
            f > 1 &&
              (c("queryString <- list("),
              h.forEach(([e, t], n) => {
                c(`${e} = "${t}"${n !== f - 1 ? "," : ""}`, 1)
              }),
              c(")"),
              d())
          const m = JSON.stringify(null == r ? void 0 : r.text)
          if ((m && (c(`payload <- ${m}`), d()), r && (r.text || r.jsonObj || r.params)))
            switch (r.mimeType) {
              case "application/x-www-form-urlencoded":
                c('encode <- "form"'), d()
                break
              case "application/json":
                c('encode <- "json"'), d()
                break
              case "multipart/form-data":
                c('encode <- "multipart"'), d()
                break
              default:
                c('encode <- "raw"'), d()
            }
          const g = bg(a, "cookie"),
            b = bg(a, "accept"),
            v = g
              ? `set_cookies(\`${String(g).replace(/;/g, '", `').replace(/` /g, "`").replace(/[=]/g, '` = "')}")`
              : void 0,
            y = b ? `accept("${Eg(b)}")` : void 0,
            O = `content_type("${Eg(null !== (l = null == r ? void 0 : r.mimeType) && void 0 !== l ? l : "application/octet-stream")}")`,
            w = Object.entries(a)
              .filter(([e]) => !["cookie", "accept", "content-type"].includes(e.toLowerCase()))
              .map(([e, t]) => `'${e}' = '${Sg(t)}'`)
              .join(", "),
            x = w ? `add_headers(${w})` : void 0
          let k = `response <- VERB("${o}", url`
          m && (k += ", body = payload"), n.length && (k += ", query = queryString")
          const _ = [x, O, y, v].filter((e) => !!e).join(", ")
          return (
            _ && (k += `, ${_}`),
            r && (r.text || r.jsonObj || r.params) && (k += ", encode = encode"),
            (k += ")"),
            c(k),
            d(),
            c('content(response, "text")'),
            u()
          )
        },
      },
      lb = (e = "") => (/^[a-z0-9-_/.@%^=:]+$/i.test(e) ? e : `'${e.replace(/'/g, "'\\''")}'`),
      cb = {
        "http1.0": "0",
        "url ": "",
        cookie: "b",
        data: "d",
        form: "F",
        globoff: "g",
        header: "H",
        insecure: "k",
        request: "X",
      },
      db = {
        info: {
          key: "curl",
          title: "cURL",
          link: "http://curl.haxx.se/",
          description: "cURL is a command line tool and library for transferring data with URL syntax",
        },
        convert: ({ fullUrl: e, method: t, httpVersion: n, headersObj: r, allHeaders: a, postData: o }, i = {}) => {
          var s
          const {
              binary: l = !1,
              globOff: c = !1,
              indent: d = "  ",
              insecureSkipVerify: u = !1,
              prettifyJson: p = !1,
              short: h = !1,
            } = i,
            { push: f, join: m } = new kg({
              ...("string" == typeof d ? { indent: d } : {}),
              join: !1 !== d ? ` \\\n${d}` : " ",
            }),
            g = ((e) => (t) => {
              if (e) {
                const e = cb[t]
                return e ? `-${e}` : ""
              }
              return `--${t}`
            })(h)
          let b = lb(e)
          if (
            (f(`curl ${g("request")} ${t}`),
            c && ((b = unescape(b)), f(g("globoff"))),
            f(`${g("url ")}${b}`),
            u && f(g("insecure")),
            "HTTP/1.0" === n && f(g("http1.0")),
            bg(a, "accept-encoding") && f("--compressed"),
            "multipart/form-data" === (null == o ? void 0 : o.mimeType))
          ) {
            const e = gg(r, "content-type")
            if (e) {
              const t = r[e]
              if (e && t) {
                const n = t.replace(/; boundary.+?(?=(;|$))/, "")
                ;(r[e] = n), (a[e] = n)
              }
            }
          }
          switch (
            (Object.keys(r)
              .sort()
              .forEach((e) => {
                const t = `${e}: ${r[e]}`
                f(`${g("header")} ${lb(t)}`)
              }),
            a.cookie && f(`${g("cookie")} ${lb(a.cookie)}`),
            null == o ? void 0 : o.mimeType)
          ) {
            case "multipart/form-data":
              null === (s = o.params) ||
                void 0 === s ||
                s.forEach((e) => {
                  let t = ""
                  ;(t = e.fileName ? `${e.name}=@${e.fileName}` : `${e.name}=${e.value}`), f(`${g("form")} ${lb(t)}`)
                })
              break
            case "application/x-www-form-urlencoded":
              o.params
                ? o.params.forEach((e) => {
                    const t = e.name,
                      n = encodeURIComponent(e.name),
                      r = n !== t
                    f(`${l ? "--data-binary" : "--data" + (r ? "-urlencode" : "")} ${lb(`${r ? n : t}=${e.value}`)}`)
                  })
                : f(`${l ? "--data-binary" : g("data")} ${lb(o.text)}`)
              break
            default: {
              if (!o) break
              if (!o.text) break
              const e = l ? "--data-binary" : g("data")
              let t = !1
              if (((v = o.mimeType), yg.some((e) => v.includes(e)) && o.text.length > 2 && p))
                try {
                  const n = JSON.parse(o.text)
                  t = !0
                  const r = JSON.stringify(n, void 0, d)
                  o.text.indexOf("'") > 0 ? f(`${e} @- <<EOF\n${r}\nEOF`) : f(`${e} '\n${r}\n'`)
                } catch (e) {}
              t || f(`${e} ${lb(o.text)}`)
            }
          }
          var v
          return m()
        },
      },
      ub = (e, t) => t.repeat(e),
      pb = (e, t, n, r) => {
        const a = ub(r, n),
          o = ub(r - 1, n),
          i = t ? `,\n${a}` : ", "
        return t ? `[\n${a}${e.join(i)}\n${o}]` : `[${e.join(i)}]`
      },
      hb = (e, t, n) => `let ${e} = ${fb(t, n)}`,
      fb = (e, t, n) => {
        switch (((n = void 0 === n ? 1 : n + 1), Object.prototype.toString.call(e))) {
          case "[object Number]":
            return e
          case "[object Array]": {
            let r = !1
            const a = e.map(
              (e) => (
                "[object Object]" === Object.prototype.toString.call(e) && (r = Object.keys(e).length > 1), fb(e, t, n)
              ),
            )
            return pb(a, r, t.indent, n)
          }
          case "[object Object]": {
            const r = []
            for (const a in e) r.push(`"${a}": ${fb(e[a], t, n)}`)
            return pb(r, t.pretty && r.length > 1, t.indent, n)
          }
          case "[object Boolean]":
            return e.toString()
          default:
            return null == e ? "" : `"${e.toString().replace(/"/g, '\\"')}"`
        }
      },
      mb = {
        c: Tg,
        clojure: Ig,
        csharp: Mg,
        go: Lg,
        http: Qg,
        java: Bg,
        javascript: zg,
        kotlin: qg,
        node: Zg,
        objc: Wg,
        ocaml: Xg,
        php: Kg,
        powershell: {
          info: { key: "powershell", title: "Powershell", extname: ".ps1", default: "webrequest" },
          clientsById: { webrequest: tb, restmethod: eb },
        },
        python: {
          info: { key: "python", title: "Python", extname: ".py", default: "python3" },
          clientsById: { python3: nb, requests: ib },
        },
        r: { info: { key: "r", title: "R", extname: ".r", default: "httr" }, clientsById: { httr: sb } },
        ruby: {
          info: { key: "ruby", title: "Ruby", extname: ".rb", default: "native" },
          clientsById: {
            native: {
              info: {
                key: "native",
                title: "net::http",
                link: "http://ruby-doc.org/stdlib-2.2.1/libdoc/net/http/rdoc/Net/HTTP.html",
                description: "Ruby HTTP client",
              },
              convert: ({ uriObj: e, method: t, fullUrl: n, postData: r, allHeaders: a }, o = {}) => {
                const { insecureSkipVerify: i = !1 } = o,
                  { push: s, blank: l, join: c } = new kg()
                s("require 'uri'"), s("require 'net/http'"), l()
                const d = t.toUpperCase(),
                  u = d.charAt(0) + d.substring(1).toLowerCase()
                ;[
                  "GET",
                  "POST",
                  "HEAD",
                  "DELETE",
                  "PATCH",
                  "PUT",
                  "OPTIONS",
                  "COPY",
                  "LOCK",
                  "UNLOCK",
                  "MOVE",
                  "TRACE",
                ].includes(d) ||
                  (s(`class Net::HTTP::${u} < Net::HTTPRequest`),
                  s(`  METHOD = '${d.toUpperCase()}'`),
                  s(`  REQUEST_HAS_BODY = '${(null == r ? void 0 : r.text) ? "true" : "false"}'`),
                  s("  RESPONSE_HAS_BODY = true"),
                  s("end"),
                  l()),
                  s(`url = URI("${n}")`),
                  l(),
                  s("http = Net::HTTP.new(url.host, url.port)"),
                  "https:" === e.protocol &&
                    (s("http.use_ssl = true"), i && s("http.verify_mode = OpenSSL::SSL::VERIFY_NONE")),
                  l(),
                  s(`request = Net::HTTP::${u}.new(url)`)
                const p = Object.keys(a)
                return (
                  p.length &&
                    p.forEach((e) => {
                      s(`request["${e}"] = '${Sg(a[e])}'`)
                    }),
                  (null == r ? void 0 : r.text) && s(`request.body = ${JSON.stringify(r.text)}`),
                  l(),
                  s("response = http.request(request)"),
                  s("puts response.read_body"),
                  c()
                )
              },
            },
          },
        },
        shell: {
          info: { key: "shell", title: "Shell", extname: ".sh", default: "curl" },
          clientsById: {
            curl: db,
            httpie: {
              info: {
                key: "httpie",
                title: "HTTPie",
                link: "http://httpie.org/",
                description: "a CLI, cURL-like tool for humans",
              },
              convert: ({ allHeaders: e, postData: t, queryObj: n, fullUrl: r, method: a, url: o }, i) => {
                const s = {
                    body: !1,
                    cert: !1,
                    headers: !1,
                    indent: "  ",
                    pretty: !1,
                    print: !1,
                    queryParams: !1,
                    short: !1,
                    style: !1,
                    timeout: !1,
                    verbose: !1,
                    verify: !1,
                    ...i,
                  },
                  {
                    push: l,
                    join: c,
                    unshift: d,
                  } = new kg({ indent: s.indent, join: !1 !== s.indent ? ` \\\n${s.indent}` : " " })
                let u = !1
                const p = []
                return (
                  s.headers && p.push(s.short ? "-h" : "--headers"),
                  s.body && p.push(s.short ? "-b" : "--body"),
                  s.verbose && p.push(s.short ? "-v" : "--verbose"),
                  s.print && p.push(`${s.short ? "-p" : "--print"}=${s.print}`),
                  s.verify && p.push(`--verify=${s.verify}`),
                  s.cert && p.push(`--cert=${s.cert}`),
                  s.pretty && p.push(`--pretty=${s.pretty}`),
                  s.style && p.push(`--style=${s.style}`),
                  s.timeout && p.push(`--timeout=${s.timeout}`),
                  s.queryParams &&
                    Object.keys(n).forEach((e) => {
                      const t = n[e]
                      Array.isArray(t)
                        ? t.forEach((t) => {
                            l(`${e}==${lb(t)}`)
                          })
                        : l(`${e}==${lb(t)}`)
                    }),
                  Object.keys(e)
                    .sort()
                    .forEach((t) => {
                      l(`${t}:${lb(e[t])}`)
                    }),
                  "application/x-www-form-urlencoded" === (null == t ? void 0 : t.mimeType)
                    ? t.params &&
                      t.params.length &&
                      (p.push(s.short ? "-f" : "--form"),
                      t.params.forEach((e) => {
                        l(`${e.name}=${lb(e.value)}`)
                      }))
                    : (u = !0),
                  d(`http ${p.length ? `${p.join(" ")} ` : ""}${a} ${(o = lb(s.queryParams ? o : r))}`),
                  u && (null == t ? void 0 : t.text) && d(`echo ${lb(t.text)} | `),
                  c()
                )
              },
            },
            wget: {
              info: {
                key: "wget",
                title: "Wget",
                link: "https://www.gnu.org/software/wget/",
                description: "a free software package for retrieving files using HTTP, HTTPS",
              },
              convert: ({ method: e, postData: t, allHeaders: n, fullUrl: r }, a) => {
                const o = { indent: "  ", short: !1, verbose: !1, ...a },
                  { push: i, join: s } = new kg({ indent: o.indent, join: !1 !== o.indent ? ` \\\n${o.indent}` : " " })
                var l
                return (
                  o.verbose ? i("wget " + (o.short ? "-v" : "--verbose")) : i("wget " + (o.short ? "-q" : "--quiet")),
                  i(`--method ${lb(e)}`),
                  Object.keys(n).forEach((e) => {
                    const t = `${e}: ${n[e]}`
                    i(`--header ${lb(t)}`)
                  }),
                  (null == t ? void 0 : t.text) &&
                    i(`--body-data ${((l = lb(t.text)), l.replace(/\r/g, "\\r").replace(/\n/g, "\\n"))}`),
                  i(o.short ? "-O" : "--output-document"),
                  i(`- ${lb(r)}`),
                  s()
                )
              },
            },
          },
        },
        swift: {
          info: { key: "swift", title: "Swift", extname: ".swift", default: "nsurlsession" },
          clientsById: {
            nsurlsession: {
              info: {
                key: "nsurlsession",
                title: "NSURLSession",
                link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
                description: "Foundation's NSURLSession request",
              },
              convert: ({ allHeaders: e, postData: t, fullUrl: n, method: r }, a) => {
                var o
                const i = { indent: "  ", pretty: !0, timeout: "10", ...a },
                  { push: s, blank: l, join: c } = new kg({ indent: i.indent }),
                  d = { hasHeaders: !1, hasBody: !1 }
                if (
                  (s("import Foundation"),
                  Object.keys(e).length && ((d.hasHeaders = !0), l(), s(hb("headers", e, i))),
                  t && (t.text || t.jsonObj || t.params))
                )
                  switch (((d.hasBody = !0), t.mimeType)) {
                    case "application/x-www-form-urlencoded":
                      if ((l(), null === (o = t.params) || void 0 === o ? void 0 : o.length)) {
                        const [e, ...n] = t.params
                        s(
                          `let postData = NSMutableData(data: "${e.name}=${e.value}".data(using: String.Encoding.utf8)!)`,
                        ),
                          n.forEach(({ name: e, value: t }) => {
                            s(`postData.append("&${e}=${t}".data(using: String.Encoding.utf8)!)`)
                          })
                      } else d.hasBody = !1
                      break
                    case "application/json":
                      t.jsonObj &&
                        (s(`${hb("parameters", t.jsonObj, i)} as [String : Any]`),
                        l(),
                        s("let postData = JSONSerialization.data(withJSONObject: parameters, options: [])"))
                      break
                    case "multipart/form-data":
                      s(hb("parameters", t.params, i)),
                        l(),
                        s(`let boundary = "${t.boundary}"`),
                        l(),
                        s('var body = ""'),
                        s("var error: NSError? = nil"),
                        s("for param in parameters {"),
                        s('let paramName = param["name"]!', 1),
                        s('body += "--\\(boundary)\\r\\n"', 1),
                        s('body += "Content-Disposition:form-data; name=\\"\\(paramName)\\""', 1),
                        s('if let filename = param["fileName"] {', 1),
                        s('let contentType = param["content-type"]!', 2),
                        s("let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)", 2),
                        s("if (error != nil) {", 2),
                        s("print(error as Any)", 3),
                        s("}", 2),
                        s('body += "; filename=\\"\\(filename)\\"\\r\\n"', 2),
                        s('body += "Content-Type: \\(contentType)\\r\\n\\r\\n"', 2),
                        s("body += fileContent", 2),
                        s('} else if let paramValue = param["value"] {', 1),
                        s('body += "\\r\\n\\r\\n\\(paramValue)"', 2),
                        s("}", 1),
                        s("}")
                      break
                    default:
                      l(), s(`let postData = NSData(data: "${t.text}".data(using: String.Encoding.utf8)!)`)
                  }
                return (
                  l(),
                  s(`let request = NSMutableURLRequest(url: NSURL(string: "${n}")! as URL,`),
                  s("                                        cachePolicy: .useProtocolCachePolicy,"),
                  s(`                                    timeoutInterval: ${parseInt(i.timeout, 10).toFixed(1)})`),
                  s(`request.httpMethod = "${r}"`),
                  d.hasHeaders && s("request.allHTTPHeaderFields = headers"),
                  d.hasBody && s("request.httpBody = postData as Data"),
                  l(),
                  s("let session = URLSession.shared"),
                  s(
                    "let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in",
                  ),
                  s("if (error != nil) {", 1),
                  s("print(error as Any)", 2),
                  s("} else {", 1),
                  s("let httpResponse = response as? HTTPURLResponse", 2),
                  s("print(httpResponse)", 2),
                  s("}", 1),
                  s("})"),
                  l(),
                  s("dataTask.resume()"),
                  c()
                )
              },
            },
          },
        },
      }
    class gb {
      constructor(e) {
        let t = []
        var n
        ;(t =
          "object" == typeof (n = e) &&
          "log" in n &&
          "object" == typeof n.log &&
          "entries" in n.log &&
          Array.isArray(n.log.entries)
            ? e.log.entries
            : [{ request: e }]),
          (this.requests = Promise.all(
            t.map(({ request: e }) => {
              var t
              const n = {
                bodySize: 0,
                headersSize: 0,
                headers: [],
                cookies: [],
                httpVersion: "HTTP/1.1",
                queryString: [],
                postData: {
                  mimeType:
                    (null === (t = e.postData) || void 0 === t ? void 0 : t.mimeType) || "application/octet-stream",
                },
                ...e,
              }
              return this.prepare(n)
            }),
          ))
      }
      async prepare(e) {
        var t, n, r, a
        const o = { ...e, fullUrl: "", queryObj: {}, headersObj: {}, cookiesObj: {}, allHeaders: {} }
        if (
          (o.queryString && o.queryString.length && (o.queryObj = o.queryString.reduce(Og, {})),
          o.headers && o.headers.length)
        ) {
          const e = /^HTTP\/2/
          o.headersObj = o.headers.reduce(
            (t, { name: n, value: r }) => ({ ...t, [e.exec(o.httpVersion) ? n.toLocaleLowerCase() : n]: r }),
            {},
          )
        }
        o.cookies &&
          o.cookies.length &&
          (o.cookiesObj = o.cookies.reduceRight((e, { name: t, value: n }) => ({ ...e, [t]: n }), {}))
        const i =
          null === (t = o.cookies) || void 0 === t
            ? void 0
            : t.map(({ name: e, value: t }) => `${encodeURIComponent(e)}=${encodeURIComponent(t)}`)
        switch (
          ((null == i ? void 0 : i.length) && (o.allHeaders.cookie = i.join("; ")),
          null === (n = o.postData) || void 0 === n ? void 0 : n.mimeType)
        ) {
          case "multipart/mixed":
          case "multipart/related":
          case "multipart/form-data":
          case "multipart/alternative":
            if (
              ((o.postData.text = ""),
              (o.postData.mimeType = "multipart/form-data"),
              null === (r = o.postData) || void 0 === r ? void 0 : r.params)
            ) {
              const e = new cg(),
                t = "---011000010111000001101001"
              null === (a = o.postData) ||
                void 0 === a ||
                a.params.forEach((t) => {
                  const n = t.name,
                    r = t.value || "",
                    a = t.fileName
                  var o
                  "object" == typeof (o = r) &&
                  "function" == typeof o.arrayBuffer &&
                  "string" == typeof o.type &&
                  "function" == typeof o.stream &&
                  "function" == typeof o.constructor &&
                  /^(Blob|File)$/.test(o[fg])
                    ? e.append(n, r, a)
                    : e.append(
                        n,
                        new dg([r], { type: t.contentType }),
                        a
                          ? (function (e) {
                              const t = e.split("/")
                              return t[t.length - 1]
                            })(a)
                          : a,
                      )
                })
              const { postData: n } = o
              for await (const r of (async function* (e, t) {
                for (const [n, r] of e)
                  yield mg(t, n, r), "string" == typeof r ? yield r : yield await r.text(), yield pg
                yield ((e) => `${hg}${e}${hg}${pg.repeat(1)}`)(t)
              })(e, t))
                n.text += r
              o.postData.boundary = t
              const r = gg(o.headersObj, "content-type") || "content-type"
              o.headersObj[r] = `multipart/form-data; boundary=${t}`
            }
            break
          case "application/x-www-form-urlencoded":
            o.postData.params
              ? ((o.postData.paramsObj = o.postData.params.reduce(Og, {})),
                (o.postData.text = wg(o.postData.paramsObj).toString()))
              : (o.postData.text = "")
            break
          case "text/json":
          case "text/x-json":
          case "application/json":
          case "application/x-json":
            if (((o.postData.mimeType = "application/json"), o.postData.text))
              try {
                o.postData.jsonObj = JSON.parse(o.postData.text)
              } catch (e) {
                o.postData.mimeType = "text/plain"
              }
        }
        const s = { ...o.allHeaders, ...o.headersObj },
          l = new URL(o.url),
          c = Object.fromEntries(l.searchParams)
        o.queryObj = { ...o.queryObj, ...c }
        const d = wg(o.queryObj),
          u = new URL(o.url)
        return (
          (u.search = d.toString()),
          (l.search = ""),
          { ...o, allHeaders: s, fullUrl: u.toString(), url: l.toString(), uriObj: new xg(u.toString()) }
        )
      }
      async convert(e, t, n) {
        !n && t && (n = t)
        const r = mb[e]
        if (!r) return null
        const { convert: a } = r.clientsById[t || r.info.default],
          o = (await this.requests).map((e) => a(e, n))
        return 1 === o.length ? o[0] : o
      }
    }
    const bb = { targetKey: "shell", clientKey: "curl" }
    function vb(e) {
      var t
      return (null == (t = xb.value.find((t) => t.key === e.targetKey)) ? void 0 : t.title) ?? e.targetKey
    }
    function yb(e) {
      var t, n
      return (
        (null ==
        (n =
          null == (t = xb.value.find((t) => t.key === e.targetKey))
            ? void 0
            : t.clients.find((t) => t.key === e.clientKey))
          ? void 0
          : n.title) ?? e.clientKey
      )
    }
    const Ob = ii(() => vb(Pb)),
      wb = ii(() => yb(Pb)),
      xb = ii(() => {
        var e
        const t = Object.keys(mb).map((e) => ({
          ...mb[e].info,
          clients: Object.keys(mb[e].clientsById).map((t) => mb[e].clientsById[t].info),
        }))
        return (
          null == (e = t.find((e) => "node" === e.key)) ||
            e.clients.unshift({
              description: "An HTTP/1.1 client, written from scratch for Node.js.",
              key: "undici",
              link: "https://github.com/nodejs/undici",
              title: "undici",
            }),
          (function (e, t) {
            return !0 === t.value
              ? []
              : e.flatMap((e) => {
                  var n
                  return "object" != typeof t.value
                    ? []
                    : Array.isArray(t.value)
                      ? ((e.clients = e.clients.filter((e) => !t.value.includes(e.key))), [e])
                      : !0 === t.value[e.key]
                        ? []
                        : (Array.isArray(t.value[e.key]) &&
                            (e.clients = e.clients.filter((n) => !t.value[e.key].includes(n.key))),
                          (null == (n = null == e ? void 0 : e.clients) ? void 0 : n.length) ? [e] : [])
                })
          })(t, _b)
        )
      }),
      kb = { node: ["unirest"] },
      _b = Dn({ ...(!0 === kb ? {} : kb) }),
      Sb = Dn()
    function Eb(e) {
      void 0 !== e && ((Sb.value = e), Db(Tb()))
    }
    const Tb = () => {
      var e, t, n, r
      return Ab(Sb.value)
        ? Sb.value
        : Ab(bb)
          ? bb
          : {
              targetKey: null == (e = xb.value[0]) ? void 0 : e.key,
              clientKey:
                null == (r = null == (n = null == (t = xb.value[0]) ? void 0 : t.clients) ? void 0 : n[0])
                  ? void 0
                  : r.key,
            }
    }
    function Ab(e) {
      return (
        void 0 !== e && !!xb.value.find((t) => t.key === e.targetKey && t.clients.find((t) => t.key === e.clientKey))
      )
    }
    function Cb() {
      Pd(Pb, Tb())
    }
    const Pb = mn(Tb()),
      Db = (e) => {
        Object.assign(Pb, { ...Pb, ...e })
      },
      Rb = () => ({
        httpClient: bn(Pb),
        resetState: Cb,
        setHttpClient: Db,
        setDefaultHttpClient: Eb,
        excludedClients: bn(_b),
        setExcludedClients: (e) => {
          ;(_b.value = e), Pd(Pb, Tb())
        },
        availableTargets: xb,
        getClientTitle: yb,
        getTargetTitle: vb,
        httpTargetTitle: Ob,
        httpClientTitle: wb,
      })
    function Nb(e) {
      "function" == typeof queueMicrotask
        ? queueMicrotask(e)
        : Promise.resolve()
            .then(e)
            .catch((e) =>
              setTimeout(() => {
                throw e
              }),
            )
    }
    function $b() {
      let e = [],
        t = {
          addEventListener: (e, n, r, a) => (e.addEventListener(n, r, a), t.add(() => e.removeEventListener(n, r, a))),
          requestAnimationFrame(...e) {
            let n = requestAnimationFrame(...e)
            t.add(() => cancelAnimationFrame(n))
          },
          nextFrame(...e) {
            t.requestAnimationFrame(() => {
              t.requestAnimationFrame(...e)
            })
          },
          setTimeout(...e) {
            let n = setTimeout(...e)
            t.add(() => clearTimeout(n))
          },
          microTask(...e) {
            let n = { current: !0 }
            return (
              Nb(() => {
                n.current && e[0]()
              }),
              t.add(() => {
                n.current = !1
              })
            )
          },
          style(e, t, n) {
            let r = e.style.getPropertyValue(t)
            return (
              Object.assign(e.style, { [t]: n }),
              this.add(() => {
                Object.assign(e.style, { [t]: r })
              })
            )
          },
          group(e) {
            let t = $b()
            return e(t), this.add(() => t.dispose())
          },
          add: (t) => (
            e.push(t),
            () => {
              let n = e.indexOf(t)
              if (n >= 0) for (let t of e.splice(n, 1)) t()
            }
          ),
          dispose() {
            for (let t of e.splice(0)) t()
          },
        }
      return t
    }
    let Ib = Symbol("headlessui.useid"),
      Mb = 0
    function Lb() {
      return xa(Ib, () => "" + ++Mb)()
    }
    function Qb(e) {
      var t
      if (null == e || null == e.value) return null
      let n = null != (t = e.value.$el) ? t : e.value
      return n instanceof Node ? n : null
    }
    function Bb(e, t, ...n) {
      if (e in t) {
        let r = t[e]
        return "function" == typeof r ? r(...n) : r
      }
      let r = new Error(
        `Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t)
          .map((e) => `"${e}"`)
          .join(", ")}.`,
      )
      throw (Error.captureStackTrace && Error.captureStackTrace(r, Bb), r)
    }
    var jb = Object.defineProperty,
      Ub = (e, t, n) => (
        ((e, t, n) => {
          t in e ? jb(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)
        })(e, "symbol" != typeof t ? t + "" : t, n),
        n
      )
    let Fb = new (class {
      constructor() {
        Ub(this, "current", this.detect()), Ub(this, "currentId", 0)
      }
      set(e) {
        this.current !== e && ((this.currentId = 0), (this.current = e))
      }
      reset() {
        this.set(this.detect())
      }
      nextId() {
        return ++this.currentId
      }
      get isServer() {
        return "server" === this.current
      }
      get isClient() {
        return "client" === this.current
      }
      detect() {
        return "undefined" == typeof window || "undefined" == typeof document ? "server" : "client"
      }
    })()
    function zb(e) {
      if (Fb.isServer) return null
      if (e instanceof Node) return e.ownerDocument
      if (null != e && e.hasOwnProperty("value")) {
        let t = Qb(e)
        if (t) return t.ownerDocument
      }
      return document
    }
    let qb = [
      "[contentEditable=true]",
      "[tabindex]",
      "a[href]",
      "area[href]",
      "button:not([disabled])",
      "iframe",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
    ]
      .map((e) => `${e}:not([tabindex='-1'])`)
      .join(",")
    var Zb,
      Hb,
      Vb,
      Wb =
        (((Vb = Wb || {})[(Vb.First = 1)] = "First"),
        (Vb[(Vb.Previous = 2)] = "Previous"),
        (Vb[(Vb.Next = 4)] = "Next"),
        (Vb[(Vb.Last = 8)] = "Last"),
        (Vb[(Vb.WrapAround = 16)] = "WrapAround"),
        (Vb[(Vb.NoScroll = 32)] = "NoScroll"),
        Vb),
      Xb =
        (((Hb = Xb || {})[(Hb.Error = 0)] = "Error"),
        (Hb[(Hb.Overflow = 1)] = "Overflow"),
        (Hb[(Hb.Success = 2)] = "Success"),
        (Hb[(Hb.Underflow = 3)] = "Underflow"),
        Hb),
      Yb = (((Zb = Yb || {})[(Zb.Previous = -1)] = "Previous"), (Zb[(Zb.Next = 1)] = "Next"), Zb)
    function Gb(e = document.body) {
      return null == e
        ? []
        : Array.from(e.querySelectorAll(qb)).sort((e, t) =>
            Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER)),
          )
    }
    var Kb = ((e) => ((e[(e.Strict = 0)] = "Strict"), (e[(e.Loose = 1)] = "Loose"), e))(Kb || {})
    function Jb(e, t = 0) {
      var n
      return (
        e !== (null == (n = zb(e)) ? void 0 : n.body) &&
        Bb(t, {
          0: () => e.matches(qb),
          1() {
            let t = e
            for (; null !== t; ) {
              if (t.matches(qb)) return !0
              t = t.parentElement
            }
            return !1
          },
        })
      )
    }
    function ev(e) {
      let t = zb(e)
      rr(() => {
        t && !Jb(t.activeElement, 0) && nv(e)
      })
    }
    var tv = ((e) => ((e[(e.Keyboard = 0)] = "Keyboard"), (e[(e.Mouse = 1)] = "Mouse"), e))(tv || {})
    function nv(e) {
      null == e || e.focus({ preventScroll: !0 })
    }
    "undefined" != typeof window &&
      "undefined" != typeof document &&
      (document.addEventListener(
        "keydown",
        (e) => {
          e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
        },
        !0,
      ),
      document.addEventListener(
        "click",
        (e) => {
          1 === e.detail
            ? delete document.documentElement.dataset.headlessuiFocusVisible
            : 0 === e.detail && (document.documentElement.dataset.headlessuiFocusVisible = "")
        },
        !0,
      ))
    let rv = ["textarea", "input"].join(",")
    function av(e, t = (e) => e) {
      return e.slice().sort((e, n) => {
        let r = t(e),
          a = t(n)
        if (null === r || null === a) return 0
        let o = r.compareDocumentPosition(a)
        return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
      })
    }
    function ov(e, t, { sorted: n = !0, relativeTo: r = null, skipElements: a = [] } = {}) {
      var o
      let i =
          null !=
          (o = Array.isArray(e) ? (e.length > 0 ? e[0].ownerDocument : document) : null == e ? void 0 : e.ownerDocument)
            ? o
            : document,
        s = Array.isArray(e) ? (n ? av(e) : e) : Gb(e)
      a.length > 0 && s.length > 1 && (s = s.filter((e) => !a.includes(e))), (r = null != r ? r : i.activeElement)
      let l,
        c = (() => {
          if (5 & t) return 1
          if (10 & t) return -1
          throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        })(),
        d = (() => {
          if (1 & t) return 0
          if (2 & t) return Math.max(0, s.indexOf(r)) - 1
          if (4 & t) return Math.max(0, s.indexOf(r)) + 1
          if (8 & t) return s.length - 1
          throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        })(),
        u = 32 & t ? { preventScroll: !0 } : {},
        p = 0,
        h = s.length
      do {
        if (p >= h || p + h <= 0) return 0
        let e = d + p
        if (16 & t) e = (e + h) % h
        else {
          if (e < 0) return 3
          if (e >= h) return 1
        }
        ;(l = s[e]), null == l || l.focus(u), (p += c)
      } while (l !== i.activeElement)
      return (
        6 & t &&
          (function (e) {
            var t, n
            return null != (n = null == (t = null == e ? void 0 : e.matches) ? void 0 : t.call(e, rv)) && n
          })(l) &&
          l.select(),
        2
      )
    }
    function iv() {
      return (
        /iPhone/gi.test(window.navigator.platform) ||
        (/Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0)
      )
    }
    function sv(e, t, n) {
      Fb.isServer ||
        Wa((r) => {
          document.addEventListener(e, t, n), r(() => document.removeEventListener(e, t, n))
        })
    }
    function lv(e, t, n) {
      Fb.isServer ||
        Wa((r) => {
          window.addEventListener(e, t, n), r(() => window.removeEventListener(e, t, n))
        })
    }
    function cv(e, t, n = ii(() => !0)) {
      function r(r, a) {
        if (!n.value || r.defaultPrevented) return
        let o = a(r)
        if (null === o || !o.getRootNode().contains(o)) return
        let i = (function e(t) {
          return "function" == typeof t ? e(t()) : Array.isArray(t) || t instanceof Set ? t : [t]
        })(e)
        for (let e of i) {
          if (null === e) continue
          let t = e instanceof HTMLElement ? e : Qb(e)
          if ((null != t && t.contains(o)) || (r.composed && r.composedPath().includes(t))) return
        }
        return !Jb(o, Kb.Loose) && -1 !== o.tabIndex && r.preventDefault(), t(r, o)
      }
      let a = Dn(null)
      sv(
        "pointerdown",
        (e) => {
          var t, r
          n.value &&
            (a.value = (null == (r = null == (t = e.composedPath) ? void 0 : t.call(e)) ? void 0 : r[0]) || e.target)
        },
        !0,
      ),
        sv(
          "mousedown",
          (e) => {
            var t, r
            n.value &&
              (a.value = (null == (r = null == (t = e.composedPath) ? void 0 : t.call(e)) ? void 0 : r[0]) || e.target)
          },
          !0,
        ),
        sv(
          "click",
          (e) => {
            iv() || /Android/gi.test(window.navigator.userAgent) || (a.value && (r(e, () => a.value), (a.value = null)))
          },
          !0,
        ),
        sv("touchend", (e) => r(e, () => (e.target instanceof HTMLElement ? e.target : null)), !0),
        lv(
          "blur",
          (e) =>
            r(e, () =>
              window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null,
            ),
          !0,
        )
    }
    function dv(e, t) {
      if (e) return e
      let n = null != t ? t : "button"
      return "string" == typeof n && "button" === n.toLowerCase() ? "button" : void 0
    }
    function uv(e, t) {
      let n = Dn(dv(e.value.type, e.value.as))
      return (
        Nr(() => {
          n.value = dv(e.value.type, e.value.as)
        }),
        Wa(() => {
          var e
          n.value ||
            (Qb(t) &&
              Qb(t) instanceof HTMLButtonElement &&
              (null == (e = Qb(t)) || !e.hasAttribute("type")) &&
              (n.value = "button"))
        }),
        n
      )
    }
    function pv(e) {
      return [e.screenX, e.screenY]
    }
    function hv() {
      let e = Dn([-1, -1])
      return {
        wasMoved(t) {
          let n = pv(t)
          return (e.value[0] !== n[0] || e.value[1] !== n[1]) && ((e.value = n), !0)
        },
        update(t) {
          e.value = pv(t)
        },
      }
    }
    var fv,
      mv = ((e) => (
        (e[(e.None = 0)] = "None"), (e[(e.RenderStrategy = 1)] = "RenderStrategy"), (e[(e.Static = 2)] = "Static"), e
      ))(mv || {}),
      gv = (((fv = gv || {})[(fv.Unmount = 0)] = "Unmount"), (fv[(fv.Hidden = 1)] = "Hidden"), fv)
    function bv({ visible: e = !0, features: t = 0, ourProps: n, theirProps: r, ...a }) {
      var o
      let i = Ov(r, n),
        s = Object.assign(a, { props: i })
      return e || (2 & t && i.static)
        ? vv(s)
        : 1 & t
          ? Bb(null == (o = i.unmount) || o ? 0 : 1, {
              0: () => null,
              1: () => vv({ ...a, props: { ...i, hidden: !0, style: { display: "none" } } }),
            })
          : vv(s)
    }
    function vv({ props: e, attrs: t, slots: n, slot: r, name: a }) {
      var o, i
      let { as: s, ...l } = wv(e, ["unmount", "static"]),
        c = null == (o = n.default) ? void 0 : o.call(n, r),
        d = {}
      if (r) {
        let e = !1,
          t = []
        for (let [n, a] of Object.entries(r)) "boolean" == typeof a && (e = !0), !0 === a && t.push(n)
        e && (d["data-headlessui-state"] = t.join(" "))
      }
      if ("template" === s) {
        if (((c = yv(null != c ? c : [])), Object.keys(l).length > 0 || Object.keys(t).length > 0)) {
          let [e, ...n] = null != c ? c : []
          if (
            !(function (e) {
              return (
                null != e && ("string" == typeof e.type || "object" == typeof e.type || "function" == typeof e.type)
              )
            })(e) ||
            n.length > 0
          )
            throw new Error(
              [
                'Passing props on "template"!',
                "",
                `The current component <${a} /> is rendering a "template".`,
                "However we need to passthrough the following props:",
                Object.keys(l)
                  .concat(Object.keys(t))
                  .map((e) => e.trim())
                  .filter((e, t, n) => n.indexOf(e) === t)
                  .sort((e, t) => e.localeCompare(t))
                  .map((e) => `  - ${e}`)
                  .join("\n"),
                "",
                "You can apply a few solutions:",
                [
                  'Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".',
                  "Render a single element as the child so that we can forward the props onto that element.",
                ]
                  .map((e) => `  - ${e}`)
                  .join("\n"),
              ].join("\n"),
            )
          let r = Ov(null != (i = e.props) ? i : {}, l, d),
            o = Io(e, r, !0)
          for (let e in r) e.startsWith("on") && (o.props || (o.props = {}), (o.props[e] = r[e]))
          return o
        }
        return Array.isArray(c) && 1 === c.length ? c[0] : c
      }
      return si(s, Object.assign({}, l, d), { default: () => c })
    }
    function yv(e) {
      return e.flatMap((e) => (e.type === go ? yv(e.children) : [e]))
    }
    function Ov(...e) {
      if (0 === e.length) return {}
      if (1 === e.length) return e[0]
      let t = {},
        n = {}
      for (let r of e)
        for (let e in r)
          e.startsWith("on") && "function" == typeof r[e]
            ? (null != n[e] || (n[e] = []), n[e].push(r[e]))
            : (t[e] = r[e])
      if (t.disabled || t["aria-disabled"])
        return Object.assign(t, Object.fromEntries(Object.keys(n).map((e) => [e, void 0])))
      for (let e in n)
        Object.assign(t, {
          [e](t, ...r) {
            let a = n[e]
            for (let e of a) {
              if (t instanceof Event && t.defaultPrevented) return
              e(t, ...r)
            }
          },
        })
      return t
    }
    function wv(e, t = []) {
      let n = Object.assign({}, e)
      for (let e of t) e in n && delete n[e]
      return n
    }
    var xv = ((e) => (
      (e[(e.None = 1)] = "None"), (e[(e.Focusable = 2)] = "Focusable"), (e[(e.Hidden = 4)] = "Hidden"), e
    ))(xv || {})
    let kv = Hr({
        name: "Hidden",
        props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } },
        setup:
          (e, { slots: t, attrs: n }) =>
          () => {
            var r
            let { features: a, ...o } = e
            return bv({
              ourProps: {
                "aria-hidden": !(2 & ~a) || (null != (r = o["aria-hidden"]) ? r : void 0),
                hidden: !(4 & ~a) || void 0,
                style: {
                  position: "fixed",
                  top: 1,
                  left: 1,
                  width: 1,
                  height: 0,
                  padding: 0,
                  margin: -1,
                  overflow: "hidden",
                  clip: "rect(0, 0, 0, 0)",
                  whiteSpace: "nowrap",
                  borderWidth: "0",
                  ...(!(4 & ~a) && !!(2 & ~a) && { display: "none" }),
                },
              },
              theirProps: o,
              slot: {},
              attrs: n,
              slots: t,
              name: "Hidden",
            })
          },
      }),
      _v = Symbol("Context")
    var Sv = ((e) => (
      (e[(e.Open = 1)] = "Open"),
      (e[(e.Closed = 2)] = "Closed"),
      (e[(e.Closing = 4)] = "Closing"),
      (e[(e.Opening = 8)] = "Opening"),
      e
    ))(Sv || {})
    function Ev() {
      return xa(_v, null)
    }
    function Tv(e) {
      wa(_v, e)
    }
    var Av,
      Cv =
        (((Av = Cv || {}).Space = " "),
        (Av.Enter = "Enter"),
        (Av.Escape = "Escape"),
        (Av.Backspace = "Backspace"),
        (Av.Delete = "Delete"),
        (Av.ArrowLeft = "ArrowLeft"),
        (Av.ArrowUp = "ArrowUp"),
        (Av.ArrowRight = "ArrowRight"),
        (Av.ArrowDown = "ArrowDown"),
        (Av.Home = "Home"),
        (Av.End = "End"),
        (Av.PageUp = "PageUp"),
        (Av.PageDown = "PageDown"),
        (Av.Tab = "Tab"),
        Av)
    let Pv = []
    !(function (e) {
      function t() {
        "loading" !== document.readyState &&
          ((() => {
            function e(e) {
              e.target instanceof HTMLElement &&
                e.target !== document.body &&
                Pv[0] !== e.target &&
                (Pv.unshift(e.target), (Pv = Pv.filter((e) => null != e && e.isConnected)), Pv.splice(10))
            }
            window.addEventListener("click", e, { capture: !0 }),
              window.addEventListener("mousedown", e, { capture: !0 }),
              window.addEventListener("focus", e, { capture: !0 }),
              document.body.addEventListener("click", e, { capture: !0 }),
              document.body.addEventListener("mousedown", e, { capture: !0 }),
              document.body.addEventListener("focus", e, { capture: !0 })
          })(),
          document.removeEventListener("DOMContentLoaded", t))
      }
      "undefined" != typeof window &&
        "undefined" != typeof document &&
        (document.addEventListener("DOMContentLoaded", t), t())
    })()
    var Dv,
      Rv =
        (((Dv = Rv || {})[(Dv.First = 0)] = "First"),
        (Dv[(Dv.Previous = 1)] = "Previous"),
        (Dv[(Dv.Next = 2)] = "Next"),
        (Dv[(Dv.Last = 3)] = "Last"),
        (Dv[(Dv.Specific = 4)] = "Specific"),
        (Dv[(Dv.Nothing = 5)] = "Nothing"),
        Dv)
    function Nv(e, t) {
      let n = t.resolveItems()
      if (n.length <= 0) return null
      let r = t.resolveActiveIndex(),
        a = null != r ? r : -1
      switch (e.focus) {
        case 0:
          for (let e = 0; e < n.length; ++e) if (!t.resolveDisabled(n[e], e, n)) return e
          return r
        case 1:
          ;-1 === a && (a = n.length)
          for (let e = a - 1; e >= 0; --e) if (!t.resolveDisabled(n[e], e, n)) return e
          return r
        case 2:
          for (let e = a + 1; e < n.length; ++e) if (!t.resolveDisabled(n[e], e, n)) return e
          return r
        case 3:
          for (let e = n.length - 1; e >= 0; --e) if (!t.resolveDisabled(n[e], e, n)) return e
          return r
        case 4:
          for (let r = 0; r < n.length; ++r) if (t.resolveId(n[r], r, n) === e.id) return r
          return r
        case 5:
          return null
        default:
          !(function (e) {
            throw new Error("Unexpected object: " + e)
          })(e)
      }
    }
    function $v(e = {}, t = null, n = []) {
      for (let [r, a] of Object.entries(e)) Mv(n, Iv(t, r), a)
      return n
    }
    function Iv(e, t) {
      return e ? e + "[" + t + "]" : t
    }
    function Mv(e, t, n) {
      if (Array.isArray(n)) for (let [r, a] of n.entries()) Mv(e, Iv(t, r.toString()), a)
      else
        n instanceof Date
          ? e.push([t, n.toISOString()])
          : "boolean" == typeof n
            ? e.push([t, n ? "1" : "0"])
            : "string" == typeof n
              ? e.push([t, n])
              : "number" == typeof n
                ? e.push([t, `${n}`])
                : null == n
                  ? e.push([t, ""])
                  : $v(n, t, e)
    }
    function Lv(e, t, n, r) {
      Fb.isServer ||
        Wa((a) => {
          ;(e = null != e ? e : window).addEventListener(t, n, r), a(() => e.removeEventListener(t, n, r))
        })
    }
    var Qv = ((e) => ((e[(e.Forwards = 0)] = "Forwards"), (e[(e.Backwards = 1)] = "Backwards"), e))(Qv || {})
    function Bv(e) {
      if (!e) return new Set()
      if ("function" == typeof e) return new Set(e())
      let t = new Set()
      for (let n of e.value) {
        let e = Qb(n)
        e instanceof HTMLElement && t.add(e)
      }
      return t
    }
    var jv = ((e) => (
      (e[(e.None = 1)] = "None"),
      (e[(e.InitialFocus = 2)] = "InitialFocus"),
      (e[(e.TabLock = 4)] = "TabLock"),
      (e[(e.FocusLock = 8)] = "FocusLock"),
      (e[(e.RestoreFocus = 16)] = "RestoreFocus"),
      (e[(e.All = 30)] = "All"),
      e
    ))(jv || {})
    let Uv = Object.assign(
      Hr({
        name: "FocusTrap",
        props: {
          as: { type: [Object, String], default: "div" },
          initialFocus: { type: Object, default: null },
          features: { type: Number, default: 30 },
          containers: { type: [Object, Function], default: Dn(new Set()) },
        },
        inheritAttrs: !1,
        setup(e, { attrs: t, slots: n, expose: r }) {
          let a = Dn(null)
          r({ el: a, $el: a })
          let o = ii(() => zb(a)),
            i = Dn(!1)
          Nr(() => (i.value = !0)),
            Lr(() => (i.value = !1)),
            (function ({ ownerDocument: e }, t) {
              let n = (function (e) {
                let t = Dn(Pv.slice())
                return (
                  Ya(
                    [e],
                    ([e], [n]) => {
                      !0 === n && !1 === e
                        ? Nb(() => {
                            t.value.splice(0)
                          })
                        : !1 === n && !0 === e && (t.value = Pv.slice())
                    },
                    { flush: "post" },
                  ),
                  () => {
                    var e
                    return null != (e = t.value.find((e) => null != e && e.isConnected)) ? e : null
                  }
                )
              })(t)
              Nr(() => {
                Wa(
                  () => {
                    var r, a
                    t.value ||
                      ((null == (r = e.value) ? void 0 : r.activeElement) ===
                        (null == (a = e.value) ? void 0 : a.body) &&
                        nv(n()))
                  },
                  { flush: "post" },
                )
              }),
                Lr(() => {
                  t.value && nv(n())
                })
            })(
              { ownerDocument: o },
              ii(() => i.value && Boolean(16 & e.features)),
            )
          let s = (function ({ ownerDocument: e, container: t, initialFocus: n }, r) {
            let a = Dn(null),
              o = Dn(!1)
            return (
              Nr(() => (o.value = !0)),
              Lr(() => (o.value = !1)),
              Nr(() => {
                Ya(
                  [t, n, r],
                  (i, s) => {
                    if (i.every((e, t) => (null == s ? void 0 : s[t]) === e) || !r.value) return
                    let l = Qb(t)
                    l &&
                      Nb(() => {
                        var t, r
                        if (!o.value) return
                        let i = Qb(n),
                          s = null == (t = e.value) ? void 0 : t.activeElement
                        if (i) {
                          if (i === s) return void (a.value = s)
                        } else if (l.contains(s)) return void (a.value = s)
                        i
                          ? nv(i)
                          : ov(l, Wb.First | Wb.NoScroll) === Xb.Error &&
                            console.warn("There are no focusable elements inside the <FocusTrap />"),
                          (a.value = null == (r = e.value) ? void 0 : r.activeElement)
                      })
                  },
                  { immediate: !0, flush: "post" },
                )
              }),
              a
            )
          })(
            { ownerDocument: o, container: a, initialFocus: ii(() => e.initialFocus) },
            ii(() => i.value && Boolean(2 & e.features)),
          )
          !(function ({ ownerDocument: e, container: t, containers: n, previousActiveElement: r }, a) {
            var o
            Lv(
              null == (o = e.value) ? void 0 : o.defaultView,
              "focus",
              (e) => {
                if (!a.value) return
                let o = Bv(n)
                Qb(t) instanceof HTMLElement && o.add(Qb(t))
                let i = r.value
                if (!i) return
                let s = e.target
                s && s instanceof HTMLElement
                  ? Fv(o, s)
                    ? ((r.value = s), nv(s))
                    : (e.preventDefault(), e.stopPropagation(), nv(i))
                  : nv(r.value)
              },
              !0,
            )
          })(
            { ownerDocument: o, container: a, containers: e.containers, previousActiveElement: s },
            ii(() => i.value && Boolean(8 & e.features)),
          )
          let l = (function () {
            let e = Dn(0)
            return (
              lv("keydown", (t) => {
                "Tab" === t.key && (e.value = t.shiftKey ? 1 : 0)
              }),
              e
            )
          })()
          function c(e) {
            let t = Qb(a)
            t &&
              Bb(l.value, {
                [Qv.Forwards]: () => {
                  ov(t, Wb.First, { skipElements: [e.relatedTarget] })
                },
                [Qv.Backwards]: () => {
                  ov(t, Wb.Last, { skipElements: [e.relatedTarget] })
                },
              })
          }
          let d = Dn(!1)
          function u(e) {
            "Tab" === e.key &&
              ((d.value = !0),
              requestAnimationFrame(() => {
                d.value = !1
              }))
          }
          function p(t) {
            if (!i.value) return
            let n = Bv(e.containers)
            Qb(a) instanceof HTMLElement && n.add(Qb(a))
            let r = t.relatedTarget
            r instanceof HTMLElement &&
              "true" !== r.dataset.headlessuiFocusGuard &&
              (Fv(n, r) ||
                (d.value
                  ? ov(
                      Qb(a),
                      Bb(l.value, { [Qv.Forwards]: () => Wb.Next, [Qv.Backwards]: () => Wb.Previous }) | Wb.WrapAround,
                      { relativeTo: t.target },
                    )
                  : t.target instanceof HTMLElement && nv(t.target)))
          }
          return () => {
            let r = { ref: a, onKeydown: u, onFocusout: p },
              { features: o, initialFocus: i, containers: s, ...l } = e
            return si(go, [
              Boolean(4 & o) &&
                si(kv, {
                  as: "button",
                  type: "button",
                  "data-headlessui-focus-guard": !0,
                  onFocus: c,
                  features: xv.Focusable,
                }),
              bv({ ourProps: r, theirProps: { ...t, ...l }, slot: {}, attrs: t, slots: n, name: "FocusTrap" }),
              Boolean(4 & o) &&
                si(kv, {
                  as: "button",
                  type: "button",
                  "data-headlessui-focus-guard": !0,
                  onFocus: c,
                  features: xv.Focusable,
                }),
            ])
          }
        },
      }),
      { features: jv },
    )
    function Fv(e, t) {
      for (let n of e) if (n.contains(t)) return !0
      return !1
    }
    function zv() {
      let e
      return {
        before({ doc: t }) {
          var n
          let r = t.documentElement
          e = (null != (n = t.defaultView) ? n : window).innerWidth - r.clientWidth
        },
        after({ doc: t, d: n }) {
          let r = t.documentElement,
            a = r.clientWidth - r.offsetWidth,
            o = e - a
          n.style(r, "paddingRight", `${o}px`)
        },
      }
    }
    function qv(e) {
      let t = {}
      for (let n of e) Object.assign(t, n(t))
      return t
    }
    let Zv = (function (e, t) {
      let n = new Map(),
        r = new Set()
      return {
        getSnapshot: () => n,
        subscribe: (e) => (r.add(e), () => r.delete(e)),
        dispatch(e, ...a) {
          let o = t[e].call(n, ...a)
          o && ((n = o), r.forEach((e) => e()))
        },
      }
    })(0, {
      PUSH(e, t) {
        var n
        let r = null != (n = this.get(e)) ? n : { doc: e, count: 0, d: $b(), meta: new Set() }
        return r.count++, r.meta.add(t), this.set(e, r), this
      },
      POP(e, t) {
        let n = this.get(e)
        return n && (n.count--, n.meta.delete(t)), this
      },
      SCROLL_PREVENT({ doc: e, d: t, meta: n }) {
        let r = { doc: e, d: t, meta: qv(n) },
          a = [
            iv()
              ? {
                  before({ doc: e, d: t, meta: n }) {
                    function r(e) {
                      return n.containers.flatMap((e) => e()).some((t) => t.contains(e))
                    }
                    t.microTask(() => {
                      var n
                      if ("auto" !== window.getComputedStyle(e.documentElement).scrollBehavior) {
                        let n = $b()
                        n.style(e.documentElement, "scrollBehavior", "auto"),
                          t.add(() => t.microTask(() => n.dispose()))
                      }
                      let a = null != (n = window.scrollY) ? n : window.pageYOffset,
                        o = null
                      t.addEventListener(
                        e,
                        "click",
                        (t) => {
                          if (t.target instanceof HTMLElement)
                            try {
                              let n = t.target.closest("a")
                              if (!n) return
                              let { hash: a } = new URL(n.href),
                                i = e.querySelector(a)
                              i && !r(i) && (o = i)
                            } catch {}
                        },
                        !0,
                      ),
                        t.addEventListener(e, "touchstart", (e) => {
                          if (e.target instanceof HTMLElement)
                            if (r(e.target)) {
                              let n = e.target
                              for (; n.parentElement && r(n.parentElement); ) n = n.parentElement
                              t.style(n, "overscrollBehavior", "contain")
                            } else t.style(e.target, "touchAction", "none")
                        }),
                        t.addEventListener(
                          e,
                          "touchmove",
                          (e) => {
                            if (e.target instanceof HTMLElement) {
                              if ("INPUT" === e.target.tagName) return
                              if (r(e.target)) {
                                let t = e.target
                                for (
                                  ;
                                  t.parentElement &&
                                  "" !== t.dataset.headlessuiPortal &&
                                  !(t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth);

                                )
                                  t = t.parentElement
                                "" === t.dataset.headlessuiPortal && e.preventDefault()
                              } else e.preventDefault()
                            }
                          },
                          { passive: !1 },
                        ),
                        t.add(() => {
                          var e
                          let t = null != (e = window.scrollY) ? e : window.pageYOffset
                          a !== t && window.scrollTo(0, a),
                            o && o.isConnected && (o.scrollIntoView({ block: "nearest" }), (o = null))
                        })
                    })
                  },
                }
              : {},
            zv(),
            {
              before({ doc: e, d: t }) {
                t.style(e.documentElement, "overflow", "hidden")
              },
            },
          ]
        a.forEach(({ before: e }) => (null == e ? void 0 : e(r))),
          a.forEach(({ after: e }) => (null == e ? void 0 : e(r)))
      },
      SCROLL_ALLOW({ d: e }) {
        e.dispose()
      },
      TEARDOWN({ doc: e }) {
        this.delete(e)
      },
    })
    Zv.subscribe(() => {
      let e = Zv.getSnapshot(),
        t = new Map()
      for (let [n] of e) t.set(n, n.documentElement.style.overflow)
      for (let n of e.values()) {
        let e = "hidden" === t.get(n.doc),
          r = 0 !== n.count
        ;((r && !e) || (!r && e)) && Zv.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n),
          0 === n.count && Zv.dispatch("TEARDOWN", n)
      }
    })
    let Hv = new Map(),
      Vv = new Map()
    function Wv(e, t = Dn(!0)) {
      Wa((n) => {
        var r
        if (!t.value) return
        let a = Qb(e)
        if (!a) return
        n(function () {
          var e
          if (!a) return
          let t = null != (e = Vv.get(a)) ? e : 1
          if ((1 === t ? Vv.delete(a) : Vv.set(a, t - 1), 1 !== t)) return
          let n = Hv.get(a)
          n &&
            (null === n["aria-hidden"]
              ? a.removeAttribute("aria-hidden")
              : a.setAttribute("aria-hidden", n["aria-hidden"]),
            (a.inert = n.inert),
            Hv.delete(a))
        })
        let o = null != (r = Vv.get(a)) ? r : 0
        Vv.set(a, o + 1),
          0 === o &&
            (Hv.set(a, { "aria-hidden": a.getAttribute("aria-hidden"), inert: a.inert }),
            a.setAttribute("aria-hidden", "true"),
            (a.inert = !0))
      })
    }
    let Xv = Symbol("ForcePortalRootContext"),
      Yv = Hr({
        name: "ForcePortalRoot",
        props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } },
        setup: (e, { slots: t, attrs: n }) => (
          wa(Xv, e.force),
          () => {
            let { force: r, ...a } = e
            return bv({ theirProps: a, ourProps: {}, slot: {}, slots: t, attrs: n, name: "ForcePortalRoot" })
          }
        ),
      }),
      Gv = Symbol("StackContext")
    var Kv = ((e) => ((e[(e.Add = 0)] = "Add"), (e[(e.Remove = 1)] = "Remove"), e))(Kv || {})
    let Jv = Symbol("DescriptionContext"),
      ey = Hr({
        name: "Description",
        props: { as: { type: [Object, String], default: "p" }, id: { type: String, default: null } },
        setup(e, { attrs: t, slots: n }) {
          var r
          let a = null != (r = e.id) ? r : `headlessui-description-${Lb()}`,
            o = (function () {
              let e = xa(Jv, null)
              if (null === e) throw new Error("Missing parent")
              return e
            })()
          return (
            Nr(() => Lr(o.register(a))),
            () => {
              let { name: r = "Description", slot: i = Dn({}), props: s = {} } = o,
                { ...l } = e
              return bv({
                ourProps: { ...Object.entries(s).reduce((e, [t, n]) => Object.assign(e, { [t]: In(n) }), {}), id: a },
                theirProps: l,
                slot: i.value,
                attrs: t,
                slots: n,
                name: r,
              })
            }
          )
        },
      })
    const ty = new WeakMap()
    function ny(e, t) {
      let n = t(
        (function (e) {
          var t
          return null != (t = ty.get(e)) ? t : 0
        })(e),
      )
      return n <= 0 ? ty.delete(e) : ty.set(e, n), n
    }
    let ry = Hr({
        name: "Portal",
        props: { as: { type: [Object, String], default: "div" } },
        setup(e, { slots: t, attrs: n }) {
          let r = Dn(null),
            a = ii(() => zb(r)),
            o = xa(Xv, !1),
            i = xa(oy, null),
            s = Dn(
              !0 === o || null == i
                ? (function (e) {
                    let t = zb(e)
                    if (!t) {
                      if (null === e) return null
                      throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${e}`)
                    }
                    let n = t.getElementById("headlessui-portal-root")
                    if (n) return n
                    let r = t.createElement("div")
                    return r.setAttribute("id", "headlessui-portal-root"), t.body.appendChild(r)
                  })(r.value)
                : i.resolveTarget(),
            )
          s.value && ny(s.value, (e) => e + 1)
          let l = Dn(!1)
          Nr(() => {
            l.value = !0
          }),
            Wa(() => {
              o || (null != i && (s.value = i.resolveTarget()))
            })
          let c = xa(ay, null),
            d = !1,
            u = Vo()
          return (
            Ya(r, () => {
              if (d || !c) return
              let e = Qb(r)
              e && (Lr(c.register(e), u), (d = !0))
            }),
            Lr(() => {
              var e, t
              let n = null == (e = a.value) ? void 0 : e.getElementById("headlessui-portal-root")
              !n ||
                s.value !== n ||
                ny(s.value, (e) => e - 1) ||
                s.value.children.length > 0 ||
                null == (t = s.value.parentElement) ||
                t.removeChild(s.value)
            }),
            () => {
              if (!l.value || null === s.value) return null
              let a = { ref: r, "data-headlessui-portal": "" }
              return si(
                fo,
                { to: s.value },
                bv({ ourProps: a, theirProps: e, slot: {}, attrs: n, slots: t, name: "Portal" }),
              )
            }
          )
        },
      }),
      ay = Symbol("PortalParentContext"),
      oy = Symbol("PortalGroupContext"),
      iy = Hr({
        name: "PortalGroup",
        props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } },
        setup(e, { attrs: t, slots: n }) {
          let r = mn({ resolveTarget: () => e.target })
          return (
            wa(oy, r),
            () => {
              let { target: r, ...a } = e
              return bv({ theirProps: a, ourProps: {}, slot: {}, attrs: t, slots: n, name: "PortalGroup" })
            }
          )
        },
      })
    var sy,
      ly = (((sy = ly || {})[(sy.Open = 0)] = "Open"), (sy[(sy.Closed = 1)] = "Closed"), sy)
    let cy = Symbol("DialogContext")
    function dy(e) {
      let t = xa(cy, null)
      if (null === t) {
        let t = new Error(`<${e} /> is missing a parent <Dialog /> component.`)
        throw (Error.captureStackTrace && Error.captureStackTrace(t, dy), t)
      }
      return t
    }
    let uy = "DC8F892D-2EBD-447C-A4C8-A03058436FF4",
      py = Hr({
        name: "Dialog",
        inheritAttrs: !1,
        props: {
          as: { type: [Object, String], default: "div" },
          static: { type: Boolean, default: !1 },
          unmount: { type: Boolean, default: !0 },
          open: { type: [Boolean, String], default: uy },
          initialFocus: { type: Object, default: null },
          id: { type: String, default: null },
          role: { type: String, default: "dialog" },
        },
        emits: { close: (e) => !0 },
        setup(e, { emit: t, attrs: n, slots: r, expose: a }) {
          var o, i
          let s = null != (o = e.id) ? o : `headlessui-dialog-${Lb()}`,
            l = Dn(!1)
          Nr(() => {
            l.value = !0
          })
          let c = !1,
            d = ii(() =>
              "dialog" === e.role || "alertdialog" === e.role
                ? e.role
                : (c ||
                    ((c = !0),
                    console.warn(
                      `Invalid role [${d}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`,
                    )),
                  "dialog"),
            ),
            u = Dn(0),
            p = Ev(),
            h = ii(() => (e.open === uy && null !== p ? (p.value & Sv.Open) === Sv.Open : e.open)),
            f = Dn(null),
            m = ii(() => zb(f))
          if ((a({ el: f, $el: f }), e.open === uy && null === p))
            throw new Error("You forgot to provide an `open` prop to the `Dialog`.")
          if ("boolean" != typeof h.value)
            throw new Error(
              `You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${h.value === uy ? void 0 : e.open}`,
            )
          let g = ii(() => (l.value && h.value ? 0 : 1)),
            b = ii(() => 0 === g.value),
            v = ii(() => u.value > 1),
            y = null !== xa(cy, null),
            [O, w] = (function () {
              let e = xa(ay, null),
                t = Dn([])
              function n(n) {
                let r = t.value.indexOf(n)
                ;-1 !== r && t.value.splice(r, 1), e && e.unregister(n)
              }
              let r = {
                register: function (r) {
                  return t.value.push(r), e && e.register(r), () => n(r)
                },
                unregister: n,
                portals: t,
              }
              return [
                t,
                Hr({
                  name: "PortalWrapper",
                  setup: (e, { slots: t }) => (
                    wa(ay, r),
                    () => {
                      var e
                      return null == (e = t.default) ? void 0 : e.call(t)
                    }
                  ),
                }),
              ]
            })(),
            {
              resolveContainers: x,
              mainTreeNodeRef: k,
              MainTreeNode: _,
            } = (function ({ defaultContainers: e = [], portals: t, mainTreeNodeRef: n } = {}) {
              let r = Dn(null),
                a = zb(r)
              function o() {
                var n, o, i
                let s = []
                for (let t of e)
                  null !== t &&
                    (t instanceof HTMLElement
                      ? s.push(t)
                      : "value" in t && t.value instanceof HTMLElement && s.push(t.value))
                if (null != t && t.value) for (let e of t.value) s.push(e)
                for (let e of null != (n = null == a ? void 0 : a.querySelectorAll("html > *, body > *")) ? n : [])
                  e !== document.body &&
                    e !== document.head &&
                    e instanceof HTMLElement &&
                    "headlessui-portal-root" !== e.id &&
                    (e.contains(Qb(r)) ||
                      e.contains(null == (i = null == (o = Qb(r)) ? void 0 : o.getRootNode()) ? void 0 : i.host) ||
                      s.some((t) => e.contains(t)) ||
                      s.push(e))
                return s
              }
              return {
                resolveContainers: o,
                contains: (e) => o().some((t) => t.contains(e)),
                mainTreeNodeRef: r,
                MainTreeNode: () => (null != n ? null : si(kv, { features: xv.Hidden, ref: r })),
              }
            })({
              portals: O,
              defaultContainers: [
                ii(() => {
                  var e
                  return null != (e = N.panelRef.value) ? e : f.value
                }),
              ],
            }),
            S = ii(() => (v.value ? "parent" : "leaf")),
            E = ii(() => null !== p && (p.value & Sv.Closing) === Sv.Closing),
            T = ii(() => !y && !E.value && b.value),
            A = ii(() => {
              var e, t, n
              return null !=
                (n = Array.from(
                  null != (t = null == (e = m.value) ? void 0 : e.querySelectorAll("body > *")) ? t : [],
                ).find((e) => "headlessui-portal-root" !== e.id && e.contains(Qb(k)) && e instanceof HTMLElement))
                ? n
                : null
            })
          Wv(A, T)
          let C = ii(() => !!v.value || b.value),
            P = ii(() => {
              var e, t, n
              return null !=
                (n = Array.from(
                  null != (t = null == (e = m.value) ? void 0 : e.querySelectorAll("[data-headlessui-portal]"))
                    ? t
                    : [],
                ).find((e) => e.contains(Qb(k)) && e instanceof HTMLElement))
                ? n
                : null
            })
          Wv(P, C),
            (function ({ type: e, enabled: t, element: n, onUpdate: r }) {
              let a = xa(Gv, () => {})
              function o(...e) {
                null == r || r(...e), a(...e)
              }
              Nr(() => {
                Ya(
                  t,
                  (t, r) => {
                    t ? o(0, e, n) : !0 === r && o(1, e, n)
                  },
                  { immediate: !0, flush: "sync" },
                )
              }),
                Lr(() => {
                  t.value && o(1, e, n)
                }),
                wa(Gv, o)
            })({
              type: "Dialog",
              enabled: ii(() => 0 === g.value),
              element: f,
              onUpdate: (e, t) => {
                if ("Dialog" === t) return Bb(e, { [Kv.Add]: () => (u.value += 1), [Kv.Remove]: () => (u.value -= 1) })
              },
            })
          let D = (function ({ slot: e = Dn({}), name: t = "Description", props: n = {} } = {}) {
              let r = Dn([])
              return (
                wa(Jv, {
                  register: function (e) {
                    return (
                      r.value.push(e),
                      () => {
                        let t = r.value.indexOf(e)
                        ;-1 !== t && r.value.splice(t, 1)
                      }
                    )
                  },
                  slot: e,
                  name: t,
                  props: n,
                }),
                ii(() => (r.value.length > 0 ? r.value.join(" ") : void 0))
              )
            })({ name: "DialogDescription", slot: ii(() => ({ open: h.value })) }),
            R = Dn(null),
            N = {
              titleId: R,
              panelRef: Dn(null),
              dialogState: g,
              setTitleId(e) {
                R.value !== e && (R.value = e)
              },
              close() {
                t("close", !1)
              },
            }
          wa(cy, N)
          let $ = ii(() => !(!b.value || v.value))
          cv(
            x,
            (e, t) => {
              e.preventDefault(), N.close(), rr(() => (null == t ? void 0 : t.focus()))
            },
            $,
          )
          let I = ii(() => !(v.value || 0 !== g.value))
          Lv(null == (i = m.value) ? void 0 : i.defaultView, "keydown", (e) => {
            I.value &&
              (e.defaultPrevented || (e.key === Cv.Escape && (e.preventDefault(), e.stopPropagation(), N.close())))
          })
          let M = ii(() => !(E.value || 0 !== g.value || y))
          return (
            (function (e, t, n) {
              let r = (function (e) {
                  let t = Rn(e.getSnapshot())
                  return (
                    Lr(
                      e.subscribe(() => {
                        t.value = e.getSnapshot()
                      }),
                    ),
                    t
                  )
                })(Zv),
                a = ii(() => {
                  let t = e.value ? r.value.get(e.value) : void 0
                  return !!t && t.count > 0
                })
              Ya(
                [e, t],
                ([e, t], [r], a) => {
                  if (!e || !t) return
                  Zv.dispatch("PUSH", e, n)
                  let o = !1
                  a(() => {
                    o || (Zv.dispatch("POP", null != r ? r : e, n), (o = !0))
                  })
                },
                { immediate: !0 },
              )
            })(m, M, (e) => {
              var t
              return { containers: [...(null != (t = e.containers) ? t : []), x] }
            }),
            Wa((e) => {
              if (0 !== g.value) return
              let t = Qb(f)
              if (!t) return
              let n = new ResizeObserver((e) => {
                for (let t of e) {
                  let e = t.target.getBoundingClientRect()
                  0 === e.x && 0 === e.y && 0 === e.width && 0 === e.height && N.close()
                }
              })
              n.observe(t), e(() => n.disconnect())
            }),
            () => {
              let { open: t, initialFocus: a, ...o } = e,
                i = {
                  ...n,
                  ref: f,
                  id: s,
                  role: d.value,
                  "aria-modal": 0 === g.value || void 0,
                  "aria-labelledby": R.value,
                  "aria-describedby": D.value,
                },
                l = { open: 0 === g.value }
              return si(Yv, { force: !0 }, () => [
                si(ry, () =>
                  si(iy, { target: f.value }, () =>
                    si(Yv, { force: !1 }, () =>
                      si(
                        Uv,
                        {
                          initialFocus: a,
                          containers: x,
                          features: b.value
                            ? Bb(S.value, {
                                parent: Uv.features.RestoreFocus,
                                leaf: Uv.features.All & ~Uv.features.FocusLock,
                              })
                            : Uv.features.None,
                        },
                        () =>
                          si(w, {}, () =>
                            bv({
                              ourProps: i,
                              theirProps: { ...o, ...n },
                              slot: l,
                              attrs: n,
                              slots: r,
                              visible: 0 === g.value,
                              features: mv.RenderStrategy | mv.Static,
                              name: "Dialog",
                            }),
                          ),
                      ),
                    ),
                  ),
                ),
                si(_),
              ])
            }
          )
        },
      }),
      hy = Hr({
        name: "DialogPanel",
        props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } },
        setup(e, { attrs: t, slots: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-dialog-panel-${Lb()}`,
            i = dy("DialogPanel")
          function s(e) {
            e.stopPropagation()
          }
          return (
            r({ el: i.panelRef, $el: i.panelRef }),
            () => {
              let { ...r } = e
              return bv({
                ourProps: { id: o, ref: i.panelRef, onClick: s },
                theirProps: r,
                slot: { open: 0 === i.dialogState.value },
                attrs: t,
                slots: n,
                name: "DialogPanel",
              })
            }
          )
        },
      }),
      fy = Hr({
        name: "DialogTitle",
        props: { as: { type: [Object, String], default: "h2" }, id: { type: String, default: null } },
        setup(e, { attrs: t, slots: n }) {
          var r
          let a = null != (r = e.id) ? r : `headlessui-dialog-title-${Lb()}`,
            o = dy("DialogTitle")
          return (
            Nr(() => {
              o.setTitleId(a), Lr(() => o.setTitleId(null))
            }),
            () => {
              let { ...r } = e
              return bv({
                ourProps: { id: a },
                theirProps: r,
                slot: { open: 0 === o.dialogState.value },
                attrs: t,
                slots: n,
                name: "DialogTitle",
              })
            }
          )
        },
      }),
      my = ey
    var gy = ((e) => ((e[(e.Open = 0)] = "Open"), (e[(e.Closed = 1)] = "Closed"), e))(gy || {})
    let by = Symbol("DisclosureContext")
    function vy(e) {
      let t = xa(by, null)
      if (null === t) {
        let t = new Error(`<${e} /> is missing a parent <Disclosure /> component.`)
        throw (Error.captureStackTrace && Error.captureStackTrace(t, vy), t)
      }
      return t
    }
    let yy = Symbol("DisclosurePanelContext"),
      Oy = Hr({
        name: "Disclosure",
        props: { as: { type: [Object, String], default: "template" }, defaultOpen: { type: [Boolean], default: !1 } },
        setup(e, { slots: t, attrs: n }) {
          let r = Dn(e.defaultOpen ? 0 : 1),
            a = Dn(null),
            o = Dn(null),
            i = {
              buttonId: Dn(`headlessui-disclosure-button-${Lb()}`),
              panelId: Dn(`headlessui-disclosure-panel-${Lb()}`),
              disclosureState: r,
              panel: a,
              button: o,
              toggleDisclosure() {
                r.value = Bb(r.value, { 0: 1, 1: 0 })
              },
              closeDisclosure() {
                1 !== r.value && (r.value = 1)
              },
              close(e) {
                i.closeDisclosure()
                let t = e
                  ? e instanceof HTMLElement
                    ? e
                    : e.value instanceof HTMLElement
                      ? Qb(e)
                      : Qb(i.button)
                  : Qb(i.button)
                null == t || t.focus()
              },
            }
          return (
            wa(by, i),
            Tv(ii(() => Bb(r.value, { 0: Sv.Open, 1: Sv.Closed }))),
            () => {
              let { defaultOpen: a, ...o } = e
              return bv({
                theirProps: o,
                ourProps: {},
                slot: { open: 0 === r.value, close: i.close },
                slots: t,
                attrs: n,
                name: "Disclosure",
              })
            }
          )
        },
      }),
      wy = Hr({
        name: "DisclosureButton",
        props: {
          as: { type: [Object, String], default: "button" },
          disabled: { type: [Boolean], default: !1 },
          id: { type: String, default: null },
        },
        setup(e, { attrs: t, slots: n, expose: r }) {
          let a = vy("DisclosureButton"),
            o = xa(yy, null),
            i = ii(() => null !== o && o.value === a.panelId.value)
          Nr(() => {
            i.value || (null !== e.id && (a.buttonId.value = e.id))
          }),
            Lr(() => {
              i.value || (a.buttonId.value = null)
            })
          let s = Dn(null)
          r({ el: s, $el: s }),
            i.value ||
              Wa(() => {
                a.button.value = s.value
              })
          let l = uv(
            ii(() => ({ as: e.as, type: t.type })),
            s,
          )
          function c() {
            var t
            e.disabled ||
              (i.value ? (a.toggleDisclosure(), null == (t = Qb(a.button)) || t.focus()) : a.toggleDisclosure())
          }
          function d(t) {
            var n
            if (!e.disabled)
              if (i.value)
                switch (t.key) {
                  case Cv.Space:
                  case Cv.Enter:
                    t.preventDefault(),
                      t.stopPropagation(),
                      a.toggleDisclosure(),
                      null == (n = Qb(a.button)) || n.focus()
                }
              else
                switch (t.key) {
                  case Cv.Space:
                  case Cv.Enter:
                    t.preventDefault(), t.stopPropagation(), a.toggleDisclosure()
                }
          }
          function u(e) {
            e.key === Cv.Space && e.preventDefault()
          }
          return () => {
            var r
            let o = { open: 0 === a.disclosureState.value },
              { id: p, ...h } = e
            return bv({
              ourProps: i.value
                ? { ref: s, type: l.value, onClick: c, onKeydown: d }
                : {
                    id: null != (r = a.buttonId.value) ? r : p,
                    ref: s,
                    type: l.value,
                    "aria-expanded": 0 === a.disclosureState.value,
                    "aria-controls": 0 === a.disclosureState.value || Qb(a.panel) ? a.panelId.value : void 0,
                    disabled: !!e.disabled || void 0,
                    onClick: c,
                    onKeydown: d,
                    onKeyup: u,
                  },
              theirProps: h,
              slot: o,
              attrs: t,
              slots: n,
              name: "DisclosureButton",
            })
          }
        },
      }),
      xy = Hr({
        name: "DisclosurePanel",
        props: {
          as: { type: [Object, String], default: "div" },
          static: { type: Boolean, default: !1 },
          unmount: { type: Boolean, default: !0 },
          id: { type: String, default: null },
        },
        setup(e, { attrs: t, slots: n, expose: r }) {
          let a = vy("DisclosurePanel")
          Nr(() => {
            null !== e.id && (a.panelId.value = e.id)
          }),
            Lr(() => {
              a.panelId.value = null
            }),
            r({ el: a.panel, $el: a.panel }),
            wa(yy, a.panelId)
          let o = Ev(),
            i = ii(() => (null !== o ? (o.value & Sv.Open) === Sv.Open : 0 === a.disclosureState.value))
          return () => {
            var r
            let o = { open: 0 === a.disclosureState.value, close: a.close },
              { id: s, ...l } = e
            return bv({
              ourProps: { id: null != (r = a.panelId.value) ? r : s, ref: a.panel },
              theirProps: l,
              slot: o,
              attrs: t,
              slots: n,
              features: mv.RenderStrategy | mv.Static,
              visible: i.value,
              name: "DisclosurePanel",
            })
          }
        },
      }),
      ky =
        /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g
    function _y(e) {
      var t, n
      let r = null != (t = e.innerText) ? t : "",
        a = e.cloneNode(!0)
      if (!(a instanceof HTMLElement)) return r
      let o = !1
      for (let e of a.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) e.remove(), (o = !0)
      let i = o ? (null != (n = a.innerText) ? n : "") : r
      return ky.test(i) && (i = i.replace(ky, "")), i
    }
    function Sy(e) {
      let t = Dn(""),
        n = Dn("")
      return () => {
        let r = Qb(e)
        if (!r) return ""
        let a = r.innerText
        if (t.value === a) return n.value
        let o = (function (e) {
          let t = e.getAttribute("aria-label")
          if ("string" == typeof t) return t.trim()
          let n = e.getAttribute("aria-labelledby")
          if (n) {
            let e = n
              .split(" ")
              .map((e) => {
                let t = document.getElementById(e)
                if (t) {
                  let e = t.getAttribute("aria-label")
                  return "string" == typeof e ? e.trim() : _y(t).trim()
                }
                return null
              })
              .filter(Boolean)
            if (e.length > 0) return e.join(", ")
          }
          return _y(e).trim()
        })(r)
          .trim()
          .toLowerCase()
        return (t.value = a), (n.value = o), o
      }
    }
    function Ey(e, t) {
      return e === t
    }
    var Ty = ((e) => ((e[(e.Open = 0)] = "Open"), (e[(e.Closed = 1)] = "Closed"), e))(Ty || {}),
      Ay = ((e) => ((e[(e.Single = 0)] = "Single"), (e[(e.Multi = 1)] = "Multi"), e))(Ay || {}),
      Cy = ((e) => ((e[(e.Pointer = 0)] = "Pointer"), (e[(e.Other = 1)] = "Other"), e))(Cy || {})
    let Py = Symbol("ListboxContext")
    function Dy(e) {
      let t = xa(Py, null)
      if (null === t) {
        let t = new Error(`<${e} /> is missing a parent <Listbox /> component.`)
        throw (Error.captureStackTrace && Error.captureStackTrace(t, Dy), t)
      }
      return t
    }
    let Ry = Hr({
        name: "Listbox",
        emits: { "update:modelValue": (e) => !0 },
        props: {
          as: { type: [Object, String], default: "template" },
          disabled: { type: [Boolean], default: !1 },
          by: { type: [String, Function], default: () => Ey },
          horizontal: { type: [Boolean], default: !1 },
          modelValue: { type: [Object, String, Number, Boolean], default: void 0 },
          defaultValue: { type: [Object, String, Number, Boolean], default: void 0 },
          form: { type: String, optional: !0 },
          name: { type: String, optional: !0 },
          multiple: { type: [Boolean], default: !1 },
        },
        inheritAttrs: !1,
        setup(e, { slots: t, attrs: n, emit: r }) {
          let a = Dn(1),
            o = Dn(null),
            i = Dn(null),
            s = Dn(null),
            l = Dn([]),
            c = Dn(""),
            d = Dn(null),
            u = Dn(1)
          function p(e = (e) => e) {
            let t = null !== d.value ? l.value[d.value] : null,
              n = av(e(l.value.slice()), (e) => Qb(e.dataRef.domRef)),
              r = t ? n.indexOf(t) : null
            return -1 === r && (r = null), { options: n, activeOptionIndex: r }
          }
          let h = ii(() => (e.multiple ? 1 : 0)),
            [f, m] = (function (e, t, n) {
              let r = Dn(null == n ? void 0 : n.value),
                a = ii(() => void 0 !== e.value)
              return [
                ii(() => (a.value ? e.value : r.value)),
                function (e) {
                  return a.value || (r.value = e), null == t ? void 0 : t(e)
                },
              ]
            })(
              ii(() => e.modelValue),
              (e) => r("update:modelValue", e),
              ii(() => e.defaultValue),
            ),
            g = ii(() => (void 0 === f.value ? Bb(h.value, { 1: [], 0: void 0 }) : f.value)),
            b = {
              listboxState: a,
              value: g,
              mode: h,
              compare(t, n) {
                if ("string" == typeof e.by) {
                  let r = e.by
                  return (null == t ? void 0 : t[r]) === (null == n ? void 0 : n[r])
                }
                return e.by(t, n)
              },
              orientation: ii(() => (e.horizontal ? "horizontal" : "vertical")),
              labelRef: o,
              buttonRef: i,
              optionsRef: s,
              disabled: ii(() => e.disabled),
              options: l,
              searchQuery: c,
              activeOptionIndex: d,
              activationTrigger: u,
              closeListbox() {
                e.disabled || (1 !== a.value && ((a.value = 1), (d.value = null)))
              },
              openListbox() {
                e.disabled || (0 !== a.value && (a.value = 0))
              },
              goToOption(t, n, r) {
                if (e.disabled || 1 === a.value) return
                let o = p(),
                  i = Nv(t === Rv.Specific ? { focus: Rv.Specific, id: n } : { focus: t }, {
                    resolveItems: () => o.options,
                    resolveActiveIndex: () => o.activeOptionIndex,
                    resolveId: (e) => e.id,
                    resolveDisabled: (e) => e.dataRef.disabled,
                  })
                ;(c.value = ""), (d.value = i), (u.value = null != r ? r : 1), (l.value = o.options)
              },
              search(t) {
                if (e.disabled || 1 === a.value) return
                let n = "" !== c.value ? 0 : 1
                c.value += t.toLowerCase()
                let r = (
                    null !== d.value ? l.value.slice(d.value + n).concat(l.value.slice(0, d.value + n)) : l.value
                  ).find((e) => e.dataRef.textValue.startsWith(c.value) && !e.dataRef.disabled),
                  o = r ? l.value.indexOf(r) : -1
                ;-1 === o || o === d.value || ((d.value = o), (u.value = 1))
              },
              clearSearch() {
                e.disabled || (1 !== a.value && "" !== c.value && (c.value = ""))
              },
              registerOption(e, t) {
                let n = p((n) => [...n, { id: e, dataRef: t }])
                ;(l.value = n.options), (d.value = n.activeOptionIndex)
              },
              unregisterOption(e) {
                let t = p((t) => {
                  let n = t.findIndex((t) => t.id === e)
                  return -1 !== n && t.splice(n, 1), t
                })
                ;(l.value = t.options), (d.value = t.activeOptionIndex), (u.value = 1)
              },
              theirOnChange(t) {
                e.disabled || m(t)
              },
              select(t) {
                e.disabled ||
                  m(
                    Bb(h.value, {
                      0: () => t,
                      1: () => {
                        let e = _n(b.value.value).slice(),
                          n = _n(t),
                          r = e.findIndex((e) => b.compare(n, _n(e)))
                        return -1 === r ? e.push(n) : e.splice(r, 1), e
                      },
                    }),
                  )
              },
            }
          cv(
            [i, s],
            (e, t) => {
              var n
              b.closeListbox(), Jb(t, Kb.Loose) || (e.preventDefault(), null == (n = Qb(i)) || n.focus())
            },
            ii(() => 0 === a.value),
          ),
            wa(Py, b),
            Tv(ii(() => Bb(a.value, { 0: Sv.Open, 1: Sv.Closed })))
          let v = ii(() => {
            var e
            return null == (e = Qb(i)) ? void 0 : e.closest("form")
          })
          return (
            Nr(() => {
              Ya(
                [v],
                () => {
                  if (v.value && void 0 !== e.defaultValue)
                    return (
                      v.value.addEventListener("reset", t),
                      () => {
                        var e
                        null == (e = v.value) || e.removeEventListener("reset", t)
                      }
                    )
                  function t() {
                    b.theirOnChange(e.defaultValue)
                  }
                },
                { immediate: !0 },
              )
            }),
            () => {
              let { name: r, modelValue: o, disabled: i, form: s, ...l } = e,
                c = { open: 0 === a.value, disabled: i, value: g.value }
              return si(go, [
                ...(null != r && null != g.value
                  ? $v({ [r]: g.value }).map(([e, t]) =>
                      si(
                        kv,
                        (function (e) {
                          let t = Object.assign({}, e)
                          for (let e in t) void 0 === t[e] && delete t[e]
                          return t
                        })({
                          features: xv.Hidden,
                          key: e,
                          as: "input",
                          type: "hidden",
                          hidden: !0,
                          readOnly: !0,
                          form: s,
                          disabled: i,
                          name: e,
                          value: t,
                        }),
                      ),
                    )
                  : []),
                bv({
                  ourProps: {},
                  theirProps: {
                    ...n,
                    ...wv(l, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"]),
                  },
                  slot: c,
                  slots: t,
                  attrs: n,
                  name: "Listbox",
                }),
              ])
            }
          )
        },
      }),
      Ny = Hr({
        name: "ListboxButton",
        props: { as: { type: [Object, String], default: "button" }, id: { type: String, default: null } },
        setup(e, { attrs: t, slots: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-listbox-button-${Lb()}`,
            i = Dy("ListboxButton")
          function s(e) {
            switch (e.key) {
              case Cv.Space:
              case Cv.Enter:
              case Cv.ArrowDown:
                e.preventDefault(),
                  i.openListbox(),
                  rr(() => {
                    var e
                    null == (e = Qb(i.optionsRef)) || e.focus({ preventScroll: !0 }),
                      i.value.value || i.goToOption(Rv.First)
                  })
                break
              case Cv.ArrowUp:
                e.preventDefault(),
                  i.openListbox(),
                  rr(() => {
                    var e
                    null == (e = Qb(i.optionsRef)) || e.focus({ preventScroll: !0 }),
                      i.value.value || i.goToOption(Rv.Last)
                  })
            }
          }
          function l(e) {
            e.key === Cv.Space && e.preventDefault()
          }
          function c(e) {
            i.disabled.value ||
              (0 === i.listboxState.value
                ? (i.closeListbox(),
                  rr(() => {
                    var e
                    return null == (e = Qb(i.buttonRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  }))
                : (e.preventDefault(),
                  i.openListbox(),
                  (function (e) {
                    requestAnimationFrame(() => requestAnimationFrame(e))
                  })(() => {
                    var e
                    return null == (e = Qb(i.optionsRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  })))
          }
          r({ el: i.buttonRef, $el: i.buttonRef })
          let d = uv(
            ii(() => ({ as: e.as, type: t.type })),
            i.buttonRef,
          )
          return () => {
            var r, a
            let u = { open: 0 === i.listboxState.value, disabled: i.disabled.value, value: i.value.value },
              { ...p } = e
            return bv({
              ourProps: {
                ref: i.buttonRef,
                id: o,
                type: d.value,
                "aria-haspopup": "listbox",
                "aria-controls": null == (r = Qb(i.optionsRef)) ? void 0 : r.id,
                "aria-expanded": 0 === i.listboxState.value,
                "aria-labelledby": i.labelRef.value
                  ? [null == (a = Qb(i.labelRef)) ? void 0 : a.id, o].join(" ")
                  : void 0,
                disabled: !0 === i.disabled.value || void 0,
                onKeydown: s,
                onKeyup: l,
                onClick: c,
              },
              theirProps: p,
              slot: u,
              attrs: t,
              slots: n,
              name: "ListboxButton",
            })
          }
        },
      }),
      $y = Hr({
        name: "ListboxOptions",
        props: {
          as: { type: [Object, String], default: "ul" },
          static: { type: Boolean, default: !1 },
          unmount: { type: Boolean, default: !0 },
          id: { type: String, default: null },
        },
        setup(e, { attrs: t, slots: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-listbox-options-${Lb()}`,
            i = Dy("ListboxOptions"),
            s = Dn(null)
          function l(e) {
            switch ((s.value && clearTimeout(s.value), e.key)) {
              case Cv.Space:
                if ("" !== i.searchQuery.value) return e.preventDefault(), e.stopPropagation(), i.search(e.key)
              case Cv.Enter:
                if ((e.preventDefault(), e.stopPropagation(), null !== i.activeOptionIndex.value)) {
                  let e = i.options.value[i.activeOptionIndex.value]
                  i.select(e.dataRef.value)
                }
                0 === i.mode.value &&
                  (i.closeListbox(),
                  rr(() => {
                    var e
                    return null == (e = Qb(i.buttonRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  }))
                break
              case Bb(i.orientation.value, { vertical: Cv.ArrowDown, horizontal: Cv.ArrowRight }):
                return e.preventDefault(), e.stopPropagation(), i.goToOption(Rv.Next)
              case Bb(i.orientation.value, { vertical: Cv.ArrowUp, horizontal: Cv.ArrowLeft }):
                return e.preventDefault(), e.stopPropagation(), i.goToOption(Rv.Previous)
              case Cv.Home:
              case Cv.PageUp:
                return e.preventDefault(), e.stopPropagation(), i.goToOption(Rv.First)
              case Cv.End:
              case Cv.PageDown:
                return e.preventDefault(), e.stopPropagation(), i.goToOption(Rv.Last)
              case Cv.Escape:
                e.preventDefault(),
                  e.stopPropagation(),
                  i.closeListbox(),
                  rr(() => {
                    var e
                    return null == (e = Qb(i.buttonRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  })
                break
              case Cv.Tab:
                e.preventDefault(), e.stopPropagation()
                break
              default:
                1 === e.key.length && (i.search(e.key), (s.value = setTimeout(() => i.clearSearch(), 350)))
            }
          }
          r({ el: i.optionsRef, $el: i.optionsRef })
          let c = Ev(),
            d = ii(() => (null !== c ? (c.value & Sv.Open) === Sv.Open : 0 === i.listboxState.value))
          return () => {
            var r, a
            let s = { open: 0 === i.listboxState.value },
              { ...c } = e
            return bv({
              ourProps: {
                "aria-activedescendant":
                  null === i.activeOptionIndex.value || null == (r = i.options.value[i.activeOptionIndex.value])
                    ? void 0
                    : r.id,
                "aria-multiselectable": 1 === i.mode.value || void 0,
                "aria-labelledby": null == (a = Qb(i.buttonRef)) ? void 0 : a.id,
                "aria-orientation": i.orientation.value,
                id: o,
                onKeydown: l,
                role: "listbox",
                tabIndex: 0,
                ref: i.optionsRef,
              },
              theirProps: c,
              slot: s,
              attrs: t,
              slots: n,
              features: mv.RenderStrategy | mv.Static,
              visible: d.value,
              name: "ListboxOptions",
            })
          }
        },
      }),
      Iy = Hr({
        name: "ListboxOption",
        props: {
          as: { type: [Object, String], default: "li" },
          value: { type: [Object, String, Number, Boolean] },
          disabled: { type: Boolean, default: !1 },
          id: { type: String, default: null },
        },
        setup(e, { slots: t, attrs: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-listbox-option-${Lb()}`,
            i = Dy("ListboxOption"),
            s = Dn(null)
          r({ el: s, $el: s })
          let l = ii(() => null !== i.activeOptionIndex.value && i.options.value[i.activeOptionIndex.value].id === o),
            c = ii(() =>
              Bb(i.mode.value, {
                0: () => i.compare(_n(i.value.value), _n(e.value)),
                1: () => _n(i.value.value).some((t) => i.compare(_n(t), _n(e.value))),
              }),
            ),
            d = ii(() =>
              Bb(i.mode.value, {
                1: () => {
                  var e
                  let t = _n(i.value.value)
                  return (
                    (null == (e = i.options.value.find((e) => t.some((t) => i.compare(_n(t), _n(e.dataRef.value)))))
                      ? void 0
                      : e.id) === o
                  )
                },
                0: () => c.value,
              }),
            ),
            u = Sy(s),
            p = ii(() => ({
              disabled: e.disabled,
              value: e.value,
              get textValue() {
                return u()
              },
              domRef: s,
            }))
          function h(t) {
            if (e.disabled) return t.preventDefault()
            i.select(e.value),
              0 === i.mode.value &&
                (i.closeListbox(),
                rr(() => {
                  var e
                  return null == (e = Qb(i.buttonRef)) ? void 0 : e.focus({ preventScroll: !0 })
                }))
          }
          function f() {
            if (e.disabled) return i.goToOption(Rv.Nothing)
            i.goToOption(Rv.Specific, o)
          }
          Nr(() => i.registerOption(o, p)),
            Lr(() => i.unregisterOption(o)),
            Nr(() => {
              Ya(
                [i.listboxState, c],
                () => {
                  0 === i.listboxState.value &&
                    c.value &&
                    Bb(i.mode.value, {
                      1: () => {
                        d.value && i.goToOption(Rv.Specific, o)
                      },
                      0: () => {
                        i.goToOption(Rv.Specific, o)
                      },
                    })
                },
                { immediate: !0 },
              )
            }),
            Wa(() => {
              0 === i.listboxState.value &&
                l.value &&
                0 !== i.activationTrigger.value &&
                rr(() => {
                  var e, t
                  return null == (t = null == (e = Qb(s)) ? void 0 : e.scrollIntoView)
                    ? void 0
                    : t.call(e, { block: "nearest" })
                })
            })
          let m = hv()
          function g(e) {
            m.update(e)
          }
          function b(t) {
            m.wasMoved(t) && (e.disabled || l.value || i.goToOption(Rv.Specific, o, 0))
          }
          function v(t) {
            m.wasMoved(t) && (e.disabled || (l.value && i.goToOption(Rv.Nothing)))
          }
          return () => {
            let { disabled: r } = e,
              a = { active: l.value, selected: c.value, disabled: r },
              { value: i, disabled: d, ...u } = e
            return bv({
              ourProps: {
                id: o,
                ref: s,
                role: "option",
                tabIndex: !0 === r ? void 0 : -1,
                "aria-disabled": !0 === r || void 0,
                "aria-selected": c.value,
                disabled: void 0,
                onClick: h,
                onFocus: f,
                onPointerenter: g,
                onMouseenter: g,
                onPointermove: b,
                onMousemove: b,
                onPointerleave: v,
                onMouseleave: v,
              },
              theirProps: u,
              slot: a,
              attrs: n,
              slots: t,
              name: "ListboxOption",
            })
          }
        },
      })
    var My = ((e) => ((e[(e.Open = 0)] = "Open"), (e[(e.Closed = 1)] = "Closed"), e))(My || {}),
      Ly = ((e) => ((e[(e.Pointer = 0)] = "Pointer"), (e[(e.Other = 1)] = "Other"), e))(Ly || {})
    let Qy = Symbol("MenuContext")
    function By(e) {
      let t = xa(Qy, null)
      if (null === t) {
        let t = new Error(`<${e} /> is missing a parent <Menu /> component.`)
        throw (Error.captureStackTrace && Error.captureStackTrace(t, By), t)
      }
      return t
    }
    let jy = Hr({
        name: "Menu",
        props: { as: { type: [Object, String], default: "template" } },
        setup(e, { slots: t, attrs: n }) {
          let r = Dn(1),
            a = Dn(null),
            o = Dn(null),
            i = Dn([]),
            s = Dn(""),
            l = Dn(null),
            c = Dn(1)
          function d(e = (e) => e) {
            let t = null !== l.value ? i.value[l.value] : null,
              n = av(e(i.value.slice()), (e) => Qb(e.dataRef.domRef)),
              r = t ? n.indexOf(t) : null
            return -1 === r && (r = null), { items: n, activeItemIndex: r }
          }
          let u = {
            menuState: r,
            buttonRef: a,
            itemsRef: o,
            items: i,
            searchQuery: s,
            activeItemIndex: l,
            activationTrigger: c,
            closeMenu: () => {
              ;(r.value = 1), (l.value = null)
            },
            openMenu: () => (r.value = 0),
            goToItem(e, t, n) {
              let r = d(),
                a = Nv(e === Rv.Specific ? { focus: Rv.Specific, id: t } : { focus: e }, {
                  resolveItems: () => r.items,
                  resolveActiveIndex: () => r.activeItemIndex,
                  resolveId: (e) => e.id,
                  resolveDisabled: (e) => e.dataRef.disabled,
                })
              ;(s.value = ""), (l.value = a), (c.value = null != n ? n : 1), (i.value = r.items)
            },
            search(e) {
              let t = "" !== s.value ? 0 : 1
              s.value += e.toLowerCase()
              let n = (
                  null !== l.value ? i.value.slice(l.value + t).concat(i.value.slice(0, l.value + t)) : i.value
                ).find((e) => e.dataRef.textValue.startsWith(s.value) && !e.dataRef.disabled),
                r = n ? i.value.indexOf(n) : -1
              ;-1 === r || r === l.value || ((l.value = r), (c.value = 1))
            },
            clearSearch() {
              s.value = ""
            },
            registerItem(e, t) {
              let n = d((n) => [...n, { id: e, dataRef: t }])
              ;(i.value = n.items), (l.value = n.activeItemIndex), (c.value = 1)
            },
            unregisterItem(e) {
              let t = d((t) => {
                let n = t.findIndex((t) => t.id === e)
                return -1 !== n && t.splice(n, 1), t
              })
              ;(i.value = t.items), (l.value = t.activeItemIndex), (c.value = 1)
            },
          }
          return (
            cv(
              [a, o],
              (e, t) => {
                var n
                u.closeMenu(), Jb(t, Kb.Loose) || (e.preventDefault(), null == (n = Qb(a)) || n.focus())
              },
              ii(() => 0 === r.value),
            ),
            wa(Qy, u),
            Tv(ii(() => Bb(r.value, { 0: Sv.Open, 1: Sv.Closed }))),
            () => {
              let a = { open: 0 === r.value, close: u.closeMenu }
              return bv({ ourProps: {}, theirProps: e, slot: a, slots: t, attrs: n, name: "Menu" })
            }
          )
        },
      }),
      Uy = Hr({
        name: "MenuButton",
        props: {
          disabled: { type: Boolean, default: !1 },
          as: { type: [Object, String], default: "button" },
          id: { type: String, default: null },
        },
        setup(e, { attrs: t, slots: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-menu-button-${Lb()}`,
            i = By("MenuButton")
          function s(e) {
            switch (e.key) {
              case Cv.Space:
              case Cv.Enter:
              case Cv.ArrowDown:
                e.preventDefault(),
                  e.stopPropagation(),
                  i.openMenu(),
                  rr(() => {
                    var e
                    null == (e = Qb(i.itemsRef)) || e.focus({ preventScroll: !0 }), i.goToItem(Rv.First)
                  })
                break
              case Cv.ArrowUp:
                e.preventDefault(),
                  e.stopPropagation(),
                  i.openMenu(),
                  rr(() => {
                    var e
                    null == (e = Qb(i.itemsRef)) || e.focus({ preventScroll: !0 }), i.goToItem(Rv.Last)
                  })
            }
          }
          function l(e) {
            e.key === Cv.Space && e.preventDefault()
          }
          function c(t) {
            e.disabled ||
              (0 === i.menuState.value
                ? (i.closeMenu(),
                  rr(() => {
                    var e
                    return null == (e = Qb(i.buttonRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  }))
                : (t.preventDefault(),
                  i.openMenu(),
                  (function (e) {
                    requestAnimationFrame(() => requestAnimationFrame(e))
                  })(() => {
                    var e
                    return null == (e = Qb(i.itemsRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  })))
          }
          r({ el: i.buttonRef, $el: i.buttonRef })
          let d = uv(
            ii(() => ({ as: e.as, type: t.type })),
            i.buttonRef,
          )
          return () => {
            var r
            let a = { open: 0 === i.menuState.value },
              { ...u } = e
            return bv({
              ourProps: {
                ref: i.buttonRef,
                id: o,
                type: d.value,
                "aria-haspopup": "menu",
                "aria-controls": null == (r = Qb(i.itemsRef)) ? void 0 : r.id,
                "aria-expanded": 0 === i.menuState.value,
                onKeydown: s,
                onKeyup: l,
                onClick: c,
              },
              theirProps: u,
              slot: a,
              attrs: t,
              slots: n,
              name: "MenuButton",
            })
          }
        },
      }),
      Fy = Hr({
        name: "MenuItems",
        props: {
          as: { type: [Object, String], default: "div" },
          static: { type: Boolean, default: !1 },
          unmount: { type: Boolean, default: !0 },
          id: { type: String, default: null },
        },
        setup(e, { attrs: t, slots: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-menu-items-${Lb()}`,
            i = By("MenuItems"),
            s = Dn(null)
          function l(e) {
            var t
            switch ((s.value && clearTimeout(s.value), e.key)) {
              case Cv.Space:
                if ("" !== i.searchQuery.value) return e.preventDefault(), e.stopPropagation(), i.search(e.key)
              case Cv.Enter:
                e.preventDefault(),
                  e.stopPropagation(),
                  null !== i.activeItemIndex.value &&
                    (null == (t = Qb(i.items.value[i.activeItemIndex.value].dataRef.domRef)) || t.click()),
                  i.closeMenu(),
                  ev(Qb(i.buttonRef))
                break
              case Cv.ArrowDown:
                return e.preventDefault(), e.stopPropagation(), i.goToItem(Rv.Next)
              case Cv.ArrowUp:
                return e.preventDefault(), e.stopPropagation(), i.goToItem(Rv.Previous)
              case Cv.Home:
              case Cv.PageUp:
                return e.preventDefault(), e.stopPropagation(), i.goToItem(Rv.First)
              case Cv.End:
              case Cv.PageDown:
                return e.preventDefault(), e.stopPropagation(), i.goToItem(Rv.Last)
              case Cv.Escape:
                e.preventDefault(),
                  e.stopPropagation(),
                  i.closeMenu(),
                  rr(() => {
                    var e
                    return null == (e = Qb(i.buttonRef)) ? void 0 : e.focus({ preventScroll: !0 })
                  })
                break
              case Cv.Tab:
                e.preventDefault(),
                  e.stopPropagation(),
                  i.closeMenu(),
                  rr(() =>
                    (function (e, t) {
                      return ov(Gb(), t, { relativeTo: e })
                    })(Qb(i.buttonRef), e.shiftKey ? Wb.Previous : Wb.Next),
                  )
                break
              default:
                1 === e.key.length && (i.search(e.key), (s.value = setTimeout(() => i.clearSearch(), 350)))
            }
          }
          function c(e) {
            e.key === Cv.Space && e.preventDefault()
          }
          r({ el: i.itemsRef, $el: i.itemsRef }),
            (function ({ container: e, accept: t, walk: n, enabled: r }) {
              Wa(() => {
                let a = e.value
                if (!a || (void 0 !== r && !r.value)) return
                let o = zb(e)
                if (!o) return
                let i = Object.assign((e) => t(e), { acceptNode: t }),
                  s = o.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, i, !1)
                for (; s.nextNode(); ) n(s.currentNode)
              })
            })({
              container: ii(() => Qb(i.itemsRef)),
              enabled: ii(() => 0 === i.menuState.value),
              accept: (e) =>
                "menuitem" === e.getAttribute("role")
                  ? NodeFilter.FILTER_REJECT
                  : e.hasAttribute("role")
                    ? NodeFilter.FILTER_SKIP
                    : NodeFilter.FILTER_ACCEPT,
              walk(e) {
                e.setAttribute("role", "none")
              },
            })
          let d = Ev(),
            u = ii(() => (null !== d ? (d.value & Sv.Open) === Sv.Open : 0 === i.menuState.value))
          return () => {
            var r, a
            let s = { open: 0 === i.menuState.value },
              { ...d } = e
            return bv({
              ourProps: {
                "aria-activedescendant":
                  null === i.activeItemIndex.value || null == (r = i.items.value[i.activeItemIndex.value])
                    ? void 0
                    : r.id,
                "aria-labelledby": null == (a = Qb(i.buttonRef)) ? void 0 : a.id,
                id: o,
                onKeydown: l,
                onKeyup: c,
                role: "menu",
                tabIndex: 0,
                ref: i.itemsRef,
              },
              theirProps: d,
              slot: s,
              attrs: t,
              slots: n,
              features: mv.RenderStrategy | mv.Static,
              visible: u.value,
              name: "MenuItems",
            })
          }
        },
      }),
      zy = Hr({
        name: "MenuItem",
        inheritAttrs: !1,
        props: {
          as: { type: [Object, String], default: "template" },
          disabled: { type: Boolean, default: !1 },
          id: { type: String, default: null },
        },
        setup(e, { slots: t, attrs: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-menu-item-${Lb()}`,
            i = By("MenuItem"),
            s = Dn(null)
          r({ el: s, $el: s })
          let l = ii(() => null !== i.activeItemIndex.value && i.items.value[i.activeItemIndex.value].id === o),
            c = Sy(s),
            d = ii(() => ({
              disabled: e.disabled,
              get textValue() {
                return c()
              },
              domRef: s,
            }))
          function u(t) {
            if (e.disabled) return t.preventDefault()
            i.closeMenu(), ev(Qb(i.buttonRef))
          }
          function p() {
            if (e.disabled) return i.goToItem(Rv.Nothing)
            i.goToItem(Rv.Specific, o)
          }
          Nr(() => i.registerItem(o, d)),
            Lr(() => i.unregisterItem(o)),
            Wa(() => {
              0 === i.menuState.value &&
                l.value &&
                0 !== i.activationTrigger.value &&
                rr(() => {
                  var e, t
                  return null == (t = null == (e = Qb(s)) ? void 0 : e.scrollIntoView)
                    ? void 0
                    : t.call(e, { block: "nearest" })
                })
            })
          let h = hv()
          function f(e) {
            h.update(e)
          }
          function m(t) {
            h.wasMoved(t) && (e.disabled || l.value || i.goToItem(Rv.Specific, o, 0))
          }
          function g(t) {
            h.wasMoved(t) && (e.disabled || (l.value && i.goToItem(Rv.Nothing)))
          }
          return () => {
            let { disabled: r, ...a } = e,
              c = { active: l.value, disabled: r, close: i.closeMenu }
            return bv({
              ourProps: {
                id: o,
                ref: s,
                role: "menuitem",
                tabIndex: !0 === r ? void 0 : -1,
                "aria-disabled": !0 === r || void 0,
                onClick: u,
                onFocus: p,
                onPointerenter: f,
                onMouseenter: f,
                onPointermove: m,
                onMousemove: m,
                onPointerleave: g,
                onMouseleave: g,
              },
              theirProps: { ...n, ...a },
              slot: c,
              attrs: n,
              slots: t,
              name: "MenuItem",
            })
          }
        },
      }),
      qy = Hr({
        props: { onFocus: { type: Function, required: !0 } },
        setup(e) {
          let t = Dn(!0)
          return () =>
            t.value
              ? si(kv, {
                  as: "button",
                  type: "button",
                  features: xv.Focusable,
                  onFocus(n) {
                    n.preventDefault()
                    let r,
                      a = 50
                    r = requestAnimationFrame(function n() {
                      var o
                      if (!(a-- <= 0))
                        return null != (o = e.onFocus) && o.call(e)
                          ? ((t.value = !1), void cancelAnimationFrame(r))
                          : void (r = requestAnimationFrame(n))
                      r && cancelAnimationFrame(r)
                    })
                  },
                })
              : null
        },
      })
    var Zy,
      Hy,
      Vy = (((Hy = Vy || {})[(Hy.Forwards = 0)] = "Forwards"), (Hy[(Hy.Backwards = 1)] = "Backwards"), Hy),
      Wy =
        (((Zy = Wy || {})[(Zy.Less = -1)] = "Less"),
        (Zy[(Zy.Equal = 0)] = "Equal"),
        (Zy[(Zy.Greater = 1)] = "Greater"),
        Zy)
    let Xy = Symbol("TabsContext")
    function Yy(e) {
      let t = xa(Xy, null)
      if (null === t) {
        let t = new Error(`<${e} /> is missing a parent <TabGroup /> component.`)
        throw (Error.captureStackTrace && Error.captureStackTrace(t, Yy), t)
      }
      return t
    }
    let Gy = Symbol("TabsSSRContext"),
      Ky = Hr({
        name: "TabGroup",
        emits: { change: (e) => !0 },
        props: {
          as: { type: [Object, String], default: "template" },
          selectedIndex: { type: [Number], default: null },
          defaultIndex: { type: [Number], default: 0 },
          vertical: { type: [Boolean], default: !1 },
          manual: { type: [Boolean], default: !1 },
        },
        inheritAttrs: !1,
        setup(e, { slots: t, attrs: n, emit: r }) {
          var a
          let o = Dn(null != (a = e.selectedIndex) ? a : e.defaultIndex),
            i = Dn([]),
            s = Dn([]),
            l = ii(() => null !== e.selectedIndex),
            c = ii(() => (l.value ? e.selectedIndex : o.value))
          function d(e) {
            var t
            let n = av(u.tabs.value, Qb),
              r = av(u.panels.value, Qb),
              a = n.filter((e) => {
                var t
                return !(null != (t = Qb(e)) && t.hasAttribute("disabled"))
              })
            if (e < 0 || e > n.length - 1) {
              let t = Bb(null === o.value ? 0 : Math.sign(e - o.value), {
                  [-1]: () => 1,
                  0: () => Bb(Math.sign(e), { [-1]: () => 0, 0: () => 0, 1: () => 1 }),
                  1: () => 0,
                }),
                i = Bb(t, { 0: () => n.indexOf(a[0]), 1: () => n.indexOf(a[a.length - 1]) })
              ;-1 !== i && (o.value = i), (u.tabs.value = n), (u.panels.value = r)
            } else {
              let i = n.slice(0, e),
                s = [...n.slice(e), ...i].find((e) => a.includes(e))
              if (!s) return
              let l = null != (t = n.indexOf(s)) ? t : u.selectedIndex.value
              ;-1 === l && (l = u.selectedIndex.value), (o.value = l), (u.tabs.value = n), (u.panels.value = r)
            }
          }
          let u = {
            selectedIndex: ii(() => {
              var t, n
              return null != (n = null != (t = o.value) ? t : e.defaultIndex) ? n : null
            }),
            orientation: ii(() => (e.vertical ? "vertical" : "horizontal")),
            activation: ii(() => (e.manual ? "manual" : "auto")),
            tabs: i,
            panels: s,
            setSelectedIndex(e) {
              c.value !== e && r("change", e), l.value || d(e)
            },
            registerTab(e) {
              var t
              if (i.value.includes(e)) return
              let n = i.value[o.value]
              if ((i.value.push(e), (i.value = av(i.value, Qb)), !l.value)) {
                let e = null != (t = i.value.indexOf(n)) ? t : o.value
                ;-1 !== e && (o.value = e)
              }
            },
            unregisterTab(e) {
              let t = i.value.indexOf(e)
              ;-1 !== t && i.value.splice(t, 1)
            },
            registerPanel(e) {
              s.value.includes(e) || (s.value.push(e), (s.value = av(s.value, Qb)))
            },
            unregisterPanel(e) {
              let t = s.value.indexOf(e)
              ;-1 !== t && s.value.splice(t, 1)
            },
          }
          wa(Xy, u)
          let p = Dn({ tabs: [], panels: [] }),
            h = Dn(!1)
          Nr(() => {
            h.value = !0
          }),
            wa(
              Gy,
              ii(() => (h.value ? null : p.value)),
            )
          let f = ii(() => e.selectedIndex)
          return (
            Nr(() => {
              Ya(
                [f],
                () => {
                  var t
                  return d(null != (t = e.selectedIndex) ? t : e.defaultIndex)
                },
                { immediate: !0 },
              )
            }),
            Wa(() => {
              if (!l.value || null == c.value || u.tabs.value.length <= 0) return
              let e = av(u.tabs.value, Qb)
              e.some((e, t) => Qb(u.tabs.value[t]) !== Qb(e)) &&
                u.setSelectedIndex(e.findIndex((e) => Qb(e) === Qb(u.tabs.value[c.value])))
            }),
            () => {
              let r = { selectedIndex: o.value }
              return si(go, [
                i.value.length <= 0 &&
                  si(qy, {
                    onFocus: () => {
                      for (let e of i.value) {
                        let t = Qb(e)
                        if (0 === (null == t ? void 0 : t.tabIndex)) return t.focus(), !0
                      }
                      return !1
                    },
                  }),
                bv({
                  theirProps: { ...n, ...wv(e, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"]) },
                  ourProps: {},
                  slot: r,
                  slots: t,
                  attrs: n,
                  name: "TabGroup",
                }),
              ])
            }
          )
        },
      }),
      Jy = Hr({
        name: "TabList",
        props: { as: { type: [Object, String], default: "div" } },
        setup(e, { attrs: t, slots: n }) {
          let r = Yy("TabList")
          return () => {
            let a = { selectedIndex: r.selectedIndex.value }
            return bv({
              ourProps: { role: "tablist", "aria-orientation": r.orientation.value },
              theirProps: e,
              slot: a,
              attrs: t,
              slots: n,
              name: "TabList",
            })
          }
        },
      }),
      eO = Hr({
        name: "Tab",
        props: {
          as: { type: [Object, String], default: "button" },
          disabled: { type: [Boolean], default: !1 },
          id: { type: String, default: null },
        },
        setup(e, { attrs: t, slots: n, expose: r }) {
          var a
          let o = null != (a = e.id) ? a : `headlessui-tabs-tab-${Lb()}`,
            i = Yy("Tab"),
            s = Dn(null)
          r({ el: s, $el: s }), Nr(() => i.registerTab(s)), Lr(() => i.unregisterTab(s))
          let l = xa(Gy),
            c = ii(() => {
              if (l.value) {
                let e = l.value.tabs.indexOf(o)
                return -1 === e ? l.value.tabs.push(o) - 1 : e
              }
              return -1
            }),
            d = ii(() => {
              let e = i.tabs.value.indexOf(s)
              return -1 === e ? c.value : e
            }),
            u = ii(() => d.value === i.selectedIndex.value)
          function p(e) {
            var t
            let n = e()
            if (n === Xb.Success && "auto" === i.activation.value) {
              let e = null == (t = zb(s)) ? void 0 : t.activeElement,
                n = i.tabs.value.findIndex((t) => Qb(t) === e)
              ;-1 !== n && i.setSelectedIndex(n)
            }
            return n
          }
          function h(e) {
            let t = i.tabs.value.map((e) => Qb(e)).filter(Boolean)
            if (e.key === Cv.Space || e.key === Cv.Enter)
              return e.preventDefault(), e.stopPropagation(), void i.setSelectedIndex(d.value)
            switch (e.key) {
              case Cv.Home:
              case Cv.PageUp:
                return e.preventDefault(), e.stopPropagation(), p(() => ov(t, Wb.First))
              case Cv.End:
              case Cv.PageDown:
                return e.preventDefault(), e.stopPropagation(), p(() => ov(t, Wb.Last))
            }
            return p(() =>
              Bb(i.orientation.value, {
                vertical: () =>
                  e.key === Cv.ArrowUp
                    ? ov(t, Wb.Previous | Wb.WrapAround)
                    : e.key === Cv.ArrowDown
                      ? ov(t, Wb.Next | Wb.WrapAround)
                      : Xb.Error,
                horizontal: () =>
                  e.key === Cv.ArrowLeft
                    ? ov(t, Wb.Previous | Wb.WrapAround)
                    : e.key === Cv.ArrowRight
                      ? ov(t, Wb.Next | Wb.WrapAround)
                      : Xb.Error,
              }),
            ) === Xb.Success
              ? e.preventDefault()
              : void 0
          }
          let f = Dn(!1)
          function m() {
            var t
            f.value ||
              ((f.value = !0),
              !e.disabled &&
                (null == (t = Qb(s)) || t.focus({ preventScroll: !0 }),
                i.setSelectedIndex(d.value),
                Nb(() => {
                  f.value = !1
                })))
          }
          function g(e) {
            e.preventDefault()
          }
          let b = uv(
            ii(() => ({ as: e.as, type: t.type })),
            s,
          )
          return () => {
            var r, a
            let l = { selected: u.value, disabled: null != (r = e.disabled) && r },
              { ...c } = e
            return bv({
              ourProps: {
                ref: s,
                onKeydown: h,
                onMousedown: g,
                onClick: m,
                id: o,
                role: "tab",
                type: b.value,
                "aria-controls": null == (a = Qb(i.panels.value[d.value])) ? void 0 : a.id,
                "aria-selected": u.value,
                tabIndex: u.value ? 0 : -1,
                disabled: !!e.disabled || void 0,
              },
              theirProps: c,
              slot: l,
              attrs: t,
              slots: n,
              name: "Tab",
            })
          }
        },
      })
    function tO(e) {
      var t,
        n,
        r = ""
      if ("string" == typeof e || "number" == typeof e) r += e
      else if ("object" == typeof e)
        if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = tO(e[t])) && (r && (r += " "), (r += n))
        else for (t in e) e[t] && (r && (r += " "), (r += t))
      return r
    }
    function nO() {
      for (var e, t, n = 0, r = ""; n < arguments.length; )
        (e = arguments[n++]) && (t = tO(e)) && (r && (r += " "), (r += t))
      return r
    }
    const rO = (e) => ("boolean" == typeof e ? "".concat(e) : 0 === e ? "0" : e),
      aO = (e) => {
        const t = function () {
          for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r]
          var a, o
          return void 0 !== (null == e || null === (a = e.hooks) || void 0 === a ? void 0 : a["cx:done"])
            ? null == e
              ? void 0
              : e.hooks["cx:done"](nO(n))
            : void 0 !== (null == e || null === (o = e.hooks) || void 0 === o ? void 0 : o.onComplete)
              ? null == e
                ? void 0
                : e.hooks.onComplete(nO(n))
              : nO(n)
        }
        return {
          compose: function () {
            for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r]
            return (e) => {
              const r = Object.fromEntries(
                Object.entries(e || {}).filter((e) => {
                  let [t] = e
                  return !["class", "className"].includes(t)
                }),
              )
              return t(
                n.map((e) => e(r)),
                null == e ? void 0 : e.class,
                null == e ? void 0 : e.className,
              )
            }
          },
          cva: (e) => (n) => {
            var r
            if (null == (null == e ? void 0 : e.variants))
              return t(null == e ? void 0 : e.base, null == n ? void 0 : n.class, null == n ? void 0 : n.className)
            const { variants: a, defaultVariants: o } = e,
              i = Object.keys(a).map((e) => {
                const t = null == n ? void 0 : n[e],
                  r = null == o ? void 0 : o[e],
                  i = rO(t) || rO(r)
                return a[e][i]
              }),
              s = {
                ...o,
                ...(n &&
                  Object.entries(n).reduce((e, t) => {
                    let [n, r] = t
                    return void 0 === r ? e : { ...e, [n]: r }
                  }, {})),
              },
              l =
                null == e || null === (r = e.compoundVariants) || void 0 === r
                  ? void 0
                  : r.reduce((e, t) => {
                      let { class: n, className: r, ...a } = t
                      return Object.entries(a).every((e) => {
                        let [t, n] = e
                        const r = s[t]
                        return Array.isArray(n) ? n.includes(r) : r === n
                      })
                        ? [...e, n, r]
                        : e
                    }, [])
            return t(null == e ? void 0 : e.base, i, l, null == n ? void 0 : n.class, null == n ? void 0 : n.className)
          },
          cx: t,
        }
      },
      { compose: oO, cva: iO, cx: sO } = aO(),
      lO = "-"
    function cO(e) {
      const t = (function (e) {
          const { theme: t, prefix: n } = e,
            r = { nextPart: new Map(), validators: [] },
            a = (function (e, t) {
              return t
                ? e.map(([e, n]) => [
                    e,
                    n.map((e) =>
                      "string" == typeof e
                        ? t + e
                        : "object" == typeof e
                          ? Object.fromEntries(Object.entries(e).map(([e, n]) => [t + e, n]))
                          : e,
                    ),
                  ])
                : e
            })(Object.entries(e.classGroups), n)
          return (
            a.forEach(([e, n]) => {
              pO(n, r, e, t)
            }),
            r
          )
        })(e),
        { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e
      return {
        getClassGroupId: function (e) {
          const n = e.split(lO)
          return (
            "" === n[0] && 1 !== n.length && n.shift(),
            dO(n, t) ||
              (function (e) {
                if (uO.test(e)) {
                  const t = uO.exec(e)[1],
                    n = null == t ? void 0 : t.substring(0, t.indexOf(":"))
                  if (n) return "arbitrary.." + n
                }
              })(e)
          )
        },
        getConflictingClassGroupIds: function (e, t) {
          const a = n[e] || []
          return t && r[e] ? [...a, ...r[e]] : a
        },
      }
    }
    function dO(e, t) {
      var n
      if (0 === e.length) return t.classGroupId
      const r = e[0],
        a = t.nextPart.get(r),
        o = a ? dO(e.slice(1), a) : void 0
      if (o) return o
      if (0 === t.validators.length) return
      const i = e.join(lO)
      return null == (n = t.validators.find(({ validator: e }) => e(i))) ? void 0 : n.classGroupId
    }
    const uO = /^\[(.+)\]$/
    function pO(e, t, n, r) {
      e.forEach((e) => {
        if ("string" != typeof e) {
          if ("function" == typeof e)
            return e.isThemeGetter ? void pO(e(r), t, n, r) : void t.validators.push({ validator: e, classGroupId: n })
          Object.entries(e).forEach(([e, a]) => {
            pO(a, hO(t, e), n, r)
          })
        } else ("" === e ? t : hO(t, e)).classGroupId = n
      })
    }
    function hO(e, t) {
      let n = e
      return (
        t.split(lO).forEach((e) => {
          n.nextPart.has(e) || n.nextPart.set(e, { nextPart: new Map(), validators: [] }), (n = n.nextPart.get(e))
        }),
        n
      )
    }
    function fO(e) {
      if (e < 1) return { get: () => {}, set: () => {} }
      let t = 0,
        n = new Map(),
        r = new Map()
      function a(a, o) {
        n.set(a, o), t++, t > e && ((t = 0), (r = n), (n = new Map()))
      }
      return {
        get(e) {
          let t = n.get(e)
          return void 0 !== t ? t : void 0 !== (t = r.get(e)) ? (a(e, t), t) : void 0
        },
        set(e, t) {
          n.has(e) ? n.set(e, t) : a(e, t)
        },
      }
    }
    const mO = "!"
    function gO(e) {
      const t = e.separator,
        n = 1 === t.length,
        r = t[0],
        a = t.length
      return function (e) {
        const o = []
        let i,
          s = 0,
          l = 0
        for (let c = 0; c < e.length; c++) {
          let d = e[c]
          if (0 === s) {
            if (d === r && (n || e.slice(c, c + a) === t)) {
              o.push(e.slice(l, c)), (l = c + a)
              continue
            }
            if ("/" === d) {
              i = c
              continue
            }
          }
          "[" === d ? s++ : "]" === d && s--
        }
        const c = 0 === o.length ? e : e.substring(l),
          d = c.startsWith(mO)
        return {
          modifiers: o,
          hasImportantModifier: d,
          baseClassName: d ? c.substring(1) : c,
          maybePostfixModifierPosition: i && i > l ? i - l : void 0,
        }
      }
    }
    const bO = /\s+/
    function vO() {
      let e,
        t,
        n = 0,
        r = ""
      for (; n < arguments.length; ) (e = arguments[n++]) && (t = yO(e)) && (r && (r += " "), (r += t))
      return r
    }
    function yO(e) {
      if ("string" == typeof e) return e
      let t,
        n = ""
      for (let r = 0; r < e.length; r++) e[r] && (t = yO(e[r])) && (n && (n += " "), (n += t))
      return n
    }
    function OO(e, ...t) {
      let n,
        r,
        a,
        o = function (s) {
          const l = t.reduce((e, t) => t(e), e())
          return (
            (n = (function (e) {
              return { cache: fO(e.cacheSize), splitModifiers: gO(e), ...cO(e) }
            })(l)),
            (r = n.cache.get),
            (a = n.cache.set),
            (o = i),
            i(s)
          )
        }
      function i(e) {
        const t = r(e)
        if (t) return t
        const o = (function (e, t) {
          const { splitModifiers: n, getClassGroupId: r, getConflictingClassGroupIds: a } = t,
            o = new Set()
          return e
            .trim()
            .split(bO)
            .map((e) => {
              const { modifiers: t, hasImportantModifier: a, baseClassName: o, maybePostfixModifierPosition: i } = n(e)
              let s = r(i ? o.substring(0, i) : o),
                l = Boolean(i)
              if (!s) {
                if (!i) return { isTailwindClass: !1, originalClassName: e }
                if (((s = r(o)), !s)) return { isTailwindClass: !1, originalClassName: e }
                l = !1
              }
              const c = (function (e) {
                if (e.length <= 1) return e
                const t = []
                let n = []
                return (
                  e.forEach((e) => {
                    "[" === e[0] ? (t.push(...n.sort(), e), (n = [])) : n.push(e)
                  }),
                  t.push(...n.sort()),
                  t
                )
              })(t).join(":")
              return {
                isTailwindClass: !0,
                modifierId: a ? c + mO : c,
                classGroupId: s,
                originalClassName: e,
                hasPostfixModifier: l,
              }
            })
            .reverse()
            .filter((e) => {
              if (!e.isTailwindClass) return !0
              const { modifierId: t, classGroupId: n, hasPostfixModifier: r } = e,
                i = t + n
              return !o.has(i) && (o.add(i), a(n, r).forEach((e) => o.add(t + e)), !0)
            })
            .reverse()
            .map((e) => e.originalClassName)
            .join(" ")
        })(e, n)
        return a(e, o), o
      }
      return function () {
        return o(vO.apply(null, arguments))
      }
    }
    function wO(e) {
      const t = (t) => t[e] || []
      return (t.isThemeGetter = !0), t
    }
    const xO = /^\[(?:([a-z-]+):)?(.+)\]$/i,
      kO = /^\d+\/\d+$/,
      _O = new Set(["px", "full", "screen"]),
      SO = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
      EO =
        /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
      TO = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
      AO = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
      CO = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
    function PO(e) {
      return RO(e) || _O.has(e) || kO.test(e)
    }
    function DO(e) {
      return ZO(e, "length", HO)
    }
    function RO(e) {
      return Boolean(e) && !Number.isNaN(Number(e))
    }
    function NO(e) {
      return ZO(e, "number", RO)
    }
    function $O(e) {
      return Boolean(e) && Number.isInteger(Number(e))
    }
    function IO(e) {
      return e.endsWith("%") && RO(e.slice(0, -1))
    }
    function MO(e) {
      return xO.test(e)
    }
    function LO(e) {
      return SO.test(e)
    }
    const QO = new Set(["length", "size", "percentage"])
    function BO(e) {
      return ZO(e, QO, VO)
    }
    function jO(e) {
      return ZO(e, "position", VO)
    }
    const UO = new Set(["image", "url"])
    function FO(e) {
      return ZO(e, UO, XO)
    }
    function zO(e) {
      return ZO(e, "", WO)
    }
    function qO() {
      return !0
    }
    function ZO(e, t, n) {
      const r = xO.exec(e)
      return !!r && (r[1] ? ("string" == typeof t ? r[1] === t : t.has(r[1])) : n(r[2]))
    }
    function HO(e) {
      return EO.test(e) && !TO.test(e)
    }
    function VO() {
      return !1
    }
    function WO(e) {
      return AO.test(e)
    }
    function XO(e) {
      return CO.test(e)
    }
    function YO() {
      const e = wO("colors"),
        t = wO("spacing"),
        n = wO("blur"),
        r = wO("brightness"),
        a = wO("borderColor"),
        o = wO("borderRadius"),
        i = wO("borderSpacing"),
        s = wO("borderWidth"),
        l = wO("contrast"),
        c = wO("grayscale"),
        d = wO("hueRotate"),
        u = wO("invert"),
        p = wO("gap"),
        h = wO("gradientColorStops"),
        f = wO("gradientColorStopPositions"),
        m = wO("inset"),
        g = wO("margin"),
        b = wO("opacity"),
        v = wO("padding"),
        y = wO("saturate"),
        O = wO("scale"),
        w = wO("sepia"),
        x = wO("skew"),
        k = wO("space"),
        _ = wO("translate"),
        S = () => ["auto", MO, t],
        E = () => [MO, t],
        T = () => ["", PO, DO],
        A = () => ["auto", RO, MO],
        C = () => ["", "0", MO],
        P = () => [RO, NO],
        D = () => [RO, MO]
      return {
        cacheSize: 500,
        separator: ":",
        theme: {
          colors: [qO],
          spacing: [PO, DO],
          blur: ["none", "", LO, MO],
          brightness: P(),
          borderColor: [e],
          borderRadius: ["none", "", "full", LO, MO],
          borderSpacing: E(),
          borderWidth: T(),
          contrast: P(),
          grayscale: C(),
          hueRotate: D(),
          invert: C(),
          gap: E(),
          gradientColorStops: [e],
          gradientColorStopPositions: [IO, DO],
          inset: S(),
          margin: S(),
          opacity: P(),
          padding: E(),
          saturate: P(),
          scale: P(),
          sepia: C(),
          skew: D(),
          space: E(),
          translate: E(),
        },
        classGroups: {
          aspect: [{ aspect: ["auto", "square", "video", MO] }],
          container: ["container"],
          columns: [{ columns: [LO] }],
          "break-after": [{ "break-after": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }],
          "break-before": [
            { "break-before": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] },
          ],
          "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }],
          "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
          box: [{ box: ["border", "content"] }],
          display: [
            "block",
            "inline-block",
            "inline",
            "flex",
            "inline-flex",
            "table",
            "inline-table",
            "table-caption",
            "table-cell",
            "table-column",
            "table-column-group",
            "table-footer-group",
            "table-header-group",
            "table-row-group",
            "table-row",
            "flow-root",
            "grid",
            "inline-grid",
            "contents",
            "list-item",
            "hidden",
          ],
          float: [{ float: ["right", "left", "none", "start", "end"] }],
          clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
          isolation: ["isolate", "isolation-auto"],
          "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }],
          "object-position": [
            {
              object: [
                "bottom",
                "center",
                "left",
                "left-bottom",
                "left-top",
                "right",
                "right-bottom",
                "right-top",
                "top",
                MO,
              ],
            },
          ],
          overflow: [{ overflow: ["auto", "hidden", "clip", "visible", "scroll"] }],
          "overflow-x": [{ "overflow-x": ["auto", "hidden", "clip", "visible", "scroll"] }],
          "overflow-y": [{ "overflow-y": ["auto", "hidden", "clip", "visible", "scroll"] }],
          overscroll: [{ overscroll: ["auto", "contain", "none"] }],
          "overscroll-x": [{ "overscroll-x": ["auto", "contain", "none"] }],
          "overscroll-y": [{ "overscroll-y": ["auto", "contain", "none"] }],
          position: ["static", "fixed", "absolute", "relative", "sticky"],
          inset: [{ inset: [m] }],
          "inset-x": [{ "inset-x": [m] }],
          "inset-y": [{ "inset-y": [m] }],
          start: [{ start: [m] }],
          end: [{ end: [m] }],
          top: [{ top: [m] }],
          right: [{ right: [m] }],
          bottom: [{ bottom: [m] }],
          left: [{ left: [m] }],
          visibility: ["visible", "invisible", "collapse"],
          z: [{ z: ["auto", $O, MO] }],
          basis: [{ basis: S() }],
          "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }],
          "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
          flex: [{ flex: ["1", "auto", "initial", "none", MO] }],
          grow: [{ grow: C() }],
          shrink: [{ shrink: C() }],
          order: [{ order: ["first", "last", "none", $O, MO] }],
          "grid-cols": [{ "grid-cols": [qO] }],
          "col-start-end": [{ col: ["auto", { span: ["full", $O, MO] }, MO] }],
          "col-start": [{ "col-start": A() }],
          "col-end": [{ "col-end": A() }],
          "grid-rows": [{ "grid-rows": [qO] }],
          "row-start-end": [{ row: ["auto", { span: [$O, MO] }, MO] }],
          "row-start": [{ "row-start": A() }],
          "row-end": [{ "row-end": A() }],
          "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }],
          "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", MO] }],
          "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", MO] }],
          gap: [{ gap: [p] }],
          "gap-x": [{ "gap-x": [p] }],
          "gap-y": [{ "gap-y": [p] }],
          "justify-content": [
            { justify: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch"] },
          ],
          "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }],
          "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }],
          "align-content": [
            { content: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch", "baseline"] },
          ],
          "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }],
          "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }],
          "place-content": [
            { "place-content": ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline"] },
          ],
          "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }],
          "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }],
          p: [{ p: [v] }],
          px: [{ px: [v] }],
          py: [{ py: [v] }],
          ps: [{ ps: [v] }],
          pe: [{ pe: [v] }],
          pt: [{ pt: [v] }],
          pr: [{ pr: [v] }],
          pb: [{ pb: [v] }],
          pl: [{ pl: [v] }],
          m: [{ m: [g] }],
          mx: [{ mx: [g] }],
          my: [{ my: [g] }],
          ms: [{ ms: [g] }],
          me: [{ me: [g] }],
          mt: [{ mt: [g] }],
          mr: [{ mr: [g] }],
          mb: [{ mb: [g] }],
          ml: [{ ml: [g] }],
          "space-x": [{ "space-x": [k] }],
          "space-x-reverse": ["space-x-reverse"],
          "space-y": [{ "space-y": [k] }],
          "space-y-reverse": ["space-y-reverse"],
          w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", MO, t] }],
          "min-w": [{ "min-w": [MO, t, "min", "max", "fit"] }],
          "max-w": [{ "max-w": [MO, t, "none", "full", "min", "max", "fit", "prose", { screen: [LO] }, LO] }],
          h: [{ h: [MO, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }],
          "min-h": [{ "min-h": [MO, t, "min", "max", "fit", "svh", "lvh", "dvh"] }],
          "max-h": [{ "max-h": [MO, t, "min", "max", "fit", "svh", "lvh", "dvh"] }],
          size: [{ size: [MO, t, "auto", "min", "max", "fit"] }],
          "font-size": [{ text: ["base", LO, DO] }],
          "font-smoothing": ["antialiased", "subpixel-antialiased"],
          "font-style": ["italic", "not-italic"],
          "font-weight": [
            { font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", NO] },
          ],
          "font-family": [{ font: [qO] }],
          "fvn-normal": ["normal-nums"],
          "fvn-ordinal": ["ordinal"],
          "fvn-slashed-zero": ["slashed-zero"],
          "fvn-figure": ["lining-nums", "oldstyle-nums"],
          "fvn-spacing": ["proportional-nums", "tabular-nums"],
          "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
          tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", MO] }],
          "line-clamp": [{ "line-clamp": ["none", RO, NO] }],
          leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", PO, MO] }],
          "list-image": [{ "list-image": ["none", MO] }],
          "list-style-type": [{ list: ["none", "disc", "decimal", MO] }],
          "list-style-position": [{ list: ["inside", "outside"] }],
          "placeholder-color": [{ placeholder: [e] }],
          "placeholder-opacity": [{ "placeholder-opacity": [b] }],
          "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }],
          "text-color": [{ text: [e] }],
          "text-opacity": [{ "text-opacity": [b] }],
          "text-decoration": ["underline", "overline", "line-through", "no-underline"],
          "text-decoration-style": [{ decoration: ["solid", "dashed", "dotted", "double", "none", "wavy"] }],
          "text-decoration-thickness": [{ decoration: ["auto", "from-font", PO, DO] }],
          "underline-offset": [{ "underline-offset": ["auto", PO, MO] }],
          "text-decoration-color": [{ decoration: [e] }],
          "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
          "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
          "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
          indent: [{ indent: E() }],
          "vertical-align": [
            { align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", MO] },
          ],
          whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }],
          break: [{ break: ["normal", "words", "all", "keep"] }],
          hyphens: [{ hyphens: ["none", "manual", "auto"] }],
          content: [{ content: ["none", MO] }],
          "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
          "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
          "bg-opacity": [{ "bg-opacity": [b] }],
          "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
          "bg-position": [
            {
              bg: [
                "bottom",
                "center",
                "left",
                "left-bottom",
                "left-top",
                "right",
                "right-bottom",
                "right-top",
                "top",
                jO,
              ],
            },
          ],
          "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }],
          "bg-size": [{ bg: ["auto", "cover", "contain", BO] }],
          "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, FO] }],
          "bg-color": [{ bg: [e] }],
          "gradient-from-pos": [{ from: [f] }],
          "gradient-via-pos": [{ via: [f] }],
          "gradient-to-pos": [{ to: [f] }],
          "gradient-from": [{ from: [h] }],
          "gradient-via": [{ via: [h] }],
          "gradient-to": [{ to: [h] }],
          rounded: [{ rounded: [o] }],
          "rounded-s": [{ "rounded-s": [o] }],
          "rounded-e": [{ "rounded-e": [o] }],
          "rounded-t": [{ "rounded-t": [o] }],
          "rounded-r": [{ "rounded-r": [o] }],
          "rounded-b": [{ "rounded-b": [o] }],
          "rounded-l": [{ "rounded-l": [o] }],
          "rounded-ss": [{ "rounded-ss": [o] }],
          "rounded-se": [{ "rounded-se": [o] }],
          "rounded-ee": [{ "rounded-ee": [o] }],
          "rounded-es": [{ "rounded-es": [o] }],
          "rounded-tl": [{ "rounded-tl": [o] }],
          "rounded-tr": [{ "rounded-tr": [o] }],
          "rounded-br": [{ "rounded-br": [o] }],
          "rounded-bl": [{ "rounded-bl": [o] }],
          "border-w": [{ border: [s] }],
          "border-w-x": [{ "border-x": [s] }],
          "border-w-y": [{ "border-y": [s] }],
          "border-w-s": [{ "border-s": [s] }],
          "border-w-e": [{ "border-e": [s] }],
          "border-w-t": [{ "border-t": [s] }],
          "border-w-r": [{ "border-r": [s] }],
          "border-w-b": [{ "border-b": [s] }],
          "border-w-l": [{ "border-l": [s] }],
          "border-opacity": [{ "border-opacity": [b] }],
          "border-style": [{ border: ["solid", "dashed", "dotted", "double", "none", "hidden"] }],
          "divide-x": [{ "divide-x": [s] }],
          "divide-x-reverse": ["divide-x-reverse"],
          "divide-y": [{ "divide-y": [s] }],
          "divide-y-reverse": ["divide-y-reverse"],
          "divide-opacity": [{ "divide-opacity": [b] }],
          "divide-style": [{ divide: ["solid", "dashed", "dotted", "double", "none"] }],
          "border-color": [{ border: [a] }],
          "border-color-x": [{ "border-x": [a] }],
          "border-color-y": [{ "border-y": [a] }],
          "border-color-t": [{ "border-t": [a] }],
          "border-color-r": [{ "border-r": [a] }],
          "border-color-b": [{ "border-b": [a] }],
          "border-color-l": [{ "border-l": [a] }],
          "divide-color": [{ divide: [a] }],
          "outline-style": [{ outline: ["", "solid", "dashed", "dotted", "double", "none"] }],
          "outline-offset": [{ "outline-offset": [PO, MO] }],
          "outline-w": [{ outline: [PO, DO] }],
          "outline-color": [{ outline: [e] }],
          "ring-w": [{ ring: T() }],
          "ring-w-inset": ["ring-inset"],
          "ring-color": [{ ring: [e] }],
          "ring-opacity": [{ "ring-opacity": [b] }],
          "ring-offset-w": [{ "ring-offset": [PO, DO] }],
          "ring-offset-color": [{ "ring-offset": [e] }],
          shadow: [{ shadow: ["", "inner", "none", LO, zO] }],
          "shadow-color": [{ shadow: [qO] }],
          opacity: [{ opacity: [b] }],
          "mix-blend": [
            {
              "mix-blend": [
                "normal",
                "multiply",
                "screen",
                "overlay",
                "darken",
                "lighten",
                "color-dodge",
                "color-burn",
                "hard-light",
                "soft-light",
                "difference",
                "exclusion",
                "hue",
                "saturation",
                "color",
                "luminosity",
                "plus-lighter",
                "plus-darker",
              ],
            },
          ],
          "bg-blend": [
            {
              "bg-blend": [
                "normal",
                "multiply",
                "screen",
                "overlay",
                "darken",
                "lighten",
                "color-dodge",
                "color-burn",
                "hard-light",
                "soft-light",
                "difference",
                "exclusion",
                "hue",
                "saturation",
                "color",
                "luminosity",
              ],
            },
          ],
          filter: [{ filter: ["", "none"] }],
          blur: [{ blur: [n] }],
          brightness: [{ brightness: [r] }],
          contrast: [{ contrast: [l] }],
          "drop-shadow": [{ "drop-shadow": ["", "none", LO, MO] }],
          grayscale: [{ grayscale: [c] }],
          "hue-rotate": [{ "hue-rotate": [d] }],
          invert: [{ invert: [u] }],
          saturate: [{ saturate: [y] }],
          sepia: [{ sepia: [w] }],
          "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
          "backdrop-blur": [{ "backdrop-blur": [n] }],
          "backdrop-brightness": [{ "backdrop-brightness": [r] }],
          "backdrop-contrast": [{ "backdrop-contrast": [l] }],
          "backdrop-grayscale": [{ "backdrop-grayscale": [c] }],
          "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [d] }],
          "backdrop-invert": [{ "backdrop-invert": [u] }],
          "backdrop-opacity": [{ "backdrop-opacity": [b] }],
          "backdrop-saturate": [{ "backdrop-saturate": [y] }],
          "backdrop-sepia": [{ "backdrop-sepia": [w] }],
          "border-collapse": [{ border: ["collapse", "separate"] }],
          "border-spacing": [{ "border-spacing": [i] }],
          "border-spacing-x": [{ "border-spacing-x": [i] }],
          "border-spacing-y": [{ "border-spacing-y": [i] }],
          "table-layout": [{ table: ["auto", "fixed"] }],
          caption: [{ caption: ["top", "bottom"] }],
          transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", MO] }],
          duration: [{ duration: D() }],
          ease: [{ ease: ["linear", "in", "out", "in-out", MO] }],
          delay: [{ delay: D() }],
          animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", MO] }],
          transform: [{ transform: ["", "gpu", "none"] }],
          scale: [{ scale: [O] }],
          "scale-x": [{ "scale-x": [O] }],
          "scale-y": [{ "scale-y": [O] }],
          rotate: [{ rotate: [$O, MO] }],
          "translate-x": [{ "translate-x": [_] }],
          "translate-y": [{ "translate-y": [_] }],
          "skew-x": [{ "skew-x": [x] }],
          "skew-y": [{ "skew-y": [x] }],
          "transform-origin": [
            {
              origin: [
                "center",
                "top",
                "top-right",
                "right",
                "bottom-right",
                "bottom",
                "bottom-left",
                "left",
                "top-left",
                MO,
              ],
            },
          ],
          accent: [{ accent: ["auto", e] }],
          appearance: [{ appearance: ["none", "auto"] }],
          cursor: [
            {
              cursor: [
                "auto",
                "default",
                "pointer",
                "wait",
                "text",
                "move",
                "help",
                "not-allowed",
                "none",
                "context-menu",
                "progress",
                "cell",
                "crosshair",
                "vertical-text",
                "alias",
                "copy",
                "no-drop",
                "grab",
                "grabbing",
                "all-scroll",
                "col-resize",
                "row-resize",
                "n-resize",
                "e-resize",
                "s-resize",
                "w-resize",
                "ne-resize",
                "nw-resize",
                "se-resize",
                "sw-resize",
                "ew-resize",
                "ns-resize",
                "nesw-resize",
                "nwse-resize",
                "zoom-in",
                "zoom-out",
                MO,
              ],
            },
          ],
          "caret-color": [{ caret: [e] }],
          "pointer-events": [{ "pointer-events": ["none", "auto"] }],
          resize: [{ resize: ["none", "y", "x", ""] }],
          "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
          "scroll-m": [{ "scroll-m": E() }],
          "scroll-mx": [{ "scroll-mx": E() }],
          "scroll-my": [{ "scroll-my": E() }],
          "scroll-ms": [{ "scroll-ms": E() }],
          "scroll-me": [{ "scroll-me": E() }],
          "scroll-mt": [{ "scroll-mt": E() }],
          "scroll-mr": [{ "scroll-mr": E() }],
          "scroll-mb": [{ "scroll-mb": E() }],
          "scroll-ml": [{ "scroll-ml": E() }],
          "scroll-p": [{ "scroll-p": E() }],
          "scroll-px": [{ "scroll-px": E() }],
          "scroll-py": [{ "scroll-py": E() }],
          "scroll-ps": [{ "scroll-ps": E() }],
          "scroll-pe": [{ "scroll-pe": E() }],
          "scroll-pt": [{ "scroll-pt": E() }],
          "scroll-pr": [{ "scroll-pr": E() }],
          "scroll-pb": [{ "scroll-pb": E() }],
          "scroll-pl": [{ "scroll-pl": E() }],
          "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
          "snap-stop": [{ snap: ["normal", "always"] }],
          "snap-type": [{ snap: ["none", "x", "y", "both"] }],
          "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
          touch: [{ touch: ["auto", "none", "manipulation"] }],
          "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
          "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
          "touch-pz": ["touch-pinch-zoom"],
          select: [{ select: ["none", "text", "all", "auto"] }],
          "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", MO] }],
          fill: [{ fill: [e, "none"] }],
          "stroke-w": [{ stroke: [PO, DO, NO] }],
          stroke: [{ stroke: [e, "none"] }],
          sr: ["sr-only", "not-sr-only"],
          "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
        },
        conflictingClassGroups: {
          overflow: ["overflow-x", "overflow-y"],
          overscroll: ["overscroll-x", "overscroll-y"],
          inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
          "inset-x": ["right", "left"],
          "inset-y": ["top", "bottom"],
          flex: ["basis", "grow", "shrink"],
          gap: ["gap-x", "gap-y"],
          p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
          px: ["pr", "pl"],
          py: ["pt", "pb"],
          m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
          mx: ["mr", "ml"],
          my: ["mt", "mb"],
          size: ["w", "h"],
          "font-size": ["leading"],
          "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
          "fvn-ordinal": ["fvn-normal"],
          "fvn-slashed-zero": ["fvn-normal"],
          "fvn-figure": ["fvn-normal"],
          "fvn-spacing": ["fvn-normal"],
          "fvn-fraction": ["fvn-normal"],
          "line-clamp": ["display", "overflow"],
          rounded: [
            "rounded-s",
            "rounded-e",
            "rounded-t",
            "rounded-r",
            "rounded-b",
            "rounded-l",
            "rounded-ss",
            "rounded-se",
            "rounded-ee",
            "rounded-es",
            "rounded-tl",
            "rounded-tr",
            "rounded-br",
            "rounded-bl",
          ],
          "rounded-s": ["rounded-ss", "rounded-es"],
          "rounded-e": ["rounded-se", "rounded-ee"],
          "rounded-t": ["rounded-tl", "rounded-tr"],
          "rounded-r": ["rounded-tr", "rounded-br"],
          "rounded-b": ["rounded-br", "rounded-bl"],
          "rounded-l": ["rounded-tl", "rounded-bl"],
          "border-spacing": ["border-spacing-x", "border-spacing-y"],
          "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
          "border-w-x": ["border-w-r", "border-w-l"],
          "border-w-y": ["border-w-t", "border-w-b"],
          "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
          "border-color-x": ["border-color-r", "border-color-l"],
          "border-color-y": ["border-color-t", "border-color-b"],
          "scroll-m": [
            "scroll-mx",
            "scroll-my",
            "scroll-ms",
            "scroll-me",
            "scroll-mt",
            "scroll-mr",
            "scroll-mb",
            "scroll-ml",
          ],
          "scroll-mx": ["scroll-mr", "scroll-ml"],
          "scroll-my": ["scroll-mt", "scroll-mb"],
          "scroll-p": [
            "scroll-px",
            "scroll-py",
            "scroll-ps",
            "scroll-pe",
            "scroll-pt",
            "scroll-pr",
            "scroll-pb",
            "scroll-pl",
          ],
          "scroll-px": ["scroll-pr", "scroll-pl"],
          "scroll-py": ["scroll-pt", "scroll-pb"],
          touch: ["touch-x", "touch-y", "touch-pz"],
          "touch-x": ["touch"],
          "touch-y": ["touch"],
          "touch-pz": ["touch"],
        },
        conflictingClassGroupModifiers: { "font-size": ["leading"] },
      }
    }
    function GO(e, t, n) {
      void 0 !== n && (e[t] = n)
    }
    function KO(e, t) {
      if (t) for (const n in t) GO(e, n, t[n])
    }
    function JO(e, t) {
      if (t)
        for (const n in t) {
          const r = t[n]
          void 0 !== r && (e[n] = (e[n] || []).concat(r))
        }
    }
    const ew = (function (e, ...t) {
        return "function" == typeof e
          ? OO(YO, e, ...t)
          : OO(
              () =>
                (function (e, { cacheSize: t, prefix: n, separator: r, extend: a = {}, override: o = {} }) {
                  GO(e, "cacheSize", t), GO(e, "prefix", n), GO(e, "separator", r)
                  for (const t in o) KO(e[t], o[t])
                  for (const t in a) JO(e[t], a[t])
                  return e
                })(YO(), e),
              ...t,
            )
      })({ extend: { classGroups: { "font-size": ["text-xxs"] } } }),
      { cva: tw, cx: nw, compose: rw } = aO({ hooks: { onComplete: (e) => ew(e) } }),
      aw = () =>
        mn({
          open: !1,
          show() {
            this.open = !0
          },
          hide() {
            this.open = !1
          },
        }),
      ow = Hr({
        __name: "ScalarModal",
        props: { state: {}, title: {}, bodyClass: {}, maxWidth: {}, size: { default: "md" }, variant: {} },
        setup(e) {
          const t = tw({
              base: [
                "scalar-modal",
                "col relative mx-auto mb-0 mt-20 w-full rounded-lg bg-b-2 p-0 text-left leading-snug text-c-1 opacity-0",
              ].join(" "),
              variants: {
                size: {
                  xs: "max-w-screen-xs",
                  sm: "max-w-screen-sm",
                  md: "max-w-screen-md",
                  lg: "max-w-screen-lg",
                  full: "mt-0 overflow-hidden",
                },
                variant: { history: "scalar-modal-history bg-b-1", search: "scalar-modal-search" },
              },
            }),
            n = tw({
              base: [
                "scalar-modal-body",
                "relative max-h-[calc(100dvh-240px)] overflow-y-auto rounded-lg bg-b-1 px-6 pb-4 pt-6",
              ].join(" "),
              variants: { variant: { history: "pt-3", search: "col max-h-[440px] overflow-hidden p-0" } },
            })
          return (e, r) => (
            xo(),
            To(
              In(py),
              { open: e.state.open, onClose: r[0] || (r[0] = (t) => e.state.hide()) },
              {
                default: yr(() => [
                  Ro(
                    "div",
                    {
                      class: Ge(
                        In(nw)(
                          "scalar-modal-layout fixed left-0 top-0 flex items-start justify-center",
                          "z-[1001] h-[100dvh] w-[100dvw]",
                          "bg-backdrop opacity-0",
                          "full" === e.size && "flex",
                        ),
                      ),
                    },
                    [
                      No(
                        In(hy),
                        { class: Ge(In(t)({ size: e.size, variant: e.variant })), style: He({ maxWidth: e.maxWidth }) },
                        {
                          default: yr(() => [
                            e.title
                              ? (xo(),
                                To(
                                  In(fy),
                                  {
                                    key: 0,
                                    class: Ge([
                                      "scalar-modal-header m-0 rounded-lg px-6 py-3 text-left text-xs font-medium text-c-1",
                                      { "pb-0 pt-6": "history" === e.variant },
                                    ]),
                                  },
                                  { default: yr(() => [Mo(at(e.title), 1)]), _: 1 },
                                  8,
                                  ["class"],
                                ))
                              : Qo("", !0),
                            "full" === e.size
                              ? (xo(),
                                Eo(
                                  "div",
                                  { key: 1, class: Ge(e.bodyClass) },
                                  [Xr(e.$slots, "default", {}, void 0, !0)],
                                  2,
                                ))
                              : (xo(),
                                To(
                                  In(my),
                                  { key: 2, class: Ge(In(nw)(e.bodyClass, In(n)({ variant: e.variant }))) },
                                  { default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]), _: 3 },
                                  8,
                                  ["class"],
                                )),
                          ]),
                          _: 3,
                        },
                        8,
                        ["class", "style"],
                      ),
                    ],
                    2,
                  ),
                ]),
                _: 3,
              },
              8,
              ["open"],
            )
          )
        },
      }),
      iw = (e, t) => {
        const n = e.__vccOpts || e
        for (const [e, r] of t) n[e] = r
        return n
      },
      sw = iw(ow, [["__scopeId", "data-v-17e9f7d4"]]),
      lw = {
        solid: [
          "scalar-button-solid",
          "bg-b-btn text-c-btn shadow-sm active:bg-b-btn active:shadow-none hocus:bg-h-btn",
        ],
        outlined: [
          "scalar-button-outlined",
          "active:bg-btn-1 border border-solid border-border bg-transparent text-c-1 hover:bg-b-2 shadow",
        ],
        ghost: ["scalar-button-ghost", "bg-transparent text-c-3 active:text-c-1 hocus:text-c-1"],
        danger: ["scalar-button-danger", "bg-error text-white active:brightness-90 hocus:brightness-90"],
      },
      cw = tw({
        base: "scalar-button scalar-row cursor-pointer items-center justify-center rounded font-medium",
        variants: {
          disabled: { true: "bg-background-2 text-color-3 cursor-not-allowed shadow-none" },
          fullWidth: { true: "w-full" },
          size: { sm: "px-2 py-1 text-xs", md: "h-10 px-6 text-sm" },
          variant: lw,
        },
        compoundVariants: [{ disabled: !0, variant: "ghost", class: "text-ghost bg-transparent" }],
      }),
      dw = Lo(
        '<path class="svg-path svg-check-mark" d="m 0 60 l 30 30 l 70 -80" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 -40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 -40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 40" data-v-47faceda></path>',
        5,
      ),
      uw = { key: 0, class: "circular-loader" },
      pw = iw(
        Hr({
          __name: "ScalarLoading",
          props: { loadingState: {}, size: { default: "24px" } },
          setup: (e) => (
            vi((e) => ({ d6cae758: e.size })),
            (e, t) =>
              e.loadingState
                ? (xo(),
                  Eo(
                    "div",
                    { key: 0, class: Ge(In(nw)("loader-wrapper")) },
                    [
                      (xo(),
                      Eo(
                        "svg",
                        {
                          class: Ge([
                            "svg-loader",
                            { "icon-is-valid": e.loadingState.isValid, "icon-is-invalid": e.loadingState.isInvalid },
                          ]),
                          viewBox: "0 0 100 100",
                          xmlns: "http://www.w3.org/2000/svg",
                          "xmlns:xlink": "http://www.w3.org/1999/xlink",
                        },
                        [
                          dw,
                          e.loadingState.isLoading
                            ? (xo(),
                              Eo("g", uw, [
                                Ro(
                                  "circle",
                                  {
                                    class: Ge([
                                      "loader-path",
                                      { "loader-path-off": e.loadingState.isValid || e.loadingState.isInvalid },
                                    ]),
                                    cx: "50",
                                    cy: "50",
                                    fill: "none",
                                    r: "20",
                                    "stroke-width": "2",
                                  },
                                  null,
                                  2,
                                ),
                              ]))
                            : Qo("", !0),
                        ],
                        2,
                      )),
                    ],
                    2,
                  ))
                : Qo("", !0)
          ),
        }),
        [["__scopeId", "data-v-47faceda"]],
      ),
      hw = ["ariaDisabled", "type"],
      fw = { key: 3, class: "centered-x absolute" },
      mw = Hr({
        inheritAttrs: !1,
        __name: "ScalarButton",
        props: {
          disabled: { type: Boolean },
          fullWidth: { type: Boolean, default: !1 },
          loading: {},
          size: { default: "md" },
          variant: { default: "solid" },
          type: { default: "button" },
        },
        setup(e) {
          const t = ii(() => {
            const { class: e, ...t } = ra()
            return { class: e || "", rest: t }
          })
          return (e, n) => {
            var r, a, o, i
            return (
              xo(),
              Eo(
                "button",
                Fo(t.value.rest, {
                  ariaDisabled: e.disabled || void 0,
                  class: In(nw)(
                    In(cw)({ fullWidth: e.fullWidth, disabled: e.disabled, size: e.size, variant: e.variant }),
                    { relative: null == (r = e.loading) ? void 0 : r.isLoading },
                    `${t.value.class}`,
                  ),
                  type: e.type,
                }),
                [
                  e.$slots.icon
                    ? (xo(),
                      Eo(
                        "div",
                        {
                          key: 0,
                          class: Ge(["mr-2 h-4 w-4", { invisible: null == (a = e.loading) ? void 0 : a.isLoading }]),
                        },
                        [Xr(e.$slots, "icon")],
                        2,
                      ))
                    : Qo("", !0),
                  e.loading
                    ? (xo(),
                      Eo(
                        "span",
                        { key: 1, class: Ge({ invisible: null == (o = e.loading) ? void 0 : o.isLoading }) },
                        [Xr(e.$slots, "default")],
                        2,
                      ))
                    : Xr(e.$slots, "default", { key: 2 }),
                  null != (i = e.loading) && i.isLoading
                    ? (xo(),
                      Eo("div", fw, [No(In(pw), { loadingState: e.loading, size: "12px" }, null, 8, ["loadingState"])]))
                    : Qo("", !0),
                ],
                16,
                hw,
              )
            )
          }
        },
      }),
      gw = {
        ts: "typescript",
        js: "javascript",
        py: "python",
        py3: "python",
        "c#": "csharp",
        "c++": "cpp",
        node: "javascript",
      },
      bw = function (e) {
        if (null == e) return yw
        if ("function" == typeof e) return vw(e)
        if ("object" == typeof e)
          return Array.isArray(e)
            ? (function (e) {
                const t = []
                let n = -1
                for (; ++n < e.length; ) t[n] = bw(e[n])
                return vw(function (...e) {
                  let n = -1
                  for (; ++n < t.length; ) if (t[n].apply(this, e)) return !0
                  return !1
                })
              })(e)
            : (function (e) {
                const t = e
                return vw(function (n) {
                  const r = n
                  let a
                  for (a in e) if (r[a] !== t[a]) return !1
                  return !0
                })
              })(e)
        if ("string" == typeof e)
          return (function (e) {
            return vw(function (t) {
              return t && t.type === e
            })
          })(e)
        throw new Error("Expected function, string, or object as test")
      }
    function vw(e) {
      return function (t, n, r) {
        return Boolean(
          (function (e) {
            return null !== e && "object" == typeof e && "type" in e
          })(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0),
        )
      }
    }
    function yw() {
      return !0
    }
    const Ow = function (e, t, n) {
        const r = bw(n)
        if (!e || !e.type || !e.children) throw new Error("Expected parent node")
        if ("number" == typeof t) {
          if (t < 0 || t === Number.POSITIVE_INFINITY) throw new Error("Expected positive finite number as index")
        } else if ((t = e.children.indexOf(t)) < 0) throw new Error("Expected child node or index")
        for (; ++t < e.children.length; ) if (r(e.children[t], t, e)) return e.children[t]
      },
      ww = function (e, t, n, r, a) {
        const o = xw(t)
        return !!Sw(e) && o.call(a, e, n, r)
      },
      xw = function (e) {
        if (null == e) return _w
        if ("string" == typeof e)
          return (function (e) {
            return kw(function (t) {
              return t.tagName === e
            })
          })(e)
        if ("object" == typeof e)
          return (function (e) {
            const t = []
            let n = -1
            for (; ++n < e.length; ) t[n] = xw(e[n])
            return kw(function (...e) {
              let n = -1
              for (; ++n < t.length; ) if (t[n].apply(this, e)) return !0
              return !1
            })
          })(e)
        if ("function" == typeof e) return kw(e)
        throw new Error("Expected function, string, or array as `test`")
      }
    function kw(e) {
      return function (t, n, r) {
        return Boolean(Sw(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0))
      }
    }
    function _w(e) {
      return Boolean(
        e &&
          "object" == typeof e &&
          "type" in e &&
          "element" === e.type &&
          "tagName" in e &&
          "string" == typeof e.tagName,
      )
    }
    function Sw(e) {
      return null !== e && "object" == typeof e && "type" in e && "tagName" in e
    }
    const Ew = /\n/g,
      Tw = /[\t ]+/g,
      Aw = xw("br"),
      Cw = xw(function (e) {
        return "td" === e.tagName || "th" === e.tagName
      }),
      Pw = xw("p"),
      Dw = xw("tr"),
      Rw = xw([
        "datalist",
        "head",
        "noembed",
        "noframes",
        "noscript",
        "rp",
        "script",
        "style",
        "template",
        "title",
        function (e) {
          return Boolean((e.properties || {}).hidden)
        },
        function (e) {
          return "dialog" === e.tagName && !(e.properties || {}).open
        },
      ]),
      Nw = xw([
        "address",
        "article",
        "aside",
        "blockquote",
        "body",
        "caption",
        "center",
        "dd",
        "dialog",
        "dir",
        "dl",
        "dt",
        "div",
        "figure",
        "figcaption",
        "footer",
        "form,",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "html",
        "legend",
        "li",
        "listing",
        "main",
        "menu",
        "nav",
        "ol",
        "p",
        "plaintext",
        "pre",
        "section",
        "ul",
        "xmp",
      ])
    function $w(e, t) {
      const n = "children" in e ? e.children : [],
        r = Nw(e),
        a = Qw(e, { whitespace: {}.whitespace || "normal", breakBefore: !1, breakAfter: !1 }),
        o = []
      ;("text" !== e.type && "comment" !== e.type) ||
        o.push(...Mw(e, { whitespace: a, breakBefore: !0, breakAfter: !0 }))
      let i = -1
      for (; ++i < n.length; )
        o.push(
          ...Iw(n[i], e, {
            whitespace: a,
            breakBefore: i ? void 0 : r,
            breakAfter: i < n.length - 1 ? Aw(n[i + 1]) : r,
          }),
        )
      const s = []
      let l
      for (i = -1; ++i < o.length; ) {
        const e = o[i]
        "number" == typeof e
          ? void 0 !== l && e > l && (l = e)
          : e && (void 0 !== l && l > -1 && s.push("\n".repeat(l) || " "), (l = -1), s.push(e))
      }
      return s.join("")
    }
    function Iw(e, t, n) {
      return "element" === e.type
        ? (function (e, t, n) {
            const r = Qw(e, n),
              a = e.children || []
            let o,
              i,
              s = -1,
              l = []
            if (Rw(e)) return l
            for (
              Aw(e) || (Dw(e) && Ow(t, e, Dw)) ? (i = "\n") : Pw(e) ? ((o = 2), (i = 2)) : Nw(e) && ((o = 1), (i = 1));
              ++s < a.length;

            )
              l = l.concat(
                Iw(a[s], e, {
                  whitespace: r,
                  breakBefore: s ? void 0 : o,
                  breakAfter: s < a.length - 1 ? Aw(a[s + 1]) : i,
                }),
              )
            return Cw(e) && Ow(t, e, Cw) && l.push("\t"), o && l.unshift(o), i && l.push(i), l
          })(e, t, n)
        : "text" === e.type
          ? "normal" === n.whitespace
            ? Mw(e, n)
            : (function (e) {
                return [String(e.value)]
              })(e)
          : []
    }
    function Mw(e, t) {
      const n = String(e.value),
        r = [],
        a = []
      let o = 0
      for (; o <= n.length; ) {
        Ew.lastIndex = o
        const e = Ew.exec(n),
          a = e && "index" in e ? e.index : n.length
        r.push(
          Lw(
            n.slice(o, a).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
            0 !== o || t.breakBefore,
            a !== n.length || t.breakAfter,
          ),
        ),
          (o = a + 1)
      }
      let i,
        s = -1
      for (; ++s < r.length; )
        8203 === r[s].charCodeAt(r[s].length - 1) || (s < r.length - 1 && 8203 === r[s + 1].charCodeAt(0))
          ? (a.push(r[s]), (i = void 0))
          : r[s]
            ? ("number" == typeof i && a.push(i), a.push(r[s]), (i = 0))
            : (0 !== s && s !== r.length - 1) || a.push(0)
      return a
    }
    function Lw(e, t, n) {
      const r = []
      let a,
        o = 0
      for (; o < e.length; ) {
        Tw.lastIndex = o
        const n = Tw.exec(e)
        ;(a = n ? n.index : e.length),
          o || a || !n || t || r.push(""),
          o !== a && r.push(e.slice(o, a)),
          (o = n ? a + n[0].length : a)
      }
      return o === a || n || r.push(""), r.join(" ")
    }
    function Qw(e, t) {
      if ("element" === e.type) {
        const n = e.properties || {}
        switch (e.tagName) {
          case "listing":
          case "plaintext":
          case "xmp":
            return "pre"
          case "nobr":
            return "nowrap"
          case "pre":
            return n.wrap ? "pre-wrap" : "pre"
          case "td":
          case "th":
            return n.noWrap ? "nowrap" : t.whitespace
          case "textarea":
            return "pre-wrap"
        }
      }
      return t.whitespace
    }
    const Bw = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video",
      ],
      jw = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        "min-width",
        "max-width",
        "min-height",
        "max-height",
      ],
      Uw = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        "host",
        "host-context",
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        "lang",
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        "nth-child",
        "nth-col",
        "nth-last-child",
        "nth-last-col",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where",
      ],
      Fw = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error",
      ],
      zw = [
        "align-content",
        "align-items",
        "align-self",
        "all",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "block-size",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "caret-color",
        "clear",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "contain",
        "content",
        "content-visibility",
        "counter-increment",
        "counter-reset",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "flow",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-variant",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "gap",
        "glyph-orientation-vertical",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inline-size",
        "isolation",
        "justify-content",
        "left",
        "letter-spacing",
        "line-break",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "mix-blend-mode",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "pause",
        "pause-after",
        "pause-before",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "right",
        "row-gap",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "speak",
        "speak-as",
        "src",
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-all",
        "text-align-last",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "white-space",
        "widows",
        "width",
        "will-change",
        "word-break",
        "word-spacing",
        "word-wrap",
        "writing-mode",
        "z-index",
      ].reverse()
    var qw = "[0-9](_*[0-9])*",
      Zw = `\\.(${qw})`,
      Hw = "[0-9a-fA-F](_*[0-9a-fA-F])*",
      Vw = {
        className: "number",
        variants: [
          { begin: `(\\b(${qw})((${Zw})|\\.)?|(${Zw}))[eE][+-]?(${qw})[fFdD]?\\b` },
          { begin: `\\b(${qw})((${Zw})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
          { begin: `(${Zw})[fFdD]?\\b` },
          { begin: `\\b(${qw})[fFdD]\\b` },
          { begin: `\\b0[xX]((${Hw})\\.?|(${Hw})?\\.(${Hw}))[pP][+-]?(${qw})[fFdD]?\\b` },
          { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
          { begin: `\\b0[xX](${Hw})[lL]?\\b` },
          { begin: "\\b0(_*[0-7])*[lL]?\\b" },
          { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" },
        ],
        relevance: 0,
      }
    function Ww(e, t, n) {
      return -1 === n ? "" : e.replace(t, (r) => Ww(e, t, n - 1))
    }
    const Xw = "[A-Za-z$_][0-9A-Za-z$_]*",
      Yw = [
        "as",
        "in",
        "of",
        "if",
        "for",
        "while",
        "finally",
        "var",
        "new",
        "function",
        "do",
        "return",
        "void",
        "else",
        "break",
        "catch",
        "instanceof",
        "with",
        "throw",
        "case",
        "default",
        "try",
        "switch",
        "continue",
        "typeof",
        "delete",
        "let",
        "yield",
        "const",
        "class",
        "debugger",
        "async",
        "await",
        "static",
        "import",
        "from",
        "export",
        "extends",
      ],
      Gw = ["true", "false", "null", "undefined", "NaN", "Infinity"],
      Kw = [
        "Object",
        "Function",
        "Boolean",
        "Symbol",
        "Math",
        "Date",
        "Number",
        "BigInt",
        "String",
        "RegExp",
        "Array",
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Int32Array",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array",
        "Set",
        "Map",
        "WeakSet",
        "WeakMap",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "Atomics",
        "DataView",
        "JSON",
        "Promise",
        "Generator",
        "GeneratorFunction",
        "AsyncFunction",
        "Reflect",
        "Proxy",
        "Intl",
        "WebAssembly",
      ],
      Jw = [
        "Error",
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError",
      ],
      ex = [
        "setInterval",
        "setTimeout",
        "clearInterval",
        "clearTimeout",
        "require",
        "exports",
        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "unescape",
      ],
      tx = [
        "arguments",
        "this",
        "super",
        "console",
        "window",
        "document",
        "localStorage",
        "sessionStorage",
        "module",
        "global",
      ],
      nx = [].concat(ex, Kw, Jw)
    var rx = "[0-9](_*[0-9])*",
      ax = `\\.(${rx})`,
      ox = "[0-9a-fA-F](_*[0-9a-fA-F])*",
      ix = {
        className: "number",
        variants: [
          { begin: `(\\b(${rx})((${ax})|\\.)?|(${ax}))[eE][+-]?(${rx})[fFdD]?\\b` },
          { begin: `\\b(${rx})((${ax})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
          { begin: `(${ax})[fFdD]?\\b` },
          { begin: `\\b(${rx})[fFdD]\\b` },
          { begin: `\\b0[xX]((${ox})\\.?|(${ox})?\\.(${ox}))[pP][+-]?(${rx})[fFdD]?\\b` },
          { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
          { begin: `\\b0[xX](${ox})[lL]?\\b` },
          { begin: "\\b0(_*[0-7])*[lL]?\\b" },
          { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" },
        ],
        relevance: 0,
      }
    const sx = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video",
      ],
      lx = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        "min-width",
        "max-width",
        "min-height",
        "max-height",
      ],
      cx = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        "host",
        "host-context",
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        "lang",
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        "nth-child",
        "nth-col",
        "nth-last-child",
        "nth-last-col",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where",
      ],
      dx = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error",
      ],
      ux = [
        "align-content",
        "align-items",
        "align-self",
        "all",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "block-size",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "caret-color",
        "clear",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "contain",
        "content",
        "content-visibility",
        "counter-increment",
        "counter-reset",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "flow",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-variant",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "gap",
        "glyph-orientation-vertical",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inline-size",
        "isolation",
        "justify-content",
        "left",
        "letter-spacing",
        "line-break",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "mix-blend-mode",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "pause",
        "pause-after",
        "pause-before",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "right",
        "row-gap",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "speak",
        "speak-as",
        "src",
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-all",
        "text-align-last",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "white-space",
        "widows",
        "width",
        "will-change",
        "word-break",
        "word-spacing",
        "word-wrap",
        "writing-mode",
        "z-index",
      ].reverse(),
      px = cx.concat(dx),
      hx = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video",
      ],
      fx = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        "min-width",
        "max-width",
        "min-height",
        "max-height",
      ],
      mx = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        "host",
        "host-context",
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        "lang",
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        "nth-child",
        "nth-col",
        "nth-last-child",
        "nth-last-col",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where",
      ],
      gx = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error",
      ],
      bx = [
        "align-content",
        "align-items",
        "align-self",
        "all",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "block-size",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "caret-color",
        "clear",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "contain",
        "content",
        "content-visibility",
        "counter-increment",
        "counter-reset",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "flow",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-variant",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "gap",
        "glyph-orientation-vertical",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inline-size",
        "isolation",
        "justify-content",
        "left",
        "letter-spacing",
        "line-break",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "mix-blend-mode",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "pause",
        "pause-after",
        "pause-before",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "right",
        "row-gap",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "speak",
        "speak-as",
        "src",
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-all",
        "text-align-last",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "white-space",
        "widows",
        "width",
        "will-change",
        "word-break",
        "word-spacing",
        "word-wrap",
        "writing-mode",
        "z-index",
      ].reverse()
    function vx(e) {
      return e ? ("string" == typeof e ? e : e.source) : null
    }
    function yx(e) {
      return Ox("(?=", e, ")")
    }
    function Ox(...e) {
      return e.map((e) => vx(e)).join("")
    }
    function wx(...e) {
      const t = (function (e) {
        const t = e[e.length - 1]
        return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {}
      })(e)
      return "(" + (t.capture ? "" : "?:") + e.map((e) => vx(e)).join("|") + ")"
    }
    const xx = (e) => Ox(/\b/, e, /\w$/.test(e) ? /\b/ : /\B/),
      kx = ["Protocol", "Type"].map(xx),
      _x = ["init", "self"].map(xx),
      Sx = ["Any", "Self"],
      Ex = [
        "actor",
        "any",
        "associatedtype",
        "async",
        "await",
        /as\?/,
        /as!/,
        "as",
        "borrowing",
        "break",
        "case",
        "catch",
        "class",
        "consume",
        "consuming",
        "continue",
        "convenience",
        "copy",
        "default",
        "defer",
        "deinit",
        "didSet",
        "distributed",
        "do",
        "dynamic",
        "each",
        "else",
        "enum",
        "extension",
        "fallthrough",
        /fileprivate\(set\)/,
        "fileprivate",
        "final",
        "for",
        "func",
        "get",
        "guard",
        "if",
        "import",
        "indirect",
        "infix",
        /init\?/,
        /init!/,
        "inout",
        /internal\(set\)/,
        "internal",
        "in",
        "is",
        "isolated",
        "nonisolated",
        "lazy",
        "let",
        "macro",
        "mutating",
        "nonmutating",
        /open\(set\)/,
        "open",
        "operator",
        "optional",
        "override",
        "postfix",
        "precedencegroup",
        "prefix",
        /private\(set\)/,
        "private",
        "protocol",
        /public\(set\)/,
        "public",
        "repeat",
        "required",
        "rethrows",
        "return",
        "set",
        "some",
        "static",
        "struct",
        "subscript",
        "super",
        "switch",
        "throws",
        "throw",
        /try\?/,
        /try!/,
        "try",
        "typealias",
        /unowned\(safe\)/,
        /unowned\(unsafe\)/,
        "unowned",
        "var",
        "weak",
        "where",
        "while",
        "willSet",
      ],
      Tx = ["false", "nil", "true"],
      Ax = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"],
      Cx = [
        "#colorLiteral",
        "#column",
        "#dsohandle",
        "#else",
        "#elseif",
        "#endif",
        "#error",
        "#file",
        "#fileID",
        "#fileLiteral",
        "#filePath",
        "#function",
        "#if",
        "#imageLiteral",
        "#keyPath",
        "#line",
        "#selector",
        "#sourceLocation",
        "#warning",
      ],
      Px = [
        "abs",
        "all",
        "any",
        "assert",
        "assertionFailure",
        "debugPrint",
        "dump",
        "fatalError",
        "getVaList",
        "isKnownUniquelyReferenced",
        "max",
        "min",
        "numericCast",
        "pointwiseMax",
        "pointwiseMin",
        "precondition",
        "preconditionFailure",
        "print",
        "readLine",
        "repeatElement",
        "sequence",
        "stride",
        "swap",
        "swift_unboxFromSwiftValueWithType",
        "transcode",
        "type",
        "unsafeBitCast",
        "unsafeDowncast",
        "withExtendedLifetime",
        "withUnsafeMutablePointer",
        "withUnsafePointer",
        "withVaList",
        "withoutActuallyEscaping",
        "zip",
      ],
      Dx = wx(
        /[/=\-+!*%<>&|^~?]/,
        /[\u00A1-\u00A7]/,
        /[\u00A9\u00AB]/,
        /[\u00AC\u00AE]/,
        /[\u00B0\u00B1]/,
        /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
        /[\u2016-\u2017]/,
        /[\u2020-\u2027]/,
        /[\u2030-\u203E]/,
        /[\u2041-\u2053]/,
        /[\u2055-\u205E]/,
        /[\u2190-\u23FF]/,
        /[\u2500-\u2775]/,
        /[\u2794-\u2BFF]/,
        /[\u2E00-\u2E7F]/,
        /[\u3001-\u3003]/,
        /[\u3008-\u3020]/,
        /[\u3030]/,
      ),
      Rx = wx(Dx, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/),
      Nx = Ox(Dx, Rx, "*"),
      $x = wx(
        /[a-zA-Z_]/,
        /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
        /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
        /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
        /[\u1E00-\u1FFF]/,
        /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
        /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
        /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
        /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
        /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
        /[\uFE47-\uFEFE\uFF00-\uFFFD]/,
      ),
      Ix = wx($x, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/),
      Mx = Ox($x, Ix, "*"),
      Lx = Ox(/[A-Z]/, Ix, "*"),
      Qx = [
        "attached",
        "autoclosure",
        Ox(/convention\(/, wx("swift", "block", "c"), /\)/),
        "discardableResult",
        "dynamicCallable",
        "dynamicMemberLookup",
        "escaping",
        "freestanding",
        "frozen",
        "GKInspectable",
        "IBAction",
        "IBDesignable",
        "IBInspectable",
        "IBOutlet",
        "IBSegueAction",
        "inlinable",
        "main",
        "nonobjc",
        "NSApplicationMain",
        "NSCopying",
        "NSManaged",
        Ox(/objc\(/, Mx, /\)/),
        "objc",
        "objcMembers",
        "propertyWrapper",
        "requires_stored_property_inits",
        "resultBuilder",
        "Sendable",
        "testable",
        "UIApplicationMain",
        "unchecked",
        "unknown",
        "usableFromInline",
        "warn_unqualified_access",
      ],
      Bx = [
        "iOS",
        "iOSApplicationExtension",
        "macOS",
        "macOSApplicationExtension",
        "macCatalyst",
        "macCatalystApplicationExtension",
        "watchOS",
        "watchOSApplicationExtension",
        "tvOS",
        "tvOSApplicationExtension",
        "swift",
      ],
      jx = "[A-Za-z$_][0-9A-Za-z$_]*",
      Ux = [
        "as",
        "in",
        "of",
        "if",
        "for",
        "while",
        "finally",
        "var",
        "new",
        "function",
        "do",
        "return",
        "void",
        "else",
        "break",
        "catch",
        "instanceof",
        "with",
        "throw",
        "case",
        "default",
        "try",
        "switch",
        "continue",
        "typeof",
        "delete",
        "let",
        "yield",
        "const",
        "class",
        "debugger",
        "async",
        "await",
        "static",
        "import",
        "from",
        "export",
        "extends",
      ],
      Fx = ["true", "false", "null", "undefined", "NaN", "Infinity"],
      zx = [
        "Object",
        "Function",
        "Boolean",
        "Symbol",
        "Math",
        "Date",
        "Number",
        "BigInt",
        "String",
        "RegExp",
        "Array",
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Int32Array",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array",
        "Set",
        "Map",
        "WeakSet",
        "WeakMap",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "Atomics",
        "DataView",
        "JSON",
        "Promise",
        "Generator",
        "GeneratorFunction",
        "AsyncFunction",
        "Reflect",
        "Proxy",
        "Intl",
        "WebAssembly",
      ],
      qx = [
        "Error",
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError",
      ],
      Zx = [
        "setInterval",
        "setTimeout",
        "clearInterval",
        "clearTimeout",
        "require",
        "exports",
        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "unescape",
      ],
      Hx = [
        "arguments",
        "this",
        "super",
        "console",
        "window",
        "document",
        "localStorage",
        "sessionStorage",
        "module",
        "global",
      ],
      Vx = [].concat(Zx, zx, qx)
    function Wx(e) {
      const t = e.regex,
        n = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u),
        r = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ },
        a = { begin: /\s/, contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }] },
        o = e.inherit(a, { begin: /\(/, end: /\)/ }),
        i = e.inherit(e.APOS_STRING_MODE, { className: "string" }),
        s = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
        l = {
          endsWithParent: !0,
          illegal: /</,
          relevance: 0,
          contains: [
            { className: "attr", begin: /[\p{L}0-9._:-]+/u, relevance: 0 },
            {
              begin: /=\s*/,
              relevance: 0,
              contains: [
                {
                  className: "string",
                  endsParent: !0,
                  variants: [
                    { begin: /"/, end: /"/, contains: [r] },
                    { begin: /'/, end: /'/, contains: [r] },
                    { begin: /[^\s"'=<>`]+/ },
                  ],
                },
              ],
            },
          ],
        }
      return {
        name: "HTML, XML",
        aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"],
        case_insensitive: !0,
        unicodeRegex: !0,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              a,
              s,
              i,
              o,
              {
                begin: /\[/,
                end: /\]/,
                contains: [{ className: "meta", begin: /<![a-z]/, end: />/, contains: [a, o, s, i] }],
              },
            ],
          },
          e.COMMENT(/<!--/, /-->/, { relevance: 10 }),
          { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
          r,
          {
            className: "meta",
            end: /\?>/,
            variants: [{ begin: /<\?xml/, relevance: 10, contains: [s] }, { begin: /<\?[a-z][a-z0-9]+/ }],
          },
          {
            className: "tag",
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [l],
            starts: { end: /<\/style>/, returnEnd: !0, subLanguage: ["css", "xml"] },
          },
          {
            className: "tag",
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [l],
            starts: { end: /<\/script>/, returnEnd: !0, subLanguage: ["javascript", "handlebars", "xml"] },
          },
          { className: "tag", begin: /<>|<\/>/ },
          {
            className: "tag",
            begin: t.concat(/</, t.lookahead(t.concat(n, t.either(/\/>/, />/, /\s/)))),
            end: /\/?>/,
            contains: [{ className: "name", begin: n, relevance: 0, starts: l }],
          },
          {
            className: "tag",
            begin: t.concat(/<\//, t.lookahead(t.concat(n, />/))),
            contains: [
              { className: "name", begin: n, relevance: 0 },
              { begin: />/, relevance: 0, endsParent: !0 },
            ],
          },
        ],
      }
    }
    function Xx(e) {
      return (
        e instanceof Map
          ? (e.clear =
              e.delete =
              e.set =
                function () {
                  throw new Error("map is read-only")
                })
          : e instanceof Set &&
            (e.add =
              e.clear =
              e.delete =
                function () {
                  throw new Error("set is read-only")
                }),
        Object.freeze(e),
        Object.getOwnPropertyNames(e).forEach((t) => {
          const n = e[t],
            r = typeof n
          ;("object" !== r && "function" !== r) || Object.isFrozen(n) || Xx(n)
        }),
        e
      )
    }
    let Yx = class {
      constructor(e) {
        void 0 === e.data && (e.data = {}), (this.data = e.data), (this.isMatchIgnored = !1)
      }
      ignoreMatch() {
        this.isMatchIgnored = !0
      }
    }
    function Gx(e) {
      return e
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#x27;")
    }
    function Kx(e, ...t) {
      const n = Object.create(null)
      for (const t in e) n[t] = e[t]
      return (
        t.forEach(function (e) {
          for (const t in e) n[t] = e[t]
        }),
        n
      )
    }
    const Jx = (e) => !!e.scope
    class ek {
      constructor(e, t) {
        ;(this.buffer = ""), (this.classPrefix = t.classPrefix), e.walk(this)
      }
      addText(e) {
        this.buffer += Gx(e)
      }
      openNode(e) {
        if (!Jx(e)) return
        const t = ((e, { prefix: t }) => {
          if (e.startsWith("language:")) return e.replace("language:", "language-")
          if (e.includes(".")) {
            const n = e.split(".")
            return [`${t}${n.shift()}`, ...n.map((e, t) => `${e}${"_".repeat(t + 1)}`)].join(" ")
          }
          return `${t}${e}`
        })(e.scope, { prefix: this.classPrefix })
        this.span(t)
      }
      closeNode(e) {
        Jx(e) && (this.buffer += "</span>")
      }
      value() {
        return this.buffer
      }
      span(e) {
        this.buffer += `<span class="${e}">`
      }
    }
    const tk = (e = {}) => {
      const t = { children: [] }
      return Object.assign(t, e), t
    }
    class nk {
      constructor() {
        ;(this.rootNode = tk()), (this.stack = [this.rootNode])
      }
      get top() {
        return this.stack[this.stack.length - 1]
      }
      get root() {
        return this.rootNode
      }
      add(e) {
        this.top.children.push(e)
      }
      openNode(e) {
        const t = tk({ scope: e })
        this.add(t), this.stack.push(t)
      }
      closeNode() {
        if (this.stack.length > 1) return this.stack.pop()
      }
      closeAllNodes() {
        for (; this.closeNode(); );
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4)
      }
      walk(e) {
        return this.constructor._walk(e, this.rootNode)
      }
      static _walk(e, t) {
        return (
          "string" == typeof t
            ? e.addText(t)
            : t.children && (e.openNode(t), t.children.forEach((t) => this._walk(e, t)), e.closeNode(t)),
          e
        )
      }
      static _collapse(e) {
        "string" != typeof e &&
          e.children &&
          (e.children.every((e) => "string" == typeof e)
            ? (e.children = [e.children.join("")])
            : e.children.forEach((e) => {
                nk._collapse(e)
              }))
      }
    }
    class rk extends nk {
      constructor(e) {
        super(), (this.options = e)
      }
      addText(e) {
        "" !== e && this.add(e)
      }
      startScope(e) {
        this.openNode(e)
      }
      endScope() {
        this.closeNode()
      }
      __addSublanguage(e, t) {
        const n = e.root
        t && (n.scope = `language:${t}`), this.add(n)
      }
      toHTML() {
        return new ek(this, this.options).value()
      }
      finalize() {
        return this.closeAllNodes(), !0
      }
    }
    function ak(e) {
      return e ? ("string" == typeof e ? e : e.source) : null
    }
    function ok(e) {
      return lk("(?=", e, ")")
    }
    function ik(e) {
      return lk("(?:", e, ")*")
    }
    function sk(e) {
      return lk("(?:", e, ")?")
    }
    function lk(...e) {
      return e.map((e) => ak(e)).join("")
    }
    function ck(...e) {
      const t = (function (e) {
        const t = e[e.length - 1]
        return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {}
      })(e)
      return "(" + (t.capture ? "" : "?:") + e.map((e) => ak(e)).join("|") + ")"
    }
    function dk(e) {
      return new RegExp(e.toString() + "|").exec("").length - 1
    }
    const uk = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
    function pk(e, { joinWith: t }) {
      let n = 0
      return e
        .map((e) => {
          n += 1
          const t = n
          let r = ak(e),
            a = ""
          for (; r.length > 0; ) {
            const e = uk.exec(r)
            if (!e) {
              a += r
              break
            }
            ;(a += r.substring(0, e.index)),
              (r = r.substring(e.index + e[0].length)),
              "\\" === e[0][0] && e[1] ? (a += "\\" + String(Number(e[1]) + t)) : ((a += e[0]), "(" === e[0] && n++)
          }
          return a
        })
        .map((e) => `(${e})`)
        .join(t)
    }
    const hk = "[a-zA-Z]\\w*",
      fk = "[a-zA-Z_]\\w*",
      mk = "\\b\\d+(\\.\\d+)?",
      gk = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",
      bk = "\\b(0b[01]+)",
      vk = { begin: "\\\\[\\s\\S]", relevance: 0 },
      yk = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [vk] },
      Ok = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [vk] },
      wk = function (e, t, n = {}) {
        const r = Kx({ scope: "comment", begin: e, end: t, contains: [] }, n)
        r.contains.push({
          scope: "doctag",
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: !0,
          relevance: 0,
        })
        const a = ck(
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          /[A-Za-z]+[-][a-z]+/,
          /[A-Za-z][a-z]{2,}/,
        )
        return r.contains.push({ begin: lk(/[ ]+/, "(", a, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), r
      },
      xk = wk("//", "$"),
      kk = wk("/\\*", "\\*/"),
      _k = wk("#", "$"),
      Sk = { scope: "number", begin: mk, relevance: 0 },
      Ek = { scope: "number", begin: gk, relevance: 0 },
      Tk = { scope: "number", begin: bk, relevance: 0 },
      Ak = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [vk, { begin: /\[/, end: /\]/, relevance: 0, contains: [vk] }],
      },
      Ck = { scope: "title", begin: hk, relevance: 0 },
      Pk = { scope: "title", begin: fk, relevance: 0 },
      Dk = { begin: "\\.\\s*" + fk, relevance: 0 }
    var Rk = Object.freeze({
      __proto__: null,
      APOS_STRING_MODE: yk,
      BACKSLASH_ESCAPE: vk,
      BINARY_NUMBER_MODE: Tk,
      BINARY_NUMBER_RE: bk,
      COMMENT: wk,
      C_BLOCK_COMMENT_MODE: kk,
      C_LINE_COMMENT_MODE: xk,
      C_NUMBER_MODE: Ek,
      C_NUMBER_RE: gk,
      END_SAME_AS_BEGIN: function (e) {
        return Object.assign(e, {
          "on:begin": (e, t) => {
            t.data._beginMatch = e[1]
          },
          "on:end": (e, t) => {
            t.data._beginMatch !== e[1] && t.ignoreMatch()
          },
        })
      },
      HASH_COMMENT_MODE: _k,
      IDENT_RE: hk,
      MATCH_NOTHING_RE: /\b\B/,
      METHOD_GUARD: Dk,
      NUMBER_MODE: Sk,
      NUMBER_RE: mk,
      PHRASAL_WORDS_MODE: {
        begin:
          /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
      },
      QUOTE_STRING_MODE: Ok,
      REGEXP_MODE: Ak,
      RE_STARTERS_RE:
        "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
      SHEBANG: (e = {}) => {
        const t = /^#![ ]*\//
        return (
          e.binary && (e.begin = lk(t, /.*\b/, e.binary, /\b.*/)),
          Kx(
            {
              scope: "meta",
              begin: t,
              end: /$/,
              relevance: 0,
              "on:begin": (e, t) => {
                0 !== e.index && t.ignoreMatch()
              },
            },
            e,
          )
        )
      },
      TITLE_MODE: Ck,
      UNDERSCORE_IDENT_RE: fk,
      UNDERSCORE_TITLE_MODE: Pk,
    })
    function Nk(e, t) {
      "." === e.input[e.index - 1] && t.ignoreMatch()
    }
    function $k(e, t) {
      void 0 !== e.className && ((e.scope = e.className), delete e.className)
    }
    function Ik(e, t) {
      t &&
        e.beginKeywords &&
        ((e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)"),
        (e.__beforeBegin = Nk),
        (e.keywords = e.keywords || e.beginKeywords),
        delete e.beginKeywords,
        void 0 === e.relevance && (e.relevance = 0))
    }
    function Mk(e, t) {
      Array.isArray(e.illegal) && (e.illegal = ck(...e.illegal))
    }
    function Lk(e, t) {
      if (e.match) {
        if (e.begin || e.end) throw new Error("begin & end are not supported with match")
        ;(e.begin = e.match), delete e.match
      }
    }
    function Qk(e, t) {
      void 0 === e.relevance && (e.relevance = 1)
    }
    const Bk = (e, t) => {
        if (!e.beforeMatch) return
        if (e.starts) throw new Error("beforeMatch cannot be used with starts")
        const n = Object.assign({}, e)
        Object.keys(e).forEach((t) => {
          delete e[t]
        }),
          (e.keywords = n.keywords),
          (e.begin = lk(n.beforeMatch, ok(n.begin))),
          (e.starts = { relevance: 0, contains: [Object.assign(n, { endsParent: !0 })] }),
          (e.relevance = 0),
          delete n.beforeMatch
      },
      jk = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"],
      Uk = "keyword"
    function Fk(e, t, n = Uk) {
      const r = Object.create(null)
      return (
        "string" == typeof e
          ? a(n, e.split(" "))
          : Array.isArray(e)
            ? a(n, e)
            : Object.keys(e).forEach(function (n) {
                Object.assign(r, Fk(e[n], t, n))
              }),
        r
      )
      function a(e, n) {
        t && (n = n.map((e) => e.toLowerCase())),
          n.forEach(function (t) {
            const n = t.split("|")
            r[n[0]] = [e, zk(n[0], n[1])]
          })
      }
    }
    function zk(e, t) {
      return t
        ? Number(t)
        : (function (e) {
              return jk.includes(e.toLowerCase())
            })(e)
          ? 0
          : 1
    }
    const qk = {},
      Zk = (e) => {
        console.error(e)
      },
      Hk = (e, ...t) => {
        console.log(`WARN: ${e}`, ...t)
      },
      Vk = (e, t) => {
        qk[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), (qk[`${e}/${t}`] = !0))
      },
      Wk = new Error()
    function Xk(e, t, { key: n }) {
      let r = 0
      const a = e[n],
        o = {},
        i = {}
      for (let e = 1; e <= t.length; e++) (i[e + r] = a[e]), (o[e + r] = !0), (r += dk(t[e - 1]))
      ;(e[n] = i), (e[n]._emit = o), (e[n]._multi = !0)
    }
    function Yk(e) {
      !(function (e) {
        e.scope && "object" == typeof e.scope && null !== e.scope && ((e.beginScope = e.scope), delete e.scope)
      })(e),
        "string" == typeof e.beginScope && (e.beginScope = { _wrap: e.beginScope }),
        "string" == typeof e.endScope && (e.endScope = { _wrap: e.endScope }),
        (function (e) {
          if (Array.isArray(e.begin)) {
            if (e.skip || e.excludeBegin || e.returnBegin)
              throw (Zk("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Wk)
            if ("object" != typeof e.beginScope || null === e.beginScope) throw (Zk("beginScope must be object"), Wk)
            Xk(e, e.begin, { key: "beginScope" }), (e.begin = pk(e.begin, { joinWith: "" }))
          }
        })(e),
        (function (e) {
          if (Array.isArray(e.end)) {
            if (e.skip || e.excludeEnd || e.returnEnd)
              throw (Zk("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Wk)
            if ("object" != typeof e.endScope || null === e.endScope) throw (Zk("endScope must be object"), Wk)
            Xk(e, e.end, { key: "endScope" }), (e.end = pk(e.end, { joinWith: "" }))
          }
        })(e)
    }
    function Gk(e) {
      function t(t, n) {
        return new RegExp(ak(t), "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (n ? "g" : ""))
      }
      class n {
        constructor() {
          ;(this.matchIndexes = {}), (this.regexes = []), (this.matchAt = 1), (this.position = 0)
        }
        addRule(e, t) {
          ;(t.position = this.position++),
            (this.matchIndexes[this.matchAt] = t),
            this.regexes.push([t, e]),
            (this.matchAt += dk(e) + 1)
        }
        compile() {
          0 === this.regexes.length && (this.exec = () => null)
          const e = this.regexes.map((e) => e[1])
          ;(this.matcherRe = t(pk(e, { joinWith: "|" }), !0)), (this.lastIndex = 0)
        }
        exec(e) {
          this.matcherRe.lastIndex = this.lastIndex
          const t = this.matcherRe.exec(e)
          if (!t) return null
          const n = t.findIndex((e, t) => t > 0 && void 0 !== e),
            r = this.matchIndexes[n]
          return t.splice(0, n), Object.assign(t, r)
        }
      }
      class r {
        constructor() {
          ;(this.rules = []), (this.multiRegexes = []), (this.count = 0), (this.lastIndex = 0), (this.regexIndex = 0)
        }
        getMatcher(e) {
          if (this.multiRegexes[e]) return this.multiRegexes[e]
          const t = new n()
          return this.rules.slice(e).forEach(([e, n]) => t.addRule(e, n)), t.compile(), (this.multiRegexes[e] = t), t
        }
        resumingScanAtSamePosition() {
          return 0 !== this.regexIndex
        }
        considerAll() {
          this.regexIndex = 0
        }
        addRule(e, t) {
          this.rules.push([e, t]), "begin" === t.type && this.count++
        }
        exec(e) {
          const t = this.getMatcher(this.regexIndex)
          t.lastIndex = this.lastIndex
          let n = t.exec(e)
          if (this.resumingScanAtSamePosition())
            if (n && n.index === this.lastIndex);
            else {
              const t = this.getMatcher(0)
              ;(t.lastIndex = this.lastIndex + 1), (n = t.exec(e))
            }
          return n && ((this.regexIndex += n.position + 1), this.regexIndex === this.count && this.considerAll()), n
        }
      }
      if ((e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self")))
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.")
      return (
        (e.classNameAliases = Kx(e.classNameAliases || {})),
        (function n(a, o) {
          const i = a
          if (a.isCompiled) return i
          ;[$k, Lk, Yk, Bk].forEach((e) => e(a, o)),
            e.compilerExtensions.forEach((e) => e(a, o)),
            (a.__beforeBegin = null),
            [Ik, Mk, Qk].forEach((e) => e(a, o)),
            (a.isCompiled = !0)
          let s = null
          return (
            "object" == typeof a.keywords &&
              a.keywords.$pattern &&
              ((a.keywords = Object.assign({}, a.keywords)), (s = a.keywords.$pattern), delete a.keywords.$pattern),
            (s = s || /\w+/),
            a.keywords && (a.keywords = Fk(a.keywords, e.case_insensitive)),
            (i.keywordPatternRe = t(s, !0)),
            o &&
              (a.begin || (a.begin = /\B|\b/),
              (i.beginRe = t(i.begin)),
              a.end || a.endsWithParent || (a.end = /\B|\b/),
              a.end && (i.endRe = t(i.end)),
              (i.terminatorEnd = ak(i.end) || ""),
              a.endsWithParent && o.terminatorEnd && (i.terminatorEnd += (a.end ? "|" : "") + o.terminatorEnd)),
            a.illegal && (i.illegalRe = t(a.illegal)),
            a.contains || (a.contains = []),
            (a.contains = [].concat(
              ...a.contains.map(function (e) {
                return (function (e) {
                  return (
                    e.variants &&
                      !e.cachedVariants &&
                      (e.cachedVariants = e.variants.map(function (t) {
                        return Kx(e, { variants: null }, t)
                      })),
                    e.cachedVariants
                      ? e.cachedVariants
                      : Kk(e)
                        ? Kx(e, { starts: e.starts ? Kx(e.starts) : null })
                        : Object.isFrozen(e)
                          ? Kx(e)
                          : e
                  )
                })("self" === e ? a : e)
              }),
            )),
            a.contains.forEach(function (e) {
              n(e, i)
            }),
            a.starts && n(a.starts, o),
            (i.matcher = (function (e) {
              const t = new r()
              return (
                e.contains.forEach((e) => t.addRule(e.begin, { rule: e, type: "begin" })),
                e.terminatorEnd && t.addRule(e.terminatorEnd, { type: "end" }),
                e.illegal && t.addRule(e.illegal, { type: "illegal" }),
                t
              )
            })(i)),
            i
          )
        })(e)
      )
    }
    function Kk(e) {
      return !!e && (e.endsWithParent || Kk(e.starts))
    }
    class Jk extends Error {
      constructor(e, t) {
        super(e), (this.name = "HTMLInjectionError"), (this.html = t)
      }
    }
    const e_ = Gx,
      t_ = Kx,
      n_ = Symbol("nomatch"),
      r_ = function (e) {
        const t = Object.create(null),
          n = Object.create(null),
          r = []
        let a = !0
        const o = "Could not find the language '{}', did you forget to load/include a language module?",
          i = { disableAutodetect: !0, name: "Plain text", contains: [] }
        let s = {
          ignoreUnescapedHTML: !1,
          throwUnescapedHTML: !1,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          __emitter: rk,
        }
        function l(e) {
          return s.noHighlightRe.test(e)
        }
        function c(e, t, n) {
          let r = "",
            a = ""
          "object" == typeof t
            ? ((r = e), (n = t.ignoreIllegals), (a = t.language))
            : (Vk("10.7.0", "highlight(lang, code, ...args) has been deprecated."),
              Vk(
                "10.7.0",
                "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277",
              ),
              (a = e),
              (r = t)),
            void 0 === n && (n = !0)
          const o = { code: r, language: a }
          v("before:highlight", o)
          const i = o.result ? o.result : d(o.language, o.code, n)
          return (i.code = o.code), v("after:highlight", i), i
        }
        function d(e, n, r, i) {
          const l = Object.create(null)
          function c() {
            if (!S.keywords) return void T.addText(A)
            let e = 0
            S.keywordPatternRe.lastIndex = 0
            let t = S.keywordPatternRe.exec(A),
              n = ""
            for (; t; ) {
              n += A.substring(e, t.index)
              const a = x.case_insensitive ? t[0].toLowerCase() : t[0],
                o = ((r = a), S.keywords[r])
              if (o) {
                const [e, r] = o
                if ((T.addText(n), (n = ""), (l[a] = (l[a] || 0) + 1), l[a] <= 7 && (C += r), e.startsWith("_")))
                  n += t[0]
                else {
                  const n = x.classNameAliases[e] || e
                  h(t[0], n)
                }
              } else n += t[0]
              ;(e = S.keywordPatternRe.lastIndex), (t = S.keywordPatternRe.exec(A))
            }
            var r
            ;(n += A.substring(e)), T.addText(n)
          }
          function p() {
            null != S.subLanguage
              ? (function () {
                  if ("" === A) return
                  let e = null
                  if ("string" == typeof S.subLanguage) {
                    if (!t[S.subLanguage]) return void T.addText(A)
                    ;(e = d(S.subLanguage, A, !0, E[S.subLanguage])), (E[S.subLanguage] = e._top)
                  } else e = u(A, S.subLanguage.length ? S.subLanguage : null)
                  S.relevance > 0 && (C += e.relevance), T.__addSublanguage(e._emitter, e.language)
                })()
              : c(),
              (A = "")
          }
          function h(e, t) {
            "" !== e && (T.startScope(t), T.addText(e), T.endScope())
          }
          function f(e, t) {
            let n = 1
            const r = t.length - 1
            for (; n <= r; ) {
              if (!e._emit[n]) {
                n++
                continue
              }
              const r = x.classNameAliases[e[n]] || e[n],
                a = t[n]
              r ? h(a, r) : ((A = a), c(), (A = "")), n++
            }
          }
          function g(e, t) {
            return (
              e.scope && "string" == typeof e.scope && T.openNode(x.classNameAliases[e.scope] || e.scope),
              e.beginScope &&
                (e.beginScope._wrap
                  ? (h(A, x.classNameAliases[e.beginScope._wrap] || e.beginScope._wrap), (A = ""))
                  : e.beginScope._multi && (f(e.beginScope, t), (A = ""))),
              (S = Object.create(e, { parent: { value: S } })),
              S
            )
          }
          function b(e, t, n) {
            let r = (function (e, t) {
              const n = e && e.exec(t)
              return n && 0 === n.index
            })(e.endRe, n)
            if (r) {
              if (e["on:end"]) {
                const n = new Yx(e)
                e["on:end"](t, n), n.isMatchIgnored && (r = !1)
              }
              if (r) {
                for (; e.endsParent && e.parent; ) e = e.parent
                return e
              }
            }
            if (e.endsWithParent) return b(e.parent, t, n)
          }
          function v(e) {
            return 0 === S.matcher.regexIndex ? ((A += e[0]), 1) : ((R = !0), 0)
          }
          function y(e) {
            const t = e[0],
              r = n.substring(e.index),
              a = b(S, e, r)
            if (!a) return n_
            const o = S
            S.endScope && S.endScope._wrap
              ? (p(), h(t, S.endScope._wrap))
              : S.endScope && S.endScope._multi
                ? (p(), f(S.endScope, e))
                : o.skip
                  ? (A += t)
                  : (o.returnEnd || o.excludeEnd || (A += t), p(), o.excludeEnd && (A = t))
            do {
              S.scope && T.closeNode(), S.skip || S.subLanguage || (C += S.relevance), (S = S.parent)
            } while (S !== a.parent)
            return a.starts && g(a.starts, e), o.returnEnd ? 0 : t.length
          }
          let O = {}
          function w(t, o) {
            const i = o && o[0]
            if (((A += t), null == i)) return p(), 0
            if ("begin" === O.type && "end" === o.type && O.index === o.index && "" === i) {
              if (((A += n.slice(o.index, o.index + 1)), !a)) {
                const t = new Error(`0 width match regex (${e})`)
                throw ((t.languageName = e), (t.badRule = O.rule), t)
              }
              return 1
            }
            if (((O = o), "begin" === o.type))
              return (function (e) {
                const t = e[0],
                  n = e.rule,
                  r = new Yx(n),
                  a = [n.__beforeBegin, n["on:begin"]]
                for (const n of a) if (n && (n(e, r), r.isMatchIgnored)) return v(t)
                return (
                  n.skip ? (A += t) : (n.excludeBegin && (A += t), p(), n.returnBegin || n.excludeBegin || (A = t)),
                  g(n, e),
                  n.returnBegin ? 0 : t.length
                )
              })(o)
            if ("illegal" === o.type && !r) {
              const e = new Error('Illegal lexeme "' + i + '" for mode "' + (S.scope || "<unnamed>") + '"')
              throw ((e.mode = S), e)
            }
            if ("end" === o.type) {
              const e = y(o)
              if (e !== n_) return e
            }
            if ("illegal" === o.type && "" === i) return 1
            if (D > 1e5 && D > 3 * o.index) throw new Error("potential infinite loop, way more iterations than matches")
            return (A += i), i.length
          }
          const x = m(e)
          if (!x) throw (Zk(o.replace("{}", e)), new Error('Unknown language: "' + e + '"'))
          const k = Gk(x)
          let _ = "",
            S = i || k
          const E = {},
            T = new s.__emitter(s)
          !(function () {
            const e = []
            for (let t = S; t !== x; t = t.parent) t.scope && e.unshift(t.scope)
            e.forEach((e) => T.openNode(e))
          })()
          let A = "",
            C = 0,
            P = 0,
            D = 0,
            R = !1
          try {
            if (x.__emitTokens) x.__emitTokens(n, T)
            else {
              for (S.matcher.considerAll(); ; ) {
                D++, R ? (R = !1) : S.matcher.considerAll(), (S.matcher.lastIndex = P)
                const e = S.matcher.exec(n)
                if (!e) break
                const t = w(n.substring(P, e.index), e)
                P = e.index + t
              }
              w(n.substring(P))
            }
            return (
              T.finalize(), (_ = T.toHTML()), { language: e, value: _, relevance: C, illegal: !1, _emitter: T, _top: S }
            )
          } catch (t) {
            if (t.message && t.message.includes("Illegal"))
              return {
                language: e,
                value: e_(n),
                illegal: !0,
                relevance: 0,
                _illegalBy: {
                  message: t.message,
                  index: P,
                  context: n.slice(P - 100, P + 100),
                  mode: t.mode,
                  resultSoFar: _,
                },
                _emitter: T,
              }
            if (a) return { language: e, value: e_(n), illegal: !1, relevance: 0, errorRaised: t, _emitter: T, _top: S }
            throw t
          }
        }
        function u(e, n) {
          n = n || s.languages || Object.keys(t)
          const r = (function (e) {
              const t = { value: e_(e), illegal: !1, relevance: 0, _top: i, _emitter: new s.__emitter(s) }
              return t._emitter.addText(e), t
            })(e),
            a = n
              .filter(m)
              .filter(b)
              .map((t) => d(t, e, !1))
          a.unshift(r)
          const o = a.sort((e, t) => {
              if (e.relevance !== t.relevance) return t.relevance - e.relevance
              if (e.language && t.language) {
                if (m(e.language).supersetOf === t.language) return 1
                if (m(t.language).supersetOf === e.language) return -1
              }
              return 0
            }),
            [l, c] = o,
            u = l
          return (u.secondBest = c), u
        }
        function p(e) {
          let t = null
          const r = (function (e) {
            let t = e.className + " "
            t += e.parentNode ? e.parentNode.className : ""
            const n = s.languageDetectRe.exec(t)
            if (n) {
              const t = m(n[1])
              return (
                t || (Hk(o.replace("{}", n[1])), Hk("Falling back to no-highlight mode for this block.", e)),
                t ? n[1] : "no-highlight"
              )
            }
            return t.split(/\s+/).find((e) => l(e) || m(e))
          })(e)
          if (l(r)) return
          if ((v("before:highlightElement", { el: e, language: r }), e.dataset.highlighted))
            return void console.log(
              "Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",
              e,
            )
          if (
            e.children.length > 0 &&
            (s.ignoreUnescapedHTML ||
              (console.warn(
                "One of your code blocks includes unescaped HTML. This is a potentially serious security risk.",
              ),
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),
              console.warn("The element with unescaped HTML:"),
              console.warn(e)),
            s.throwUnescapedHTML)
          )
            throw new Jk("One of your code blocks includes unescaped HTML.", e.innerHTML)
          t = e
          const a = t.textContent,
            i = r ? c(a, { language: r, ignoreIllegals: !0 }) : u(a)
          ;(e.innerHTML = i.value),
            (e.dataset.highlighted = "yes"),
            (function (e, t, r) {
              const a = (t && n[t]) || r
              e.classList.add("hljs"), e.classList.add(`language-${a}`)
            })(e, r, i.language),
            (e.result = { language: i.language, re: i.relevance, relevance: i.relevance }),
            i.secondBest && (e.secondBest = { language: i.secondBest.language, relevance: i.secondBest.relevance }),
            v("after:highlightElement", { el: e, result: i, text: a })
        }
        let h = !1
        function f() {
          "loading" !== document.readyState ? document.querySelectorAll(s.cssSelector).forEach(p) : (h = !0)
        }
        function m(e) {
          return (e = (e || "").toLowerCase()), t[e] || t[n[e]]
        }
        function g(e, { languageName: t }) {
          "string" == typeof e && (e = [e]),
            e.forEach((e) => {
              n[e.toLowerCase()] = t
            })
        }
        function b(e) {
          const t = m(e)
          return t && !t.disableAutodetect
        }
        function v(e, t) {
          const n = e
          r.forEach(function (e) {
            e[n] && e[n](t)
          })
        }
        "undefined" != typeof window &&
          window.addEventListener &&
          window.addEventListener(
            "DOMContentLoaded",
            function () {
              h && f()
            },
            !1,
          ),
          Object.assign(e, {
            highlight: c,
            highlightAuto: u,
            highlightAll: f,
            highlightElement: p,
            highlightBlock: function (e) {
              return (
                Vk("10.7.0", "highlightBlock will be removed entirely in v12.0"),
                Vk("10.7.0", "Please use highlightElement now."),
                p(e)
              )
            },
            configure: function (e) {
              s = t_(s, e)
            },
            initHighlighting: () => {
              f(), Vk("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.")
            },
            initHighlightingOnLoad: function () {
              f(), Vk("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.")
            },
            registerLanguage: function (n, r) {
              let o = null
              try {
                o = r(e)
              } catch (e) {
                if ((Zk("Language definition for '{}' could not be registered.".replace("{}", n)), !a)) throw e
                Zk(e), (o = i)
              }
              o.name || (o.name = n),
                (t[n] = o),
                (o.rawDefinition = r.bind(null, e)),
                o.aliases && g(o.aliases, { languageName: n })
            },
            unregisterLanguage: function (e) {
              delete t[e]
              for (const t of Object.keys(n)) n[t] === e && delete n[t]
            },
            listLanguages: function () {
              return Object.keys(t)
            },
            getLanguage: m,
            registerAliases: g,
            autoDetection: b,
            inherit: t_,
            addPlugin: function (e) {
              !(function (e) {
                e["before:highlightBlock"] &&
                  !e["before:highlightElement"] &&
                  (e["before:highlightElement"] = (t) => {
                    e["before:highlightBlock"](Object.assign({ block: t.el }, t))
                  }),
                  e["after:highlightBlock"] &&
                    !e["after:highlightElement"] &&
                    (e["after:highlightElement"] = (t) => {
                      e["after:highlightBlock"](Object.assign({ block: t.el }, t))
                    })
              })(e),
                r.push(e)
            },
            removePlugin: function (e) {
              const t = r.indexOf(e)
              ;-1 !== t && r.splice(t, 1)
            },
          }),
          (e.debugMode = function () {
            a = !1
          }),
          (e.safeMode = function () {
            a = !0
          }),
          (e.versionString = "11.9.0"),
          (e.regex = { concat: lk, lookahead: ok, either: ck, optional: sk, anyNumberOfTimes: ik })
        for (const e in Rk) "object" == typeof Rk[e] && Xx(Rk[e])
        return Object.assign(e, Rk), e
      },
      a_ = r_({})
    a_.newInstance = () => r_({})
    var o_ = a_
    ;(a_.HighlightJS = a_), (a_.default = a_)
    const i_ = em(o_),
      s_ = {},
      l_ = "hljs-"
    class c_ {
      constructor(e) {
        ;(this.options = e),
          (this.root = { type: "root", children: [], data: { language: void 0, relevance: 0 } }),
          (this.stack = [this.root])
      }
      addText(e) {
        if ("" === e) return
        const t = this.stack[this.stack.length - 1],
          n = t.children[t.children.length - 1]
        n && "text" === n.type ? (n.value += e) : t.children.push({ type: "text", value: e })
      }
      startScope(e) {
        this.openNode(String(e))
      }
      endScope() {
        this.closeNode()
      }
      __addSublanguage(e, t) {
        const n = this.stack[this.stack.length - 1],
          r = e.root.children
        t
          ? n.children.push({ type: "element", tagName: "span", properties: { className: [t] }, children: r })
          : n.children.push(...r)
      }
      openNode(e) {
        const t = this,
          n = {
            type: "element",
            tagName: "span",
            properties: {
              className: e.split(".").map(function (e, n) {
                return n ? e + "_".repeat(n) : t.options.classPrefix + e
              }),
            },
            children: [],
          }
        this.stack[this.stack.length - 1].children.push(n), this.stack.push(n)
      }
      closeNode() {
        this.stack.pop()
      }
      finalize() {}
      toHTML() {
        return ""
      }
    }
    const d_ = [],
      u_ = !0,
      p_ = !1,
      h_ = "skip"
    function f_(e, t, n, r) {
      let a
      "function" == typeof t && "function" != typeof n ? ((r = n), (n = t)) : (a = t)
      const o = bw(a),
        i = r ? -1 : 1
      !(function e(a, s, l) {
        const c = a && "object" == typeof a ? a : {}
        if ("string" == typeof c.type) {
          const e = "string" == typeof c.tagName ? c.tagName : "string" == typeof c.name ? c.name : void 0
          Object.defineProperty(d, "name", { value: "node (" + a.type + (e ? "<" + e + ">" : "") + ")" })
        }
        return d
        function d() {
          let c,
            d,
            u,
            p = d_
          if (
            (!t || o(a, s, l[l.length - 1] || void 0)) &&
            ((p = (function (e) {
              return Array.isArray(e) ? e : "number" == typeof e ? [u_, e] : null == e ? d_ : [e]
            })(n(a, l))),
            p[0] === p_)
          )
            return p
          if ("children" in a && a.children) {
            const t = a
            if (t.children && p[0] !== h_)
              for (d = (r ? t.children.length : -1) + i, u = l.concat(t); d > -1 && d < t.children.length; ) {
                const n = t.children[d]
                if (((c = e(n, d, u)()), c[0] === p_)) return c
                d = "number" == typeof c[1] ? c[1] : d + i
              }
          }
          return p
        }
      })(e, void 0, [])()
    }
    function m_(e, t, n, r) {
      let a, o, i
      "function" == typeof t && "function" != typeof n ? ((o = void 0), (i = t), (a = n)) : ((o = t), (i = n), (a = r)),
        f_(
          e,
          o,
          function (e, t) {
            const n = t[t.length - 1],
              r = n ? n.children.indexOf(e) : void 0
            return i(e, r, n)
          },
          a,
        )
    }
    const g_ = {}
    function b_(e) {
      const t = e || g_,
        n = t.aliases,
        r = (null == e ? void 0 : e.detect) ?? !1,
        a = t.languages,
        o = t.plainText,
        i = t.prefix,
        s = t.subset
      let l = "hljs"
      const c =
        (null == e ? void 0 : e.lowlight) ??
        (function (e) {
          const t = i_.newInstance()
          return (
            e && a(e),
            {
              highlight: n,
              highlightAuto: function (e, a) {
                const o = (a || s_).subset || r()
                let i,
                  s = -1,
                  l = 0
                for (; ++s < o.length; ) {
                  const r = o[s]
                  if (!t.getLanguage(r)) continue
                  const c = n(r, e, a)
                  c.data && void 0 !== c.data.relevance && c.data.relevance > l && ((l = c.data.relevance), (i = c))
                }
                return i || { type: "root", children: [], data: { language: void 0, relevance: l } }
              },
              listLanguages: r,
              register: a,
              registerAlias: function (e, n) {
                if ("string" == typeof e) t.registerAliases("string" == typeof n ? n : [...n], { languageName: e })
                else {
                  let n
                  for (n in e)
                    if (Object.hasOwn(e, n)) {
                      const r = e[n]
                      t.registerAliases("string" == typeof r ? r : [...r], { languageName: n })
                    }
                }
              },
              registered: function (e) {
                return Boolean(t.getLanguage(e))
              },
            }
          )
          function n(e, n, r) {
            const a = r || s_,
              o = "string" == typeof a.prefix ? a.prefix : l_
            if (!t.getLanguage(e)) throw new Error("Unknown language: `" + e + "` is not registered")
            t.configure({ __emitter: c_, classPrefix: o })
            const i = t.highlight(n, { ignoreIllegals: !0, language: e })
            if (i.errorRaised) throw new Error("Could not highlight with `Highlight.js`", { cause: i.errorRaised })
            const s = i._emitter.root,
              l = s.data
            return (l.language = i.language), (l.relevance = i.relevance), s
          }
          function r() {
            return t.listLanguages()
          }
          function a(e, n) {
            if ("string" == typeof e) t.registerLanguage(e, n)
            else {
              let n
              for (n in e) Object.hasOwn(e, n) && t.registerLanguage(n, e[n])
            }
          }
        })(a)
      if ((n && c.registerAlias(n), i)) {
        const e = i.indexOf("-")
        l = e > -1 ? i.slice(0, e) : i
      }
      return function (e, t) {
        m_(e, "element", function (e, n, a) {
          var d
          if ("code" !== e.tagName || !a || "element" !== a.type || "pre" !== a.tagName) return
          const u = (function (e) {
            const t = e.properties.className
            if (!Array.isArray(t)) return ""
            const n = t.reduce((e, t) => {
              if (e) return e
              const n = String(t)
              return "no-highlight" === n || "nohighlight" === n
                ? "no-highlight"
                : "lang-" === n.slice(0, 5)
                  ? n.slice(5)
                  : "language-" === n.slice(0, 9)
                    ? n.slice(9)
                    : e
            }, "")
            return gw[n || ""] || n
          })(e)
          if ("no-highlight" === u || (!u && !r) || (u && (null == o ? void 0 : o.includes(u)))) return
          let p
          Array.isArray(e.properties.className) || (e.properties.className = []),
            e.properties.className.includes(l) || e.properties.className.unshift(l)
          try {
            p = u ? c.highlight(u, $w(a), { prefix: i }) : c.highlightAuto($w(a), { prefix: i, subset: s })
          } catch (n) {
            const r = n
            if (u && /Unknown language/.test(r.message))
              return void t.message("Cannot highlight as `" + u + "`, its not registered", {
                ancestors: [a, e],
                cause: r,
                place: e.position,
                ruleId: "missing-language",
                source: "rehype-highlight",
              })
            throw r
          }
          !u &&
            (null == (d = p.data) ? void 0 : d.language) &&
            e.properties.className.push("language-" + p.data.language),
            p.children.length > 0 && (e.children = p.children)
        })
      }
    }
    const v_ = "object" == typeof self ? self : globalThis,
      y_ = (e) =>
        ((e, t) => {
          const n = (t, n) => (e.set(n, t), t),
            r = (a) => {
              if (e.has(a)) return e.get(a)
              const [o, i] = t[a]
              switch (o) {
                case 0:
                case -1:
                  return n(i, a)
                case 1: {
                  const e = n([], a)
                  for (const t of i) e.push(r(t))
                  return e
                }
                case 2: {
                  const e = n({}, a)
                  for (const [t, n] of i) e[r(t)] = r(n)
                  return e
                }
                case 3:
                  return n(new Date(i), a)
                case 4: {
                  const { source: e, flags: t } = i
                  return n(new RegExp(e, t), a)
                }
                case 5: {
                  const e = n(new Map(), a)
                  for (const [t, n] of i) e.set(r(t), r(n))
                  return e
                }
                case 6: {
                  const e = n(new Set(), a)
                  for (const t of i) e.add(r(t))
                  return e
                }
                case 7: {
                  const { name: e, message: t } = i
                  return n(new v_[e](t), a)
                }
                case 8:
                  return n(BigInt(i), a)
                case "BigInt":
                  return n(Object(BigInt(i)), a)
              }
              return n(new v_[o](i), a)
            }
          return r
        })(
          new Map(),
          e,
        )(0),
      O_ = "",
      { toString: w_ } = {},
      { keys: x_ } = Object,
      k_ = (e) => {
        const t = typeof e
        if ("object" !== t || !e) return [0, t]
        const n = w_.call(e).slice(8, -1)
        switch (n) {
          case "Array":
            return [1, O_]
          case "Object":
            return [2, O_]
          case "Date":
            return [3, O_]
          case "RegExp":
            return [4, O_]
          case "Map":
            return [5, O_]
          case "Set":
            return [6, O_]
        }
        return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n]
      },
      __ = ([e, t]) => 0 === e && ("function" === t || "symbol" === t),
      S_ = (e, { json: t, lossy: n } = {}) => {
        const r = []
        return (
          ((e, t, n, r) => {
            const a = (e, t) => {
                const a = r.push(e) - 1
                return n.set(t, a), a
              },
              o = (r) => {
                if (n.has(r)) return n.get(r)
                let [i, s] = k_(r)
                switch (i) {
                  case 0: {
                    let t = r
                    switch (s) {
                      case "bigint":
                        ;(i = 8), (t = r.toString())
                        break
                      case "function":
                      case "symbol":
                        if (e) throw new TypeError("unable to serialize " + s)
                        t = null
                        break
                      case "undefined":
                        return a([-1], r)
                    }
                    return a([i, t], r)
                  }
                  case 1: {
                    if (s) return a([s, [...r]], r)
                    const e = [],
                      t = a([i, e], r)
                    for (const t of r) e.push(o(t))
                    return t
                  }
                  case 2: {
                    if (s)
                      switch (s) {
                        case "BigInt":
                          return a([s, r.toString()], r)
                        case "Boolean":
                        case "Number":
                        case "String":
                          return a([s, r.valueOf()], r)
                      }
                    if (t && "toJSON" in r) return o(r.toJSON())
                    const n = [],
                      l = a([i, n], r)
                    for (const t of x_(r)) (!e && __(k_(r[t]))) || n.push([o(t), o(r[t])])
                    return l
                  }
                  case 3:
                    return a([i, r.toISOString()], r)
                  case 4: {
                    const { source: e, flags: t } = r
                    return a([i, { source: e, flags: t }], r)
                  }
                  case 5: {
                    const t = [],
                      n = a([i, t], r)
                    for (const [n, a] of r) (e || (!__(k_(n)) && !__(k_(a)))) && t.push([o(n), o(a)])
                    return n
                  }
                  case 6: {
                    const t = [],
                      n = a([i, t], r)
                    for (const n of r) (!e && __(k_(n))) || t.push(o(n))
                    return n
                  }
                }
                const { message: l } = r
                return a([i, { name: s, message: l }], r)
              }
            return o
          })(
            !(t || n),
            !!t,
            new Map(),
            r,
          )(e),
          r
        )
      },
      E_ =
        "function" == typeof structuredClone
          ? (e, t) => (t && ("json" in t || "lossy" in t) ? y_(S_(e, t)) : structuredClone(e))
          : (e, t) => y_(S_(e, t)),
      T_ = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/,
      A_ = /^[a-zA-Z]:\\/
    function C_(e) {
      const t = String(e || "").trim()
      return t ? t.split(/[ \t\n\r\f]+/g) : []
    }
    function P_(e) {
      return e.join(" ").trim()
    }
    const D_ = ["http", "https"],
      R_ = ["nofollow"],
      N_ = {}
    function $_(e) {
      const t = e || N_,
        n = t.protocols || D_,
        r = xw(t.test)
      return function (e) {
        m_(e, "element", function (e, a, o) {
          if ("a" === e.tagName && "string" == typeof e.properties.href && r(e, a, o)) {
            const r = e.properties.href
            if (
              (function (e) {
                if ("string" != typeof e) throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``)
                return !A_.test(e) && T_.test(e)
              })(r)
                ? n.includes(r.slice(0, r.indexOf(":")))
                : r.startsWith("//")
            ) {
              const n = I_(t.content, e),
                r = n && !Array.isArray(n) ? [n] : n,
                a = I_(t.rel, e) || R_,
                o = "string" == typeof a ? C_(a) : a,
                i = I_(t.target, e),
                s = I_(t.properties, e)
              if (
                (s && Object.assign(e.properties, E_(s)),
                o.length > 0 && (e.properties.rel = [...o]),
                i && (e.properties.target = i),
                r)
              ) {
                const n = I_(t.contentProperties, e) || {}
                e.children.push({ type: "element", tagName: "span", properties: E_(n), children: E_(r) })
              }
            }
          }
        })
      }
    }
    function I_(e, t) {
      return "function" == typeof e ? e(t) : e
    }
    const M_ = xw(function (e) {
        return (
          "audio" === e.tagName ||
          "canvas" === e.tagName ||
          "embed" === e.tagName ||
          "iframe" === e.tagName ||
          "img" === e.tagName ||
          "math" === e.tagName ||
          "object" === e.tagName ||
          "picture" === e.tagName ||
          "svg" === e.tagName ||
          "video" === e.tagName
        )
      }),
      L_ = {}.hasOwnProperty,
      Q_ = new Set(["pingback", "prefetch", "stylesheet"]),
      B_ = xw([
        "a",
        "abbr",
        "area",
        "b",
        "bdi",
        "bdo",
        "br",
        "button",
        "cite",
        "code",
        "data",
        "datalist",
        "del",
        "dfn",
        "em",
        "i",
        "input",
        "ins",
        "kbd",
        "keygen",
        "label",
        "map",
        "mark",
        "meter",
        "noscript",
        "output",
        "progress",
        "q",
        "ruby",
        "s",
        "samp",
        "script",
        "select",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "template",
        "textarea",
        "time",
        "u",
        "var",
        "wbr",
      ]),
      j_ = xw("meta")
    const U_ = /[ \t\n\f\r]/g
    function F_(e) {
      return "object" == typeof e ? "text" === e.type && z_(e.value) : z_(e)
    }
    function z_(e) {
      return "" === e.replace(U_, "")
    }
    const q_ = ["pre", "script", "style", "textarea"],
      Z_ = [
        "address",
        "article",
        "aside",
        "blockquote",
        "body",
        "br",
        "caption",
        "center",
        "col",
        "colgroup",
        "dd",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "legend",
        "li",
        "li",
        "listing",
        "main",
        "menu",
        "nav",
        "ol",
        "optgroup",
        "option",
        "p",
        "plaintext",
        "pre",
        "section",
        "summary",
        "table",
        "tbody",
        "td",
        "td",
        "tfoot",
        "th",
        "th",
        "thead",
        "tr",
        "ul",
        "wbr",
        "xmp",
      ],
      H_ = ["button", "input", "select", "textarea"],
      V_ = [
        "area",
        "base",
        "basefont",
        "dialog",
        "datalist",
        "head",
        "link",
        "meta",
        "noembed",
        "noframes",
        "param",
        "rp",
        "script",
        "source",
        "style",
        "template",
        "track",
        "title",
      ],
      W_ = {},
      X_ = bw(["doctype", "comment"])
    function Y_(e, t) {
      if ("children" in e) {
        const n = { ...t }
        return (
          ("root" === e.type || eS(e)) && ((n.before = !0), (n.after = !0)),
          (n.whitespace = (function (e, t) {
            if ("tagName" in e && e.properties)
              switch (e.tagName) {
                case "listing":
                case "plaintext":
                case "script":
                case "style":
                case "xmp":
                  return "pre"
                case "nobr":
                  return "nowrap"
                case "pre":
                  return e.properties.wrap ? "pre-wrap" : "pre"
                case "td":
                case "th":
                  return e.properties.noWrap ? "nowrap" : t.whitespace
                case "textarea":
                  return "pre-wrap"
              }
            return t.whitespace
          })(e, t)),
          (function (e, t) {
            let n = t.before
            const r = t.after,
              a = e.children
            let o = a.length,
              i = -1
            for (; ++i < o; ) {
              const e = Y_(a[i], { ...t, after: G_(a, i, r), before: n })
              e.remove ? (a.splice(i, 1), i--, o--) : e.ignore || (n = e.stripAtStart), J_(a[i]) && (n = !1)
            }
            return { ignore: !1, stripAtStart: Boolean(n || r), remove: !1 }
          })(e, n)
        )
      }
      if ("text" === e.type) {
        if ("normal" === t.whitespace)
          return (function (e, t) {
            const n = t.collapse(e.value),
              r = { ignore: !1, stripAtStart: !1, remove: !1 }
            let a = 0,
              o = n.length
            return (
              t.before && nS(n.charAt(0)) && a++,
              a !== o && nS(n.charAt(o - 1)) && (t.after ? o-- : (r.stripAtStart = !0)),
              a === o ? (r.remove = !0) : (e.value = n.slice(a, o)),
              r
            )
          })(e, t)
        "nowrap" === t.whitespace && (e.value = t.collapse(e.value))
      }
      return { ignore: X_(e), stripAtStart: !1, remove: !1 }
    }
    function G_(e, t, n) {
      for (; ++t < e.length; ) {
        const n = e[t]
        let r = K_(n)
        if ((void 0 === r && "children" in n && !tS(n) && (r = G_(n.children, -1)), "boolean" == typeof r)) return r
      }
      return n
    }
    function K_(e) {
      if ("element" === e.type) {
        if (J_(e)) return !1
        if (eS(e)) return !0
      } else if ("text" === e.type) {
        if (!F_(e)) return !1
      } else if (!X_(e)) return !1
    }
    function J_(e) {
      return M_(e) || ww(e, H_)
    }
    function eS(e) {
      return ww(e, Z_)
    }
    function tS(e) {
      return Boolean("element" === e.type && e.properties.hidden) || X_(e) || ww(e, V_)
    }
    function nS(e) {
      return " " === e || "\n" === e
    }
    function rS(e) {
      const t = /\r?\n|\r/.exec(e)
      return t ? t[0] : " "
    }
    function aS() {
      return " "
    }
    const oS = {},
      iS = (function (e) {
        const t = (function (e) {
          return function (t) {
            return String(t).replace(/[\t\n\v\f\r ]+/g, e)
          }
        })(({ newlines: !0 } || W_).newlines ? rS : aS)
        return function (e) {
          Y_(e, { collapse: t, whitespace: "normal" })
        }
      })()
    function sS(e) {
      const t = e || oS
      let n = t.indent || 2,
        r = t.indentInitial
      return (
        "number" == typeof n && (n = " ".repeat(n)),
        null == r && (r = !0),
        function (e) {
          let t
          iS(e),
            f_(e, function (e, o) {
              let i = -1
              if (!("children" in e)) return
              if ((ww(e, "head") && (t = !0), t && ww(e, "body") && (t = void 0), ww(e, q_))) return h_
              const s = e.children
              let l,
                c = o.length
              if (0 === s.length || !lS(e, t)) return
              for (r || c--; ++i < s.length; ) {
                const e = s[i]
                ;("text" !== e.type && "comment" !== e.type) ||
                  (e.value.includes("\n") && (l = !0), (e.value = e.value.replace(/ *\n/g, "$&" + String(n).repeat(c))))
              }
              const d = []
              let u
              for (i = -1; ++i < s.length; ) {
                const e = s[i]
                ;(lS(e, t) || (l && !i)) && (a(d, c, e), (l = !0)), (u = e), d.push(e)
              }
              u && (l || lS(u, t)) && (F_(u) && (d.pop(), (u = d[d.length - 1])), a(d, c - 1)), (e.children = d)
            })
        }
      )
      function a(e, t, r) {
        const a = e[e.length - 1],
          i = (o(a && F_(a) ? e[e.length - 2] : a) && o(r) ? "\n\n" : "\n") + String(n).repeat(Math.max(t, 0))
        a && "text" === a.type ? (a.value = F_(a) ? i : a.value + i) : e.push({ type: "text", value: i })
      }
      function o(e) {
        return Boolean(e && "element" === e.type && t.blanks && t.blanks.length > 0 && t.blanks.includes(e.tagName))
      }
    }
    function lS(e, t) {
      return (
        "root" === e.type ||
        ("element" === e.type &&
          (t ||
            ww(e, "script") ||
            M_(e) ||
            !(function (e) {
              return Boolean(
                "text" === e.type ||
                  B_(e) ||
                  M_(e) ||
                  (function (e) {
                    if ("element" !== e.type || "link" !== e.tagName) return !1
                    if (e.properties.itemProp) return !0
                    const t = e.properties.rel
                    let n = -1
                    if (!Array.isArray(t) || 0 === t.length) return !1
                    for (; ++n < t.length; ) if (!Q_.has(String(t[n]))) return !1
                    return !0
                  })(e) ||
                  (j_(e) &&
                    (function (e, t) {
                      const n = "element" === e.type && L_.call(e.properties, t) && e.properties[t]
                      return null != n && !1 !== n
                    })(e, "itemProp")),
              )
            })(e)))
      )
    }
    let cS = class {
      constructor(e, t, n) {
        ;(this.property = e), (this.normal = t), n && (this.space = n)
      }
    }
    function dS(e, t) {
      const n = {},
        r = {}
      let a = -1
      for (; ++a < e.length; ) Object.assign(n, e[a].property), Object.assign(r, e[a].normal)
      return new cS(n, r, t)
    }
    function uS(e) {
      return e.toLowerCase()
    }
    ;(cS.prototype.property = {}), (cS.prototype.normal = {}), (cS.prototype.space = null)
    class pS {
      constructor(e, t) {
        ;(this.property = e), (this.attribute = t)
      }
    }
    ;(pS.prototype.space = null),
      (pS.prototype.boolean = !1),
      (pS.prototype.booleanish = !1),
      (pS.prototype.overloadedBoolean = !1),
      (pS.prototype.number = !1),
      (pS.prototype.commaSeparated = !1),
      (pS.prototype.spaceSeparated = !1),
      (pS.prototype.commaOrSpaceSeparated = !1),
      (pS.prototype.mustUseProperty = !1),
      (pS.prototype.defined = !1)
    let hS = 0
    const fS = wS(),
      mS = wS(),
      gS = wS(),
      bS = wS(),
      vS = wS(),
      yS = wS(),
      OS = wS()
    function wS() {
      return 2 ** ++hS
    }
    const xS = Object.freeze(
        Object.defineProperty(
          {
            __proto__: null,
            boolean: fS,
            booleanish: mS,
            commaOrSpaceSeparated: OS,
            commaSeparated: yS,
            number: bS,
            overloadedBoolean: gS,
            spaceSeparated: vS,
          },
          Symbol.toStringTag,
          { value: "Module" },
        ),
      ),
      kS = Object.keys(xS)
    class _S extends pS {
      constructor(e, t, n, r) {
        let a = -1
        if ((super(e, t), SS(this, "space", r), "number" == typeof n))
          for (; ++a < kS.length; ) {
            const e = kS[a]
            SS(this, kS[a], (n & xS[e]) === xS[e])
          }
      }
    }
    function SS(e, t, n) {
      n && (e[t] = n)
    }
    _S.prototype.defined = !0
    const ES = {}.hasOwnProperty
    function TS(e) {
      const t = {},
        n = {}
      let r
      for (r in e.properties)
        if (ES.call(e.properties, r)) {
          const a = e.properties[r],
            o = new _S(r, e.transform(e.attributes || {}, r), a, e.space)
          e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0),
            (t[r] = o),
            (n[uS(r)] = r),
            (n[uS(o.attribute)] = r)
        }
      return new cS(t, n, e.space)
    }
    const AS = TS({
        space: "xlink",
        transform: (e, t) => "xlink:" + t.slice(5).toLowerCase(),
        properties: {
          xLinkActuate: null,
          xLinkArcRole: null,
          xLinkHref: null,
          xLinkRole: null,
          xLinkShow: null,
          xLinkTitle: null,
          xLinkType: null,
        },
      }),
      CS = TS({
        space: "xml",
        transform: (e, t) => "xml:" + t.slice(3).toLowerCase(),
        properties: { xmlLang: null, xmlBase: null, xmlSpace: null },
      })
    function PS(e, t) {
      return t in e ? e[t] : t
    }
    function DS(e, t) {
      return PS(e, t.toLowerCase())
    }
    const RS = TS({
        space: "xmlns",
        attributes: { xmlnsxlink: "xmlns:xlink" },
        transform: DS,
        properties: { xmlns: null, xmlnsXLink: null },
      }),
      NS = TS({
        transform: (e, t) => ("role" === t ? t : "aria-" + t.slice(4).toLowerCase()),
        properties: {
          ariaActiveDescendant: null,
          ariaAtomic: mS,
          ariaAutoComplete: null,
          ariaBusy: mS,
          ariaChecked: mS,
          ariaColCount: bS,
          ariaColIndex: bS,
          ariaColSpan: bS,
          ariaControls: vS,
          ariaCurrent: null,
          ariaDescribedBy: vS,
          ariaDetails: null,
          ariaDisabled: mS,
          ariaDropEffect: vS,
          ariaErrorMessage: null,
          ariaExpanded: mS,
          ariaFlowTo: vS,
          ariaGrabbed: mS,
          ariaHasPopup: null,
          ariaHidden: mS,
          ariaInvalid: null,
          ariaKeyShortcuts: null,
          ariaLabel: null,
          ariaLabelledBy: vS,
          ariaLevel: bS,
          ariaLive: null,
          ariaModal: mS,
          ariaMultiLine: mS,
          ariaMultiSelectable: mS,
          ariaOrientation: null,
          ariaOwns: vS,
          ariaPlaceholder: null,
          ariaPosInSet: bS,
          ariaPressed: mS,
          ariaReadOnly: mS,
          ariaRelevant: null,
          ariaRequired: mS,
          ariaRoleDescription: vS,
          ariaRowCount: bS,
          ariaRowIndex: bS,
          ariaRowSpan: bS,
          ariaSelected: mS,
          ariaSetSize: bS,
          ariaSort: null,
          ariaValueMax: bS,
          ariaValueMin: bS,
          ariaValueNow: bS,
          ariaValueText: null,
          role: null,
        },
      }),
      $S = TS({
        space: "html",
        attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" },
        transform: DS,
        mustUseProperty: ["checked", "multiple", "muted", "selected"],
        properties: {
          abbr: null,
          accept: yS,
          acceptCharset: vS,
          accessKey: vS,
          action: null,
          allow: null,
          allowFullScreen: fS,
          allowPaymentRequest: fS,
          allowUserMedia: fS,
          alt: null,
          as: null,
          async: fS,
          autoCapitalize: null,
          autoComplete: vS,
          autoFocus: fS,
          autoPlay: fS,
          blocking: vS,
          capture: null,
          charSet: null,
          checked: fS,
          cite: null,
          className: vS,
          cols: bS,
          colSpan: null,
          content: null,
          contentEditable: mS,
          controls: fS,
          controlsList: vS,
          coords: bS | yS,
          crossOrigin: null,
          data: null,
          dateTime: null,
          decoding: null,
          default: fS,
          defer: fS,
          dir: null,
          dirName: null,
          disabled: fS,
          download: gS,
          draggable: mS,
          encType: null,
          enterKeyHint: null,
          fetchPriority: null,
          form: null,
          formAction: null,
          formEncType: null,
          formMethod: null,
          formNoValidate: fS,
          formTarget: null,
          headers: vS,
          height: bS,
          hidden: fS,
          high: bS,
          href: null,
          hrefLang: null,
          htmlFor: vS,
          httpEquiv: vS,
          id: null,
          imageSizes: null,
          imageSrcSet: null,
          inert: fS,
          inputMode: null,
          integrity: null,
          is: null,
          isMap: fS,
          itemId: null,
          itemProp: vS,
          itemRef: vS,
          itemScope: fS,
          itemType: vS,
          kind: null,
          label: null,
          lang: null,
          language: null,
          list: null,
          loading: null,
          loop: fS,
          low: bS,
          manifest: null,
          max: null,
          maxLength: bS,
          media: null,
          method: null,
          min: null,
          minLength: bS,
          multiple: fS,
          muted: fS,
          name: null,
          nonce: null,
          noModule: fS,
          noValidate: fS,
          onAbort: null,
          onAfterPrint: null,
          onAuxClick: null,
          onBeforeMatch: null,
          onBeforePrint: null,
          onBeforeToggle: null,
          onBeforeUnload: null,
          onBlur: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onContextLost: null,
          onContextMenu: null,
          onContextRestored: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFormData: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLanguageChange: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadEnd: null,
          onLoadStart: null,
          onMessage: null,
          onMessageError: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRejectionHandled: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onScrollEnd: null,
          onSecurityPolicyViolation: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onSlotChange: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnhandledRejection: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onWheel: null,
          open: fS,
          optimum: bS,
          pattern: null,
          ping: vS,
          placeholder: null,
          playsInline: fS,
          popover: null,
          popoverTarget: null,
          popoverTargetAction: null,
          poster: null,
          preload: null,
          readOnly: fS,
          referrerPolicy: null,
          rel: vS,
          required: fS,
          reversed: fS,
          rows: bS,
          rowSpan: bS,
          sandbox: vS,
          scope: null,
          scoped: fS,
          seamless: fS,
          selected: fS,
          shadowRootClonable: fS,
          shadowRootDelegatesFocus: fS,
          shadowRootMode: null,
          shape: null,
          size: bS,
          sizes: null,
          slot: null,
          span: bS,
          spellCheck: mS,
          src: null,
          srcDoc: null,
          srcLang: null,
          srcSet: null,
          start: bS,
          step: null,
          style: null,
          tabIndex: bS,
          target: null,
          title: null,
          translate: null,
          type: null,
          typeMustMatch: fS,
          useMap: null,
          value: mS,
          width: bS,
          wrap: null,
          writingSuggestions: null,
          align: null,
          aLink: null,
          archive: vS,
          axis: null,
          background: null,
          bgColor: null,
          border: bS,
          borderColor: null,
          bottomMargin: bS,
          cellPadding: null,
          cellSpacing: null,
          char: null,
          charOff: null,
          classId: null,
          clear: null,
          code: null,
          codeBase: null,
          codeType: null,
          color: null,
          compact: fS,
          declare: fS,
          event: null,
          face: null,
          frame: null,
          frameBorder: null,
          hSpace: bS,
          leftMargin: bS,
          link: null,
          longDesc: null,
          lowSrc: null,
          marginHeight: bS,
          marginWidth: bS,
          noResize: fS,
          noHref: fS,
          noShade: fS,
          noWrap: fS,
          object: null,
          profile: null,
          prompt: null,
          rev: null,
          rightMargin: bS,
          rules: null,
          scheme: null,
          scrolling: mS,
          standby: null,
          summary: null,
          text: null,
          topMargin: bS,
          valueType: null,
          version: null,
          vAlign: null,
          vLink: null,
          vSpace: bS,
          allowTransparency: null,
          autoCorrect: null,
          autoSave: null,
          disablePictureInPicture: fS,
          disableRemotePlayback: fS,
          prefix: null,
          property: null,
          results: bS,
          security: null,
          unselectable: null,
        },
      }),
      IS = TS({
        space: "svg",
        attributes: {
          accentHeight: "accent-height",
          alignmentBaseline: "alignment-baseline",
          arabicForm: "arabic-form",
          baselineShift: "baseline-shift",
          capHeight: "cap-height",
          className: "class",
          clipPath: "clip-path",
          clipRule: "clip-rule",
          colorInterpolation: "color-interpolation",
          colorInterpolationFilters: "color-interpolation-filters",
          colorProfile: "color-profile",
          colorRendering: "color-rendering",
          crossOrigin: "crossorigin",
          dataType: "datatype",
          dominantBaseline: "dominant-baseline",
          enableBackground: "enable-background",
          fillOpacity: "fill-opacity",
          fillRule: "fill-rule",
          floodColor: "flood-color",
          floodOpacity: "flood-opacity",
          fontFamily: "font-family",
          fontSize: "font-size",
          fontSizeAdjust: "font-size-adjust",
          fontStretch: "font-stretch",
          fontStyle: "font-style",
          fontVariant: "font-variant",
          fontWeight: "font-weight",
          glyphName: "glyph-name",
          glyphOrientationHorizontal: "glyph-orientation-horizontal",
          glyphOrientationVertical: "glyph-orientation-vertical",
          hrefLang: "hreflang",
          horizAdvX: "horiz-adv-x",
          horizOriginX: "horiz-origin-x",
          horizOriginY: "horiz-origin-y",
          imageRendering: "image-rendering",
          letterSpacing: "letter-spacing",
          lightingColor: "lighting-color",
          markerEnd: "marker-end",
          markerMid: "marker-mid",
          markerStart: "marker-start",
          navDown: "nav-down",
          navDownLeft: "nav-down-left",
          navDownRight: "nav-down-right",
          navLeft: "nav-left",
          navNext: "nav-next",
          navPrev: "nav-prev",
          navRight: "nav-right",
          navUp: "nav-up",
          navUpLeft: "nav-up-left",
          navUpRight: "nav-up-right",
          onAbort: "onabort",
          onActivate: "onactivate",
          onAfterPrint: "onafterprint",
          onBeforePrint: "onbeforeprint",
          onBegin: "onbegin",
          onCancel: "oncancel",
          onCanPlay: "oncanplay",
          onCanPlayThrough: "oncanplaythrough",
          onChange: "onchange",
          onClick: "onclick",
          onClose: "onclose",
          onCopy: "oncopy",
          onCueChange: "oncuechange",
          onCut: "oncut",
          onDblClick: "ondblclick",
          onDrag: "ondrag",
          onDragEnd: "ondragend",
          onDragEnter: "ondragenter",
          onDragExit: "ondragexit",
          onDragLeave: "ondragleave",
          onDragOver: "ondragover",
          onDragStart: "ondragstart",
          onDrop: "ondrop",
          onDurationChange: "ondurationchange",
          onEmptied: "onemptied",
          onEnd: "onend",
          onEnded: "onended",
          onError: "onerror",
          onFocus: "onfocus",
          onFocusIn: "onfocusin",
          onFocusOut: "onfocusout",
          onHashChange: "onhashchange",
          onInput: "oninput",
          onInvalid: "oninvalid",
          onKeyDown: "onkeydown",
          onKeyPress: "onkeypress",
          onKeyUp: "onkeyup",
          onLoad: "onload",
          onLoadedData: "onloadeddata",
          onLoadedMetadata: "onloadedmetadata",
          onLoadStart: "onloadstart",
          onMessage: "onmessage",
          onMouseDown: "onmousedown",
          onMouseEnter: "onmouseenter",
          onMouseLeave: "onmouseleave",
          onMouseMove: "onmousemove",
          onMouseOut: "onmouseout",
          onMouseOver: "onmouseover",
          onMouseUp: "onmouseup",
          onMouseWheel: "onmousewheel",
          onOffline: "onoffline",
          onOnline: "ononline",
          onPageHide: "onpagehide",
          onPageShow: "onpageshow",
          onPaste: "onpaste",
          onPause: "onpause",
          onPlay: "onplay",
          onPlaying: "onplaying",
          onPopState: "onpopstate",
          onProgress: "onprogress",
          onRateChange: "onratechange",
          onRepeat: "onrepeat",
          onReset: "onreset",
          onResize: "onresize",
          onScroll: "onscroll",
          onSeeked: "onseeked",
          onSeeking: "onseeking",
          onSelect: "onselect",
          onShow: "onshow",
          onStalled: "onstalled",
          onStorage: "onstorage",
          onSubmit: "onsubmit",
          onSuspend: "onsuspend",
          onTimeUpdate: "ontimeupdate",
          onToggle: "ontoggle",
          onUnload: "onunload",
          onVolumeChange: "onvolumechange",
          onWaiting: "onwaiting",
          onZoom: "onzoom",
          overlinePosition: "overline-position",
          overlineThickness: "overline-thickness",
          paintOrder: "paint-order",
          panose1: "panose-1",
          pointerEvents: "pointer-events",
          referrerPolicy: "referrerpolicy",
          renderingIntent: "rendering-intent",
          shapeRendering: "shape-rendering",
          stopColor: "stop-color",
          stopOpacity: "stop-opacity",
          strikethroughPosition: "strikethrough-position",
          strikethroughThickness: "strikethrough-thickness",
          strokeDashArray: "stroke-dasharray",
          strokeDashOffset: "stroke-dashoffset",
          strokeLineCap: "stroke-linecap",
          strokeLineJoin: "stroke-linejoin",
          strokeMiterLimit: "stroke-miterlimit",
          strokeOpacity: "stroke-opacity",
          strokeWidth: "stroke-width",
          tabIndex: "tabindex",
          textAnchor: "text-anchor",
          textDecoration: "text-decoration",
          textRendering: "text-rendering",
          transformOrigin: "transform-origin",
          typeOf: "typeof",
          underlinePosition: "underline-position",
          underlineThickness: "underline-thickness",
          unicodeBidi: "unicode-bidi",
          unicodeRange: "unicode-range",
          unitsPerEm: "units-per-em",
          vAlphabetic: "v-alphabetic",
          vHanging: "v-hanging",
          vIdeographic: "v-ideographic",
          vMathematical: "v-mathematical",
          vectorEffect: "vector-effect",
          vertAdvY: "vert-adv-y",
          vertOriginX: "vert-origin-x",
          vertOriginY: "vert-origin-y",
          wordSpacing: "word-spacing",
          writingMode: "writing-mode",
          xHeight: "x-height",
          playbackOrder: "playbackorder",
          timelineBegin: "timelinebegin",
        },
        transform: PS,
        properties: {
          about: OS,
          accentHeight: bS,
          accumulate: null,
          additive: null,
          alignmentBaseline: null,
          alphabetic: bS,
          amplitude: bS,
          arabicForm: null,
          ascent: bS,
          attributeName: null,
          attributeType: null,
          azimuth: bS,
          bandwidth: null,
          baselineShift: null,
          baseFrequency: null,
          baseProfile: null,
          bbox: null,
          begin: null,
          bias: bS,
          by: null,
          calcMode: null,
          capHeight: bS,
          className: vS,
          clip: null,
          clipPath: null,
          clipPathUnits: null,
          clipRule: null,
          color: null,
          colorInterpolation: null,
          colorInterpolationFilters: null,
          colorProfile: null,
          colorRendering: null,
          content: null,
          contentScriptType: null,
          contentStyleType: null,
          crossOrigin: null,
          cursor: null,
          cx: null,
          cy: null,
          d: null,
          dataType: null,
          defaultAction: null,
          descent: bS,
          diffuseConstant: bS,
          direction: null,
          display: null,
          dur: null,
          divisor: bS,
          dominantBaseline: null,
          download: fS,
          dx: null,
          dy: null,
          edgeMode: null,
          editable: null,
          elevation: bS,
          enableBackground: null,
          end: null,
          event: null,
          exponent: bS,
          externalResourcesRequired: null,
          fill: null,
          fillOpacity: bS,
          fillRule: null,
          filter: null,
          filterRes: null,
          filterUnits: null,
          floodColor: null,
          floodOpacity: null,
          focusable: null,
          focusHighlight: null,
          fontFamily: null,
          fontSize: null,
          fontSizeAdjust: null,
          fontStretch: null,
          fontStyle: null,
          fontVariant: null,
          fontWeight: null,
          format: null,
          fr: null,
          from: null,
          fx: null,
          fy: null,
          g1: yS,
          g2: yS,
          glyphName: yS,
          glyphOrientationHorizontal: null,
          glyphOrientationVertical: null,
          glyphRef: null,
          gradientTransform: null,
          gradientUnits: null,
          handler: null,
          hanging: bS,
          hatchContentUnits: null,
          hatchUnits: null,
          height: null,
          href: null,
          hrefLang: null,
          horizAdvX: bS,
          horizOriginX: bS,
          horizOriginY: bS,
          id: null,
          ideographic: bS,
          imageRendering: null,
          initialVisibility: null,
          in: null,
          in2: null,
          intercept: bS,
          k: bS,
          k1: bS,
          k2: bS,
          k3: bS,
          k4: bS,
          kernelMatrix: OS,
          kernelUnitLength: null,
          keyPoints: null,
          keySplines: null,
          keyTimes: null,
          kerning: null,
          lang: null,
          lengthAdjust: null,
          letterSpacing: null,
          lightingColor: null,
          limitingConeAngle: bS,
          local: null,
          markerEnd: null,
          markerMid: null,
          markerStart: null,
          markerHeight: null,
          markerUnits: null,
          markerWidth: null,
          mask: null,
          maskContentUnits: null,
          maskUnits: null,
          mathematical: null,
          max: null,
          media: null,
          mediaCharacterEncoding: null,
          mediaContentEncodings: null,
          mediaSize: bS,
          mediaTime: null,
          method: null,
          min: null,
          mode: null,
          name: null,
          navDown: null,
          navDownLeft: null,
          navDownRight: null,
          navLeft: null,
          navNext: null,
          navPrev: null,
          navRight: null,
          navUp: null,
          navUpLeft: null,
          navUpRight: null,
          numOctaves: null,
          observer: null,
          offset: null,
          onAbort: null,
          onActivate: null,
          onAfterPrint: null,
          onBeforePrint: null,
          onBegin: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnd: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFocusIn: null,
          onFocusOut: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadStart: null,
          onMessage: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onMouseWheel: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRepeat: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onShow: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onZoom: null,
          opacity: null,
          operator: null,
          order: null,
          orient: null,
          orientation: null,
          origin: null,
          overflow: null,
          overlay: null,
          overlinePosition: bS,
          overlineThickness: bS,
          paintOrder: null,
          panose1: null,
          path: null,
          pathLength: bS,
          patternContentUnits: null,
          patternTransform: null,
          patternUnits: null,
          phase: null,
          ping: vS,
          pitch: null,
          playbackOrder: null,
          pointerEvents: null,
          points: null,
          pointsAtX: bS,
          pointsAtY: bS,
          pointsAtZ: bS,
          preserveAlpha: null,
          preserveAspectRatio: null,
          primitiveUnits: null,
          propagate: null,
          property: OS,
          r: null,
          radius: null,
          referrerPolicy: null,
          refX: null,
          refY: null,
          rel: OS,
          rev: OS,
          renderingIntent: null,
          repeatCount: null,
          repeatDur: null,
          requiredExtensions: OS,
          requiredFeatures: OS,
          requiredFonts: OS,
          requiredFormats: OS,
          resource: null,
          restart: null,
          result: null,
          rotate: null,
          rx: null,
          ry: null,
          scale: null,
          seed: null,
          shapeRendering: null,
          side: null,
          slope: null,
          snapshotTime: null,
          specularConstant: bS,
          specularExponent: bS,
          spreadMethod: null,
          spacing: null,
          startOffset: null,
          stdDeviation: null,
          stemh: null,
          stemv: null,
          stitchTiles: null,
          stopColor: null,
          stopOpacity: null,
          strikethroughPosition: bS,
          strikethroughThickness: bS,
          string: null,
          stroke: null,
          strokeDashArray: OS,
          strokeDashOffset: null,
          strokeLineCap: null,
          strokeLineJoin: null,
          strokeMiterLimit: bS,
          strokeOpacity: bS,
          strokeWidth: null,
          style: null,
          surfaceScale: bS,
          syncBehavior: null,
          syncBehaviorDefault: null,
          syncMaster: null,
          syncTolerance: null,
          syncToleranceDefault: null,
          systemLanguage: OS,
          tabIndex: bS,
          tableValues: null,
          target: null,
          targetX: bS,
          targetY: bS,
          textAnchor: null,
          textDecoration: null,
          textRendering: null,
          textLength: null,
          timelineBegin: null,
          title: null,
          transformBehavior: null,
          type: null,
          typeOf: OS,
          to: null,
          transform: null,
          transformOrigin: null,
          u1: null,
          u2: null,
          underlinePosition: bS,
          underlineThickness: bS,
          unicode: null,
          unicodeBidi: null,
          unicodeRange: null,
          unitsPerEm: bS,
          values: null,
          vAlphabetic: bS,
          vMathematical: bS,
          vectorEffect: null,
          vHanging: bS,
          vIdeographic: bS,
          version: null,
          vertAdvY: bS,
          vertOriginX: bS,
          vertOriginY: bS,
          viewBox: null,
          viewTarget: null,
          visibility: null,
          width: null,
          widths: null,
          wordSpacing: null,
          writingMode: null,
          x: null,
          x1: null,
          x2: null,
          xChannelSelector: null,
          xHeight: bS,
          y: null,
          y1: null,
          y2: null,
          yChannelSelector: null,
          z: null,
          zoomAndPan: null,
        },
      }),
      MS = /^data[-\w.:]+$/i,
      LS = /-[a-z]/g,
      QS = /[A-Z]/g
    function BS(e, t) {
      const n = uS(t)
      let r = t,
        a = pS
      if (n in e.normal) return e.property[e.normal[n]]
      if (n.length > 4 && "data" === n.slice(0, 4) && MS.test(t)) {
        if ("-" === t.charAt(4)) {
          const e = t.slice(5).replace(LS, US)
          r = "data" + e.charAt(0).toUpperCase() + e.slice(1)
        } else {
          const e = t.slice(4)
          if (!LS.test(e)) {
            let n = e.replace(QS, jS)
            "-" !== n.charAt(0) && (n = "-" + n), (t = "data" + n)
          }
        }
        a = _S
      }
      return new a(r, t)
    }
    function jS(e) {
      return "-" + e.toLowerCase()
    }
    function US(e) {
      return e.charAt(1).toUpperCase()
    }
    const FS = dS([CS, AS, RS, NS, $S], "html"),
      zS = dS([CS, AS, RS, NS, IS], "svg")
    function qS(e) {
      const t = [],
        n = String(e || "")
      let r = n.indexOf(","),
        a = 0,
        o = !1
      for (; !o; ) {
        ;-1 === r && ((r = n.length), (o = !0))
        const e = n.slice(a, r).trim()
        ;(!e && o) || t.push(e), (a = r + 1), (r = n.indexOf(",", a))
      }
      return t
    }
    function ZS(e, t) {
      const n = t || {}
      return ("" === e[e.length - 1] ? [...e, ""] : e)
        .join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " "))
        .trim()
    }
    const HS = /[#.]/g,
      VS = new Set(["button", "menu", "reset", "submit"]),
      WS = {}.hasOwnProperty
    function XS(e, t, n) {
      const r =
        n &&
        (function (e) {
          const t = {}
          let n = -1
          for (; ++n < e.length; ) t[e[n].toLowerCase()] = e[n]
          return t
        })(n)
      return function (n, a, ...o) {
        let i,
          s = -1
        if (null == n) {
          i = { type: "root", children: [] }
          const e = a
          o.unshift(e)
        } else if (
          ((i = (function (e, t) {
            const n = e || "",
              r = {}
            let a,
              o,
              i = 0
            for (; i < n.length; ) {
              HS.lastIndex = i
              const e = HS.exec(n),
                t = n.slice(i, e ? e.index : n.length)
              t &&
                (a
                  ? "#" === a
                    ? (r.id = t)
                    : Array.isArray(r.className)
                      ? r.className.push(t)
                      : (r.className = [t])
                  : (o = t),
                (i += t.length)),
                e && ((a = e[0]), i++)
            }
            return { type: "element", tagName: o || t || "div", properties: r, children: [] }
          })(n, t)),
          (i.tagName = i.tagName.toLowerCase()),
          r && WS.call(r, i.tagName) && (i.tagName = r[i.tagName]),
          (function (e, t) {
            return (
              null != e &&
              "object" == typeof e &&
              !Array.isArray(e) &&
              ("input" === t ||
                !e.type ||
                "string" != typeof e.type ||
                ((!("children" in e) || !Array.isArray(e.children)) &&
                  ("button" === t ? VS.has(e.type.toLowerCase()) : !("value" in e))))
            )
          })(a, i.tagName))
        ) {
          let t
          for (t in a) WS.call(a, t) && YS(e, i.properties, t, a[t])
        } else o.unshift(a)
        for (; ++s < o.length; ) GS(i.children, o[s])
        return (
          "element" === i.type &&
            "template" === i.tagName &&
            ((i.content = { type: "root", children: i.children }), (i.children = [])),
          i
        )
      }
    }
    function YS(e, t, n, r) {
      const a = BS(e, n)
      let o,
        i = -1
      if (null != r) {
        if ("number" == typeof r) {
          if (Number.isNaN(r)) return
          o = r
        } else
          o =
            "boolean" == typeof r
              ? r
              : "string" == typeof r
                ? a.spaceSeparated
                  ? C_(r)
                  : a.commaSeparated
                    ? qS(r)
                    : a.commaOrSpaceSeparated
                      ? C_(qS(r).join(" "))
                      : KS(a, a.property, r)
                : Array.isArray(r)
                  ? r.concat()
                  : "style" === a.property
                    ? (function (e) {
                        const t = []
                        let n
                        for (n in e) WS.call(e, n) && t.push([n, e[n]].join(": "))
                        return t.join("; ")
                      })(r)
                    : String(r)
        if (Array.isArray(o)) {
          const e = []
          for (; ++i < o.length; ) {
            const t = KS(a, a.property, o[i])
            e[i] = t
          }
          o = e
        }
        if ("className" === a.property && Array.isArray(t.className)) {
          const e = o
          o = t.className.concat(e)
        }
        t[a.property] = o
      }
    }
    function GS(e, t) {
      let n = -1
      if (null == t);
      else if ("string" == typeof t || "number" == typeof t) e.push({ type: "text", value: String(t) })
      else if (Array.isArray(t)) for (; ++n < t.length; ) GS(e, t[n])
      else {
        if ("object" != typeof t || !("type" in t)) throw new Error("Expected node, nodes, or string, got `" + t + "`")
        "root" === t.type ? GS(e, t.children) : e.push(t)
      }
    }
    function KS(e, t, n) {
      if ("string" == typeof n) {
        if (e.number && n && !Number.isNaN(Number(n))) return Number(n)
        if ((e.boolean || e.overloadedBoolean) && ("" === n || uS(n) === uS(t))) return !0
      }
      return n
    }
    const JS = XS(FS, "div"),
      eE = XS(zS, "g", [
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "solidColor",
        "textArea",
        "textPath",
      ]),
      tE = /\r?\n|\r/g,
      nE = {
        html: "http://www.w3.org/1999/xhtml",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
      },
      rE = {}.hasOwnProperty,
      aE = Object.prototype
    function oE(e, t) {
      const n = t || {}
      return iE(
        { file: n.file || void 0, location: !1, schema: "svg" === n.space ? zS : FS, verbose: n.verbose || !1 },
        e,
      )
    }
    function iE(e, t) {
      let n
      switch (t.nodeName) {
        case "#comment": {
          const r = t
          return (n = { type: "comment", value: r.data }), lE(e, r, n), n
        }
        case "#document":
        case "#document-fragment": {
          const r = t,
            a = "mode" in r && ("quirks" === r.mode || "limited-quirks" === r.mode)
          if (((n = { type: "root", children: sE(e, t.childNodes), data: { quirksMode: a } }), e.file && e.location)) {
            const t = String(e.file),
              r = (function (e) {
                const t = String(e),
                  n = []
                for (tE.lastIndex = 0; tE.test(t); ) n.push(tE.lastIndex)
                return (
                  n.push(t.length + 1),
                  {
                    toPoint: function (e) {
                      let t = -1
                      if ("number" == typeof e && e > -1 && e < n[n.length - 1])
                        for (; ++t < n.length; )
                          if (n[t] > e) return { line: t + 1, column: e - (t > 0 ? n[t - 1] : 0) + 1, offset: e }
                    },
                    toOffset: function (e) {
                      const t = e && e.line,
                        r = e && e.column
                      if (
                        "number" == typeof t &&
                        "number" == typeof r &&
                        !Number.isNaN(t) &&
                        !Number.isNaN(r) &&
                        t - 1 in n
                      ) {
                        const e = (n[t - 2] || 0) + r - 1 || 0
                        if (e > -1 && e < n[n.length - 1]) return e
                      }
                    },
                  }
                )
              })(t),
              a = r.toPoint(0),
              o = r.toPoint(t.length)
            n.position = { start: a, end: o }
          }
          return n
        }
        case "#documentType":
          return (n = { type: "doctype" }), lE(e, t, n), n
        case "#text": {
          const r = t
          return (n = { type: "text", value: r.value }), lE(e, r, n), n
        }
        default:
          return (
            (n = (function (e, t) {
              const n = e.schema
              e.schema = t.namespaceURI === nE.svg ? zS : FS
              let r = -1
              const a = {}
              for (; ++r < t.attrs.length; ) {
                const e = t.attrs[r],
                  n = (e.prefix ? e.prefix + ":" : "") + e.name
                rE.call(aE, n) || (a[n] = e.value)
              }
              const o = ("svg" === e.schema.space ? eE : JS)(t.tagName, a, sE(e, t.childNodes))
              if ((lE(e, t, o), "template" === o.tagName)) {
                const n = t,
                  r = n.sourceCodeLocation,
                  a = r && r.startTag && cE(r.startTag),
                  i = r && r.endTag && cE(r.endTag),
                  s = iE(e, n.content)
                a && i && e.file && (s.position = { start: a.end, end: i.start }), (o.content = s)
              }
              return (e.schema = n), o
            })(e, t)),
            n
          )
      }
    }
    function sE(e, t) {
      let n = -1
      const r = []
      for (; ++n < t.length; ) {
        const a = iE(e, t[n])
        r.push(a)
      }
      return r
    }
    function lE(e, t, n) {
      if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
        const r = (function (e, t, n) {
          const r = cE(n)
          if ("element" === t.type) {
            const a = t.children[t.children.length - 1]
            if (
              (r && !n.endTag && a && a.position && a.position.end && (r.end = Object.assign({}, a.position.end)),
              e.verbose)
            ) {
              const r = {}
              let a
              if (n.attrs) for (a in n.attrs) rE.call(n.attrs, a) && (r[BS(e.schema, a).property] = cE(n.attrs[a]))
              n.startTag
              const o = cE(n.startTag),
                i = n.endTag ? cE(n.endTag) : void 0,
                s = { opening: o }
              i && (s.closing = i), (s.properties = r), (t.data = { position: s })
            }
          }
          return r
        })(e, n, t.sourceCodeLocation)
        r && ((e.location = !0), (n.position = r))
      }
    }
    function cE(e) {
      const t = dE({ line: e.startLine, column: e.startCol, offset: e.startOffset }),
        n = dE({ line: e.endLine, column: e.endCol, offset: e.endOffset })
      return t || n ? { start: t, end: n } : void 0
    }
    function dE(e) {
      return e.line && e.column ? e : void 0
    }
    const uE = {}.hasOwnProperty
    function pE(e, t) {
      const n = t || {}
      function r(t, ...n) {
        let a = r.invalid
        const o = r.handlers
        if (t && uE.call(t, e)) {
          const n = String(t[e])
          a = uE.call(o, n) ? o[n] : r.unknown
        }
        if (a) return a.call(this, t, ...n)
      }
      return (r.handlers = n.handlers || {}), (r.invalid = n.invalid), (r.unknown = n.unknown), r
    }
    const hE = {},
      fE = {}.hasOwnProperty,
      mE = pE("type", {
        handlers: {
          root: function (e, t) {
            const n = {
              nodeName: "#document",
              mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
              childNodes: [],
            }
            return (n.childNodes = bE(e.children, n, t)), vE(e, n), n
          },
          element: function (e, t) {
            const n = t
            let r = n
            "element" === e.type && "svg" === e.tagName.toLowerCase() && "html" === n.space && (r = zS)
            const a = []
            let o
            if (e.properties)
              for (o in e.properties)
                if ("children" !== o && fE.call(e.properties, o)) {
                  const t = gE(r, o, e.properties[o])
                  t && a.push(t)
                }
            const i = r.space,
              s = {
                nodeName: e.tagName,
                tagName: e.tagName,
                attrs: a,
                namespaceURI: nE[i],
                childNodes: [],
                parentNode: null,
              }
            return (
              (s.childNodes = bE(e.children, s, r)),
              vE(e, s),
              "template" === e.tagName &&
                e.content &&
                (s.content = (function (e, t) {
                  const n = { nodeName: "#document-fragment", childNodes: [] }
                  return (n.childNodes = bE(e.children, n, t)), vE(e, n), n
                })(e.content, r)),
              s
            )
          },
          text: function (e) {
            const t = { nodeName: "#text", value: e.value, parentNode: null }
            return vE(e, t), t
          },
          comment: function (e) {
            const t = { nodeName: "#comment", data: e.value, parentNode: null }
            return vE(e, t), t
          },
          doctype: function (e) {
            const t = { nodeName: "#documentType", name: "html", publicId: "", systemId: "", parentNode: null }
            return vE(e, t), t
          },
        },
      })
    function gE(e, t, n) {
      const r = BS(e, t)
      if (!1 === n || null == n || ("number" == typeof n && Number.isNaN(n)) || (!n && r.boolean)) return
      Array.isArray(n) && (n = r.commaSeparated ? ZS(n) : P_(n))
      const a = { name: r.attribute, value: !0 === n ? "" : String(n) }
      if (r.space && "html" !== r.space && "svg" !== r.space) {
        const e = a.name.indexOf(":")
        e < 0 ? (a.prefix = "") : ((a.name = a.name.slice(e + 1)), (a.prefix = r.attribute.slice(0, e))),
          (a.namespace = nE[r.space])
      }
      return a
    }
    function bE(e, t, n) {
      let r = -1
      const a = []
      if (e)
        for (; ++r < e.length; ) {
          const o = mE(e[r], n)
          ;(o.parentNode = t), a.push(o)
        }
      return a
    }
    function vE(e, t) {
      const n = e.position
      n &&
        n.start &&
        n.end &&
        (n.start.offset,
        n.end.offset,
        (t.sourceCodeLocation = {
          startLine: n.start.line,
          startCol: n.start.column,
          startOffset: n.start.offset,
          endLine: n.end.line,
          endCol: n.end.column,
          endOffset: n.end.offset,
        }))
    }
    const yE = [
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "image",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
      ],
      OE = new Set([
        65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751,
        524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503,
        983038, 983039, 1048574, 1048575, 1114110, 1114111,
      ]),
      wE = ""
    var xE, kE
    ;((kE = xE = xE || (xE = {}))[(kE.EOF = -1)] = "EOF"),
      (kE[(kE.NULL = 0)] = "NULL"),
      (kE[(kE.TABULATION = 9)] = "TABULATION"),
      (kE[(kE.CARRIAGE_RETURN = 13)] = "CARRIAGE_RETURN"),
      (kE[(kE.LINE_FEED = 10)] = "LINE_FEED"),
      (kE[(kE.FORM_FEED = 12)] = "FORM_FEED"),
      (kE[(kE.SPACE = 32)] = "SPACE"),
      (kE[(kE.EXCLAMATION_MARK = 33)] = "EXCLAMATION_MARK"),
      (kE[(kE.QUOTATION_MARK = 34)] = "QUOTATION_MARK"),
      (kE[(kE.NUMBER_SIGN = 35)] = "NUMBER_SIGN"),
      (kE[(kE.AMPERSAND = 38)] = "AMPERSAND"),
      (kE[(kE.APOSTROPHE = 39)] = "APOSTROPHE"),
      (kE[(kE.HYPHEN_MINUS = 45)] = "HYPHEN_MINUS"),
      (kE[(kE.SOLIDUS = 47)] = "SOLIDUS"),
      (kE[(kE.DIGIT_0 = 48)] = "DIGIT_0"),
      (kE[(kE.DIGIT_9 = 57)] = "DIGIT_9"),
      (kE[(kE.SEMICOLON = 59)] = "SEMICOLON"),
      (kE[(kE.LESS_THAN_SIGN = 60)] = "LESS_THAN_SIGN"),
      (kE[(kE.EQUALS_SIGN = 61)] = "EQUALS_SIGN"),
      (kE[(kE.GREATER_THAN_SIGN = 62)] = "GREATER_THAN_SIGN"),
      (kE[(kE.QUESTION_MARK = 63)] = "QUESTION_MARK"),
      (kE[(kE.LATIN_CAPITAL_A = 65)] = "LATIN_CAPITAL_A"),
      (kE[(kE.LATIN_CAPITAL_F = 70)] = "LATIN_CAPITAL_F"),
      (kE[(kE.LATIN_CAPITAL_X = 88)] = "LATIN_CAPITAL_X"),
      (kE[(kE.LATIN_CAPITAL_Z = 90)] = "LATIN_CAPITAL_Z"),
      (kE[(kE.RIGHT_SQUARE_BRACKET = 93)] = "RIGHT_SQUARE_BRACKET"),
      (kE[(kE.GRAVE_ACCENT = 96)] = "GRAVE_ACCENT"),
      (kE[(kE.LATIN_SMALL_A = 97)] = "LATIN_SMALL_A"),
      (kE[(kE.LATIN_SMALL_F = 102)] = "LATIN_SMALL_F"),
      (kE[(kE.LATIN_SMALL_X = 120)] = "LATIN_SMALL_X"),
      (kE[(kE.LATIN_SMALL_Z = 122)] = "LATIN_SMALL_Z"),
      (kE[(kE.REPLACEMENT_CHARACTER = 65533)] = "REPLACEMENT_CHARACTER")
    const _E = "[CDATA[",
      SE = "doctype",
      EE = "script"
    function TE(e) {
      return e >= 55296 && e <= 57343
    }
    function AE(e) {
      return (32 !== e && 10 !== e && 13 !== e && 9 !== e && 12 !== e && e >= 1 && e <= 31) || (e >= 127 && e <= 159)
    }
    function CE(e) {
      return (e >= 64976 && e <= 65007) || OE.has(e)
    }
    var PE, DE, RE, NE
    ;((DE = PE = PE || (PE = {})).controlCharacterInInputStream = "control-character-in-input-stream"),
      (DE.noncharacterInInputStream = "noncharacter-in-input-stream"),
      (DE.surrogateInInputStream = "surrogate-in-input-stream"),
      (DE.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus"),
      (DE.endTagWithAttributes = "end-tag-with-attributes"),
      (DE.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus"),
      (DE.unexpectedSolidusInTag = "unexpected-solidus-in-tag"),
      (DE.unexpectedNullCharacter = "unexpected-null-character"),
      (DE.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name"),
      (DE.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name"),
      (DE.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name"),
      (DE.missingEndTagName = "missing-end-tag-name"),
      (DE.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name"),
      (DE.unknownNamedCharacterReference = "unknown-named-character-reference"),
      (DE.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference"),
      (DE.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier"),
      (DE.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value"),
      (DE.eofBeforeTagName = "eof-before-tag-name"),
      (DE.eofInTag = "eof-in-tag"),
      (DE.missingAttributeValue = "missing-attribute-value"),
      (DE.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes"),
      (DE.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword"),
      (DE.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers =
        "missing-whitespace-between-doctype-public-and-system-identifiers"),
      (DE.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword"),
      (DE.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier"),
      (DE.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier"),
      (DE.missingDoctypePublicIdentifier = "missing-doctype-public-identifier"),
      (DE.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier"),
      (DE.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier"),
      (DE.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier"),
      (DE.cdataInHtmlContent = "cdata-in-html-content"),
      (DE.incorrectlyOpenedComment = "incorrectly-opened-comment"),
      (DE.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text"),
      (DE.eofInDoctype = "eof-in-doctype"),
      (DE.nestedComment = "nested-comment"),
      (DE.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment"),
      (DE.eofInComment = "eof-in-comment"),
      (DE.incorrectlyClosedComment = "incorrectly-closed-comment"),
      (DE.eofInCdata = "eof-in-cdata"),
      (DE.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference"),
      (DE.nullCharacterReference = "null-character-reference"),
      (DE.surrogateCharacterReference = "surrogate-character-reference"),
      (DE.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range"),
      (DE.controlCharacterReference = "control-character-reference"),
      (DE.noncharacterCharacterReference = "noncharacter-character-reference"),
      (DE.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name"),
      (DE.missingDoctypeName = "missing-doctype-name"),
      (DE.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name"),
      (DE.duplicateAttribute = "duplicate-attribute"),
      (DE.nonConformingDoctype = "non-conforming-doctype"),
      (DE.missingDoctype = "missing-doctype"),
      (DE.misplacedDoctype = "misplaced-doctype"),
      (DE.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element"),
      (DE.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements"),
      (DE.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head"),
      (DE.openElementsLeftAfterEof = "open-elements-left-after-eof"),
      (DE.abandonedHeadElementChild = "abandoned-head-element-child"),
      (DE.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element"),
      (DE.nestedNoscriptInHead = "nested-noscript-in-head"),
      (DE.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text")
    class $E {
      constructor(e) {
        ;(this.handler = e),
          (this.html = ""),
          (this.pos = -1),
          (this.lastGapPos = -2),
          (this.gapStack = []),
          (this.skipNextNewLine = !1),
          (this.lastChunkWritten = !1),
          (this.endOfChunkHit = !1),
          (this.bufferWaterline = 65536),
          (this.isEol = !1),
          (this.lineStartPos = 0),
          (this.droppedBufferSize = 0),
          (this.line = 1),
          (this.lastErrOffset = -1)
      }
      get col() {
        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos)
      }
      get offset() {
        return this.droppedBufferSize + this.pos
      }
      getError(e) {
        const { line: t, col: n, offset: r } = this
        return { code: e, startLine: t, endLine: t, startCol: n, endCol: n, startOffset: r, endOffset: r }
      }
      _err(e) {
        this.handler.onParseError &&
          this.lastErrOffset !== this.offset &&
          ((this.lastErrOffset = this.offset), this.handler.onParseError(this.getError(e)))
      }
      _addGap() {
        this.gapStack.push(this.lastGapPos), (this.lastGapPos = this.pos)
      }
      _processSurrogate(e) {
        if (this.pos !== this.html.length - 1) {
          const t = this.html.charCodeAt(this.pos + 1)
          if (
            (function (e) {
              return e >= 56320 && e <= 57343
            })(t)
          )
            return this.pos++, this._addGap(), 1024 * (e - 55296) + 9216 + t
        } else if (!this.lastChunkWritten) return (this.endOfChunkHit = !0), xE.EOF
        return this._err(PE.surrogateInInputStream), e
      }
      willDropParsedChunk() {
        return this.pos > this.bufferWaterline
      }
      dropParsedChunk() {
        this.willDropParsedChunk() &&
          ((this.html = this.html.substring(this.pos)),
          (this.lineStartPos -= this.pos),
          (this.droppedBufferSize += this.pos),
          (this.pos = 0),
          (this.lastGapPos = -2),
          (this.gapStack.length = 0))
      }
      write(e, t) {
        this.html.length > 0 ? (this.html += e) : (this.html = e),
          (this.endOfChunkHit = !1),
          (this.lastChunkWritten = t)
      }
      insertHtmlAtCurrentPos(e) {
        ;(this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1)),
          (this.endOfChunkHit = !1)
      }
      startsWith(e, t) {
        if (this.pos + e.length > this.html.length) return (this.endOfChunkHit = !this.lastChunkWritten), !1
        if (t) return this.html.startsWith(e, this.pos)
        for (let t = 0; t < e.length; t++) if ((32 | this.html.charCodeAt(this.pos + t)) !== e.charCodeAt(t)) return !1
        return !0
      }
      peek(e) {
        const t = this.pos + e
        if (t >= this.html.length) return (this.endOfChunkHit = !this.lastChunkWritten), xE.EOF
        const n = this.html.charCodeAt(t)
        return n === xE.CARRIAGE_RETURN ? xE.LINE_FEED : n
      }
      advance() {
        if (
          (this.pos++,
          this.isEol && ((this.isEol = !1), this.line++, (this.lineStartPos = this.pos)),
          this.pos >= this.html.length)
        )
          return (this.endOfChunkHit = !this.lastChunkWritten), xE.EOF
        let e = this.html.charCodeAt(this.pos)
        return e === xE.CARRIAGE_RETURN
          ? ((this.isEol = !0), (this.skipNextNewLine = !0), xE.LINE_FEED)
          : e === xE.LINE_FEED && ((this.isEol = !0), this.skipNextNewLine)
            ? (this.line--, (this.skipNextNewLine = !1), this._addGap(), this.advance())
            : ((this.skipNextNewLine = !1),
              TE(e) && (e = this._processSurrogate(e)),
              null === this.handler.onParseError ||
                (e > 31 && e < 127) ||
                e === xE.LINE_FEED ||
                e === xE.CARRIAGE_RETURN ||
                (e > 159 && e < 64976) ||
                this._checkForProblematicCharacters(e),
              e)
      }
      _checkForProblematicCharacters(e) {
        AE(e) ? this._err(PE.controlCharacterInInputStream) : CE(e) && this._err(PE.noncharacterInInputStream)
      }
      retreat(e) {
        for (this.pos -= e; this.pos < this.lastGapPos; ) (this.lastGapPos = this.gapStack.pop()), this.pos--
        this.isEol = !1
      }
    }
    function IE(e, t) {
      for (let n = e.attrs.length - 1; n >= 0; n--) if (e.attrs[n].name === t) return e.attrs[n].value
      return null
    }
    ;((NE = RE = RE || (RE = {}))[(NE.CHARACTER = 0)] = "CHARACTER"),
      (NE[(NE.NULL_CHARACTER = 1)] = "NULL_CHARACTER"),
      (NE[(NE.WHITESPACE_CHARACTER = 2)] = "WHITESPACE_CHARACTER"),
      (NE[(NE.START_TAG = 3)] = "START_TAG"),
      (NE[(NE.END_TAG = 4)] = "END_TAG"),
      (NE[(NE.COMMENT = 5)] = "COMMENT"),
      (NE[(NE.DOCTYPE = 6)] = "DOCTYPE"),
      (NE[(NE.EOF = 7)] = "EOF"),
      (NE[(NE.HIBERNATION = 8)] = "HIBERNATION")
    const ME = new Uint16Array(
        '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'
          .split("")
          .map((e) => e.charCodeAt(0)),
      ),
      LE = new Uint16Array("aglq\t\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0)))
    var QE
    const BE = new Map([
        [0, 65533],
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
      ]),
      jE =
        null !== (QE = String.fromCodePoint) && void 0 !== QE
          ? QE
          : function (e) {
              let t = ""
              return (
                e > 65535 &&
                  ((e -= 65536), (t += String.fromCharCode(((e >>> 10) & 1023) | 55296)), (e = 56320 | (1023 & e))),
                (t += String.fromCharCode(e)),
                t
              )
            }
    var UE, FE, zE, qE, ZE, HE, VE, WE, XE, YE, GE, KE, JE, eT, tT, nT, rT, aT
    function oT(e) {
      return e >= UE.ZERO && e <= UE.NINE
    }
    function iT(e) {
      return (
        e === UE.EQUALS ||
        (function (e) {
          return (e >= UE.UPPER_A && e <= UE.UPPER_Z) || (e >= UE.LOWER_A && e <= UE.LOWER_Z) || oT(e)
        })(e)
      )
    }
    ;((FE = UE || (UE = {}))[(FE.NUM = 35)] = "NUM"),
      (FE[(FE.SEMI = 59)] = "SEMI"),
      (FE[(FE.EQUALS = 61)] = "EQUALS"),
      (FE[(FE.ZERO = 48)] = "ZERO"),
      (FE[(FE.NINE = 57)] = "NINE"),
      (FE[(FE.LOWER_A = 97)] = "LOWER_A"),
      (FE[(FE.LOWER_F = 102)] = "LOWER_F"),
      (FE[(FE.LOWER_X = 120)] = "LOWER_X"),
      (FE[(FE.LOWER_Z = 122)] = "LOWER_Z"),
      (FE[(FE.UPPER_A = 65)] = "UPPER_A"),
      (FE[(FE.UPPER_F = 70)] = "UPPER_F"),
      (FE[(FE.UPPER_Z = 90)] = "UPPER_Z"),
      ((qE = zE || (zE = {}))[(qE.VALUE_LENGTH = 49152)] = "VALUE_LENGTH"),
      (qE[(qE.BRANCH_LENGTH = 16256)] = "BRANCH_LENGTH"),
      (qE[(qE.JUMP_TABLE = 127)] = "JUMP_TABLE"),
      ((HE = ZE || (ZE = {}))[(HE.EntityStart = 0)] = "EntityStart"),
      (HE[(HE.NumericStart = 1)] = "NumericStart"),
      (HE[(HE.NumericDecimal = 2)] = "NumericDecimal"),
      (HE[(HE.NumericHex = 3)] = "NumericHex"),
      (HE[(HE.NamedEntity = 4)] = "NamedEntity"),
      ((WE = VE || (VE = {}))[(WE.Legacy = 0)] = "Legacy"),
      (WE[(WE.Strict = 1)] = "Strict"),
      (WE[(WE.Attribute = 2)] = "Attribute")
    class sT {
      constructor(e, t, n) {
        ;(this.decodeTree = e),
          (this.emitCodePoint = t),
          (this.errors = n),
          (this.state = ZE.EntityStart),
          (this.consumed = 1),
          (this.result = 0),
          (this.treeIndex = 0),
          (this.excess = 1),
          (this.decodeMode = VE.Strict)
      }
      startEntity(e) {
        ;(this.decodeMode = e),
          (this.state = ZE.EntityStart),
          (this.result = 0),
          (this.treeIndex = 0),
          (this.excess = 1),
          (this.consumed = 1)
      }
      write(e, t) {
        switch (this.state) {
          case ZE.EntityStart:
            return e.charCodeAt(t) === UE.NUM
              ? ((this.state = ZE.NumericStart), (this.consumed += 1), this.stateNumericStart(e, t + 1))
              : ((this.state = ZE.NamedEntity), this.stateNamedEntity(e, t))
          case ZE.NumericStart:
            return this.stateNumericStart(e, t)
          case ZE.NumericDecimal:
            return this.stateNumericDecimal(e, t)
          case ZE.NumericHex:
            return this.stateNumericHex(e, t)
          case ZE.NamedEntity:
            return this.stateNamedEntity(e, t)
        }
      }
      stateNumericStart(e, t) {
        return t >= e.length
          ? -1
          : (32 | e.charCodeAt(t)) === UE.LOWER_X
            ? ((this.state = ZE.NumericHex), (this.consumed += 1), this.stateNumericHex(e, t + 1))
            : ((this.state = ZE.NumericDecimal), this.stateNumericDecimal(e, t))
      }
      addToNumericResult(e, t, n, r) {
        if (t !== n) {
          const a = n - t
          ;(this.result = this.result * Math.pow(r, a) + parseInt(e.substr(t, a), r)), (this.consumed += a)
        }
      }
      stateNumericHex(e, t) {
        const n = t
        for (; t < e.length; ) {
          const a = e.charCodeAt(t)
          if (!(oT(a) || ((r = a), (r >= UE.UPPER_A && r <= UE.UPPER_F) || (r >= UE.LOWER_A && r <= UE.LOWER_F))))
            return this.addToNumericResult(e, n, t, 16), this.emitNumericEntity(a, 3)
          t += 1
        }
        var r
        return this.addToNumericResult(e, n, t, 16), -1
      }
      stateNumericDecimal(e, t) {
        const n = t
        for (; t < e.length; ) {
          const r = e.charCodeAt(t)
          if (!oT(r)) return this.addToNumericResult(e, n, t, 10), this.emitNumericEntity(r, 2)
          t += 1
        }
        return this.addToNumericResult(e, n, t, 10), -1
      }
      emitNumericEntity(e, t) {
        var n
        if (this.consumed <= t)
          return (
            null === (n = this.errors) || void 0 === n || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0
          )
        if (e === UE.SEMI) this.consumed += 1
        else if (this.decodeMode === VE.Strict) return 0
        return (
          this.emitCodePoint(
            (function (e) {
              var t
              return (e >= 55296 && e <= 57343) || e > 1114111
                ? 65533
                : null !== (t = BE.get(e)) && void 0 !== t
                  ? t
                  : e
            })(this.result),
            this.consumed,
          ),
          this.errors &&
            (e !== UE.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
            this.errors.validateNumericCharacterReference(this.result)),
          this.consumed
        )
      }
      stateNamedEntity(e, t) {
        const { decodeTree: n } = this
        let r = n[this.treeIndex],
          a = (r & zE.VALUE_LENGTH) >> 14
        for (; t < e.length; t++, this.excess++) {
          const o = e.charCodeAt(t)
          if (((this.treeIndex = cT(n, r, this.treeIndex + Math.max(1, a), o)), this.treeIndex < 0))
            return 0 === this.result || (this.decodeMode === VE.Attribute && (0 === a || iT(o)))
              ? 0
              : this.emitNotTerminatedNamedEntity()
          if (((r = n[this.treeIndex]), (a = (r & zE.VALUE_LENGTH) >> 14), 0 !== a)) {
            if (o === UE.SEMI) return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess)
            this.decodeMode !== VE.Strict &&
              ((this.result = this.treeIndex), (this.consumed += this.excess), (this.excess = 0))
          }
        }
        return -1
      }
      emitNotTerminatedNamedEntity() {
        var e
        const { result: t, decodeTree: n } = this,
          r = (n[t] & zE.VALUE_LENGTH) >> 14
        return (
          this.emitNamedEntityData(t, r, this.consumed),
          null === (e = this.errors) || void 0 === e || e.missingSemicolonAfterCharacterReference(),
          this.consumed
        )
      }
      emitNamedEntityData(e, t, n) {
        const { decodeTree: r } = this
        return (
          this.emitCodePoint(1 === t ? r[e] & ~zE.VALUE_LENGTH : r[e + 1], n),
          3 === t && this.emitCodePoint(r[e + 2], n),
          n
        )
      }
      end() {
        var e
        switch (this.state) {
          case ZE.NamedEntity:
            return 0 === this.result || (this.decodeMode === VE.Attribute && this.result !== this.treeIndex)
              ? 0
              : this.emitNotTerminatedNamedEntity()
          case ZE.NumericDecimal:
            return this.emitNumericEntity(0, 2)
          case ZE.NumericHex:
            return this.emitNumericEntity(0, 3)
          case ZE.NumericStart:
            return (
              null === (e = this.errors) || void 0 === e || e.absenceOfDigitsInNumericCharacterReference(this.consumed),
              0
            )
          case ZE.EntityStart:
            return 0
        }
      }
    }
    function lT(e) {
      let t = ""
      const n = new sT(e, (e) => (t += jE(e)))
      return function (e, r) {
        let a = 0,
          o = 0
        for (; (o = e.indexOf("&", o)) >= 0; ) {
          ;(t += e.slice(a, o)), n.startEntity(r)
          const i = n.write(e, o + 1)
          if (i < 0) {
            a = o + n.end()
            break
          }
          ;(a = o + i), (o = 0 === i ? a + 1 : a)
        }
        const i = t + e.slice(a)
        return (t = ""), i
      }
    }
    function cT(e, t, n, r) {
      const a = (t & zE.BRANCH_LENGTH) >> 7,
        o = t & zE.JUMP_TABLE
      if (0 === a) return 0 !== o && r === o ? n : -1
      if (o) {
        const t = r - o
        return t < 0 || t >= a ? -1 : e[n + t] - 1
      }
      let i = n,
        s = i + a - 1
      for (; i <= s; ) {
        const t = (i + s) >>> 1,
          n = e[t]
        if (n < r) i = t + 1
        else {
          if (!(n > r)) return e[t + a]
          s = t - 1
        }
      }
      return -1
    }
    lT(ME),
      lT(LE),
      ((YE = XE = XE || (XE = {})).HTML = "http://www.w3.org/1999/xhtml"),
      (YE.MATHML = "http://www.w3.org/1998/Math/MathML"),
      (YE.SVG = "http://www.w3.org/2000/svg"),
      (YE.XLINK = "http://www.w3.org/1999/xlink"),
      (YE.XML = "http://www.w3.org/XML/1998/namespace"),
      (YE.XMLNS = "http://www.w3.org/2000/xmlns/"),
      ((KE = GE = GE || (GE = {})).TYPE = "type"),
      (KE.ACTION = "action"),
      (KE.ENCODING = "encoding"),
      (KE.PROMPT = "prompt"),
      (KE.NAME = "name"),
      (KE.COLOR = "color"),
      (KE.FACE = "face"),
      (KE.SIZE = "size"),
      ((eT = JE = JE || (JE = {})).NO_QUIRKS = "no-quirks"),
      (eT.QUIRKS = "quirks"),
      (eT.LIMITED_QUIRKS = "limited-quirks"),
      ((nT = tT = tT || (tT = {})).A = "a"),
      (nT.ADDRESS = "address"),
      (nT.ANNOTATION_XML = "annotation-xml"),
      (nT.APPLET = "applet"),
      (nT.AREA = "area"),
      (nT.ARTICLE = "article"),
      (nT.ASIDE = "aside"),
      (nT.B = "b"),
      (nT.BASE = "base"),
      (nT.BASEFONT = "basefont"),
      (nT.BGSOUND = "bgsound"),
      (nT.BIG = "big"),
      (nT.BLOCKQUOTE = "blockquote"),
      (nT.BODY = "body"),
      (nT.BR = "br"),
      (nT.BUTTON = "button"),
      (nT.CAPTION = "caption"),
      (nT.CENTER = "center"),
      (nT.CODE = "code"),
      (nT.COL = "col"),
      (nT.COLGROUP = "colgroup"),
      (nT.DD = "dd"),
      (nT.DESC = "desc"),
      (nT.DETAILS = "details"),
      (nT.DIALOG = "dialog"),
      (nT.DIR = "dir"),
      (nT.DIV = "div"),
      (nT.DL = "dl"),
      (nT.DT = "dt"),
      (nT.EM = "em"),
      (nT.EMBED = "embed"),
      (nT.FIELDSET = "fieldset"),
      (nT.FIGCAPTION = "figcaption"),
      (nT.FIGURE = "figure"),
      (nT.FONT = "font"),
      (nT.FOOTER = "footer"),
      (nT.FOREIGN_OBJECT = "foreignObject"),
      (nT.FORM = "form"),
      (nT.FRAME = "frame"),
      (nT.FRAMESET = "frameset"),
      (nT.H1 = "h1"),
      (nT.H2 = "h2"),
      (nT.H3 = "h3"),
      (nT.H4 = "h4"),
      (nT.H5 = "h5"),
      (nT.H6 = "h6"),
      (nT.HEAD = "head"),
      (nT.HEADER = "header"),
      (nT.HGROUP = "hgroup"),
      (nT.HR = "hr"),
      (nT.HTML = "html"),
      (nT.I = "i"),
      (nT.IMG = "img"),
      (nT.IMAGE = "image"),
      (nT.INPUT = "input"),
      (nT.IFRAME = "iframe"),
      (nT.KEYGEN = "keygen"),
      (nT.LABEL = "label"),
      (nT.LI = "li"),
      (nT.LINK = "link"),
      (nT.LISTING = "listing"),
      (nT.MAIN = "main"),
      (nT.MALIGNMARK = "malignmark"),
      (nT.MARQUEE = "marquee"),
      (nT.MATH = "math"),
      (nT.MENU = "menu"),
      (nT.META = "meta"),
      (nT.MGLYPH = "mglyph"),
      (nT.MI = "mi"),
      (nT.MO = "mo"),
      (nT.MN = "mn"),
      (nT.MS = "ms"),
      (nT.MTEXT = "mtext"),
      (nT.NAV = "nav"),
      (nT.NOBR = "nobr"),
      (nT.NOFRAMES = "noframes"),
      (nT.NOEMBED = "noembed"),
      (nT.NOSCRIPT = "noscript"),
      (nT.OBJECT = "object"),
      (nT.OL = "ol"),
      (nT.OPTGROUP = "optgroup"),
      (nT.OPTION = "option"),
      (nT.P = "p"),
      (nT.PARAM = "param"),
      (nT.PLAINTEXT = "plaintext"),
      (nT.PRE = "pre"),
      (nT.RB = "rb"),
      (nT.RP = "rp"),
      (nT.RT = "rt"),
      (nT.RTC = "rtc"),
      (nT.RUBY = "ruby"),
      (nT.S = "s"),
      (nT.SCRIPT = "script"),
      (nT.SECTION = "section"),
      (nT.SELECT = "select"),
      (nT.SOURCE = "source"),
      (nT.SMALL = "small"),
      (nT.SPAN = "span"),
      (nT.STRIKE = "strike"),
      (nT.STRONG = "strong"),
      (nT.STYLE = "style"),
      (nT.SUB = "sub"),
      (nT.SUMMARY = "summary"),
      (nT.SUP = "sup"),
      (nT.TABLE = "table"),
      (nT.TBODY = "tbody"),
      (nT.TEMPLATE = "template"),
      (nT.TEXTAREA = "textarea"),
      (nT.TFOOT = "tfoot"),
      (nT.TD = "td"),
      (nT.TH = "th"),
      (nT.THEAD = "thead"),
      (nT.TITLE = "title"),
      (nT.TR = "tr"),
      (nT.TRACK = "track"),
      (nT.TT = "tt"),
      (nT.U = "u"),
      (nT.UL = "ul"),
      (nT.SVG = "svg"),
      (nT.VAR = "var"),
      (nT.WBR = "wbr"),
      (nT.XMP = "xmp"),
      ((aT = rT = rT || (rT = {}))[(aT.UNKNOWN = 0)] = "UNKNOWN"),
      (aT[(aT.A = 1)] = "A"),
      (aT[(aT.ADDRESS = 2)] = "ADDRESS"),
      (aT[(aT.ANNOTATION_XML = 3)] = "ANNOTATION_XML"),
      (aT[(aT.APPLET = 4)] = "APPLET"),
      (aT[(aT.AREA = 5)] = "AREA"),
      (aT[(aT.ARTICLE = 6)] = "ARTICLE"),
      (aT[(aT.ASIDE = 7)] = "ASIDE"),
      (aT[(aT.B = 8)] = "B"),
      (aT[(aT.BASE = 9)] = "BASE"),
      (aT[(aT.BASEFONT = 10)] = "BASEFONT"),
      (aT[(aT.BGSOUND = 11)] = "BGSOUND"),
      (aT[(aT.BIG = 12)] = "BIG"),
      (aT[(aT.BLOCKQUOTE = 13)] = "BLOCKQUOTE"),
      (aT[(aT.BODY = 14)] = "BODY"),
      (aT[(aT.BR = 15)] = "BR"),
      (aT[(aT.BUTTON = 16)] = "BUTTON"),
      (aT[(aT.CAPTION = 17)] = "CAPTION"),
      (aT[(aT.CENTER = 18)] = "CENTER"),
      (aT[(aT.CODE = 19)] = "CODE"),
      (aT[(aT.COL = 20)] = "COL"),
      (aT[(aT.COLGROUP = 21)] = "COLGROUP"),
      (aT[(aT.DD = 22)] = "DD"),
      (aT[(aT.DESC = 23)] = "DESC"),
      (aT[(aT.DETAILS = 24)] = "DETAILS"),
      (aT[(aT.DIALOG = 25)] = "DIALOG"),
      (aT[(aT.DIR = 26)] = "DIR"),
      (aT[(aT.DIV = 27)] = "DIV"),
      (aT[(aT.DL = 28)] = "DL"),
      (aT[(aT.DT = 29)] = "DT"),
      (aT[(aT.EM = 30)] = "EM"),
      (aT[(aT.EMBED = 31)] = "EMBED"),
      (aT[(aT.FIELDSET = 32)] = "FIELDSET"),
      (aT[(aT.FIGCAPTION = 33)] = "FIGCAPTION"),
      (aT[(aT.FIGURE = 34)] = "FIGURE"),
      (aT[(aT.FONT = 35)] = "FONT"),
      (aT[(aT.FOOTER = 36)] = "FOOTER"),
      (aT[(aT.FOREIGN_OBJECT = 37)] = "FOREIGN_OBJECT"),
      (aT[(aT.FORM = 38)] = "FORM"),
      (aT[(aT.FRAME = 39)] = "FRAME"),
      (aT[(aT.FRAMESET = 40)] = "FRAMESET"),
      (aT[(aT.H1 = 41)] = "H1"),
      (aT[(aT.H2 = 42)] = "H2"),
      (aT[(aT.H3 = 43)] = "H3"),
      (aT[(aT.H4 = 44)] = "H4"),
      (aT[(aT.H5 = 45)] = "H5"),
      (aT[(aT.H6 = 46)] = "H6"),
      (aT[(aT.HEAD = 47)] = "HEAD"),
      (aT[(aT.HEADER = 48)] = "HEADER"),
      (aT[(aT.HGROUP = 49)] = "HGROUP"),
      (aT[(aT.HR = 50)] = "HR"),
      (aT[(aT.HTML = 51)] = "HTML"),
      (aT[(aT.I = 52)] = "I"),
      (aT[(aT.IMG = 53)] = "IMG"),
      (aT[(aT.IMAGE = 54)] = "IMAGE"),
      (aT[(aT.INPUT = 55)] = "INPUT"),
      (aT[(aT.IFRAME = 56)] = "IFRAME"),
      (aT[(aT.KEYGEN = 57)] = "KEYGEN"),
      (aT[(aT.LABEL = 58)] = "LABEL"),
      (aT[(aT.LI = 59)] = "LI"),
      (aT[(aT.LINK = 60)] = "LINK"),
      (aT[(aT.LISTING = 61)] = "LISTING"),
      (aT[(aT.MAIN = 62)] = "MAIN"),
      (aT[(aT.MALIGNMARK = 63)] = "MALIGNMARK"),
      (aT[(aT.MARQUEE = 64)] = "MARQUEE"),
      (aT[(aT.MATH = 65)] = "MATH"),
      (aT[(aT.MENU = 66)] = "MENU"),
      (aT[(aT.META = 67)] = "META"),
      (aT[(aT.MGLYPH = 68)] = "MGLYPH"),
      (aT[(aT.MI = 69)] = "MI"),
      (aT[(aT.MO = 70)] = "MO"),
      (aT[(aT.MN = 71)] = "MN"),
      (aT[(aT.MS = 72)] = "MS"),
      (aT[(aT.MTEXT = 73)] = "MTEXT"),
      (aT[(aT.NAV = 74)] = "NAV"),
      (aT[(aT.NOBR = 75)] = "NOBR"),
      (aT[(aT.NOFRAMES = 76)] = "NOFRAMES"),
      (aT[(aT.NOEMBED = 77)] = "NOEMBED"),
      (aT[(aT.NOSCRIPT = 78)] = "NOSCRIPT"),
      (aT[(aT.OBJECT = 79)] = "OBJECT"),
      (aT[(aT.OL = 80)] = "OL"),
      (aT[(aT.OPTGROUP = 81)] = "OPTGROUP"),
      (aT[(aT.OPTION = 82)] = "OPTION"),
      (aT[(aT.P = 83)] = "P"),
      (aT[(aT.PARAM = 84)] = "PARAM"),
      (aT[(aT.PLAINTEXT = 85)] = "PLAINTEXT"),
      (aT[(aT.PRE = 86)] = "PRE"),
      (aT[(aT.RB = 87)] = "RB"),
      (aT[(aT.RP = 88)] = "RP"),
      (aT[(aT.RT = 89)] = "RT"),
      (aT[(aT.RTC = 90)] = "RTC"),
      (aT[(aT.RUBY = 91)] = "RUBY"),
      (aT[(aT.S = 92)] = "S"),
      (aT[(aT.SCRIPT = 93)] = "SCRIPT"),
      (aT[(aT.SECTION = 94)] = "SECTION"),
      (aT[(aT.SELECT = 95)] = "SELECT"),
      (aT[(aT.SOURCE = 96)] = "SOURCE"),
      (aT[(aT.SMALL = 97)] = "SMALL"),
      (aT[(aT.SPAN = 98)] = "SPAN"),
      (aT[(aT.STRIKE = 99)] = "STRIKE"),
      (aT[(aT.STRONG = 100)] = "STRONG"),
      (aT[(aT.STYLE = 101)] = "STYLE"),
      (aT[(aT.SUB = 102)] = "SUB"),
      (aT[(aT.SUMMARY = 103)] = "SUMMARY"),
      (aT[(aT.SUP = 104)] = "SUP"),
      (aT[(aT.TABLE = 105)] = "TABLE"),
      (aT[(aT.TBODY = 106)] = "TBODY"),
      (aT[(aT.TEMPLATE = 107)] = "TEMPLATE"),
      (aT[(aT.TEXTAREA = 108)] = "TEXTAREA"),
      (aT[(aT.TFOOT = 109)] = "TFOOT"),
      (aT[(aT.TD = 110)] = "TD"),
      (aT[(aT.TH = 111)] = "TH"),
      (aT[(aT.THEAD = 112)] = "THEAD"),
      (aT[(aT.TITLE = 113)] = "TITLE"),
      (aT[(aT.TR = 114)] = "TR"),
      (aT[(aT.TRACK = 115)] = "TRACK"),
      (aT[(aT.TT = 116)] = "TT"),
      (aT[(aT.U = 117)] = "U"),
      (aT[(aT.UL = 118)] = "UL"),
      (aT[(aT.SVG = 119)] = "SVG"),
      (aT[(aT.VAR = 120)] = "VAR"),
      (aT[(aT.WBR = 121)] = "WBR"),
      (aT[(aT.XMP = 122)] = "XMP")
    const dT = new Map([
      [tT.A, rT.A],
      [tT.ADDRESS, rT.ADDRESS],
      [tT.ANNOTATION_XML, rT.ANNOTATION_XML],
      [tT.APPLET, rT.APPLET],
      [tT.AREA, rT.AREA],
      [tT.ARTICLE, rT.ARTICLE],
      [tT.ASIDE, rT.ASIDE],
      [tT.B, rT.B],
      [tT.BASE, rT.BASE],
      [tT.BASEFONT, rT.BASEFONT],
      [tT.BGSOUND, rT.BGSOUND],
      [tT.BIG, rT.BIG],
      [tT.BLOCKQUOTE, rT.BLOCKQUOTE],
      [tT.BODY, rT.BODY],
      [tT.BR, rT.BR],
      [tT.BUTTON, rT.BUTTON],
      [tT.CAPTION, rT.CAPTION],
      [tT.CENTER, rT.CENTER],
      [tT.CODE, rT.CODE],
      [tT.COL, rT.COL],
      [tT.COLGROUP, rT.COLGROUP],
      [tT.DD, rT.DD],
      [tT.DESC, rT.DESC],
      [tT.DETAILS, rT.DETAILS],
      [tT.DIALOG, rT.DIALOG],
      [tT.DIR, rT.DIR],
      [tT.DIV, rT.DIV],
      [tT.DL, rT.DL],
      [tT.DT, rT.DT],
      [tT.EM, rT.EM],
      [tT.EMBED, rT.EMBED],
      [tT.FIELDSET, rT.FIELDSET],
      [tT.FIGCAPTION, rT.FIGCAPTION],
      [tT.FIGURE, rT.FIGURE],
      [tT.FONT, rT.FONT],
      [tT.FOOTER, rT.FOOTER],
      [tT.FOREIGN_OBJECT, rT.FOREIGN_OBJECT],
      [tT.FORM, rT.FORM],
      [tT.FRAME, rT.FRAME],
      [tT.FRAMESET, rT.FRAMESET],
      [tT.H1, rT.H1],
      [tT.H2, rT.H2],
      [tT.H3, rT.H3],
      [tT.H4, rT.H4],
      [tT.H5, rT.H5],
      [tT.H6, rT.H6],
      [tT.HEAD, rT.HEAD],
      [tT.HEADER, rT.HEADER],
      [tT.HGROUP, rT.HGROUP],
      [tT.HR, rT.HR],
      [tT.HTML, rT.HTML],
      [tT.I, rT.I],
      [tT.IMG, rT.IMG],
      [tT.IMAGE, rT.IMAGE],
      [tT.INPUT, rT.INPUT],
      [tT.IFRAME, rT.IFRAME],
      [tT.KEYGEN, rT.KEYGEN],
      [tT.LABEL, rT.LABEL],
      [tT.LI, rT.LI],
      [tT.LINK, rT.LINK],
      [tT.LISTING, rT.LISTING],
      [tT.MAIN, rT.MAIN],
      [tT.MALIGNMARK, rT.MALIGNMARK],
      [tT.MARQUEE, rT.MARQUEE],
      [tT.MATH, rT.MATH],
      [tT.MENU, rT.MENU],
      [tT.META, rT.META],
      [tT.MGLYPH, rT.MGLYPH],
      [tT.MI, rT.MI],
      [tT.MO, rT.MO],
      [tT.MN, rT.MN],
      [tT.MS, rT.MS],
      [tT.MTEXT, rT.MTEXT],
      [tT.NAV, rT.NAV],
      [tT.NOBR, rT.NOBR],
      [tT.NOFRAMES, rT.NOFRAMES],
      [tT.NOEMBED, rT.NOEMBED],
      [tT.NOSCRIPT, rT.NOSCRIPT],
      [tT.OBJECT, rT.OBJECT],
      [tT.OL, rT.OL],
      [tT.OPTGROUP, rT.OPTGROUP],
      [tT.OPTION, rT.OPTION],
      [tT.P, rT.P],
      [tT.PARAM, rT.PARAM],
      [tT.PLAINTEXT, rT.PLAINTEXT],
      [tT.PRE, rT.PRE],
      [tT.RB, rT.RB],
      [tT.RP, rT.RP],
      [tT.RT, rT.RT],
      [tT.RTC, rT.RTC],
      [tT.RUBY, rT.RUBY],
      [tT.S, rT.S],
      [tT.SCRIPT, rT.SCRIPT],
      [tT.SECTION, rT.SECTION],
      [tT.SELECT, rT.SELECT],
      [tT.SOURCE, rT.SOURCE],
      [tT.SMALL, rT.SMALL],
      [tT.SPAN, rT.SPAN],
      [tT.STRIKE, rT.STRIKE],
      [tT.STRONG, rT.STRONG],
      [tT.STYLE, rT.STYLE],
      [tT.SUB, rT.SUB],
      [tT.SUMMARY, rT.SUMMARY],
      [tT.SUP, rT.SUP],
      [tT.TABLE, rT.TABLE],
      [tT.TBODY, rT.TBODY],
      [tT.TEMPLATE, rT.TEMPLATE],
      [tT.TEXTAREA, rT.TEXTAREA],
      [tT.TFOOT, rT.TFOOT],
      [tT.TD, rT.TD],
      [tT.TH, rT.TH],
      [tT.THEAD, rT.THEAD],
      [tT.TITLE, rT.TITLE],
      [tT.TR, rT.TR],
      [tT.TRACK, rT.TRACK],
      [tT.TT, rT.TT],
      [tT.U, rT.U],
      [tT.UL, rT.UL],
      [tT.SVG, rT.SVG],
      [tT.VAR, rT.VAR],
      [tT.WBR, rT.WBR],
      [tT.XMP, rT.XMP],
    ])
    function uT(e) {
      var t
      return null !== (t = dT.get(e)) && void 0 !== t ? t : rT.UNKNOWN
    }
    const pT = rT,
      hT = {
        [XE.HTML]: new Set([
          pT.ADDRESS,
          pT.APPLET,
          pT.AREA,
          pT.ARTICLE,
          pT.ASIDE,
          pT.BASE,
          pT.BASEFONT,
          pT.BGSOUND,
          pT.BLOCKQUOTE,
          pT.BODY,
          pT.BR,
          pT.BUTTON,
          pT.CAPTION,
          pT.CENTER,
          pT.COL,
          pT.COLGROUP,
          pT.DD,
          pT.DETAILS,
          pT.DIR,
          pT.DIV,
          pT.DL,
          pT.DT,
          pT.EMBED,
          pT.FIELDSET,
          pT.FIGCAPTION,
          pT.FIGURE,
          pT.FOOTER,
          pT.FORM,
          pT.FRAME,
          pT.FRAMESET,
          pT.H1,
          pT.H2,
          pT.H3,
          pT.H4,
          pT.H5,
          pT.H6,
          pT.HEAD,
          pT.HEADER,
          pT.HGROUP,
          pT.HR,
          pT.HTML,
          pT.IFRAME,
          pT.IMG,
          pT.INPUT,
          pT.LI,
          pT.LINK,
          pT.LISTING,
          pT.MAIN,
          pT.MARQUEE,
          pT.MENU,
          pT.META,
          pT.NAV,
          pT.NOEMBED,
          pT.NOFRAMES,
          pT.NOSCRIPT,
          pT.OBJECT,
          pT.OL,
          pT.P,
          pT.PARAM,
          pT.PLAINTEXT,
          pT.PRE,
          pT.SCRIPT,
          pT.SECTION,
          pT.SELECT,
          pT.SOURCE,
          pT.STYLE,
          pT.SUMMARY,
          pT.TABLE,
          pT.TBODY,
          pT.TD,
          pT.TEMPLATE,
          pT.TEXTAREA,
          pT.TFOOT,
          pT.TH,
          pT.THEAD,
          pT.TITLE,
          pT.TR,
          pT.TRACK,
          pT.UL,
          pT.WBR,
          pT.XMP,
        ]),
        [XE.MATHML]: new Set([pT.MI, pT.MO, pT.MN, pT.MS, pT.MTEXT, pT.ANNOTATION_XML]),
        [XE.SVG]: new Set([pT.TITLE, pT.FOREIGN_OBJECT, pT.DESC]),
        [XE.XLINK]: new Set(),
        [XE.XML]: new Set(),
        [XE.XMLNS]: new Set(),
      }
    function fT(e) {
      return e === pT.H1 || e === pT.H2 || e === pT.H3 || e === pT.H4 || e === pT.H5 || e === pT.H6
    }
    tT.STYLE, tT.SCRIPT, tT.XMP, tT.IFRAME, tT.NOEMBED, tT.NOFRAMES, tT.PLAINTEXT
    const mT = new Map([
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
    ])
    var gT, bT
    ;((bT = gT || (gT = {}))[(bT.DATA = 0)] = "DATA"),
      (bT[(bT.RCDATA = 1)] = "RCDATA"),
      (bT[(bT.RAWTEXT = 2)] = "RAWTEXT"),
      (bT[(bT.SCRIPT_DATA = 3)] = "SCRIPT_DATA"),
      (bT[(bT.PLAINTEXT = 4)] = "PLAINTEXT"),
      (bT[(bT.TAG_OPEN = 5)] = "TAG_OPEN"),
      (bT[(bT.END_TAG_OPEN = 6)] = "END_TAG_OPEN"),
      (bT[(bT.TAG_NAME = 7)] = "TAG_NAME"),
      (bT[(bT.RCDATA_LESS_THAN_SIGN = 8)] = "RCDATA_LESS_THAN_SIGN"),
      (bT[(bT.RCDATA_END_TAG_OPEN = 9)] = "RCDATA_END_TAG_OPEN"),
      (bT[(bT.RCDATA_END_TAG_NAME = 10)] = "RCDATA_END_TAG_NAME"),
      (bT[(bT.RAWTEXT_LESS_THAN_SIGN = 11)] = "RAWTEXT_LESS_THAN_SIGN"),
      (bT[(bT.RAWTEXT_END_TAG_OPEN = 12)] = "RAWTEXT_END_TAG_OPEN"),
      (bT[(bT.RAWTEXT_END_TAG_NAME = 13)] = "RAWTEXT_END_TAG_NAME"),
      (bT[(bT.SCRIPT_DATA_LESS_THAN_SIGN = 14)] = "SCRIPT_DATA_LESS_THAN_SIGN"),
      (bT[(bT.SCRIPT_DATA_END_TAG_OPEN = 15)] = "SCRIPT_DATA_END_TAG_OPEN"),
      (bT[(bT.SCRIPT_DATA_END_TAG_NAME = 16)] = "SCRIPT_DATA_END_TAG_NAME"),
      (bT[(bT.SCRIPT_DATA_ESCAPE_START = 17)] = "SCRIPT_DATA_ESCAPE_START"),
      (bT[(bT.SCRIPT_DATA_ESCAPE_START_DASH = 18)] = "SCRIPT_DATA_ESCAPE_START_DASH"),
      (bT[(bT.SCRIPT_DATA_ESCAPED = 19)] = "SCRIPT_DATA_ESCAPED"),
      (bT[(bT.SCRIPT_DATA_ESCAPED_DASH = 20)] = "SCRIPT_DATA_ESCAPED_DASH"),
      (bT[(bT.SCRIPT_DATA_ESCAPED_DASH_DASH = 21)] = "SCRIPT_DATA_ESCAPED_DASH_DASH"),
      (bT[(bT.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22)] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"),
      (bT[(bT.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23)] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN"),
      (bT[(bT.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24)] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME"),
      (bT[(bT.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25)] = "SCRIPT_DATA_DOUBLE_ESCAPE_START"),
      (bT[(bT.SCRIPT_DATA_DOUBLE_ESCAPED = 26)] = "SCRIPT_DATA_DOUBLE_ESCAPED"),
      (bT[(bT.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27)] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH"),
      (bT[(bT.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28)] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"),
      (bT[(bT.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29)] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"),
      (bT[(bT.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30)] = "SCRIPT_DATA_DOUBLE_ESCAPE_END"),
      (bT[(bT.BEFORE_ATTRIBUTE_NAME = 31)] = "BEFORE_ATTRIBUTE_NAME"),
      (bT[(bT.ATTRIBUTE_NAME = 32)] = "ATTRIBUTE_NAME"),
      (bT[(bT.AFTER_ATTRIBUTE_NAME = 33)] = "AFTER_ATTRIBUTE_NAME"),
      (bT[(bT.BEFORE_ATTRIBUTE_VALUE = 34)] = "BEFORE_ATTRIBUTE_VALUE"),
      (bT[(bT.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35)] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED"),
      (bT[(bT.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36)] = "ATTRIBUTE_VALUE_SINGLE_QUOTED"),
      (bT[(bT.ATTRIBUTE_VALUE_UNQUOTED = 37)] = "ATTRIBUTE_VALUE_UNQUOTED"),
      (bT[(bT.AFTER_ATTRIBUTE_VALUE_QUOTED = 38)] = "AFTER_ATTRIBUTE_VALUE_QUOTED"),
      (bT[(bT.SELF_CLOSING_START_TAG = 39)] = "SELF_CLOSING_START_TAG"),
      (bT[(bT.BOGUS_COMMENT = 40)] = "BOGUS_COMMENT"),
      (bT[(bT.MARKUP_DECLARATION_OPEN = 41)] = "MARKUP_DECLARATION_OPEN"),
      (bT[(bT.COMMENT_START = 42)] = "COMMENT_START"),
      (bT[(bT.COMMENT_START_DASH = 43)] = "COMMENT_START_DASH"),
      (bT[(bT.COMMENT = 44)] = "COMMENT"),
      (bT[(bT.COMMENT_LESS_THAN_SIGN = 45)] = "COMMENT_LESS_THAN_SIGN"),
      (bT[(bT.COMMENT_LESS_THAN_SIGN_BANG = 46)] = "COMMENT_LESS_THAN_SIGN_BANG"),
      (bT[(bT.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47)] = "COMMENT_LESS_THAN_SIGN_BANG_DASH"),
      (bT[(bT.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48)] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"),
      (bT[(bT.COMMENT_END_DASH = 49)] = "COMMENT_END_DASH"),
      (bT[(bT.COMMENT_END = 50)] = "COMMENT_END"),
      (bT[(bT.COMMENT_END_BANG = 51)] = "COMMENT_END_BANG"),
      (bT[(bT.DOCTYPE = 52)] = "DOCTYPE"),
      (bT[(bT.BEFORE_DOCTYPE_NAME = 53)] = "BEFORE_DOCTYPE_NAME"),
      (bT[(bT.DOCTYPE_NAME = 54)] = "DOCTYPE_NAME"),
      (bT[(bT.AFTER_DOCTYPE_NAME = 55)] = "AFTER_DOCTYPE_NAME"),
      (bT[(bT.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56)] = "AFTER_DOCTYPE_PUBLIC_KEYWORD"),
      (bT[(bT.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57)] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"),
      (bT[(bT.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58)] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"),
      (bT[(bT.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59)] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"),
      (bT[(bT.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60)] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER"),
      (bT[(bT.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61)] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"),
      (bT[(bT.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62)] = "AFTER_DOCTYPE_SYSTEM_KEYWORD"),
      (bT[(bT.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63)] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"),
      (bT[(bT.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64)] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"),
      (bT[(bT.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65)] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"),
      (bT[(bT.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66)] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER"),
      (bT[(bT.BOGUS_DOCTYPE = 67)] = "BOGUS_DOCTYPE"),
      (bT[(bT.CDATA_SECTION = 68)] = "CDATA_SECTION"),
      (bT[(bT.CDATA_SECTION_BRACKET = 69)] = "CDATA_SECTION_BRACKET"),
      (bT[(bT.CDATA_SECTION_END = 70)] = "CDATA_SECTION_END"),
      (bT[(bT.CHARACTER_REFERENCE = 71)] = "CHARACTER_REFERENCE"),
      (bT[(bT.NAMED_CHARACTER_REFERENCE = 72)] = "NAMED_CHARACTER_REFERENCE"),
      (bT[(bT.AMBIGUOUS_AMPERSAND = 73)] = "AMBIGUOUS_AMPERSAND"),
      (bT[(bT.NUMERIC_CHARACTER_REFERENCE = 74)] = "NUMERIC_CHARACTER_REFERENCE"),
      (bT[(bT.HEXADEMICAL_CHARACTER_REFERENCE_START = 75)] = "HEXADEMICAL_CHARACTER_REFERENCE_START"),
      (bT[(bT.HEXADEMICAL_CHARACTER_REFERENCE = 76)] = "HEXADEMICAL_CHARACTER_REFERENCE"),
      (bT[(bT.DECIMAL_CHARACTER_REFERENCE = 77)] = "DECIMAL_CHARACTER_REFERENCE"),
      (bT[(bT.NUMERIC_CHARACTER_REFERENCE_END = 78)] = "NUMERIC_CHARACTER_REFERENCE_END")
    const vT = {
      DATA: gT.DATA,
      RCDATA: gT.RCDATA,
      RAWTEXT: gT.RAWTEXT,
      SCRIPT_DATA: gT.SCRIPT_DATA,
      PLAINTEXT: gT.PLAINTEXT,
      CDATA_SECTION: gT.CDATA_SECTION,
    }
    function yT(e) {
      return e >= xE.DIGIT_0 && e <= xE.DIGIT_9
    }
    function OT(e) {
      return e >= xE.LATIN_CAPITAL_A && e <= xE.LATIN_CAPITAL_Z
    }
    function wT(e) {
      return (
        (function (e) {
          return e >= xE.LATIN_SMALL_A && e <= xE.LATIN_SMALL_Z
        })(e) || OT(e)
      )
    }
    function xT(e) {
      return wT(e) || yT(e)
    }
    function kT(e) {
      return e >= xE.LATIN_CAPITAL_A && e <= xE.LATIN_CAPITAL_F
    }
    function _T(e) {
      return e >= xE.LATIN_SMALL_A && e <= xE.LATIN_SMALL_F
    }
    function ST(e) {
      return e + 32
    }
    function ET(e) {
      return e === xE.SPACE || e === xE.LINE_FEED || e === xE.TABULATION || e === xE.FORM_FEED
    }
    function TT(e) {
      return ET(e) || e === xE.SOLIDUS || e === xE.GREATER_THAN_SIGN
    }
    class AT {
      constructor(e, t) {
        ;(this.options = e),
          (this.handler = t),
          (this.paused = !1),
          (this.inLoop = !1),
          (this.inForeignNode = !1),
          (this.lastStartTagName = ""),
          (this.active = !1),
          (this.state = gT.DATA),
          (this.returnState = gT.DATA),
          (this.charRefCode = -1),
          (this.consumedAfterSnapshot = -1),
          (this.currentCharacterToken = null),
          (this.currentToken = null),
          (this.currentAttr = { name: "", value: "" }),
          (this.preprocessor = new $E(t)),
          (this.currentLocation = this.getCurrentLocation(-1))
      }
      _err(e) {
        var t, n
        null === (n = (t = this.handler).onParseError) || void 0 === n || n.call(t, this.preprocessor.getError(e))
      }
      getCurrentLocation(e) {
        return this.options.sourceCodeLocationInfo
          ? {
              startLine: this.preprocessor.line,
              startCol: this.preprocessor.col - e,
              startOffset: this.preprocessor.offset - e,
              endLine: -1,
              endCol: -1,
              endOffset: -1,
            }
          : null
      }
      _runParsingLoop() {
        if (!this.inLoop) {
          for (this.inLoop = !0; this.active && !this.paused; ) {
            this.consumedAfterSnapshot = 0
            const e = this._consume()
            this._ensureHibernation() || this._callState(e)
          }
          this.inLoop = !1
        }
      }
      pause() {
        this.paused = !0
      }
      resume(e) {
        if (!this.paused) throw new Error("Parser was already resumed")
        ;(this.paused = !1), this.inLoop || (this._runParsingLoop(), this.paused || null == e || e())
      }
      write(e, t, n) {
        ;(this.active = !0), this.preprocessor.write(e, t), this._runParsingLoop(), this.paused || null == n || n()
      }
      insertHtmlAtCurrentPos(e) {
        ;(this.active = !0), this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop()
      }
      _ensureHibernation() {
        return (
          !!this.preprocessor.endOfChunkHit && (this._unconsume(this.consumedAfterSnapshot), (this.active = !1), !0)
        )
      }
      _consume() {
        return this.consumedAfterSnapshot++, this.preprocessor.advance()
      }
      _unconsume(e) {
        ;(this.consumedAfterSnapshot -= e), this.preprocessor.retreat(e)
      }
      _reconsumeInState(e, t) {
        ;(this.state = e), this._callState(t)
      }
      _advanceBy(e) {
        this.consumedAfterSnapshot += e
        for (let t = 0; t < e; t++) this.preprocessor.advance()
      }
      _consumeSequenceIfMatch(e, t) {
        return !!this.preprocessor.startsWith(e, t) && (this._advanceBy(e.length - 1), !0)
      }
      _createStartTagToken() {
        this.currentToken = {
          type: RE.START_TAG,
          tagName: "",
          tagID: rT.UNKNOWN,
          selfClosing: !1,
          ackSelfClosing: !1,
          attrs: [],
          location: this.getCurrentLocation(1),
        }
      }
      _createEndTagToken() {
        this.currentToken = {
          type: RE.END_TAG,
          tagName: "",
          tagID: rT.UNKNOWN,
          selfClosing: !1,
          ackSelfClosing: !1,
          attrs: [],
          location: this.getCurrentLocation(2),
        }
      }
      _createCommentToken(e) {
        this.currentToken = { type: RE.COMMENT, data: "", location: this.getCurrentLocation(e) }
      }
      _createDoctypeToken(e) {
        this.currentToken = {
          type: RE.DOCTYPE,
          name: e,
          forceQuirks: !1,
          publicId: null,
          systemId: null,
          location: this.currentLocation,
        }
      }
      _createCharacterToken(e, t) {
        this.currentCharacterToken = { type: e, chars: t, location: this.currentLocation }
      }
      _createAttr(e) {
        ;(this.currentAttr = { name: e, value: "" }), (this.currentLocation = this.getCurrentLocation(0))
      }
      _leaveAttrName() {
        var e, t
        const n = this.currentToken
        null === IE(n, this.currentAttr.name)
          ? (n.attrs.push(this.currentAttr),
            n.location &&
              this.currentLocation &&
              (((null !== (e = (t = n.location).attrs) && void 0 !== e ? e : (t.attrs = Object.create(null)))[
                this.currentAttr.name
              ] = this.currentLocation),
              this._leaveAttrValue()))
          : this._err(PE.duplicateAttribute)
      }
      _leaveAttrValue() {
        this.currentLocation &&
          ((this.currentLocation.endLine = this.preprocessor.line),
          (this.currentLocation.endCol = this.preprocessor.col),
          (this.currentLocation.endOffset = this.preprocessor.offset))
      }
      prepareToken(e) {
        this._emitCurrentCharacterToken(e.location),
          (this.currentToken = null),
          e.location &&
            ((e.location.endLine = this.preprocessor.line),
            (e.location.endCol = this.preprocessor.col + 1),
            (e.location.endOffset = this.preprocessor.offset + 1)),
          (this.currentLocation = this.getCurrentLocation(-1))
      }
      emitCurrentTagToken() {
        const e = this.currentToken
        this.prepareToken(e),
          (e.tagID = uT(e.tagName)),
          e.type === RE.START_TAG
            ? ((this.lastStartTagName = e.tagName), this.handler.onStartTag(e))
            : (e.attrs.length > 0 && this._err(PE.endTagWithAttributes),
              e.selfClosing && this._err(PE.endTagWithTrailingSolidus),
              this.handler.onEndTag(e)),
          this.preprocessor.dropParsedChunk()
      }
      emitCurrentComment(e) {
        this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk()
      }
      emitCurrentDoctype(e) {
        this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk()
      }
      _emitCurrentCharacterToken(e) {
        if (this.currentCharacterToken) {
          switch (
            (e &&
              this.currentCharacterToken.location &&
              ((this.currentCharacterToken.location.endLine = e.startLine),
              (this.currentCharacterToken.location.endCol = e.startCol),
              (this.currentCharacterToken.location.endOffset = e.startOffset)),
            this.currentCharacterToken.type)
          ) {
            case RE.CHARACTER:
              this.handler.onCharacter(this.currentCharacterToken)
              break
            case RE.NULL_CHARACTER:
              this.handler.onNullCharacter(this.currentCharacterToken)
              break
            case RE.WHITESPACE_CHARACTER:
              this.handler.onWhitespaceCharacter(this.currentCharacterToken)
          }
          this.currentCharacterToken = null
        }
      }
      _emitEOFToken() {
        const e = this.getCurrentLocation(0)
        e && ((e.endLine = e.startLine), (e.endCol = e.startCol), (e.endOffset = e.startOffset)),
          this._emitCurrentCharacterToken(e),
          this.handler.onEof({ type: RE.EOF, location: e }),
          (this.active = !1)
      }
      _appendCharToCurrentCharacterToken(e, t) {
        if (this.currentCharacterToken) {
          if (this.currentCharacterToken.type === e) return void (this.currentCharacterToken.chars += t)
          ;(this.currentLocation = this.getCurrentLocation(0)),
            this._emitCurrentCharacterToken(this.currentLocation),
            this.preprocessor.dropParsedChunk()
        }
        this._createCharacterToken(e, t)
      }
      _emitCodePoint(e) {
        const t = ET(e) ? RE.WHITESPACE_CHARACTER : e === xE.NULL ? RE.NULL_CHARACTER : RE.CHARACTER
        this._appendCharToCurrentCharacterToken(t, String.fromCodePoint(e))
      }
      _emitChars(e) {
        this._appendCharToCurrentCharacterToken(RE.CHARACTER, e)
      }
      _matchNamedCharacterReference(e) {
        let t = null,
          n = 0,
          r = !1
        for (let o = 0, i = ME[0]; o >= 0 && ((o = cT(ME, i, o + 1, e)), !(o < 0)); e = this._consume()) {
          ;(n += 1), (i = ME[o])
          const s = i & zE.VALUE_LENGTH
          if (s) {
            const i = (s >> 14) - 1
            if (
              (e !== xE.SEMICOLON &&
              this._isCharacterReferenceInAttribute() &&
              ((a = this.preprocessor.peek(1)) === xE.EQUALS_SIGN || xT(a))
                ? ((t = [xE.AMPERSAND]), (o += i))
                : ((t = 0 === i ? [ME[o] & ~zE.VALUE_LENGTH] : 1 === i ? [ME[++o]] : [ME[++o], ME[++o]]),
                  (n = 0),
                  (r = e !== xE.SEMICOLON)),
              0 === i)
            ) {
              this._consume()
              break
            }
          }
        }
        var a
        return (
          this._unconsume(n),
          r && !this.preprocessor.endOfChunkHit && this._err(PE.missingSemicolonAfterCharacterReference),
          this._unconsume(1),
          t
        )
      }
      _isCharacterReferenceInAttribute() {
        return (
          this.returnState === gT.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
          this.returnState === gT.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
          this.returnState === gT.ATTRIBUTE_VALUE_UNQUOTED
        )
      }
      _flushCodePointConsumedAsCharacterReference(e) {
        this._isCharacterReferenceInAttribute()
          ? (this.currentAttr.value += String.fromCodePoint(e))
          : this._emitCodePoint(e)
      }
      _callState(e) {
        switch (this.state) {
          case gT.DATA:
            this._stateData(e)
            break
          case gT.RCDATA:
            this._stateRcdata(e)
            break
          case gT.RAWTEXT:
            this._stateRawtext(e)
            break
          case gT.SCRIPT_DATA:
            this._stateScriptData(e)
            break
          case gT.PLAINTEXT:
            this._statePlaintext(e)
            break
          case gT.TAG_OPEN:
            this._stateTagOpen(e)
            break
          case gT.END_TAG_OPEN:
            this._stateEndTagOpen(e)
            break
          case gT.TAG_NAME:
            this._stateTagName(e)
            break
          case gT.RCDATA_LESS_THAN_SIGN:
            this._stateRcdataLessThanSign(e)
            break
          case gT.RCDATA_END_TAG_OPEN:
            this._stateRcdataEndTagOpen(e)
            break
          case gT.RCDATA_END_TAG_NAME:
            this._stateRcdataEndTagName(e)
            break
          case gT.RAWTEXT_LESS_THAN_SIGN:
            this._stateRawtextLessThanSign(e)
            break
          case gT.RAWTEXT_END_TAG_OPEN:
            this._stateRawtextEndTagOpen(e)
            break
          case gT.RAWTEXT_END_TAG_NAME:
            this._stateRawtextEndTagName(e)
            break
          case gT.SCRIPT_DATA_LESS_THAN_SIGN:
            this._stateScriptDataLessThanSign(e)
            break
          case gT.SCRIPT_DATA_END_TAG_OPEN:
            this._stateScriptDataEndTagOpen(e)
            break
          case gT.SCRIPT_DATA_END_TAG_NAME:
            this._stateScriptDataEndTagName(e)
            break
          case gT.SCRIPT_DATA_ESCAPE_START:
            this._stateScriptDataEscapeStart(e)
            break
          case gT.SCRIPT_DATA_ESCAPE_START_DASH:
            this._stateScriptDataEscapeStartDash(e)
            break
          case gT.SCRIPT_DATA_ESCAPED:
            this._stateScriptDataEscaped(e)
            break
          case gT.SCRIPT_DATA_ESCAPED_DASH:
            this._stateScriptDataEscapedDash(e)
            break
          case gT.SCRIPT_DATA_ESCAPED_DASH_DASH:
            this._stateScriptDataEscapedDashDash(e)
            break
          case gT.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
            this._stateScriptDataEscapedLessThanSign(e)
            break
          case gT.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:
            this._stateScriptDataEscapedEndTagOpen(e)
            break
          case gT.SCRIPT_DATA_ESCAPED_END_TAG_NAME:
            this._stateScriptDataEscapedEndTagName(e)
            break
          case gT.SCRIPT_DATA_DOUBLE_ESCAPE_START:
            this._stateScriptDataDoubleEscapeStart(e)
            break
          case gT.SCRIPT_DATA_DOUBLE_ESCAPED:
            this._stateScriptDataDoubleEscaped(e)
            break
          case gT.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:
            this._stateScriptDataDoubleEscapedDash(e)
            break
          case gT.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:
            this._stateScriptDataDoubleEscapedDashDash(e)
            break
          case gT.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:
            this._stateScriptDataDoubleEscapedLessThanSign(e)
            break
          case gT.SCRIPT_DATA_DOUBLE_ESCAPE_END:
            this._stateScriptDataDoubleEscapeEnd(e)
            break
          case gT.BEFORE_ATTRIBUTE_NAME:
            this._stateBeforeAttributeName(e)
            break
          case gT.ATTRIBUTE_NAME:
            this._stateAttributeName(e)
            break
          case gT.AFTER_ATTRIBUTE_NAME:
            this._stateAfterAttributeName(e)
            break
          case gT.BEFORE_ATTRIBUTE_VALUE:
            this._stateBeforeAttributeValue(e)
            break
          case gT.ATTRIBUTE_VALUE_DOUBLE_QUOTED:
            this._stateAttributeValueDoubleQuoted(e)
            break
          case gT.ATTRIBUTE_VALUE_SINGLE_QUOTED:
            this._stateAttributeValueSingleQuoted(e)
            break
          case gT.ATTRIBUTE_VALUE_UNQUOTED:
            this._stateAttributeValueUnquoted(e)
            break
          case gT.AFTER_ATTRIBUTE_VALUE_QUOTED:
            this._stateAfterAttributeValueQuoted(e)
            break
          case gT.SELF_CLOSING_START_TAG:
            this._stateSelfClosingStartTag(e)
            break
          case gT.BOGUS_COMMENT:
            this._stateBogusComment(e)
            break
          case gT.MARKUP_DECLARATION_OPEN:
            this._stateMarkupDeclarationOpen(e)
            break
          case gT.COMMENT_START:
            this._stateCommentStart(e)
            break
          case gT.COMMENT_START_DASH:
            this._stateCommentStartDash(e)
            break
          case gT.COMMENT:
            this._stateComment(e)
            break
          case gT.COMMENT_LESS_THAN_SIGN:
            this._stateCommentLessThanSign(e)
            break
          case gT.COMMENT_LESS_THAN_SIGN_BANG:
            this._stateCommentLessThanSignBang(e)
            break
          case gT.COMMENT_LESS_THAN_SIGN_BANG_DASH:
            this._stateCommentLessThanSignBangDash(e)
            break
          case gT.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:
            this._stateCommentLessThanSignBangDashDash(e)
            break
          case gT.COMMENT_END_DASH:
            this._stateCommentEndDash(e)
            break
          case gT.COMMENT_END:
            this._stateCommentEnd(e)
            break
          case gT.COMMENT_END_BANG:
            this._stateCommentEndBang(e)
            break
          case gT.DOCTYPE:
            this._stateDoctype(e)
            break
          case gT.BEFORE_DOCTYPE_NAME:
            this._stateBeforeDoctypeName(e)
            break
          case gT.DOCTYPE_NAME:
            this._stateDoctypeName(e)
            break
          case gT.AFTER_DOCTYPE_NAME:
            this._stateAfterDoctypeName(e)
            break
          case gT.AFTER_DOCTYPE_PUBLIC_KEYWORD:
            this._stateAfterDoctypePublicKeyword(e)
            break
          case gT.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
            this._stateBeforeDoctypePublicIdentifier(e)
            break
          case gT.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
            this._stateDoctypePublicIdentifierDoubleQuoted(e)
            break
          case gT.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
            this._stateDoctypePublicIdentifierSingleQuoted(e)
            break
          case gT.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
            this._stateAfterDoctypePublicIdentifier(e)
            break
          case gT.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
            this._stateBetweenDoctypePublicAndSystemIdentifiers(e)
            break
          case gT.AFTER_DOCTYPE_SYSTEM_KEYWORD:
            this._stateAfterDoctypeSystemKeyword(e)
            break
          case gT.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
            this._stateBeforeDoctypeSystemIdentifier(e)
            break
          case gT.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
            this._stateDoctypeSystemIdentifierDoubleQuoted(e)
            break
          case gT.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
            this._stateDoctypeSystemIdentifierSingleQuoted(e)
            break
          case gT.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
            this._stateAfterDoctypeSystemIdentifier(e)
            break
          case gT.BOGUS_DOCTYPE:
            this._stateBogusDoctype(e)
            break
          case gT.CDATA_SECTION:
            this._stateCdataSection(e)
            break
          case gT.CDATA_SECTION_BRACKET:
            this._stateCdataSectionBracket(e)
            break
          case gT.CDATA_SECTION_END:
            this._stateCdataSectionEnd(e)
            break
          case gT.CHARACTER_REFERENCE:
            this._stateCharacterReference(e)
            break
          case gT.NAMED_CHARACTER_REFERENCE:
            this._stateNamedCharacterReference(e)
            break
          case gT.AMBIGUOUS_AMPERSAND:
            this._stateAmbiguousAmpersand(e)
            break
          case gT.NUMERIC_CHARACTER_REFERENCE:
            this._stateNumericCharacterReference(e)
            break
          case gT.HEXADEMICAL_CHARACTER_REFERENCE_START:
            this._stateHexademicalCharacterReferenceStart(e)
            break
          case gT.HEXADEMICAL_CHARACTER_REFERENCE:
            this._stateHexademicalCharacterReference(e)
            break
          case gT.DECIMAL_CHARACTER_REFERENCE:
            this._stateDecimalCharacterReference(e)
            break
          case gT.NUMERIC_CHARACTER_REFERENCE_END:
            this._stateNumericCharacterReferenceEnd(e)
            break
          default:
            throw new Error("Unknown state")
        }
      }
      _stateData(e) {
        switch (e) {
          case xE.LESS_THAN_SIGN:
            this.state = gT.TAG_OPEN
            break
          case xE.AMPERSAND:
            ;(this.returnState = gT.DATA), (this.state = gT.CHARACTER_REFERENCE)
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitCodePoint(e)
            break
          case xE.EOF:
            this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateRcdata(e) {
        switch (e) {
          case xE.AMPERSAND:
            ;(this.returnState = gT.RCDATA), (this.state = gT.CHARACTER_REFERENCE)
            break
          case xE.LESS_THAN_SIGN:
            this.state = gT.RCDATA_LESS_THAN_SIGN
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitChars(wE)
            break
          case xE.EOF:
            this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateRawtext(e) {
        switch (e) {
          case xE.LESS_THAN_SIGN:
            this.state = gT.RAWTEXT_LESS_THAN_SIGN
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitChars(wE)
            break
          case xE.EOF:
            this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateScriptData(e) {
        switch (e) {
          case xE.LESS_THAN_SIGN:
            this.state = gT.SCRIPT_DATA_LESS_THAN_SIGN
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitChars(wE)
            break
          case xE.EOF:
            this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _statePlaintext(e) {
        switch (e) {
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitChars(wE)
            break
          case xE.EOF:
            this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateTagOpen(e) {
        if (wT(e)) this._createStartTagToken(), (this.state = gT.TAG_NAME), this._stateTagName(e)
        else
          switch (e) {
            case xE.EXCLAMATION_MARK:
              this.state = gT.MARKUP_DECLARATION_OPEN
              break
            case xE.SOLIDUS:
              this.state = gT.END_TAG_OPEN
              break
            case xE.QUESTION_MARK:
              this._err(PE.unexpectedQuestionMarkInsteadOfTagName),
                this._createCommentToken(1),
                (this.state = gT.BOGUS_COMMENT),
                this._stateBogusComment(e)
              break
            case xE.EOF:
              this._err(PE.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken()
              break
            default:
              this._err(PE.invalidFirstCharacterOfTagName),
                this._emitChars("<"),
                (this.state = gT.DATA),
                this._stateData(e)
          }
      }
      _stateEndTagOpen(e) {
        if (wT(e)) this._createEndTagToken(), (this.state = gT.TAG_NAME), this._stateTagName(e)
        else
          switch (e) {
            case xE.GREATER_THAN_SIGN:
              this._err(PE.missingEndTagName), (this.state = gT.DATA)
              break
            case xE.EOF:
              this._err(PE.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken()
              break
            default:
              this._err(PE.invalidFirstCharacterOfTagName),
                this._createCommentToken(2),
                (this.state = gT.BOGUS_COMMENT),
                this._stateBogusComment(e)
          }
      }
      _stateTagName(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this.state = gT.BEFORE_ATTRIBUTE_NAME
            break
          case xE.SOLIDUS:
            this.state = gT.SELF_CLOSING_START_TAG
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentTagToken()
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.tagName += wE)
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            t.tagName += String.fromCodePoint(OT(e) ? ST(e) : e)
        }
      }
      _stateRcdataLessThanSign(e) {
        e === xE.SOLIDUS
          ? (this.state = gT.RCDATA_END_TAG_OPEN)
          : (this._emitChars("<"), (this.state = gT.RCDATA), this._stateRcdata(e))
      }
      _stateRcdataEndTagOpen(e) {
        wT(e)
          ? ((this.state = gT.RCDATA_END_TAG_NAME), this._stateRcdataEndTagName(e))
          : (this._emitChars("</"), (this.state = gT.RCDATA), this._stateRcdata(e))
      }
      handleSpecialEndTag(e) {
        if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation()
        switch (
          (this._createEndTagToken(),
          (this.currentToken.tagName = this.lastStartTagName),
          this.preprocessor.peek(this.lastStartTagName.length))
        ) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            return this._advanceBy(this.lastStartTagName.length), (this.state = gT.BEFORE_ATTRIBUTE_NAME), !1
          case xE.SOLIDUS:
            return this._advanceBy(this.lastStartTagName.length), (this.state = gT.SELF_CLOSING_START_TAG), !1
          case xE.GREATER_THAN_SIGN:
            return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), (this.state = gT.DATA), !1
          default:
            return !this._ensureHibernation()
        }
      }
      _stateRcdataEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"), (this.state = gT.RCDATA), this._stateRcdata(e))
      }
      _stateRawtextLessThanSign(e) {
        e === xE.SOLIDUS
          ? (this.state = gT.RAWTEXT_END_TAG_OPEN)
          : (this._emitChars("<"), (this.state = gT.RAWTEXT), this._stateRawtext(e))
      }
      _stateRawtextEndTagOpen(e) {
        wT(e)
          ? ((this.state = gT.RAWTEXT_END_TAG_NAME), this._stateRawtextEndTagName(e))
          : (this._emitChars("</"), (this.state = gT.RAWTEXT), this._stateRawtext(e))
      }
      _stateRawtextEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"), (this.state = gT.RAWTEXT), this._stateRawtext(e))
      }
      _stateScriptDataLessThanSign(e) {
        switch (e) {
          case xE.SOLIDUS:
            this.state = gT.SCRIPT_DATA_END_TAG_OPEN
            break
          case xE.EXCLAMATION_MARK:
            ;(this.state = gT.SCRIPT_DATA_ESCAPE_START), this._emitChars("<!")
            break
          default:
            this._emitChars("<"), (this.state = gT.SCRIPT_DATA), this._stateScriptData(e)
        }
      }
      _stateScriptDataEndTagOpen(e) {
        wT(e)
          ? ((this.state = gT.SCRIPT_DATA_END_TAG_NAME), this._stateScriptDataEndTagName(e))
          : (this._emitChars("</"), (this.state = gT.SCRIPT_DATA), this._stateScriptData(e))
      }
      _stateScriptDataEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"), (this.state = gT.SCRIPT_DATA), this._stateScriptData(e))
      }
      _stateScriptDataEscapeStart(e) {
        e === xE.HYPHEN_MINUS
          ? ((this.state = gT.SCRIPT_DATA_ESCAPE_START_DASH), this._emitChars("-"))
          : ((this.state = gT.SCRIPT_DATA), this._stateScriptData(e))
      }
      _stateScriptDataEscapeStartDash(e) {
        e === xE.HYPHEN_MINUS
          ? ((this.state = gT.SCRIPT_DATA_ESCAPED_DASH_DASH), this._emitChars("-"))
          : ((this.state = gT.SCRIPT_DATA), this._stateScriptData(e))
      }
      _stateScriptDataEscaped(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            ;(this.state = gT.SCRIPT_DATA_ESCAPED_DASH), this._emitChars("-")
            break
          case xE.LESS_THAN_SIGN:
            this.state = gT.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitChars(wE)
            break
          case xE.EOF:
            this._err(PE.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateScriptDataEscapedDash(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            ;(this.state = gT.SCRIPT_DATA_ESCAPED_DASH_DASH), this._emitChars("-")
            break
          case xE.LESS_THAN_SIGN:
            this.state = gT.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.state = gT.SCRIPT_DATA_ESCAPED), this._emitChars(wE)
            break
          case xE.EOF:
            this._err(PE.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
            break
          default:
            ;(this.state = gT.SCRIPT_DATA_ESCAPED), this._emitCodePoint(e)
        }
      }
      _stateScriptDataEscapedDashDash(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            this._emitChars("-")
            break
          case xE.LESS_THAN_SIGN:
            this.state = gT.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.SCRIPT_DATA), this._emitChars(">")
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.state = gT.SCRIPT_DATA_ESCAPED), this._emitChars(wE)
            break
          case xE.EOF:
            this._err(PE.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
            break
          default:
            ;(this.state = gT.SCRIPT_DATA_ESCAPED), this._emitCodePoint(e)
        }
      }
      _stateScriptDataEscapedLessThanSign(e) {
        e === xE.SOLIDUS
          ? (this.state = gT.SCRIPT_DATA_ESCAPED_END_TAG_OPEN)
          : wT(e)
            ? (this._emitChars("<"),
              (this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPE_START),
              this._stateScriptDataDoubleEscapeStart(e))
            : (this._emitChars("<"), (this.state = gT.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(e))
      }
      _stateScriptDataEscapedEndTagOpen(e) {
        wT(e)
          ? ((this.state = gT.SCRIPT_DATA_ESCAPED_END_TAG_NAME), this._stateScriptDataEscapedEndTagName(e))
          : (this._emitChars("</"), (this.state = gT.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(e))
      }
      _stateScriptDataEscapedEndTagName(e) {
        this.handleSpecialEndTag(e) &&
          (this._emitChars("</"), (this.state = gT.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(e))
      }
      _stateScriptDataDoubleEscapeStart(e) {
        if (this.preprocessor.startsWith(EE, !1) && TT(this.preprocessor.peek(6))) {
          this._emitCodePoint(e)
          for (let e = 0; e < 6; e++) this._emitCodePoint(this._consume())
          this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED
        } else this._ensureHibernation() || ((this.state = gT.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(e))
      }
      _stateScriptDataDoubleEscaped(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED_DASH), this._emitChars("-")
            break
          case xE.LESS_THAN_SIGN:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars("<")
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), this._emitChars(wE)
            break
          case xE.EOF:
            this._err(PE.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateScriptDataDoubleEscapedDash(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH), this._emitChars("-")
            break
          case xE.LESS_THAN_SIGN:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars("<")
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitChars(wE)
            break
          case xE.EOF:
            this._err(PE.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
            break
          default:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitCodePoint(e)
        }
      }
      _stateScriptDataDoubleEscapedDashDash(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            this._emitChars("-")
            break
          case xE.LESS_THAN_SIGN:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars("<")
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.SCRIPT_DATA), this._emitChars(">")
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitChars(wE)
            break
          case xE.EOF:
            this._err(PE.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
            break
          default:
            ;(this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitCodePoint(e)
        }
      }
      _stateScriptDataDoubleEscapedLessThanSign(e) {
        e === xE.SOLIDUS
          ? ((this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPE_END), this._emitChars("/"))
          : ((this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED), this._stateScriptDataDoubleEscaped(e))
      }
      _stateScriptDataDoubleEscapeEnd(e) {
        if (this.preprocessor.startsWith(EE, !1) && TT(this.preprocessor.peek(6))) {
          this._emitCodePoint(e)
          for (let e = 0; e < 6; e++) this._emitCodePoint(this._consume())
          this.state = gT.SCRIPT_DATA_ESCAPED
        } else
          this._ensureHibernation() ||
            ((this.state = gT.SCRIPT_DATA_DOUBLE_ESCAPED), this._stateScriptDataDoubleEscaped(e))
      }
      _stateBeforeAttributeName(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.SOLIDUS:
          case xE.GREATER_THAN_SIGN:
          case xE.EOF:
            ;(this.state = gT.AFTER_ATTRIBUTE_NAME), this._stateAfterAttributeName(e)
            break
          case xE.EQUALS_SIGN:
            this._err(PE.unexpectedEqualsSignBeforeAttributeName),
              this._createAttr("="),
              (this.state = gT.ATTRIBUTE_NAME)
            break
          default:
            this._createAttr(""), (this.state = gT.ATTRIBUTE_NAME), this._stateAttributeName(e)
        }
      }
      _stateAttributeName(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
          case xE.SOLIDUS:
          case xE.GREATER_THAN_SIGN:
          case xE.EOF:
            this._leaveAttrName(), (this.state = gT.AFTER_ATTRIBUTE_NAME), this._stateAfterAttributeName(e)
            break
          case xE.EQUALS_SIGN:
            this._leaveAttrName(), (this.state = gT.BEFORE_ATTRIBUTE_VALUE)
            break
          case xE.QUOTATION_MARK:
          case xE.APOSTROPHE:
          case xE.LESS_THAN_SIGN:
            this._err(PE.unexpectedCharacterInAttributeName), (this.currentAttr.name += String.fromCodePoint(e))
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.currentAttr.name += wE)
            break
          default:
            this.currentAttr.name += String.fromCodePoint(OT(e) ? ST(e) : e)
        }
      }
      _stateAfterAttributeName(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.SOLIDUS:
            this.state = gT.SELF_CLOSING_START_TAG
            break
          case xE.EQUALS_SIGN:
            this.state = gT.BEFORE_ATTRIBUTE_VALUE
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentTagToken()
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            this._createAttr(""), (this.state = gT.ATTRIBUTE_NAME), this._stateAttributeName(e)
        }
      }
      _stateBeforeAttributeValue(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.QUOTATION_MARK:
            this.state = gT.ATTRIBUTE_VALUE_DOUBLE_QUOTED
            break
          case xE.APOSTROPHE:
            this.state = gT.ATTRIBUTE_VALUE_SINGLE_QUOTED
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.missingAttributeValue), (this.state = gT.DATA), this.emitCurrentTagToken()
            break
          default:
            ;(this.state = gT.ATTRIBUTE_VALUE_UNQUOTED), this._stateAttributeValueUnquoted(e)
        }
      }
      _stateAttributeValueDoubleQuoted(e) {
        switch (e) {
          case xE.QUOTATION_MARK:
            this.state = gT.AFTER_ATTRIBUTE_VALUE_QUOTED
            break
          case xE.AMPERSAND:
            ;(this.returnState = gT.ATTRIBUTE_VALUE_DOUBLE_QUOTED), (this.state = gT.CHARACTER_REFERENCE)
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.currentAttr.value += wE)
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            this.currentAttr.value += String.fromCodePoint(e)
        }
      }
      _stateAttributeValueSingleQuoted(e) {
        switch (e) {
          case xE.APOSTROPHE:
            this.state = gT.AFTER_ATTRIBUTE_VALUE_QUOTED
            break
          case xE.AMPERSAND:
            ;(this.returnState = gT.ATTRIBUTE_VALUE_SINGLE_QUOTED), (this.state = gT.CHARACTER_REFERENCE)
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.currentAttr.value += wE)
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            this.currentAttr.value += String.fromCodePoint(e)
        }
      }
      _stateAttributeValueUnquoted(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this._leaveAttrValue(), (this.state = gT.BEFORE_ATTRIBUTE_NAME)
            break
          case xE.AMPERSAND:
            ;(this.returnState = gT.ATTRIBUTE_VALUE_UNQUOTED), (this.state = gT.CHARACTER_REFERENCE)
            break
          case xE.GREATER_THAN_SIGN:
            this._leaveAttrValue(), (this.state = gT.DATA), this.emitCurrentTagToken()
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (this.currentAttr.value += wE)
            break
          case xE.QUOTATION_MARK:
          case xE.APOSTROPHE:
          case xE.LESS_THAN_SIGN:
          case xE.EQUALS_SIGN:
          case xE.GRAVE_ACCENT:
            this._err(PE.unexpectedCharacterInUnquotedAttributeValue),
              (this.currentAttr.value += String.fromCodePoint(e))
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            this.currentAttr.value += String.fromCodePoint(e)
        }
      }
      _stateAfterAttributeValueQuoted(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this._leaveAttrValue(), (this.state = gT.BEFORE_ATTRIBUTE_NAME)
            break
          case xE.SOLIDUS:
            this._leaveAttrValue(), (this.state = gT.SELF_CLOSING_START_TAG)
            break
          case xE.GREATER_THAN_SIGN:
            this._leaveAttrValue(), (this.state = gT.DATA), this.emitCurrentTagToken()
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            this._err(PE.missingWhitespaceBetweenAttributes),
              (this.state = gT.BEFORE_ATTRIBUTE_NAME),
              this._stateBeforeAttributeName(e)
        }
      }
      _stateSelfClosingStartTag(e) {
        switch (e) {
          case xE.GREATER_THAN_SIGN:
            ;(this.currentToken.selfClosing = !0), (this.state = gT.DATA), this.emitCurrentTagToken()
            break
          case xE.EOF:
            this._err(PE.eofInTag), this._emitEOFToken()
            break
          default:
            this._err(PE.unexpectedSolidusInTag),
              (this.state = gT.BEFORE_ATTRIBUTE_NAME),
              this._stateBeforeAttributeName(e)
        }
      }
      _stateBogusComment(e) {
        const t = this.currentToken
        switch (e) {
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentComment(t)
            break
          case xE.EOF:
            this.emitCurrentComment(t), this._emitEOFToken()
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.data += wE)
            break
          default:
            t.data += String.fromCodePoint(e)
        }
      }
      _stateMarkupDeclarationOpen(e) {
        this._consumeSequenceIfMatch("--", !0)
          ? (this._createCommentToken(3), (this.state = gT.COMMENT_START))
          : this._consumeSequenceIfMatch(SE, !1)
            ? ((this.currentLocation = this.getCurrentLocation(8)), (this.state = gT.DOCTYPE))
            : this._consumeSequenceIfMatch(_E, !0)
              ? this.inForeignNode
                ? (this.state = gT.CDATA_SECTION)
                : (this._err(PE.cdataInHtmlContent),
                  this._createCommentToken(8),
                  (this.currentToken.data = "[CDATA["),
                  (this.state = gT.BOGUS_COMMENT))
              : this._ensureHibernation() ||
                (this._err(PE.incorrectlyOpenedComment),
                this._createCommentToken(2),
                (this.state = gT.BOGUS_COMMENT),
                this._stateBogusComment(e))
      }
      _stateCommentStart(e) {
        switch (e) {
          case xE.HYPHEN_MINUS:
            this.state = gT.COMMENT_START_DASH
            break
          case xE.GREATER_THAN_SIGN: {
            this._err(PE.abruptClosingOfEmptyComment), (this.state = gT.DATA)
            const e = this.currentToken
            this.emitCurrentComment(e)
            break
          }
          default:
            ;(this.state = gT.COMMENT), this._stateComment(e)
        }
      }
      _stateCommentStartDash(e) {
        const t = this.currentToken
        switch (e) {
          case xE.HYPHEN_MINUS:
            this.state = gT.COMMENT_END
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.abruptClosingOfEmptyComment), (this.state = gT.DATA), this.emitCurrentComment(t)
            break
          case xE.EOF:
            this._err(PE.eofInComment), this.emitCurrentComment(t), this._emitEOFToken()
            break
          default:
            ;(t.data += "-"), (this.state = gT.COMMENT), this._stateComment(e)
        }
      }
      _stateComment(e) {
        const t = this.currentToken
        switch (e) {
          case xE.HYPHEN_MINUS:
            this.state = gT.COMMENT_END_DASH
            break
          case xE.LESS_THAN_SIGN:
            ;(t.data += "<"), (this.state = gT.COMMENT_LESS_THAN_SIGN)
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.data += wE)
            break
          case xE.EOF:
            this._err(PE.eofInComment), this.emitCurrentComment(t), this._emitEOFToken()
            break
          default:
            t.data += String.fromCodePoint(e)
        }
      }
      _stateCommentLessThanSign(e) {
        const t = this.currentToken
        switch (e) {
          case xE.EXCLAMATION_MARK:
            ;(t.data += "!"), (this.state = gT.COMMENT_LESS_THAN_SIGN_BANG)
            break
          case xE.LESS_THAN_SIGN:
            t.data += "<"
            break
          default:
            ;(this.state = gT.COMMENT), this._stateComment(e)
        }
      }
      _stateCommentLessThanSignBang(e) {
        e === xE.HYPHEN_MINUS
          ? (this.state = gT.COMMENT_LESS_THAN_SIGN_BANG_DASH)
          : ((this.state = gT.COMMENT), this._stateComment(e))
      }
      _stateCommentLessThanSignBangDash(e) {
        e === xE.HYPHEN_MINUS
          ? (this.state = gT.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH)
          : ((this.state = gT.COMMENT_END_DASH), this._stateCommentEndDash(e))
      }
      _stateCommentLessThanSignBangDashDash(e) {
        e !== xE.GREATER_THAN_SIGN && e !== xE.EOF && this._err(PE.nestedComment),
          (this.state = gT.COMMENT_END),
          this._stateCommentEnd(e)
      }
      _stateCommentEndDash(e) {
        const t = this.currentToken
        switch (e) {
          case xE.HYPHEN_MINUS:
            this.state = gT.COMMENT_END
            break
          case xE.EOF:
            this._err(PE.eofInComment), this.emitCurrentComment(t), this._emitEOFToken()
            break
          default:
            ;(t.data += "-"), (this.state = gT.COMMENT), this._stateComment(e)
        }
      }
      _stateCommentEnd(e) {
        const t = this.currentToken
        switch (e) {
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentComment(t)
            break
          case xE.EXCLAMATION_MARK:
            this.state = gT.COMMENT_END_BANG
            break
          case xE.HYPHEN_MINUS:
            t.data += "-"
            break
          case xE.EOF:
            this._err(PE.eofInComment), this.emitCurrentComment(t), this._emitEOFToken()
            break
          default:
            ;(t.data += "--"), (this.state = gT.COMMENT), this._stateComment(e)
        }
      }
      _stateCommentEndBang(e) {
        const t = this.currentToken
        switch (e) {
          case xE.HYPHEN_MINUS:
            ;(t.data += "--!"), (this.state = gT.COMMENT_END_DASH)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.incorrectlyClosedComment), (this.state = gT.DATA), this.emitCurrentComment(t)
            break
          case xE.EOF:
            this._err(PE.eofInComment), this.emitCurrentComment(t), this._emitEOFToken()
            break
          default:
            ;(t.data += "--!"), (this.state = gT.COMMENT), this._stateComment(e)
        }
      }
      _stateDoctype(e) {
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this.state = gT.BEFORE_DOCTYPE_NAME
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.BEFORE_DOCTYPE_NAME), this._stateBeforeDoctypeName(e)
            break
          case xE.EOF: {
            this._err(PE.eofInDoctype), this._createDoctypeToken(null)
            const e = this.currentToken
            ;(e.forceQuirks = !0), this.emitCurrentDoctype(e), this._emitEOFToken()
            break
          }
          default:
            this._err(PE.missingWhitespaceBeforeDoctypeName),
              (this.state = gT.BEFORE_DOCTYPE_NAME),
              this._stateBeforeDoctypeName(e)
        }
      }
      _stateBeforeDoctypeName(e) {
        if (OT(e)) this._createDoctypeToken(String.fromCharCode(ST(e))), (this.state = gT.DOCTYPE_NAME)
        else
          switch (e) {
            case xE.SPACE:
            case xE.LINE_FEED:
            case xE.TABULATION:
            case xE.FORM_FEED:
              break
            case xE.NULL:
              this._err(PE.unexpectedNullCharacter), this._createDoctypeToken(wE), (this.state = gT.DOCTYPE_NAME)
              break
            case xE.GREATER_THAN_SIGN: {
              this._err(PE.missingDoctypeName), this._createDoctypeToken(null)
              const e = this.currentToken
              ;(e.forceQuirks = !0), this.emitCurrentDoctype(e), (this.state = gT.DATA)
              break
            }
            case xE.EOF: {
              this._err(PE.eofInDoctype), this._createDoctypeToken(null)
              const e = this.currentToken
              ;(e.forceQuirks = !0), this.emitCurrentDoctype(e), this._emitEOFToken()
              break
            }
            default:
              this._createDoctypeToken(String.fromCodePoint(e)), (this.state = gT.DOCTYPE_NAME)
          }
      }
      _stateDoctypeName(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this.state = gT.AFTER_DOCTYPE_NAME
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentDoctype(t)
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.name += wE)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            t.name += String.fromCodePoint(OT(e) ? ST(e) : e)
        }
      }
      _stateAfterDoctypeName(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentDoctype(t)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._consumeSequenceIfMatch("public", !1)
              ? (this.state = gT.AFTER_DOCTYPE_PUBLIC_KEYWORD)
              : this._consumeSequenceIfMatch("system", !1)
                ? (this.state = gT.AFTER_DOCTYPE_SYSTEM_KEYWORD)
                : this._ensureHibernation() ||
                  (this._err(PE.invalidCharacterSequenceAfterDoctypeName),
                  (t.forceQuirks = !0),
                  (this.state = gT.BOGUS_DOCTYPE),
                  this._stateBogusDoctype(e))
        }
      }
      _stateAfterDoctypePublicKeyword(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this.state = gT.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER
            break
          case xE.QUOTATION_MARK:
            this._err(PE.missingWhitespaceAfterDoctypePublicKeyword),
              (t.publicId = ""),
              (this.state = gT.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED)
            break
          case xE.APOSTROPHE:
            this._err(PE.missingWhitespaceAfterDoctypePublicKeyword),
              (t.publicId = ""),
              (this.state = gT.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.missingDoctypePublicIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.DATA),
              this.emitCurrentDoctype(t)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.missingQuoteBeforeDoctypePublicIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateBeforeDoctypePublicIdentifier(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.QUOTATION_MARK:
            ;(t.publicId = ""), (this.state = gT.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED)
            break
          case xE.APOSTROPHE:
            ;(t.publicId = ""), (this.state = gT.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.missingDoctypePublicIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.DATA),
              this.emitCurrentDoctype(t)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.missingQuoteBeforeDoctypePublicIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateDoctypePublicIdentifierDoubleQuoted(e) {
        const t = this.currentToken
        switch (e) {
          case xE.QUOTATION_MARK:
            this.state = gT.AFTER_DOCTYPE_PUBLIC_IDENTIFIER
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.publicId += wE)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.abruptDoctypePublicIdentifier),
              (t.forceQuirks = !0),
              this.emitCurrentDoctype(t),
              (this.state = gT.DATA)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            t.publicId += String.fromCodePoint(e)
        }
      }
      _stateDoctypePublicIdentifierSingleQuoted(e) {
        const t = this.currentToken
        switch (e) {
          case xE.APOSTROPHE:
            this.state = gT.AFTER_DOCTYPE_PUBLIC_IDENTIFIER
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.publicId += wE)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.abruptDoctypePublicIdentifier),
              (t.forceQuirks = !0),
              this.emitCurrentDoctype(t),
              (this.state = gT.DATA)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            t.publicId += String.fromCodePoint(e)
        }
      }
      _stateAfterDoctypePublicIdentifier(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this.state = gT.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS
            break
          case xE.GREATER_THAN_SIGN:
            ;(this.state = gT.DATA), this.emitCurrentDoctype(t)
            break
          case xE.QUOTATION_MARK:
            this._err(PE.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
              (t.systemId = ""),
              (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
            break
          case xE.APOSTROPHE:
            this._err(PE.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
              (t.systemId = ""),
              (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.missingQuoteBeforeDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.GREATER_THAN_SIGN:
            this.emitCurrentDoctype(t), (this.state = gT.DATA)
            break
          case xE.QUOTATION_MARK:
            ;(t.systemId = ""), (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
            break
          case xE.APOSTROPHE:
            ;(t.systemId = ""), (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.missingQuoteBeforeDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateAfterDoctypeSystemKeyword(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            this.state = gT.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER
            break
          case xE.QUOTATION_MARK:
            this._err(PE.missingWhitespaceAfterDoctypeSystemKeyword),
              (t.systemId = ""),
              (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
            break
          case xE.APOSTROPHE:
            this._err(PE.missingWhitespaceAfterDoctypeSystemKeyword),
              (t.systemId = ""),
              (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.missingDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.DATA),
              this.emitCurrentDoctype(t)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.missingQuoteBeforeDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateBeforeDoctypeSystemIdentifier(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.QUOTATION_MARK:
            ;(t.systemId = ""), (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
            break
          case xE.APOSTROPHE:
            ;(t.systemId = ""), (this.state = gT.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.missingDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.DATA),
              this.emitCurrentDoctype(t)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.missingQuoteBeforeDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateDoctypeSystemIdentifierDoubleQuoted(e) {
        const t = this.currentToken
        switch (e) {
          case xE.QUOTATION_MARK:
            this.state = gT.AFTER_DOCTYPE_SYSTEM_IDENTIFIER
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.systemId += wE)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.abruptDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              this.emitCurrentDoctype(t),
              (this.state = gT.DATA)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            t.systemId += String.fromCodePoint(e)
        }
      }
      _stateDoctypeSystemIdentifierSingleQuoted(e) {
        const t = this.currentToken
        switch (e) {
          case xE.APOSTROPHE:
            this.state = gT.AFTER_DOCTYPE_SYSTEM_IDENTIFIER
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter), (t.systemId += wE)
            break
          case xE.GREATER_THAN_SIGN:
            this._err(PE.abruptDoctypeSystemIdentifier),
              (t.forceQuirks = !0),
              this.emitCurrentDoctype(t),
              (this.state = gT.DATA)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            t.systemId += String.fromCodePoint(e)
        }
      }
      _stateAfterDoctypeSystemIdentifier(e) {
        const t = this.currentToken
        switch (e) {
          case xE.SPACE:
          case xE.LINE_FEED:
          case xE.TABULATION:
          case xE.FORM_FEED:
            break
          case xE.GREATER_THAN_SIGN:
            this.emitCurrentDoctype(t), (this.state = gT.DATA)
            break
          case xE.EOF:
            this._err(PE.eofInDoctype), (t.forceQuirks = !0), this.emitCurrentDoctype(t), this._emitEOFToken()
            break
          default:
            this._err(PE.unexpectedCharacterAfterDoctypeSystemIdentifier),
              (this.state = gT.BOGUS_DOCTYPE),
              this._stateBogusDoctype(e)
        }
      }
      _stateBogusDoctype(e) {
        const t = this.currentToken
        switch (e) {
          case xE.GREATER_THAN_SIGN:
            this.emitCurrentDoctype(t), (this.state = gT.DATA)
            break
          case xE.NULL:
            this._err(PE.unexpectedNullCharacter)
            break
          case xE.EOF:
            this.emitCurrentDoctype(t), this._emitEOFToken()
        }
      }
      _stateCdataSection(e) {
        switch (e) {
          case xE.RIGHT_SQUARE_BRACKET:
            this.state = gT.CDATA_SECTION_BRACKET
            break
          case xE.EOF:
            this._err(PE.eofInCdata), this._emitEOFToken()
            break
          default:
            this._emitCodePoint(e)
        }
      }
      _stateCdataSectionBracket(e) {
        e === xE.RIGHT_SQUARE_BRACKET
          ? (this.state = gT.CDATA_SECTION_END)
          : (this._emitChars("]"), (this.state = gT.CDATA_SECTION), this._stateCdataSection(e))
      }
      _stateCdataSectionEnd(e) {
        switch (e) {
          case xE.GREATER_THAN_SIGN:
            this.state = gT.DATA
            break
          case xE.RIGHT_SQUARE_BRACKET:
            this._emitChars("]")
            break
          default:
            this._emitChars("]]"), (this.state = gT.CDATA_SECTION), this._stateCdataSection(e)
        }
      }
      _stateCharacterReference(e) {
        e === xE.NUMBER_SIGN
          ? (this.state = gT.NUMERIC_CHARACTER_REFERENCE)
          : xT(e)
            ? ((this.state = gT.NAMED_CHARACTER_REFERENCE), this._stateNamedCharacterReference(e))
            : (this._flushCodePointConsumedAsCharacterReference(xE.AMPERSAND),
              this._reconsumeInState(this.returnState, e))
      }
      _stateNamedCharacterReference(e) {
        const t = this._matchNamedCharacterReference(e)
        if (this._ensureHibernation());
        else if (t) {
          for (let e = 0; e < t.length; e++) this._flushCodePointConsumedAsCharacterReference(t[e])
          this.state = this.returnState
        } else this._flushCodePointConsumedAsCharacterReference(xE.AMPERSAND), (this.state = gT.AMBIGUOUS_AMPERSAND)
      }
      _stateAmbiguousAmpersand(e) {
        xT(e)
          ? this._flushCodePointConsumedAsCharacterReference(e)
          : (e === xE.SEMICOLON && this._err(PE.unknownNamedCharacterReference),
            this._reconsumeInState(this.returnState, e))
      }
      _stateNumericCharacterReference(e) {
        ;(this.charRefCode = 0),
          e === xE.LATIN_SMALL_X || e === xE.LATIN_CAPITAL_X
            ? (this.state = gT.HEXADEMICAL_CHARACTER_REFERENCE_START)
            : yT(e)
              ? ((this.state = gT.DECIMAL_CHARACTER_REFERENCE), this._stateDecimalCharacterReference(e))
              : (this._err(PE.absenceOfDigitsInNumericCharacterReference),
                this._flushCodePointConsumedAsCharacterReference(xE.AMPERSAND),
                this._flushCodePointConsumedAsCharacterReference(xE.NUMBER_SIGN),
                this._reconsumeInState(this.returnState, e))
      }
      _stateHexademicalCharacterReferenceStart(e) {
        !(function (e) {
          return yT(e) || kT(e) || _T(e)
        })(e)
          ? (this._err(PE.absenceOfDigitsInNumericCharacterReference),
            this._flushCodePointConsumedAsCharacterReference(xE.AMPERSAND),
            this._flushCodePointConsumedAsCharacterReference(xE.NUMBER_SIGN),
            this._unconsume(2),
            (this.state = this.returnState))
          : ((this.state = gT.HEXADEMICAL_CHARACTER_REFERENCE), this._stateHexademicalCharacterReference(e))
      }
      _stateHexademicalCharacterReference(e) {
        kT(e)
          ? (this.charRefCode = 16 * this.charRefCode + e - 55)
          : _T(e)
            ? (this.charRefCode = 16 * this.charRefCode + e - 87)
            : yT(e)
              ? (this.charRefCode = 16 * this.charRefCode + e - 48)
              : e === xE.SEMICOLON
                ? (this.state = gT.NUMERIC_CHARACTER_REFERENCE_END)
                : (this._err(PE.missingSemicolonAfterCharacterReference),
                  (this.state = gT.NUMERIC_CHARACTER_REFERENCE_END),
                  this._stateNumericCharacterReferenceEnd(e))
      }
      _stateDecimalCharacterReference(e) {
        yT(e)
          ? (this.charRefCode = 10 * this.charRefCode + e - 48)
          : e === xE.SEMICOLON
            ? (this.state = gT.NUMERIC_CHARACTER_REFERENCE_END)
            : (this._err(PE.missingSemicolonAfterCharacterReference),
              (this.state = gT.NUMERIC_CHARACTER_REFERENCE_END),
              this._stateNumericCharacterReferenceEnd(e))
      }
      _stateNumericCharacterReferenceEnd(e) {
        if (this.charRefCode === xE.NULL)
          this._err(PE.nullCharacterReference), (this.charRefCode = xE.REPLACEMENT_CHARACTER)
        else if (this.charRefCode > 1114111)
          this._err(PE.characterReferenceOutsideUnicodeRange), (this.charRefCode = xE.REPLACEMENT_CHARACTER)
        else if (TE(this.charRefCode))
          this._err(PE.surrogateCharacterReference), (this.charRefCode = xE.REPLACEMENT_CHARACTER)
        else if (CE(this.charRefCode)) this._err(PE.noncharacterCharacterReference)
        else if (AE(this.charRefCode) || this.charRefCode === xE.CARRIAGE_RETURN) {
          this._err(PE.controlCharacterReference)
          const e = mT.get(this.charRefCode)
          void 0 !== e && (this.charRefCode = e)
        }
        this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, e)
      }
    }
    const CT = new Set([rT.DD, rT.DT, rT.LI, rT.OPTGROUP, rT.OPTION, rT.P, rT.RB, rT.RP, rT.RT, rT.RTC]),
      PT = new Set([...CT, rT.CAPTION, rT.COLGROUP, rT.TBODY, rT.TD, rT.TFOOT, rT.TH, rT.THEAD, rT.TR]),
      DT = new Map([
        [rT.APPLET, XE.HTML],
        [rT.CAPTION, XE.HTML],
        [rT.HTML, XE.HTML],
        [rT.MARQUEE, XE.HTML],
        [rT.OBJECT, XE.HTML],
        [rT.TABLE, XE.HTML],
        [rT.TD, XE.HTML],
        [rT.TEMPLATE, XE.HTML],
        [rT.TH, XE.HTML],
        [rT.ANNOTATION_XML, XE.MATHML],
        [rT.MI, XE.MATHML],
        [rT.MN, XE.MATHML],
        [rT.MO, XE.MATHML],
        [rT.MS, XE.MATHML],
        [rT.MTEXT, XE.MATHML],
        [rT.DESC, XE.SVG],
        [rT.FOREIGN_OBJECT, XE.SVG],
        [rT.TITLE, XE.SVG],
      ]),
      RT = [rT.H1, rT.H2, rT.H3, rT.H4, rT.H5, rT.H6],
      NT = [rT.TR, rT.TEMPLATE, rT.HTML],
      $T = [rT.TBODY, rT.TFOOT, rT.THEAD, rT.TEMPLATE, rT.HTML],
      IT = [rT.TABLE, rT.TEMPLATE, rT.HTML],
      MT = [rT.TD, rT.TH]
    class LT {
      get currentTmplContentOrNode() {
        return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current
      }
      constructor(e, t, n) {
        ;(this.treeAdapter = t),
          (this.handler = n),
          (this.items = []),
          (this.tagIDs = []),
          (this.stackTop = -1),
          (this.tmplCount = 0),
          (this.currentTagId = rT.UNKNOWN),
          (this.current = e)
      }
      _indexOf(e) {
        return this.items.lastIndexOf(e, this.stackTop)
      }
      _isInTemplate() {
        return this.currentTagId === rT.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === XE.HTML
      }
      _updateCurrentElement() {
        ;(this.current = this.items[this.stackTop]), (this.currentTagId = this.tagIDs[this.stackTop])
      }
      push(e, t) {
        this.stackTop++,
          (this.items[this.stackTop] = e),
          (this.current = e),
          (this.tagIDs[this.stackTop] = t),
          (this.currentTagId = t),
          this._isInTemplate() && this.tmplCount++,
          this.handler.onItemPush(e, t, !0)
      }
      pop() {
        const e = this.current
        this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--,
          this.stackTop--,
          this._updateCurrentElement(),
          this.handler.onItemPop(e, !0)
      }
      replace(e, t) {
        const n = this._indexOf(e)
        ;(this.items[n] = t), n === this.stackTop && (this.current = t)
      }
      insertAfter(e, t, n) {
        const r = this._indexOf(e) + 1
        this.items.splice(r, 0, t),
          this.tagIDs.splice(r, 0, n),
          this.stackTop++,
          r === this.stackTop && this._updateCurrentElement(),
          this.handler.onItemPush(this.current, this.currentTagId, r === this.stackTop)
      }
      popUntilTagNamePopped(e) {
        let t = this.stackTop + 1
        do {
          t = this.tagIDs.lastIndexOf(e, t - 1)
        } while (t > 0 && this.treeAdapter.getNamespaceURI(this.items[t]) !== XE.HTML)
        this.shortenToLength(t < 0 ? 0 : t)
      }
      shortenToLength(e) {
        for (; this.stackTop >= e; ) {
          const t = this.current
          this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1),
            this.stackTop--,
            this._updateCurrentElement(),
            this.handler.onItemPop(t, this.stackTop < e)
        }
      }
      popUntilElementPopped(e) {
        const t = this._indexOf(e)
        this.shortenToLength(t < 0 ? 0 : t)
      }
      popUntilPopped(e, t) {
        const n = this._indexOfTagNames(e, t)
        this.shortenToLength(n < 0 ? 0 : n)
      }
      popUntilNumberedHeaderPopped() {
        this.popUntilPopped(RT, XE.HTML)
      }
      popUntilTableCellPopped() {
        this.popUntilPopped(MT, XE.HTML)
      }
      popAllUpToHtmlElement() {
        ;(this.tmplCount = 0), this.shortenToLength(1)
      }
      _indexOfTagNames(e, t) {
        for (let n = this.stackTop; n >= 0; n--)
          if (e.includes(this.tagIDs[n]) && this.treeAdapter.getNamespaceURI(this.items[n]) === t) return n
        return -1
      }
      clearBackTo(e, t) {
        const n = this._indexOfTagNames(e, t)
        this.shortenToLength(n + 1)
      }
      clearBackToTableContext() {
        this.clearBackTo(IT, XE.HTML)
      }
      clearBackToTableBodyContext() {
        this.clearBackTo($T, XE.HTML)
      }
      clearBackToTableRowContext() {
        this.clearBackTo(NT, XE.HTML)
      }
      remove(e) {
        const t = this._indexOf(e)
        t >= 0 &&
          (t === this.stackTop
            ? this.pop()
            : (this.items.splice(t, 1),
              this.tagIDs.splice(t, 1),
              this.stackTop--,
              this._updateCurrentElement(),
              this.handler.onItemPop(e, !1)))
      }
      tryPeekProperlyNestedBodyElement() {
        return this.stackTop >= 1 && this.tagIDs[1] === rT.BODY ? this.items[1] : null
      }
      contains(e) {
        return this._indexOf(e) > -1
      }
      getCommonAncestor(e) {
        const t = this._indexOf(e) - 1
        return t >= 0 ? this.items[t] : null
      }
      isRootHtmlElementCurrent() {
        return 0 === this.stackTop && this.tagIDs[0] === rT.HTML
      }
      hasInScope(e) {
        for (let t = this.stackTop; t >= 0; t--) {
          const n = this.tagIDs[t],
            r = this.treeAdapter.getNamespaceURI(this.items[t])
          if (n === e && r === XE.HTML) return !0
          if (DT.get(n) === r) return !1
        }
        return !0
      }
      hasNumberedHeaderInScope() {
        for (let e = this.stackTop; e >= 0; e--) {
          const t = this.tagIDs[e],
            n = this.treeAdapter.getNamespaceURI(this.items[e])
          if (fT(t) && n === XE.HTML) return !0
          if (DT.get(t) === n) return !1
        }
        return !0
      }
      hasInListItemScope(e) {
        for (let t = this.stackTop; t >= 0; t--) {
          const n = this.tagIDs[t],
            r = this.treeAdapter.getNamespaceURI(this.items[t])
          if (n === e && r === XE.HTML) return !0
          if (((n === rT.UL || n === rT.OL) && r === XE.HTML) || DT.get(n) === r) return !1
        }
        return !0
      }
      hasInButtonScope(e) {
        for (let t = this.stackTop; t >= 0; t--) {
          const n = this.tagIDs[t],
            r = this.treeAdapter.getNamespaceURI(this.items[t])
          if (n === e && r === XE.HTML) return !0
          if ((n === rT.BUTTON && r === XE.HTML) || DT.get(n) === r) return !1
        }
        return !0
      }
      hasInTableScope(e) {
        for (let t = this.stackTop; t >= 0; t--) {
          const n = this.tagIDs[t]
          if (this.treeAdapter.getNamespaceURI(this.items[t]) === XE.HTML) {
            if (n === e) return !0
            if (n === rT.TABLE || n === rT.TEMPLATE || n === rT.HTML) return !1
          }
        }
        return !0
      }
      hasTableBodyContextInTableScope() {
        for (let e = this.stackTop; e >= 0; e--) {
          const t = this.tagIDs[e]
          if (this.treeAdapter.getNamespaceURI(this.items[e]) === XE.HTML) {
            if (t === rT.TBODY || t === rT.THEAD || t === rT.TFOOT) return !0
            if (t === rT.TABLE || t === rT.HTML) return !1
          }
        }
        return !0
      }
      hasInSelectScope(e) {
        for (let t = this.stackTop; t >= 0; t--) {
          const n = this.tagIDs[t]
          if (this.treeAdapter.getNamespaceURI(this.items[t]) === XE.HTML) {
            if (n === e) return !0
            if (n !== rT.OPTION && n !== rT.OPTGROUP) return !1
          }
        }
        return !0
      }
      generateImpliedEndTags() {
        for (; CT.has(this.currentTagId); ) this.pop()
      }
      generateImpliedEndTagsThoroughly() {
        for (; PT.has(this.currentTagId); ) this.pop()
      }
      generateImpliedEndTagsWithExclusion(e) {
        for (; this.currentTagId !== e && PT.has(this.currentTagId); ) this.pop()
      }
    }
    var QT, BT
    ;((BT = QT = QT || (QT = {}))[(BT.Marker = 0)] = "Marker"), (BT[(BT.Element = 1)] = "Element")
    const jT = { type: QT.Marker }
    class UT {
      constructor(e) {
        ;(this.treeAdapter = e), (this.entries = []), (this.bookmark = null)
      }
      _getNoahArkConditionCandidates(e, t) {
        const n = [],
          r = t.length,
          a = this.treeAdapter.getTagName(e),
          o = this.treeAdapter.getNamespaceURI(e)
        for (let e = 0; e < this.entries.length; e++) {
          const t = this.entries[e]
          if (t.type === QT.Marker) break
          const { element: i } = t
          if (this.treeAdapter.getTagName(i) === a && this.treeAdapter.getNamespaceURI(i) === o) {
            const t = this.treeAdapter.getAttrList(i)
            t.length === r && n.push({ idx: e, attrs: t })
          }
        }
        return n
      }
      _ensureNoahArkCondition(e) {
        if (this.entries.length < 3) return
        const t = this.treeAdapter.getAttrList(e),
          n = this._getNoahArkConditionCandidates(e, t)
        if (n.length < 3) return
        const r = new Map(t.map((e) => [e.name, e.value]))
        let a = 0
        for (let e = 0; e < n.length; e++) {
          const t = n[e]
          t.attrs.every((e) => r.get(e.name) === e.value) && ((a += 1), a >= 3 && this.entries.splice(t.idx, 1))
        }
      }
      insertMarker() {
        this.entries.unshift(jT)
      }
      pushElement(e, t) {
        this._ensureNoahArkCondition(e), this.entries.unshift({ type: QT.Element, element: e, token: t })
      }
      insertElementAfterBookmark(e, t) {
        const n = this.entries.indexOf(this.bookmark)
        this.entries.splice(n, 0, { type: QT.Element, element: e, token: t })
      }
      removeEntry(e) {
        const t = this.entries.indexOf(e)
        t >= 0 && this.entries.splice(t, 1)
      }
      clearToLastMarker() {
        const e = this.entries.indexOf(jT)
        e >= 0 ? this.entries.splice(0, e + 1) : (this.entries.length = 0)
      }
      getElementEntryInScopeWithTagName(e) {
        const t = this.entries.find((t) => t.type === QT.Marker || this.treeAdapter.getTagName(t.element) === e)
        return t && t.type === QT.Element ? t : null
      }
      getElementEntry(e) {
        return this.entries.find((t) => t.type === QT.Element && t.element === e)
      }
    }
    function FT(e) {
      return { nodeName: "#text", value: e, parentNode: null }
    }
    const zT = {
        createDocument: () => ({ nodeName: "#document", mode: JE.NO_QUIRKS, childNodes: [] }),
        createDocumentFragment: () => ({ nodeName: "#document-fragment", childNodes: [] }),
        createElement: (e, t, n) => ({
          nodeName: e,
          tagName: e,
          attrs: n,
          namespaceURI: t,
          childNodes: [],
          parentNode: null,
        }),
        createCommentNode: (e) => ({ nodeName: "#comment", data: e, parentNode: null }),
        appendChild(e, t) {
          e.childNodes.push(t), (t.parentNode = e)
        },
        insertBefore(e, t, n) {
          const r = e.childNodes.indexOf(n)
          e.childNodes.splice(r, 0, t), (t.parentNode = e)
        },
        setTemplateContent(e, t) {
          e.content = t
        },
        getTemplateContent: (e) => e.content,
        setDocumentType(e, t, n, r) {
          const a = e.childNodes.find((e) => "#documentType" === e.nodeName)
          if (a) (a.name = t), (a.publicId = n), (a.systemId = r)
          else {
            const a = { nodeName: "#documentType", name: t, publicId: n, systemId: r, parentNode: null }
            zT.appendChild(e, a)
          }
        },
        setDocumentMode(e, t) {
          e.mode = t
        },
        getDocumentMode: (e) => e.mode,
        detachNode(e) {
          if (e.parentNode) {
            const t = e.parentNode.childNodes.indexOf(e)
            e.parentNode.childNodes.splice(t, 1), (e.parentNode = null)
          }
        },
        insertText(e, t) {
          if (e.childNodes.length > 0) {
            const n = e.childNodes[e.childNodes.length - 1]
            if (zT.isTextNode(n)) return void (n.value += t)
          }
          zT.appendChild(e, FT(t))
        },
        insertTextBefore(e, t, n) {
          const r = e.childNodes[e.childNodes.indexOf(n) - 1]
          r && zT.isTextNode(r) ? (r.value += t) : zT.insertBefore(e, FT(t), n)
        },
        adoptAttributes(e, t) {
          const n = new Set(e.attrs.map((e) => e.name))
          for (let r = 0; r < t.length; r++) n.has(t[r].name) || e.attrs.push(t[r])
        },
        getFirstChild: (e) => e.childNodes[0],
        getChildNodes: (e) => e.childNodes,
        getParentNode: (e) => e.parentNode,
        getAttrList: (e) => e.attrs,
        getTagName: (e) => e.tagName,
        getNamespaceURI: (e) => e.namespaceURI,
        getTextNodeContent: (e) => e.value,
        getCommentNodeContent: (e) => e.data,
        getDocumentTypeNodeName: (e) => e.name,
        getDocumentTypeNodePublicId: (e) => e.publicId,
        getDocumentTypeNodeSystemId: (e) => e.systemId,
        isTextNode: (e) => "#text" === e.nodeName,
        isCommentNode: (e) => "#comment" === e.nodeName,
        isDocumentTypeNode: (e) => "#documentType" === e.nodeName,
        isElementNode: (e) => Object.prototype.hasOwnProperty.call(e, "tagName"),
        setNodeSourceCodeLocation(e, t) {
          e.sourceCodeLocation = t
        },
        getNodeSourceCodeLocation: (e) => e.sourceCodeLocation,
        updateNodeSourceCodeLocation(e, t) {
          e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t }
        },
      },
      qT = "html",
      ZT = [
        "+//silmaril//dtd html pro v0r11 19970101//",
        "-//as//dtd html 3.0 aswedit + extensions//",
        "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
        "-//ietf//dtd html 2.0 level 1//",
        "-//ietf//dtd html 2.0 level 2//",
        "-//ietf//dtd html 2.0 strict level 1//",
        "-//ietf//dtd html 2.0 strict level 2//",
        "-//ietf//dtd html 2.0 strict//",
        "-//ietf//dtd html 2.0//",
        "-//ietf//dtd html 2.1e//",
        "-//ietf//dtd html 3.0//",
        "-//ietf//dtd html 3.2 final//",
        "-//ietf//dtd html 3.2//",
        "-//ietf//dtd html 3//",
        "-//ietf//dtd html level 0//",
        "-//ietf//dtd html level 1//",
        "-//ietf//dtd html level 2//",
        "-//ietf//dtd html level 3//",
        "-//ietf//dtd html strict level 0//",
        "-//ietf//dtd html strict level 1//",
        "-//ietf//dtd html strict level 2//",
        "-//ietf//dtd html strict level 3//",
        "-//ietf//dtd html strict//",
        "-//ietf//dtd html//",
        "-//metrius//dtd metrius presentational//",
        "-//microsoft//dtd internet explorer 2.0 html strict//",
        "-//microsoft//dtd internet explorer 2.0 html//",
        "-//microsoft//dtd internet explorer 2.0 tables//",
        "-//microsoft//dtd internet explorer 3.0 html strict//",
        "-//microsoft//dtd internet explorer 3.0 html//",
        "-//microsoft//dtd internet explorer 3.0 tables//",
        "-//netscape comm. corp.//dtd html//",
        "-//netscape comm. corp.//dtd strict html//",
        "-//o'reilly and associates//dtd html 2.0//",
        "-//o'reilly and associates//dtd html extended 1.0//",
        "-//o'reilly and associates//dtd html extended relaxed 1.0//",
        "-//sq//dtd html 2.0 hotmetal + extensions//",
        "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
        "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
        "-//spyglass//dtd html 2.0 extended//",
        "-//sun microsystems corp.//dtd hotjava html//",
        "-//sun microsystems corp.//dtd hotjava strict html//",
        "-//w3c//dtd html 3 1995-03-24//",
        "-//w3c//dtd html 3.2 draft//",
        "-//w3c//dtd html 3.2 final//",
        "-//w3c//dtd html 3.2//",
        "-//w3c//dtd html 3.2s draft//",
        "-//w3c//dtd html 4.0 frameset//",
        "-//w3c//dtd html 4.0 transitional//",
        "-//w3c//dtd html experimental 19960712//",
        "-//w3c//dtd html experimental 970421//",
        "-//w3c//dtd w3 html//",
        "-//w3o//dtd w3 html 3.0//",
        "-//webtechs//dtd mozilla html 2.0//",
        "-//webtechs//dtd mozilla html//",
      ],
      HT = [...ZT, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"],
      VT = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]),
      WT = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"],
      XT = [...WT, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]
    function YT(e, t) {
      return t.some((t) => e.startsWith(t))
    }
    const GT = "text/html",
      KT = "application/xhtml+xml",
      JT = "definitionurl",
      eA = "definitionURL",
      tA = new Map(
        [
          "attributeName",
          "attributeType",
          "baseFrequency",
          "baseProfile",
          "calcMode",
          "clipPathUnits",
          "diffuseConstant",
          "edgeMode",
          "filterUnits",
          "glyphRef",
          "gradientTransform",
          "gradientUnits",
          "kernelMatrix",
          "kernelUnitLength",
          "keyPoints",
          "keySplines",
          "keyTimes",
          "lengthAdjust",
          "limitingConeAngle",
          "markerHeight",
          "markerUnits",
          "markerWidth",
          "maskContentUnits",
          "maskUnits",
          "numOctaves",
          "pathLength",
          "patternContentUnits",
          "patternTransform",
          "patternUnits",
          "pointsAtX",
          "pointsAtY",
          "pointsAtZ",
          "preserveAlpha",
          "preserveAspectRatio",
          "primitiveUnits",
          "refX",
          "refY",
          "repeatCount",
          "repeatDur",
          "requiredExtensions",
          "requiredFeatures",
          "specularConstant",
          "specularExponent",
          "spreadMethod",
          "startOffset",
          "stdDeviation",
          "stitchTiles",
          "surfaceScale",
          "systemLanguage",
          "tableValues",
          "targetX",
          "targetY",
          "textLength",
          "viewBox",
          "viewTarget",
          "xChannelSelector",
          "yChannelSelector",
          "zoomAndPan",
        ].map((e) => [e.toLowerCase(), e]),
      ),
      nA = new Map([
        ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: XE.XLINK }],
        ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: XE.XLINK }],
        ["xlink:href", { prefix: "xlink", name: "href", namespace: XE.XLINK }],
        ["xlink:role", { prefix: "xlink", name: "role", namespace: XE.XLINK }],
        ["xlink:show", { prefix: "xlink", name: "show", namespace: XE.XLINK }],
        ["xlink:title", { prefix: "xlink", name: "title", namespace: XE.XLINK }],
        ["xlink:type", { prefix: "xlink", name: "type", namespace: XE.XLINK }],
        ["xml:base", { prefix: "xml", name: "base", namespace: XE.XML }],
        ["xml:lang", { prefix: "xml", name: "lang", namespace: XE.XML }],
        ["xml:space", { prefix: "xml", name: "space", namespace: XE.XML }],
        ["xmlns", { prefix: "", name: "xmlns", namespace: XE.XMLNS }],
        ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: XE.XMLNS }],
      ]),
      rA = new Map(
        [
          "altGlyph",
          "altGlyphDef",
          "altGlyphItem",
          "animateColor",
          "animateMotion",
          "animateTransform",
          "clipPath",
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDistantLight",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "fePointLight",
          "feSpecularLighting",
          "feSpotLight",
          "feTile",
          "feTurbulence",
          "foreignObject",
          "glyphRef",
          "linearGradient",
          "radialGradient",
          "textPath",
        ].map((e) => [e.toLowerCase(), e]),
      ),
      aA = new Set([
        rT.B,
        rT.BIG,
        rT.BLOCKQUOTE,
        rT.BODY,
        rT.BR,
        rT.CENTER,
        rT.CODE,
        rT.DD,
        rT.DIV,
        rT.DL,
        rT.DT,
        rT.EM,
        rT.EMBED,
        rT.H1,
        rT.H2,
        rT.H3,
        rT.H4,
        rT.H5,
        rT.H6,
        rT.HEAD,
        rT.HR,
        rT.I,
        rT.IMG,
        rT.LI,
        rT.LISTING,
        rT.MENU,
        rT.META,
        rT.NOBR,
        rT.OL,
        rT.P,
        rT.PRE,
        rT.RUBY,
        rT.S,
        rT.SMALL,
        rT.SPAN,
        rT.STRONG,
        rT.STRIKE,
        rT.SUB,
        rT.SUP,
        rT.TABLE,
        rT.TT,
        rT.U,
        rT.UL,
        rT.VAR,
      ])
    function oA(e) {
      for (let t = 0; t < e.attrs.length; t++)
        if (e.attrs[t].name === JT) {
          e.attrs[t].name = eA
          break
        }
    }
    function iA(e) {
      for (let t = 0; t < e.attrs.length; t++) {
        const n = tA.get(e.attrs[t].name)
        null != n && (e.attrs[t].name = n)
      }
    }
    function sA(e) {
      for (let t = 0; t < e.attrs.length; t++) {
        const n = nA.get(e.attrs[t].name)
        n && ((e.attrs[t].prefix = n.prefix), (e.attrs[t].name = n.name), (e.attrs[t].namespace = n.namespace))
      }
    }
    const lA = "hidden",
      cA = 8,
      dA = 3
    var uA, pA
    ;((pA = uA || (uA = {}))[(pA.INITIAL = 0)] = "INITIAL"),
      (pA[(pA.BEFORE_HTML = 1)] = "BEFORE_HTML"),
      (pA[(pA.BEFORE_HEAD = 2)] = "BEFORE_HEAD"),
      (pA[(pA.IN_HEAD = 3)] = "IN_HEAD"),
      (pA[(pA.IN_HEAD_NO_SCRIPT = 4)] = "IN_HEAD_NO_SCRIPT"),
      (pA[(pA.AFTER_HEAD = 5)] = "AFTER_HEAD"),
      (pA[(pA.IN_BODY = 6)] = "IN_BODY"),
      (pA[(pA.TEXT = 7)] = "TEXT"),
      (pA[(pA.IN_TABLE = 8)] = "IN_TABLE"),
      (pA[(pA.IN_TABLE_TEXT = 9)] = "IN_TABLE_TEXT"),
      (pA[(pA.IN_CAPTION = 10)] = "IN_CAPTION"),
      (pA[(pA.IN_COLUMN_GROUP = 11)] = "IN_COLUMN_GROUP"),
      (pA[(pA.IN_TABLE_BODY = 12)] = "IN_TABLE_BODY"),
      (pA[(pA.IN_ROW = 13)] = "IN_ROW"),
      (pA[(pA.IN_CELL = 14)] = "IN_CELL"),
      (pA[(pA.IN_SELECT = 15)] = "IN_SELECT"),
      (pA[(pA.IN_SELECT_IN_TABLE = 16)] = "IN_SELECT_IN_TABLE"),
      (pA[(pA.IN_TEMPLATE = 17)] = "IN_TEMPLATE"),
      (pA[(pA.AFTER_BODY = 18)] = "AFTER_BODY"),
      (pA[(pA.IN_FRAMESET = 19)] = "IN_FRAMESET"),
      (pA[(pA.AFTER_FRAMESET = 20)] = "AFTER_FRAMESET"),
      (pA[(pA.AFTER_AFTER_BODY = 21)] = "AFTER_AFTER_BODY"),
      (pA[(pA.AFTER_AFTER_FRAMESET = 22)] = "AFTER_AFTER_FRAMESET")
    const hA = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 },
      fA = new Set([rT.TABLE, rT.TBODY, rT.TFOOT, rT.THEAD, rT.TR]),
      mA = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: zT, onParseError: null }
    let gA = class {
      constructor(e, t, n = null, r = null) {
        ;(this.fragmentContext = n),
          (this.scriptHandler = r),
          (this.currentToken = null),
          (this.stopped = !1),
          (this.insertionMode = uA.INITIAL),
          (this.originalInsertionMode = uA.INITIAL),
          (this.headElement = null),
          (this.formElement = null),
          (this.currentNotInHTML = !1),
          (this.tmplInsertionModeStack = []),
          (this.pendingCharacterTokens = []),
          (this.hasNonWhitespacePendingCharacterToken = !1),
          (this.framesetOk = !0),
          (this.skipNextNewLine = !1),
          (this.fosterParentingEnabled = !1),
          (this.options = { ...mA, ...e }),
          (this.treeAdapter = this.options.treeAdapter),
          (this.onParseError = this.options.onParseError),
          this.onParseError && (this.options.sourceCodeLocationInfo = !0),
          (this.document = null != t ? t : this.treeAdapter.createDocument()),
          (this.tokenizer = new AT(this.options, this)),
          (this.activeFormattingElements = new UT(this.treeAdapter)),
          (this.fragmentContextID = n ? uT(this.treeAdapter.getTagName(n)) : rT.UNKNOWN),
          this._setContextModes(null != n ? n : this.document, this.fragmentContextID),
          (this.openElements = new LT(this.document, this.treeAdapter, this))
      }
      static parse(e, t) {
        const n = new this(t)
        return n.tokenizer.write(e, !0), n.document
      }
      static getFragmentParser(e, t) {
        const n = { ...mA, ...t }
        null != e || (e = n.treeAdapter.createElement(tT.TEMPLATE, XE.HTML, []))
        const r = n.treeAdapter.createElement("documentmock", XE.HTML, []),
          a = new this(n, r, e)
        return (
          a.fragmentContextID === rT.TEMPLATE && a.tmplInsertionModeStack.unshift(uA.IN_TEMPLATE),
          a._initTokenizerForFragmentParsing(),
          a._insertFakeRootElement(),
          a._resetInsertionMode(),
          a._findFormInFragmentContext(),
          a
        )
      }
      getFragment() {
        const e = this.treeAdapter.getFirstChild(this.document),
          t = this.treeAdapter.createDocumentFragment()
        return this._adoptNodes(e, t), t
      }
      _err(e, t, n) {
        var r
        if (!this.onParseError) return
        const a = null !== (r = e.location) && void 0 !== r ? r : hA,
          o = {
            code: t,
            startLine: a.startLine,
            startCol: a.startCol,
            startOffset: a.startOffset,
            endLine: n ? a.startLine : a.endLine,
            endCol: n ? a.startCol : a.endCol,
            endOffset: n ? a.startOffset : a.endOffset,
          }
        this.onParseError(o)
      }
      onItemPush(e, t, n) {
        var r, a
        null === (a = (r = this.treeAdapter).onItemPush) || void 0 === a || a.call(r, e),
          n && this.openElements.stackTop > 0 && this._setContextModes(e, t)
      }
      onItemPop(e, t) {
        var n, r
        if (
          (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken),
          null === (r = (n = this.treeAdapter).onItemPop) || void 0 === r || r.call(n, e, this.openElements.current),
          t)
        ) {
          let e, t
          0 === this.openElements.stackTop && this.fragmentContext
            ? ((e = this.fragmentContext), (t = this.fragmentContextID))
            : ({ current: e, currentTagId: t } = this.openElements),
            this._setContextModes(e, t)
        }
      }
      _setContextModes(e, t) {
        const n = e === this.document || this.treeAdapter.getNamespaceURI(e) === XE.HTML
        ;(this.currentNotInHTML = !n), (this.tokenizer.inForeignNode = !n && !this._isIntegrationPoint(t, e))
      }
      _switchToTextParsing(e, t) {
        this._insertElement(e, XE.HTML),
          (this.tokenizer.state = t),
          (this.originalInsertionMode = this.insertionMode),
          (this.insertionMode = uA.TEXT)
      }
      switchToPlaintextParsing() {
        ;(this.insertionMode = uA.TEXT),
          (this.originalInsertionMode = uA.IN_BODY),
          (this.tokenizer.state = vT.PLAINTEXT)
      }
      _getAdjustedCurrentElement() {
        return 0 === this.openElements.stackTop && this.fragmentContext
          ? this.fragmentContext
          : this.openElements.current
      }
      _findFormInFragmentContext() {
        let e = this.fragmentContext
        for (; e; ) {
          if (this.treeAdapter.getTagName(e) === tT.FORM) {
            this.formElement = e
            break
          }
          e = this.treeAdapter.getParentNode(e)
        }
      }
      _initTokenizerForFragmentParsing() {
        if (this.fragmentContext && this.treeAdapter.getNamespaceURI(this.fragmentContext) === XE.HTML)
          switch (this.fragmentContextID) {
            case rT.TITLE:
            case rT.TEXTAREA:
              this.tokenizer.state = vT.RCDATA
              break
            case rT.STYLE:
            case rT.XMP:
            case rT.IFRAME:
            case rT.NOEMBED:
            case rT.NOFRAMES:
            case rT.NOSCRIPT:
              this.tokenizer.state = vT.RAWTEXT
              break
            case rT.SCRIPT:
              this.tokenizer.state = vT.SCRIPT_DATA
              break
            case rT.PLAINTEXT:
              this.tokenizer.state = vT.PLAINTEXT
          }
      }
      _setDocumentType(e) {
        const t = e.name || "",
          n = e.publicId || "",
          r = e.systemId || ""
        if ((this.treeAdapter.setDocumentType(this.document, t, n, r), e.location)) {
          const t = this.treeAdapter.getChildNodes(this.document).find((e) => this.treeAdapter.isDocumentTypeNode(e))
          t && this.treeAdapter.setNodeSourceCodeLocation(t, e.location)
        }
      }
      _attachElementToTree(e, t) {
        if (this.options.sourceCodeLocationInfo) {
          const n = t && { ...t, startTag: t }
          this.treeAdapter.setNodeSourceCodeLocation(e, n)
        }
        if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(e)
        else {
          const t = this.openElements.currentTmplContentOrNode
          this.treeAdapter.appendChild(t, e)
        }
      }
      _appendElement(e, t) {
        const n = this.treeAdapter.createElement(e.tagName, t, e.attrs)
        this._attachElementToTree(n, e.location)
      }
      _insertElement(e, t) {
        const n = this.treeAdapter.createElement(e.tagName, t, e.attrs)
        this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID)
      }
      _insertFakeElement(e, t) {
        const n = this.treeAdapter.createElement(e, XE.HTML, [])
        this._attachElementToTree(n, null), this.openElements.push(n, t)
      }
      _insertTemplate(e) {
        const t = this.treeAdapter.createElement(e.tagName, XE.HTML, e.attrs),
          n = this.treeAdapter.createDocumentFragment()
        this.treeAdapter.setTemplateContent(t, n),
          this._attachElementToTree(t, e.location),
          this.openElements.push(t, e.tagID),
          this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, null)
      }
      _insertFakeRootElement() {
        const e = this.treeAdapter.createElement(tT.HTML, XE.HTML, [])
        this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null),
          this.treeAdapter.appendChild(this.openElements.current, e),
          this.openElements.push(e, rT.HTML)
      }
      _appendCommentNode(e, t) {
        const n = this.treeAdapter.createCommentNode(e.data)
        this.treeAdapter.appendChild(t, n),
          this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, e.location)
      }
      _insertCharacters(e) {
        let t, n
        if (
          (this._shouldFosterParentOnInsertion()
            ? (({ parent: t, beforeElement: n } = this._findFosterParentingLocation()),
              n ? this.treeAdapter.insertTextBefore(t, e.chars, n) : this.treeAdapter.insertText(t, e.chars))
            : ((t = this.openElements.currentTmplContentOrNode), this.treeAdapter.insertText(t, e.chars)),
          !e.location)
        )
          return
        const r = this.treeAdapter.getChildNodes(t),
          a = n ? r.lastIndexOf(n) : r.length,
          o = r[a - 1]
        if (this.treeAdapter.getNodeSourceCodeLocation(o)) {
          const { endLine: t, endCol: n, endOffset: r } = e.location
          this.treeAdapter.updateNodeSourceCodeLocation(o, { endLine: t, endCol: n, endOffset: r })
        } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(o, e.location)
      }
      _adoptNodes(e, t) {
        for (let n = this.treeAdapter.getFirstChild(e); n; n = this.treeAdapter.getFirstChild(e))
          this.treeAdapter.detachNode(n), this.treeAdapter.appendChild(t, n)
      }
      _setEndLocation(e, t) {
        if (this.treeAdapter.getNodeSourceCodeLocation(e) && t.location) {
          const n = t.location,
            r = this.treeAdapter.getTagName(e),
            a =
              t.type === RE.END_TAG && r === t.tagName
                ? { endTag: { ...n }, endLine: n.endLine, endCol: n.endCol, endOffset: n.endOffset }
                : { endLine: n.startLine, endCol: n.startCol, endOffset: n.startOffset }
          this.treeAdapter.updateNodeSourceCodeLocation(e, a)
        }
      }
      shouldProcessStartTagTokenInForeignContent(e) {
        if (!this.currentNotInHTML) return !1
        let t, n
        return (
          0 === this.openElements.stackTop && this.fragmentContext
            ? ((t = this.fragmentContext), (n = this.fragmentContextID))
            : ({ current: t, currentTagId: n } = this.openElements),
          (e.tagID !== rT.SVG ||
            this.treeAdapter.getTagName(t) !== tT.ANNOTATION_XML ||
            this.treeAdapter.getNamespaceURI(t) !== XE.MATHML) &&
            (this.tokenizer.inForeignNode ||
              ((e.tagID === rT.MGLYPH || e.tagID === rT.MALIGNMARK) && !this._isIntegrationPoint(n, t, XE.HTML)))
        )
      }
      _processToken(e) {
        switch (e.type) {
          case RE.CHARACTER:
            this.onCharacter(e)
            break
          case RE.NULL_CHARACTER:
            this.onNullCharacter(e)
            break
          case RE.COMMENT:
            this.onComment(e)
            break
          case RE.DOCTYPE:
            this.onDoctype(e)
            break
          case RE.START_TAG:
            this._processStartTag(e)
            break
          case RE.END_TAG:
            this.onEndTag(e)
            break
          case RE.EOF:
            this.onEof(e)
            break
          case RE.WHITESPACE_CHARACTER:
            this.onWhitespaceCharacter(e)
        }
      }
      _isIntegrationPoint(e, t, n) {
        return (function (e, t, n, r) {
          return (
            ((!r || r === XE.HTML) &&
              (function (e, t, n) {
                if (t === XE.MATHML && e === rT.ANNOTATION_XML)
                  for (let e = 0; e < n.length; e++)
                    if (n[e].name === GE.ENCODING) {
                      const t = n[e].value.toLowerCase()
                      return t === GT || t === KT
                    }
                return t === XE.SVG && (e === rT.FOREIGN_OBJECT || e === rT.DESC || e === rT.TITLE)
              })(e, t, n)) ||
            ((!r || r === XE.MATHML) &&
              (function (e, t) {
                return t === XE.MATHML && (e === rT.MI || e === rT.MO || e === rT.MN || e === rT.MS || e === rT.MTEXT)
              })(e, t))
          )
        })(e, this.treeAdapter.getNamespaceURI(t), this.treeAdapter.getAttrList(t), n)
      }
      _reconstructActiveFormattingElements() {
        const e = this.activeFormattingElements.entries.length
        if (e) {
          const t = this.activeFormattingElements.entries.findIndex(
            (e) => e.type === QT.Marker || this.openElements.contains(e.element),
          )
          for (let n = t < 0 ? e - 1 : t - 1; n >= 0; n--) {
            const e = this.activeFormattingElements.entries[n]
            this._insertElement(e.token, this.treeAdapter.getNamespaceURI(e.element)),
              (e.element = this.openElements.current)
          }
        }
      }
      _closeTableCell() {
        this.openElements.generateImpliedEndTags(),
          this.openElements.popUntilTableCellPopped(),
          this.activeFormattingElements.clearToLastMarker(),
          (this.insertionMode = uA.IN_ROW)
      }
      _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion(rT.P), this.openElements.popUntilTagNamePopped(rT.P)
      }
      _resetInsertionMode() {
        for (let e = this.openElements.stackTop; e >= 0; e--)
          switch (0 === e && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
            case rT.TR:
              return void (this.insertionMode = uA.IN_ROW)
            case rT.TBODY:
            case rT.THEAD:
            case rT.TFOOT:
              return void (this.insertionMode = uA.IN_TABLE_BODY)
            case rT.CAPTION:
              return void (this.insertionMode = uA.IN_CAPTION)
            case rT.COLGROUP:
              return void (this.insertionMode = uA.IN_COLUMN_GROUP)
            case rT.TABLE:
              return void (this.insertionMode = uA.IN_TABLE)
            case rT.BODY:
              return void (this.insertionMode = uA.IN_BODY)
            case rT.FRAMESET:
              return void (this.insertionMode = uA.IN_FRAMESET)
            case rT.SELECT:
              return void this._resetInsertionModeForSelect(e)
            case rT.TEMPLATE:
              return void (this.insertionMode = this.tmplInsertionModeStack[0])
            case rT.HTML:
              return void (this.insertionMode = this.headElement ? uA.AFTER_HEAD : uA.BEFORE_HEAD)
            case rT.TD:
            case rT.TH:
              if (e > 0) return void (this.insertionMode = uA.IN_CELL)
              break
            case rT.HEAD:
              if (e > 0) return void (this.insertionMode = uA.IN_HEAD)
          }
        this.insertionMode = uA.IN_BODY
      }
      _resetInsertionModeForSelect(e) {
        if (e > 0)
          for (let t = e - 1; t > 0; t--) {
            const e = this.openElements.tagIDs[t]
            if (e === rT.TEMPLATE) break
            if (e === rT.TABLE) return void (this.insertionMode = uA.IN_SELECT_IN_TABLE)
          }
        this.insertionMode = uA.IN_SELECT
      }
      _isElementCausesFosterParenting(e) {
        return fA.has(e)
      }
      _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId)
      }
      _findFosterParentingLocation() {
        for (let e = this.openElements.stackTop; e >= 0; e--) {
          const t = this.openElements.items[e]
          switch (this.openElements.tagIDs[e]) {
            case rT.TEMPLATE:
              if (this.treeAdapter.getNamespaceURI(t) === XE.HTML)
                return { parent: this.treeAdapter.getTemplateContent(t), beforeElement: null }
              break
            case rT.TABLE: {
              const n = this.treeAdapter.getParentNode(t)
              return n
                ? { parent: n, beforeElement: t }
                : { parent: this.openElements.items[e - 1], beforeElement: null }
            }
          }
        }
        return { parent: this.openElements.items[0], beforeElement: null }
      }
      _fosterParentElement(e) {
        const t = this._findFosterParentingLocation()
        t.beforeElement
          ? this.treeAdapter.insertBefore(t.parent, e, t.beforeElement)
          : this.treeAdapter.appendChild(t.parent, e)
      }
      _isSpecialElement(e, t) {
        const n = this.treeAdapter.getNamespaceURI(e)
        return hT[n].has(t)
      }
      onCharacter(e) {
        if (((this.skipNextNewLine = !1), this.tokenizer.inForeignNode))
          !(function (e, t) {
            e._insertCharacters(t), (e.framesetOk = !1)
          })(this, e)
        else
          switch (this.insertionMode) {
            case uA.INITIAL:
              EA(this, e)
              break
            case uA.BEFORE_HTML:
              TA(this, e)
              break
            case uA.BEFORE_HEAD:
              AA(this, e)
              break
            case uA.IN_HEAD:
              DA(this, e)
              break
            case uA.IN_HEAD_NO_SCRIPT:
              RA(this, e)
              break
            case uA.AFTER_HEAD:
              NA(this, e)
              break
            case uA.IN_BODY:
            case uA.IN_CAPTION:
            case uA.IN_CELL:
            case uA.IN_TEMPLATE:
              MA(this, e)
              break
            case uA.TEXT:
            case uA.IN_SELECT:
            case uA.IN_SELECT_IN_TABLE:
              this._insertCharacters(e)
              break
            case uA.IN_TABLE:
            case uA.IN_TABLE_BODY:
            case uA.IN_ROW:
              ZA(this, e)
              break
            case uA.IN_TABLE_TEXT:
              YA(this, e)
              break
            case uA.IN_COLUMN_GROUP:
              eC(this, e)
              break
            case uA.AFTER_BODY:
              cC(this, e)
              break
            case uA.AFTER_AFTER_BODY:
              dC(this, e)
          }
      }
      onNullCharacter(e) {
        if (((this.skipNextNewLine = !1), this.tokenizer.inForeignNode))
          !(function (e, t) {
            ;(t.chars = wE), e._insertCharacters(t)
          })(this, e)
        else
          switch (this.insertionMode) {
            case uA.INITIAL:
              EA(this, e)
              break
            case uA.BEFORE_HTML:
              TA(this, e)
              break
            case uA.BEFORE_HEAD:
              AA(this, e)
              break
            case uA.IN_HEAD:
              DA(this, e)
              break
            case uA.IN_HEAD_NO_SCRIPT:
              RA(this, e)
              break
            case uA.AFTER_HEAD:
              NA(this, e)
              break
            case uA.TEXT:
              this._insertCharacters(e)
              break
            case uA.IN_TABLE:
            case uA.IN_TABLE_BODY:
            case uA.IN_ROW:
              ZA(this, e)
              break
            case uA.IN_COLUMN_GROUP:
              eC(this, e)
              break
            case uA.AFTER_BODY:
              cC(this, e)
              break
            case uA.AFTER_AFTER_BODY:
              dC(this, e)
          }
      }
      onComment(e) {
        if (((this.skipNextNewLine = !1), this.currentNotInHTML)) _A(this, e)
        else
          switch (this.insertionMode) {
            case uA.INITIAL:
            case uA.BEFORE_HTML:
            case uA.BEFORE_HEAD:
            case uA.IN_HEAD:
            case uA.IN_HEAD_NO_SCRIPT:
            case uA.AFTER_HEAD:
            case uA.IN_BODY:
            case uA.IN_TABLE:
            case uA.IN_CAPTION:
            case uA.IN_COLUMN_GROUP:
            case uA.IN_TABLE_BODY:
            case uA.IN_ROW:
            case uA.IN_CELL:
            case uA.IN_SELECT:
            case uA.IN_SELECT_IN_TABLE:
            case uA.IN_TEMPLATE:
            case uA.IN_FRAMESET:
            case uA.AFTER_FRAMESET:
              _A(this, e)
              break
            case uA.IN_TABLE_TEXT:
              GA(this, e)
              break
            case uA.AFTER_BODY:
              !(function (e, t) {
                e._appendCommentNode(t, e.openElements.items[0])
              })(this, e)
              break
            case uA.AFTER_AFTER_BODY:
            case uA.AFTER_AFTER_FRAMESET:
              !(function (e, t) {
                e._appendCommentNode(t, e.document)
              })(this, e)
          }
      }
      onDoctype(e) {
        switch (((this.skipNextNewLine = !1), this.insertionMode)) {
          case uA.INITIAL:
            !(function (e, t) {
              e._setDocumentType(t)
              const n = t.forceQuirks
                ? JE.QUIRKS
                : (function (e) {
                    if (e.name !== qT) return JE.QUIRKS
                    const { systemId: t } = e
                    if (t && "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd" === t.toLowerCase())
                      return JE.QUIRKS
                    let { publicId: n } = e
                    if (null !== n) {
                      if (((n = n.toLowerCase()), VT.has(n))) return JE.QUIRKS
                      let e = null === t ? HT : ZT
                      if (YT(n, e)) return JE.QUIRKS
                      if (((e = null === t ? WT : XT), YT(n, e))) return JE.LIMITED_QUIRKS
                    }
                    return JE.NO_QUIRKS
                  })(t)
              ;(function (e) {
                return (
                  e.name === qT && null === e.publicId && (null === e.systemId || "about:legacy-compat" === e.systemId)
                )
              })(t) || e._err(t, PE.nonConformingDoctype),
                e.treeAdapter.setDocumentMode(e.document, n),
                (e.insertionMode = uA.BEFORE_HTML)
            })(this, e)
            break
          case uA.BEFORE_HEAD:
          case uA.IN_HEAD:
          case uA.IN_HEAD_NO_SCRIPT:
          case uA.AFTER_HEAD:
            this._err(e, PE.misplacedDoctype)
            break
          case uA.IN_TABLE_TEXT:
            GA(this, e)
        }
      }
      onStartTag(e) {
        ;(this.skipNextNewLine = !1),
          (this.currentToken = e),
          this._processStartTag(e),
          e.selfClosing && !e.ackSelfClosing && this._err(e, PE.nonVoidHtmlElementStartTagWithTrailingSolidus)
      }
      _processStartTag(e) {
        this.shouldProcessStartTagTokenInForeignContent(e)
          ? (function (e, t) {
              if (
                (function (e) {
                  const t = e.tagID
                  return (
                    (t === rT.FONT &&
                      e.attrs.some(({ name: e }) => e === GE.COLOR || e === GE.SIZE || e === GE.FACE)) ||
                    aA.has(t)
                  )
                })(t)
              )
                uC(e), e._startTagOutsideForeignContent(t)
              else {
                const n = e._getAdjustedCurrentElement(),
                  r = e.treeAdapter.getNamespaceURI(n)
                r === XE.MATHML
                  ? oA(t)
                  : r === XE.SVG &&
                    ((function (e) {
                      const t = rA.get(e.tagName)
                      null != t && ((e.tagName = t), (e.tagID = uT(e.tagName)))
                    })(t),
                    iA(t)),
                  sA(t),
                  t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r),
                  (t.ackSelfClosing = !0)
              }
            })(this, e)
          : this._startTagOutsideForeignContent(e)
      }
      _startTagOutsideForeignContent(e) {
        switch (this.insertionMode) {
          case uA.INITIAL:
            EA(this, e)
            break
          case uA.BEFORE_HTML:
            !(function (e, t) {
              t.tagID === rT.HTML ? (e._insertElement(t, XE.HTML), (e.insertionMode = uA.BEFORE_HEAD)) : TA(e, t)
            })(this, e)
            break
          case uA.BEFORE_HEAD:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HTML:
                  UA(e, t)
                  break
                case rT.HEAD:
                  e._insertElement(t, XE.HTML), (e.headElement = e.openElements.current), (e.insertionMode = uA.IN_HEAD)
                  break
                default:
                  AA(e, t)
              }
            })(this, e)
            break
          case uA.IN_HEAD:
            CA(this, e)
            break
          case uA.IN_HEAD_NO_SCRIPT:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HTML:
                  UA(e, t)
                  break
                case rT.BASEFONT:
                case rT.BGSOUND:
                case rT.HEAD:
                case rT.LINK:
                case rT.META:
                case rT.NOFRAMES:
                case rT.STYLE:
                  CA(e, t)
                  break
                case rT.NOSCRIPT:
                  e._err(t, PE.nestedNoscriptInHead)
                  break
                default:
                  RA(e, t)
              }
            })(this, e)
            break
          case uA.AFTER_HEAD:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HTML:
                  UA(e, t)
                  break
                case rT.BODY:
                  e._insertElement(t, XE.HTML), (e.framesetOk = !1), (e.insertionMode = uA.IN_BODY)
                  break
                case rT.FRAMESET:
                  e._insertElement(t, XE.HTML), (e.insertionMode = uA.IN_FRAMESET)
                  break
                case rT.BASE:
                case rT.BASEFONT:
                case rT.BGSOUND:
                case rT.LINK:
                case rT.META:
                case rT.NOFRAMES:
                case rT.SCRIPT:
                case rT.STYLE:
                case rT.TEMPLATE:
                case rT.TITLE:
                  e._err(t, PE.abandonedHeadElementChild),
                    e.openElements.push(e.headElement, rT.HEAD),
                    CA(e, t),
                    e.openElements.remove(e.headElement)
                  break
                case rT.HEAD:
                  e._err(t, PE.misplacedStartTagForHeadElement)
                  break
                default:
                  NA(e, t)
              }
            })(this, e)
            break
          case uA.IN_BODY:
            UA(this, e)
            break
          case uA.IN_TABLE:
            HA(this, e)
            break
          case uA.IN_TABLE_TEXT:
            GA(this, e)
            break
          case uA.IN_CAPTION:
            !(function (e, t) {
              const n = t.tagID
              KA.has(n)
                ? e.openElements.hasInTableScope(rT.CAPTION) &&
                  (e.openElements.generateImpliedEndTags(),
                  e.openElements.popUntilTagNamePopped(rT.CAPTION),
                  e.activeFormattingElements.clearToLastMarker(),
                  (e.insertionMode = uA.IN_TABLE),
                  HA(e, t))
                : UA(e, t)
            })(this, e)
            break
          case uA.IN_COLUMN_GROUP:
            JA(this, e)
            break
          case uA.IN_TABLE_BODY:
            tC(this, e)
            break
          case uA.IN_ROW:
            rC(this, e)
            break
          case uA.IN_CELL:
            !(function (e, t) {
              const n = t.tagID
              KA.has(n)
                ? (e.openElements.hasInTableScope(rT.TD) || e.openElements.hasInTableScope(rT.TH)) &&
                  (e._closeTableCell(), rC(e, t))
                : UA(e, t)
            })(this, e)
            break
          case uA.IN_SELECT:
            oC(this, e)
            break
          case uA.IN_SELECT_IN_TABLE:
            !(function (e, t) {
              const n = t.tagID
              n === rT.CAPTION ||
              n === rT.TABLE ||
              n === rT.TBODY ||
              n === rT.TFOOT ||
              n === rT.THEAD ||
              n === rT.TR ||
              n === rT.TD ||
              n === rT.TH
                ? (e.openElements.popUntilTagNamePopped(rT.SELECT), e._resetInsertionMode(), e._processStartTag(t))
                : oC(e, t)
            })(this, e)
            break
          case uA.IN_TEMPLATE:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.BASE:
                case rT.BASEFONT:
                case rT.BGSOUND:
                case rT.LINK:
                case rT.META:
                case rT.NOFRAMES:
                case rT.SCRIPT:
                case rT.STYLE:
                case rT.TEMPLATE:
                case rT.TITLE:
                  CA(e, t)
                  break
                case rT.CAPTION:
                case rT.COLGROUP:
                case rT.TBODY:
                case rT.TFOOT:
                case rT.THEAD:
                  ;(e.tmplInsertionModeStack[0] = uA.IN_TABLE), (e.insertionMode = uA.IN_TABLE), HA(e, t)
                  break
                case rT.COL:
                  ;(e.tmplInsertionModeStack[0] = uA.IN_COLUMN_GROUP), (e.insertionMode = uA.IN_COLUMN_GROUP), JA(e, t)
                  break
                case rT.TR:
                  ;(e.tmplInsertionModeStack[0] = uA.IN_TABLE_BODY), (e.insertionMode = uA.IN_TABLE_BODY), tC(e, t)
                  break
                case rT.TD:
                case rT.TH:
                  ;(e.tmplInsertionModeStack[0] = uA.IN_ROW), (e.insertionMode = uA.IN_ROW), rC(e, t)
                  break
                default:
                  ;(e.tmplInsertionModeStack[0] = uA.IN_BODY), (e.insertionMode = uA.IN_BODY), UA(e, t)
              }
            })(this, e)
            break
          case uA.AFTER_BODY:
            !(function (e, t) {
              t.tagID === rT.HTML ? UA(e, t) : cC(e, t)
            })(this, e)
            break
          case uA.IN_FRAMESET:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HTML:
                  UA(e, t)
                  break
                case rT.FRAMESET:
                  e._insertElement(t, XE.HTML)
                  break
                case rT.FRAME:
                  e._appendElement(t, XE.HTML), (t.ackSelfClosing = !0)
                  break
                case rT.NOFRAMES:
                  CA(e, t)
              }
            })(this, e)
            break
          case uA.AFTER_FRAMESET:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HTML:
                  UA(e, t)
                  break
                case rT.NOFRAMES:
                  CA(e, t)
              }
            })(this, e)
            break
          case uA.AFTER_AFTER_BODY:
            !(function (e, t) {
              t.tagID === rT.HTML ? UA(e, t) : dC(e, t)
            })(this, e)
            break
          case uA.AFTER_AFTER_FRAMESET:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HTML:
                  UA(e, t)
                  break
                case rT.NOFRAMES:
                  CA(e, t)
              }
            })(this, e)
        }
      }
      onEndTag(e) {
        ;(this.skipNextNewLine = !1),
          (this.currentToken = e),
          this.currentNotInHTML
            ? (function (e, t) {
                if (t.tagID === rT.P || t.tagID === rT.BR) return uC(e), void e._endTagOutsideForeignContent(t)
                for (let n = e.openElements.stackTop; n > 0; n--) {
                  const r = e.openElements.items[n]
                  if (e.treeAdapter.getNamespaceURI(r) === XE.HTML) {
                    e._endTagOutsideForeignContent(t)
                    break
                  }
                  const a = e.treeAdapter.getTagName(r)
                  if (a.toLowerCase() === t.tagName) {
                    ;(t.tagName = a), e.openElements.shortenToLength(n)
                    break
                  }
                }
              })(this, e)
            : this._endTagOutsideForeignContent(e)
      }
      _endTagOutsideForeignContent(e) {
        switch (this.insertionMode) {
          case uA.INITIAL:
            EA(this, e)
            break
          case uA.BEFORE_HTML:
            !(function (e, t) {
              const n = t.tagID
              ;(n !== rT.HTML && n !== rT.HEAD && n !== rT.BODY && n !== rT.BR) || TA(e, t)
            })(this, e)
            break
          case uA.BEFORE_HEAD:
            !(function (e, t) {
              const n = t.tagID
              n === rT.HEAD || n === rT.BODY || n === rT.HTML || n === rT.BR
                ? AA(e, t)
                : e._err(t, PE.endTagWithoutMatchingOpenElement)
            })(this, e)
            break
          case uA.IN_HEAD:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.HEAD:
                  e.openElements.pop(), (e.insertionMode = uA.AFTER_HEAD)
                  break
                case rT.BODY:
                case rT.BR:
                case rT.HTML:
                  DA(e, t)
                  break
                case rT.TEMPLATE:
                  PA(e, t)
                  break
                default:
                  e._err(t, PE.endTagWithoutMatchingOpenElement)
              }
            })(this, e)
            break
          case uA.IN_HEAD_NO_SCRIPT:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.NOSCRIPT:
                  e.openElements.pop(), (e.insertionMode = uA.IN_HEAD)
                  break
                case rT.BR:
                  RA(e, t)
                  break
                default:
                  e._err(t, PE.endTagWithoutMatchingOpenElement)
              }
            })(this, e)
            break
          case uA.AFTER_HEAD:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.BODY:
                case rT.HTML:
                case rT.BR:
                  NA(e, t)
                  break
                case rT.TEMPLATE:
                  PA(e, t)
                  break
                default:
                  e._err(t, PE.endTagWithoutMatchingOpenElement)
              }
            })(this, e)
            break
          case uA.IN_BODY:
            zA(this, e)
            break
          case uA.TEXT:
            !(function (e, t) {
              var n
              t.tagID === rT.SCRIPT &&
                (null === (n = e.scriptHandler) || void 0 === n || n.call(e, e.openElements.current)),
                e.openElements.pop(),
                (e.insertionMode = e.originalInsertionMode)
            })(this, e)
            break
          case uA.IN_TABLE:
            VA(this, e)
            break
          case uA.IN_TABLE_TEXT:
            GA(this, e)
            break
          case uA.IN_CAPTION:
            !(function (e, t) {
              const n = t.tagID
              switch (n) {
                case rT.CAPTION:
                case rT.TABLE:
                  e.openElements.hasInTableScope(rT.CAPTION) &&
                    (e.openElements.generateImpliedEndTags(),
                    e.openElements.popUntilTagNamePopped(rT.CAPTION),
                    e.activeFormattingElements.clearToLastMarker(),
                    (e.insertionMode = uA.IN_TABLE),
                    n === rT.TABLE && VA(e, t))
                  break
                case rT.BODY:
                case rT.COL:
                case rT.COLGROUP:
                case rT.HTML:
                case rT.TBODY:
                case rT.TD:
                case rT.TFOOT:
                case rT.TH:
                case rT.THEAD:
                case rT.TR:
                  break
                default:
                  zA(e, t)
              }
            })(this, e)
            break
          case uA.IN_COLUMN_GROUP:
            !(function (e, t) {
              switch (t.tagID) {
                case rT.COLGROUP:
                  e.openElements.currentTagId === rT.COLGROUP && (e.openElements.pop(), (e.insertionMode = uA.IN_TABLE))
                  break
                case rT.TEMPLATE:
                  PA(e, t)
                  break
                case rT.COL:
                  break
                default:
                  eC(e, t)
              }
            })(this, e)
            break
          case uA.IN_TABLE_BODY:
            nC(this, e)
            break
          case uA.IN_ROW:
            aC(this, e)
            break
          case uA.IN_CELL:
            !(function (e, t) {
              const n = t.tagID
              switch (n) {
                case rT.TD:
                case rT.TH:
                  e.openElements.hasInTableScope(n) &&
                    (e.openElements.generateImpliedEndTags(),
                    e.openElements.popUntilTagNamePopped(n),
                    e.activeFormattingElements.clearToLastMarker(),
                    (e.insertionMode = uA.IN_ROW))
                  break
                case rT.TABLE:
                case rT.TBODY:
                case rT.TFOOT:
                case rT.THEAD:
                case rT.TR:
                  e.openElements.hasInTableScope(n) && (e._closeTableCell(), aC(e, t))
                  break
                case rT.BODY:
                case rT.CAPTION:
                case rT.COL:
                case rT.COLGROUP:
                case rT.HTML:
                  break
                default:
                  zA(e, t)
              }
            })(this, e)
            break
          case uA.IN_SELECT:
            iC(this, e)
            break
          case uA.IN_SELECT_IN_TABLE:
            !(function (e, t) {
              const n = t.tagID
              n === rT.CAPTION ||
              n === rT.TABLE ||
              n === rT.TBODY ||
              n === rT.TFOOT ||
              n === rT.THEAD ||
              n === rT.TR ||
              n === rT.TD ||
              n === rT.TH
                ? e.openElements.hasInTableScope(n) &&
                  (e.openElements.popUntilTagNamePopped(rT.SELECT), e._resetInsertionMode(), e.onEndTag(t))
                : iC(e, t)
            })(this, e)
            break
          case uA.IN_TEMPLATE:
            !(function (e, t) {
              t.tagID === rT.TEMPLATE && PA(e, t)
            })(this, e)
            break
          case uA.AFTER_BODY:
            lC(this, e)
            break
          case uA.IN_FRAMESET:
            !(function (e, t) {
              t.tagID !== rT.FRAMESET ||
                e.openElements.isRootHtmlElementCurrent() ||
                (e.openElements.pop(),
                e.fragmentContext ||
                  e.openElements.currentTagId === rT.FRAMESET ||
                  (e.insertionMode = uA.AFTER_FRAMESET))
            })(this, e)
            break
          case uA.AFTER_FRAMESET:
            !(function (e, t) {
              t.tagID === rT.HTML && (e.insertionMode = uA.AFTER_AFTER_FRAMESET)
            })(this, e)
            break
          case uA.AFTER_AFTER_BODY:
            dC(this, e)
        }
      }
      onEof(e) {
        switch (this.insertionMode) {
          case uA.INITIAL:
            EA(this, e)
            break
          case uA.BEFORE_HTML:
            TA(this, e)
            break
          case uA.BEFORE_HEAD:
            AA(this, e)
            break
          case uA.IN_HEAD:
            DA(this, e)
            break
          case uA.IN_HEAD_NO_SCRIPT:
            RA(this, e)
            break
          case uA.AFTER_HEAD:
            NA(this, e)
            break
          case uA.IN_BODY:
          case uA.IN_TABLE:
          case uA.IN_CAPTION:
          case uA.IN_COLUMN_GROUP:
          case uA.IN_TABLE_BODY:
          case uA.IN_ROW:
          case uA.IN_CELL:
          case uA.IN_SELECT:
          case uA.IN_SELECT_IN_TABLE:
            qA(this, e)
            break
          case uA.TEXT:
            !(function (e, t) {
              e._err(t, PE.eofInElementThatCanContainOnlyText),
                e.openElements.pop(),
                (e.insertionMode = e.originalInsertionMode),
                e.onEof(t)
            })(this, e)
            break
          case uA.IN_TABLE_TEXT:
            GA(this, e)
            break
          case uA.IN_TEMPLATE:
            sC(this, e)
            break
          case uA.AFTER_BODY:
          case uA.IN_FRAMESET:
          case uA.AFTER_FRAMESET:
          case uA.AFTER_AFTER_BODY:
          case uA.AFTER_AFTER_FRAMESET:
            SA(this, e)
        }
      }
      onWhitespaceCharacter(e) {
        if (this.skipNextNewLine && ((this.skipNextNewLine = !1), e.chars.charCodeAt(0) === xE.LINE_FEED)) {
          if (1 === e.chars.length) return
          e.chars = e.chars.substr(1)
        }
        if (this.tokenizer.inForeignNode) this._insertCharacters(e)
        else
          switch (this.insertionMode) {
            case uA.IN_HEAD:
            case uA.IN_HEAD_NO_SCRIPT:
            case uA.AFTER_HEAD:
            case uA.TEXT:
            case uA.IN_COLUMN_GROUP:
            case uA.IN_SELECT:
            case uA.IN_SELECT_IN_TABLE:
            case uA.IN_FRAMESET:
            case uA.AFTER_FRAMESET:
              this._insertCharacters(e)
              break
            case uA.IN_BODY:
            case uA.IN_CAPTION:
            case uA.IN_CELL:
            case uA.IN_TEMPLATE:
            case uA.AFTER_BODY:
            case uA.AFTER_AFTER_BODY:
            case uA.AFTER_AFTER_FRAMESET:
              IA(this, e)
              break
            case uA.IN_TABLE:
            case uA.IN_TABLE_BODY:
            case uA.IN_ROW:
              ZA(this, e)
              break
            case uA.IN_TABLE_TEXT:
              XA(this, e)
          }
      }
    }
    function bA(e, t) {
      let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName)
      return (
        n
          ? e.openElements.contains(n.element)
            ? e.openElements.hasInScope(t.tagID) || (n = null)
            : (e.activeFormattingElements.removeEntry(n), (n = null))
          : FA(e, t),
        n
      )
    }
    function vA(e, t) {
      let n = null,
        r = e.openElements.stackTop
      for (; r >= 0; r--) {
        const a = e.openElements.items[r]
        if (a === t.element) break
        e._isSpecialElement(a, e.openElements.tagIDs[r]) && (n = a)
      }
      return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n
    }
    function yA(e, t, n) {
      let r = t,
        a = e.openElements.getCommonAncestor(t)
      for (let o = 0, i = a; i !== n; o++, i = a) {
        a = e.openElements.getCommonAncestor(i)
        const n = e.activeFormattingElements.getElementEntry(i),
          s = n && o >= dA
        !n || s
          ? (s && e.activeFormattingElements.removeEntry(n), e.openElements.remove(i))
          : ((i = OA(e, n)),
            r === t && (e.activeFormattingElements.bookmark = n),
            e.treeAdapter.detachNode(r),
            e.treeAdapter.appendChild(i, r),
            (r = i))
      }
      return r
    }
    function OA(e, t) {
      const n = e.treeAdapter.getNamespaceURI(t.element),
        r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs)
      return e.openElements.replace(t.element, r), (t.element = r), r
    }
    function wA(e, t, n) {
      const r = uT(e.treeAdapter.getTagName(t))
      if (e._isElementCausesFosterParenting(r)) e._fosterParentElement(n)
      else {
        const a = e.treeAdapter.getNamespaceURI(t)
        r === rT.TEMPLATE && a === XE.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n)
      }
    }
    function xA(e, t, n) {
      const r = e.treeAdapter.getNamespaceURI(n.element),
        { token: a } = n,
        o = e.treeAdapter.createElement(a.tagName, r, a.attrs)
      e._adoptNodes(t, o),
        e.treeAdapter.appendChild(t, o),
        e.activeFormattingElements.insertElementAfterBookmark(o, a),
        e.activeFormattingElements.removeEntry(n),
        e.openElements.remove(n.element),
        e.openElements.insertAfter(t, o, a.tagID)
    }
    function kA(e, t) {
      for (let n = 0; n < cA; n++) {
        const n = bA(e, t)
        if (!n) break
        const r = vA(e, n)
        if (!r) break
        e.activeFormattingElements.bookmark = n
        const a = yA(e, r, n.element),
          o = e.openElements.getCommonAncestor(n.element)
        e.treeAdapter.detachNode(a), o && wA(e, o, a), xA(e, r, n)
      }
    }
    function _A(e, t) {
      e._appendCommentNode(t, e.openElements.currentTmplContentOrNode)
    }
    function SA(e, t) {
      if (((e.stopped = !0), t.location)) {
        const n = e.fragmentContext ? 0 : 2
        for (let r = e.openElements.stackTop; r >= n; r--) e._setEndLocation(e.openElements.items[r], t)
        if (!e.fragmentContext && e.openElements.stackTop >= 0) {
          const n = e.openElements.items[0],
            r = e.treeAdapter.getNodeSourceCodeLocation(n)
          if (r && !r.endTag && (e._setEndLocation(n, t), e.openElements.stackTop >= 1)) {
            const n = e.openElements.items[1],
              r = e.treeAdapter.getNodeSourceCodeLocation(n)
            r && !r.endTag && e._setEndLocation(n, t)
          }
        }
      }
    }
    function EA(e, t) {
      e._err(t, PE.missingDoctype, !0),
        e.treeAdapter.setDocumentMode(e.document, JE.QUIRKS),
        (e.insertionMode = uA.BEFORE_HTML),
        e._processToken(t)
    }
    function TA(e, t) {
      e._insertFakeRootElement(), (e.insertionMode = uA.BEFORE_HEAD), e._processToken(t)
    }
    function AA(e, t) {
      e._insertFakeElement(tT.HEAD, rT.HEAD),
        (e.headElement = e.openElements.current),
        (e.insertionMode = uA.IN_HEAD),
        e._processToken(t)
    }
    function CA(e, t) {
      switch (t.tagID) {
        case rT.HTML:
          UA(e, t)
          break
        case rT.BASE:
        case rT.BASEFONT:
        case rT.BGSOUND:
        case rT.LINK:
        case rT.META:
          e._appendElement(t, XE.HTML), (t.ackSelfClosing = !0)
          break
        case rT.TITLE:
          e._switchToTextParsing(t, vT.RCDATA)
          break
        case rT.NOSCRIPT:
          e.options.scriptingEnabled
            ? e._switchToTextParsing(t, vT.RAWTEXT)
            : (e._insertElement(t, XE.HTML), (e.insertionMode = uA.IN_HEAD_NO_SCRIPT))
          break
        case rT.NOFRAMES:
        case rT.STYLE:
          e._switchToTextParsing(t, vT.RAWTEXT)
          break
        case rT.SCRIPT:
          e._switchToTextParsing(t, vT.SCRIPT_DATA)
          break
        case rT.TEMPLATE:
          e._insertTemplate(t),
            e.activeFormattingElements.insertMarker(),
            (e.framesetOk = !1),
            (e.insertionMode = uA.IN_TEMPLATE),
            e.tmplInsertionModeStack.unshift(uA.IN_TEMPLATE)
          break
        case rT.HEAD:
          e._err(t, PE.misplacedStartTagForHeadElement)
          break
        default:
          DA(e, t)
      }
    }
    function PA(e, t) {
      e.openElements.tmplCount > 0
        ? (e.openElements.generateImpliedEndTagsThoroughly(),
          e.openElements.currentTagId !== rT.TEMPLATE && e._err(t, PE.closingOfElementWithOpenChildElements),
          e.openElements.popUntilTagNamePopped(rT.TEMPLATE),
          e.activeFormattingElements.clearToLastMarker(),
          e.tmplInsertionModeStack.shift(),
          e._resetInsertionMode())
        : e._err(t, PE.endTagWithoutMatchingOpenElement)
    }
    function DA(e, t) {
      e.openElements.pop(), (e.insertionMode = uA.AFTER_HEAD), e._processToken(t)
    }
    function RA(e, t) {
      const n = t.type === RE.EOF ? PE.openElementsLeftAfterEof : PE.disallowedContentInNoscriptInHead
      e._err(t, n), e.openElements.pop(), (e.insertionMode = uA.IN_HEAD), e._processToken(t)
    }
    function NA(e, t) {
      e._insertFakeElement(tT.BODY, rT.BODY), (e.insertionMode = uA.IN_BODY), $A(e, t)
    }
    function $A(e, t) {
      switch (t.type) {
        case RE.CHARACTER:
          MA(e, t)
          break
        case RE.WHITESPACE_CHARACTER:
          IA(e, t)
          break
        case RE.COMMENT:
          _A(e, t)
          break
        case RE.START_TAG:
          UA(e, t)
          break
        case RE.END_TAG:
          zA(e, t)
          break
        case RE.EOF:
          qA(e, t)
      }
    }
    function IA(e, t) {
      e._reconstructActiveFormattingElements(), e._insertCharacters(t)
    }
    function MA(e, t) {
      e._reconstructActiveFormattingElements(), e._insertCharacters(t), (e.framesetOk = !1)
    }
    function LA(e, t) {
      e._reconstructActiveFormattingElements(),
        e._appendElement(t, XE.HTML),
        (e.framesetOk = !1),
        (t.ackSelfClosing = !0)
    }
    function QA(e) {
      const t = IE(e, GE.TYPE)
      return null != t && t.toLowerCase() === lA
    }
    function BA(e, t) {
      e._switchToTextParsing(t, vT.RAWTEXT)
    }
    function jA(e, t) {
      e._reconstructActiveFormattingElements(), e._insertElement(t, XE.HTML)
    }
    function UA(e, t) {
      switch (t.tagID) {
        case rT.I:
        case rT.S:
        case rT.B:
        case rT.U:
        case rT.EM:
        case rT.TT:
        case rT.BIG:
        case rT.CODE:
        case rT.FONT:
        case rT.SMALL:
        case rT.STRIKE:
        case rT.STRONG:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              e._insertElement(t, XE.HTML),
              e.activeFormattingElements.pushElement(e.openElements.current, t)
          })(e, t)
          break
        case rT.A:
          !(function (e, t) {
            const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(tT.A)
            n && (kA(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)),
              e._reconstructActiveFormattingElements(),
              e._insertElement(t, XE.HTML),
              e.activeFormattingElements.pushElement(e.openElements.current, t)
          })(e, t)
          break
        case rT.H1:
        case rT.H2:
        case rT.H3:
        case rT.H4:
        case rT.H5:
        case rT.H6:
          !(function (e, t) {
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(),
              fT(e.openElements.currentTagId) && e.openElements.pop(),
              e._insertElement(t, XE.HTML)
          })(e, t)
          break
        case rT.P:
        case rT.DL:
        case rT.OL:
        case rT.UL:
        case rT.DIV:
        case rT.DIR:
        case rT.NAV:
        case rT.MAIN:
        case rT.MENU:
        case rT.ASIDE:
        case rT.CENTER:
        case rT.FIGURE:
        case rT.FOOTER:
        case rT.HEADER:
        case rT.HGROUP:
        case rT.DIALOG:
        case rT.DETAILS:
        case rT.ADDRESS:
        case rT.ARTICLE:
        case rT.SECTION:
        case rT.SUMMARY:
        case rT.FIELDSET:
        case rT.BLOCKQUOTE:
        case rT.FIGCAPTION:
          !(function (e, t) {
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(), e._insertElement(t, XE.HTML)
          })(e, t)
          break
        case rT.LI:
        case rT.DD:
        case rT.DT:
          !(function (e, t) {
            e.framesetOk = !1
            const n = t.tagID
            for (let t = e.openElements.stackTop; t >= 0; t--) {
              const r = e.openElements.tagIDs[t]
              if ((n === rT.LI && r === rT.LI) || ((n === rT.DD || n === rT.DT) && (r === rT.DD || r === rT.DT))) {
                e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.popUntilTagNamePopped(r)
                break
              }
              if (r !== rT.ADDRESS && r !== rT.DIV && r !== rT.P && e._isSpecialElement(e.openElements.items[t], r))
                break
            }
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(), e._insertElement(t, XE.HTML)
          })(e, t)
          break
        case rT.BR:
        case rT.IMG:
        case rT.WBR:
        case rT.AREA:
        case rT.EMBED:
        case rT.KEYGEN:
          LA(e, t)
          break
        case rT.HR:
          !(function (e, t) {
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(),
              e._appendElement(t, XE.HTML),
              (e.framesetOk = !1),
              (t.ackSelfClosing = !0)
          })(e, t)
          break
        case rT.RB:
        case rT.RTC:
          !(function (e, t) {
            e.openElements.hasInScope(rT.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, XE.HTML)
          })(e, t)
          break
        case rT.RT:
        case rT.RP:
          !(function (e, t) {
            e.openElements.hasInScope(rT.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(rT.RTC),
              e._insertElement(t, XE.HTML)
          })(e, t)
          break
        case rT.PRE:
        case rT.LISTING:
          !(function (e, t) {
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(),
              e._insertElement(t, XE.HTML),
              (e.skipNextNewLine = !0),
              (e.framesetOk = !1)
          })(e, t)
          break
        case rT.XMP:
          !(function (e, t) {
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(),
              e._reconstructActiveFormattingElements(),
              (e.framesetOk = !1),
              e._switchToTextParsing(t, vT.RAWTEXT)
          })(e, t)
          break
        case rT.SVG:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              iA(t),
              sA(t),
              t.selfClosing ? e._appendElement(t, XE.SVG) : e._insertElement(t, XE.SVG),
              (t.ackSelfClosing = !0)
          })(e, t)
          break
        case rT.HTML:
          !(function (e, t) {
            0 === e.openElements.tmplCount && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs)
          })(e, t)
          break
        case rT.BASE:
        case rT.LINK:
        case rT.META:
        case rT.STYLE:
        case rT.TITLE:
        case rT.SCRIPT:
        case rT.BGSOUND:
        case rT.BASEFONT:
        case rT.TEMPLATE:
          CA(e, t)
          break
        case rT.BODY:
          !(function (e, t) {
            const n = e.openElements.tryPeekProperlyNestedBodyElement()
            n && 0 === e.openElements.tmplCount && ((e.framesetOk = !1), e.treeAdapter.adoptAttributes(n, t.attrs))
          })(e, t)
          break
        case rT.FORM:
          !(function (e, t) {
            const n = e.openElements.tmplCount > 0
            ;(e.formElement && !n) ||
              (e.openElements.hasInButtonScope(rT.P) && e._closePElement(),
              e._insertElement(t, XE.HTML),
              n || (e.formElement = e.openElements.current))
          })(e, t)
          break
        case rT.NOBR:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              e.openElements.hasInScope(rT.NOBR) && (kA(e, t), e._reconstructActiveFormattingElements()),
              e._insertElement(t, XE.HTML),
              e.activeFormattingElements.pushElement(e.openElements.current, t)
          })(e, t)
          break
        case rT.MATH:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              oA(t),
              sA(t),
              t.selfClosing ? e._appendElement(t, XE.MATHML) : e._insertElement(t, XE.MATHML),
              (t.ackSelfClosing = !0)
          })(e, t)
          break
        case rT.TABLE:
          !(function (e, t) {
            e.treeAdapter.getDocumentMode(e.document) !== JE.QUIRKS &&
              e.openElements.hasInButtonScope(rT.P) &&
              e._closePElement(),
              e._insertElement(t, XE.HTML),
              (e.framesetOk = !1),
              (e.insertionMode = uA.IN_TABLE)
          })(e, t)
          break
        case rT.INPUT:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              e._appendElement(t, XE.HTML),
              QA(t) || (e.framesetOk = !1),
              (t.ackSelfClosing = !0)
          })(e, t)
          break
        case rT.PARAM:
        case rT.TRACK:
        case rT.SOURCE:
          !(function (e, t) {
            e._appendElement(t, XE.HTML), (t.ackSelfClosing = !0)
          })(e, t)
          break
        case rT.IMAGE:
          !(function (e, t) {
            ;(t.tagName = tT.IMG), (t.tagID = rT.IMG), LA(e, t)
          })(e, t)
          break
        case rT.BUTTON:
          !(function (e, t) {
            e.openElements.hasInScope(rT.BUTTON) &&
              (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(rT.BUTTON)),
              e._reconstructActiveFormattingElements(),
              e._insertElement(t, XE.HTML),
              (e.framesetOk = !1)
          })(e, t)
          break
        case rT.APPLET:
        case rT.OBJECT:
        case rT.MARQUEE:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              e._insertElement(t, XE.HTML),
              e.activeFormattingElements.insertMarker(),
              (e.framesetOk = !1)
          })(e, t)
          break
        case rT.IFRAME:
          !(function (e, t) {
            ;(e.framesetOk = !1), e._switchToTextParsing(t, vT.RAWTEXT)
          })(e, t)
          break
        case rT.SELECT:
          !(function (e, t) {
            e._reconstructActiveFormattingElements(),
              e._insertElement(t, XE.HTML),
              (e.framesetOk = !1),
              (e.insertionMode =
                e.insertionMode === uA.IN_TABLE ||
                e.insertionMode === uA.IN_CAPTION ||
                e.insertionMode === uA.IN_TABLE_BODY ||
                e.insertionMode === uA.IN_ROW ||
                e.insertionMode === uA.IN_CELL
                  ? uA.IN_SELECT_IN_TABLE
                  : uA.IN_SELECT)
          })(e, t)
          break
        case rT.OPTION:
        case rT.OPTGROUP:
          !(function (e, t) {
            e.openElements.currentTagId === rT.OPTION && e.openElements.pop(),
              e._reconstructActiveFormattingElements(),
              e._insertElement(t, XE.HTML)
          })(e, t)
          break
        case rT.NOEMBED:
          BA(e, t)
          break
        case rT.FRAMESET:
          !(function (e, t) {
            const n = e.openElements.tryPeekProperlyNestedBodyElement()
            e.framesetOk &&
              n &&
              (e.treeAdapter.detachNode(n),
              e.openElements.popAllUpToHtmlElement(),
              e._insertElement(t, XE.HTML),
              (e.insertionMode = uA.IN_FRAMESET))
          })(e, t)
          break
        case rT.TEXTAREA:
          !(function (e, t) {
            e._insertElement(t, XE.HTML),
              (e.skipNextNewLine = !0),
              (e.tokenizer.state = vT.RCDATA),
              (e.originalInsertionMode = e.insertionMode),
              (e.framesetOk = !1),
              (e.insertionMode = uA.TEXT)
          })(e, t)
          break
        case rT.NOSCRIPT:
          e.options.scriptingEnabled ? BA(e, t) : jA(e, t)
          break
        case rT.PLAINTEXT:
          !(function (e, t) {
            e.openElements.hasInButtonScope(rT.P) && e._closePElement(),
              e._insertElement(t, XE.HTML),
              (e.tokenizer.state = vT.PLAINTEXT)
          })(e, t)
          break
        case rT.COL:
        case rT.TH:
        case rT.TD:
        case rT.TR:
        case rT.HEAD:
        case rT.FRAME:
        case rT.TBODY:
        case rT.TFOOT:
        case rT.THEAD:
        case rT.CAPTION:
        case rT.COLGROUP:
          break
        default:
          jA(e, t)
      }
    }
    function FA(e, t) {
      const n = t.tagName,
        r = t.tagID
      for (let t = e.openElements.stackTop; t > 0; t--) {
        const a = e.openElements.items[t],
          o = e.openElements.tagIDs[t]
        if (r === o && (r !== rT.UNKNOWN || e.treeAdapter.getTagName(a) === n)) {
          e.openElements.generateImpliedEndTagsWithExclusion(r),
            e.openElements.stackTop >= t && e.openElements.shortenToLength(t)
          break
        }
        if (e._isSpecialElement(a, o)) break
      }
    }
    function zA(e, t) {
      switch (t.tagID) {
        case rT.A:
        case rT.B:
        case rT.I:
        case rT.S:
        case rT.U:
        case rT.EM:
        case rT.TT:
        case rT.BIG:
        case rT.CODE:
        case rT.FONT:
        case rT.NOBR:
        case rT.SMALL:
        case rT.STRIKE:
        case rT.STRONG:
          kA(e, t)
          break
        case rT.P:
          !(function (e) {
            e.openElements.hasInButtonScope(rT.P) || e._insertFakeElement(tT.P, rT.P), e._closePElement()
          })(e)
          break
        case rT.DL:
        case rT.UL:
        case rT.OL:
        case rT.DIR:
        case rT.DIV:
        case rT.NAV:
        case rT.PRE:
        case rT.MAIN:
        case rT.MENU:
        case rT.ASIDE:
        case rT.BUTTON:
        case rT.CENTER:
        case rT.FIGURE:
        case rT.FOOTER:
        case rT.HEADER:
        case rT.HGROUP:
        case rT.DIALOG:
        case rT.ADDRESS:
        case rT.ARTICLE:
        case rT.DETAILS:
        case rT.SECTION:
        case rT.SUMMARY:
        case rT.LISTING:
        case rT.FIELDSET:
        case rT.BLOCKQUOTE:
        case rT.FIGCAPTION:
          !(function (e, t) {
            const n = t.tagID
            e.openElements.hasInScope(n) &&
              (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n))
          })(e, t)
          break
        case rT.LI:
          !(function (e) {
            e.openElements.hasInListItemScope(rT.LI) &&
              (e.openElements.generateImpliedEndTagsWithExclusion(rT.LI), e.openElements.popUntilTagNamePopped(rT.LI))
          })(e)
          break
        case rT.DD:
        case rT.DT:
          !(function (e, t) {
            const n = t.tagID
            e.openElements.hasInScope(n) &&
              (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n))
          })(e, t)
          break
        case rT.H1:
        case rT.H2:
        case rT.H3:
        case rT.H4:
        case rT.H5:
        case rT.H6:
          !(function (e) {
            e.openElements.hasNumberedHeaderInScope() &&
              (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped())
          })(e)
          break
        case rT.BR:
          !(function (e) {
            e._reconstructActiveFormattingElements(),
              e._insertFakeElement(tT.BR, rT.BR),
              e.openElements.pop(),
              (e.framesetOk = !1)
          })(e)
          break
        case rT.BODY:
          !(function (e, t) {
            if (
              e.openElements.hasInScope(rT.BODY) &&
              ((e.insertionMode = uA.AFTER_BODY), e.options.sourceCodeLocationInfo)
            ) {
              const n = e.openElements.tryPeekProperlyNestedBodyElement()
              n && e._setEndLocation(n, t)
            }
          })(e, t)
          break
        case rT.HTML:
          !(function (e, t) {
            e.openElements.hasInScope(rT.BODY) && ((e.insertionMode = uA.AFTER_BODY), lC(e, t))
          })(e, t)
          break
        case rT.FORM:
          !(function (e) {
            const t = e.openElements.tmplCount > 0,
              { formElement: n } = e
            t || (e.formElement = null),
              (n || t) &&
                e.openElements.hasInScope(rT.FORM) &&
                (e.openElements.generateImpliedEndTags(),
                t ? e.openElements.popUntilTagNamePopped(rT.FORM) : n && e.openElements.remove(n))
          })(e)
          break
        case rT.APPLET:
        case rT.OBJECT:
        case rT.MARQUEE:
          !(function (e, t) {
            const n = t.tagID
            e.openElements.hasInScope(n) &&
              (e.openElements.generateImpliedEndTags(),
              e.openElements.popUntilTagNamePopped(n),
              e.activeFormattingElements.clearToLastMarker())
          })(e, t)
          break
        case rT.TEMPLATE:
          PA(e, t)
          break
        default:
          FA(e, t)
      }
    }
    function qA(e, t) {
      e.tmplInsertionModeStack.length > 0 ? sC(e, t) : SA(e, t)
    }
    function ZA(e, t) {
      if (fA.has(e.openElements.currentTagId))
        switch (
          ((e.pendingCharacterTokens.length = 0),
          (e.hasNonWhitespacePendingCharacterToken = !1),
          (e.originalInsertionMode = e.insertionMode),
          (e.insertionMode = uA.IN_TABLE_TEXT),
          t.type)
        ) {
          case RE.CHARACTER:
            YA(e, t)
            break
          case RE.WHITESPACE_CHARACTER:
            XA(e, t)
        }
      else WA(e, t)
    }
    function HA(e, t) {
      switch (t.tagID) {
        case rT.TD:
        case rT.TH:
        case rT.TR:
          !(function (e, t) {
            e.openElements.clearBackToTableContext(),
              e._insertFakeElement(tT.TBODY, rT.TBODY),
              (e.insertionMode = uA.IN_TABLE_BODY),
              tC(e, t)
          })(e, t)
          break
        case rT.STYLE:
        case rT.SCRIPT:
        case rT.TEMPLATE:
          CA(e, t)
          break
        case rT.COL:
          !(function (e, t) {
            e.openElements.clearBackToTableContext(),
              e._insertFakeElement(tT.COLGROUP, rT.COLGROUP),
              (e.insertionMode = uA.IN_COLUMN_GROUP),
              JA(e, t)
          })(e, t)
          break
        case rT.FORM:
          !(function (e, t) {
            e.formElement ||
              0 !== e.openElements.tmplCount ||
              (e._insertElement(t, XE.HTML), (e.formElement = e.openElements.current), e.openElements.pop())
          })(e, t)
          break
        case rT.TABLE:
          !(function (e, t) {
            e.openElements.hasInTableScope(rT.TABLE) &&
              (e.openElements.popUntilTagNamePopped(rT.TABLE), e._resetInsertionMode(), e._processStartTag(t))
          })(e, t)
          break
        case rT.TBODY:
        case rT.TFOOT:
        case rT.THEAD:
          !(function (e, t) {
            e.openElements.clearBackToTableContext(), e._insertElement(t, XE.HTML), (e.insertionMode = uA.IN_TABLE_BODY)
          })(e, t)
          break
        case rT.INPUT:
          !(function (e, t) {
            QA(t) ? e._appendElement(t, XE.HTML) : WA(e, t), (t.ackSelfClosing = !0)
          })(e, t)
          break
        case rT.CAPTION:
          !(function (e, t) {
            e.openElements.clearBackToTableContext(),
              e.activeFormattingElements.insertMarker(),
              e._insertElement(t, XE.HTML),
              (e.insertionMode = uA.IN_CAPTION)
          })(e, t)
          break
        case rT.COLGROUP:
          !(function (e, t) {
            e.openElements.clearBackToTableContext(),
              e._insertElement(t, XE.HTML),
              (e.insertionMode = uA.IN_COLUMN_GROUP)
          })(e, t)
          break
        default:
          WA(e, t)
      }
    }
    function VA(e, t) {
      switch (t.tagID) {
        case rT.TABLE:
          e.openElements.hasInTableScope(rT.TABLE) &&
            (e.openElements.popUntilTagNamePopped(rT.TABLE), e._resetInsertionMode())
          break
        case rT.TEMPLATE:
          PA(e, t)
          break
        case rT.BODY:
        case rT.CAPTION:
        case rT.COL:
        case rT.COLGROUP:
        case rT.HTML:
        case rT.TBODY:
        case rT.TD:
        case rT.TFOOT:
        case rT.TH:
        case rT.THEAD:
        case rT.TR:
          break
        default:
          WA(e, t)
      }
    }
    function WA(e, t) {
      const n = e.fosterParentingEnabled
      ;(e.fosterParentingEnabled = !0), $A(e, t), (e.fosterParentingEnabled = n)
    }
    function XA(e, t) {
      e.pendingCharacterTokens.push(t)
    }
    function YA(e, t) {
      e.pendingCharacterTokens.push(t), (e.hasNonWhitespacePendingCharacterToken = !0)
    }
    function GA(e, t) {
      let n = 0
      if (e.hasNonWhitespacePendingCharacterToken)
        for (; n < e.pendingCharacterTokens.length; n++) WA(e, e.pendingCharacterTokens[n])
      else for (; n < e.pendingCharacterTokens.length; n++) e._insertCharacters(e.pendingCharacterTokens[n])
      ;(e.insertionMode = e.originalInsertionMode), e._processToken(t)
    }
    const KA = new Set([rT.CAPTION, rT.COL, rT.COLGROUP, rT.TBODY, rT.TD, rT.TFOOT, rT.TH, rT.THEAD, rT.TR])
    function JA(e, t) {
      switch (t.tagID) {
        case rT.HTML:
          UA(e, t)
          break
        case rT.COL:
          e._appendElement(t, XE.HTML), (t.ackSelfClosing = !0)
          break
        case rT.TEMPLATE:
          CA(e, t)
          break
        default:
          eC(e, t)
      }
    }
    function eC(e, t) {
      e.openElements.currentTagId === rT.COLGROUP &&
        (e.openElements.pop(), (e.insertionMode = uA.IN_TABLE), e._processToken(t))
    }
    function tC(e, t) {
      switch (t.tagID) {
        case rT.TR:
          e.openElements.clearBackToTableBodyContext(), e._insertElement(t, XE.HTML), (e.insertionMode = uA.IN_ROW)
          break
        case rT.TH:
        case rT.TD:
          e.openElements.clearBackToTableBodyContext(),
            e._insertFakeElement(tT.TR, rT.TR),
            (e.insertionMode = uA.IN_ROW),
            rC(e, t)
          break
        case rT.CAPTION:
        case rT.COL:
        case rT.COLGROUP:
        case rT.TBODY:
        case rT.TFOOT:
        case rT.THEAD:
          e.openElements.hasTableBodyContextInTableScope() &&
            (e.openElements.clearBackToTableBodyContext(),
            e.openElements.pop(),
            (e.insertionMode = uA.IN_TABLE),
            HA(e, t))
          break
        default:
          HA(e, t)
      }
    }
    function nC(e, t) {
      const n = t.tagID
      switch (t.tagID) {
        case rT.TBODY:
        case rT.TFOOT:
        case rT.THEAD:
          e.openElements.hasInTableScope(n) &&
            (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), (e.insertionMode = uA.IN_TABLE))
          break
        case rT.TABLE:
          e.openElements.hasTableBodyContextInTableScope() &&
            (e.openElements.clearBackToTableBodyContext(),
            e.openElements.pop(),
            (e.insertionMode = uA.IN_TABLE),
            VA(e, t))
          break
        case rT.BODY:
        case rT.CAPTION:
        case rT.COL:
        case rT.COLGROUP:
        case rT.HTML:
        case rT.TD:
        case rT.TH:
        case rT.TR:
          break
        default:
          VA(e, t)
      }
    }
    function rC(e, t) {
      switch (t.tagID) {
        case rT.TH:
        case rT.TD:
          e.openElements.clearBackToTableRowContext(),
            e._insertElement(t, XE.HTML),
            (e.insertionMode = uA.IN_CELL),
            e.activeFormattingElements.insertMarker()
          break
        case rT.CAPTION:
        case rT.COL:
        case rT.COLGROUP:
        case rT.TBODY:
        case rT.TFOOT:
        case rT.THEAD:
        case rT.TR:
          e.openElements.hasInTableScope(rT.TR) &&
            (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            (e.insertionMode = uA.IN_TABLE_BODY),
            tC(e, t))
          break
        default:
          HA(e, t)
      }
    }
    function aC(e, t) {
      switch (t.tagID) {
        case rT.TR:
          e.openElements.hasInTableScope(rT.TR) &&
            (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), (e.insertionMode = uA.IN_TABLE_BODY))
          break
        case rT.TABLE:
          e.openElements.hasInTableScope(rT.TR) &&
            (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            (e.insertionMode = uA.IN_TABLE_BODY),
            nC(e, t))
          break
        case rT.TBODY:
        case rT.TFOOT:
        case rT.THEAD:
          ;(e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(rT.TR)) &&
            (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            (e.insertionMode = uA.IN_TABLE_BODY),
            nC(e, t))
          break
        case rT.BODY:
        case rT.CAPTION:
        case rT.COL:
        case rT.COLGROUP:
        case rT.HTML:
        case rT.TD:
        case rT.TH:
          break
        default:
          VA(e, t)
      }
    }
    function oC(e, t) {
      switch (t.tagID) {
        case rT.HTML:
          UA(e, t)
          break
        case rT.OPTION:
          e.openElements.currentTagId === rT.OPTION && e.openElements.pop(), e._insertElement(t, XE.HTML)
          break
        case rT.OPTGROUP:
          e.openElements.currentTagId === rT.OPTION && e.openElements.pop(),
            e.openElements.currentTagId === rT.OPTGROUP && e.openElements.pop(),
            e._insertElement(t, XE.HTML)
          break
        case rT.INPUT:
        case rT.KEYGEN:
        case rT.TEXTAREA:
        case rT.SELECT:
          e.openElements.hasInSelectScope(rT.SELECT) &&
            (e.openElements.popUntilTagNamePopped(rT.SELECT),
            e._resetInsertionMode(),
            t.tagID !== rT.SELECT && e._processStartTag(t))
          break
        case rT.SCRIPT:
        case rT.TEMPLATE:
          CA(e, t)
      }
    }
    function iC(e, t) {
      switch (t.tagID) {
        case rT.OPTGROUP:
          e.openElements.stackTop > 0 &&
            e.openElements.currentTagId === rT.OPTION &&
            e.openElements.tagIDs[e.openElements.stackTop - 1] === rT.OPTGROUP &&
            e.openElements.pop(),
            e.openElements.currentTagId === rT.OPTGROUP && e.openElements.pop()
          break
        case rT.OPTION:
          e.openElements.currentTagId === rT.OPTION && e.openElements.pop()
          break
        case rT.SELECT:
          e.openElements.hasInSelectScope(rT.SELECT) &&
            (e.openElements.popUntilTagNamePopped(rT.SELECT), e._resetInsertionMode())
          break
        case rT.TEMPLATE:
          PA(e, t)
      }
    }
    function sC(e, t) {
      e.openElements.tmplCount > 0
        ? (e.openElements.popUntilTagNamePopped(rT.TEMPLATE),
          e.activeFormattingElements.clearToLastMarker(),
          e.tmplInsertionModeStack.shift(),
          e._resetInsertionMode(),
          e.onEof(t))
        : SA(e, t)
    }
    function lC(e, t) {
      var n
      if (t.tagID === rT.HTML) {
        if (
          (e.fragmentContext || (e.insertionMode = uA.AFTER_AFTER_BODY),
          e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === rT.HTML)
        ) {
          e._setEndLocation(e.openElements.items[0], t)
          const r = e.openElements.items[1]
          r &&
            !(null === (n = e.treeAdapter.getNodeSourceCodeLocation(r)) || void 0 === n ? void 0 : n.endTag) &&
            e._setEndLocation(r, t)
        }
      } else cC(e, t)
    }
    function cC(e, t) {
      ;(e.insertionMode = uA.IN_BODY), $A(e, t)
    }
    function dC(e, t) {
      ;(e.insertionMode = uA.IN_BODY), $A(e, t)
    }
    function uC(e) {
      for (
        ;
        e.treeAdapter.getNamespaceURI(e.openElements.current) !== XE.HTML &&
        !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);

      )
        e.openElements.pop()
    }
    function pC(e, t) {
      return gA.parse(e, t)
    }
    function hC(e, t, n) {
      "string" == typeof e && ((n = t), (t = e), (e = null))
      const r = gA.getFragmentParser(e, n)
      return r.tokenizer.write(t, !0), r.getFragment()
    }
    tT.AREA,
      tT.BASE,
      tT.BASEFONT,
      tT.BGSOUND,
      tT.BR,
      tT.COL,
      tT.EMBED,
      tT.FRAME,
      tT.HR,
      tT.IMG,
      tT.INPUT,
      tT.KEYGEN,
      tT.LINK,
      tT.META,
      tT.PARAM,
      tT.SOURCE,
      tT.TRACK,
      tT.WBR
    const fC = gC("end"),
      mC = gC("start")
    function gC(e) {
      return function (t) {
        const n = (t && t.position && t.position[e]) || {}
        if ("number" == typeof n.line && n.line > 0 && "number" == typeof n.column && n.column > 0)
          return {
            line: n.line,
            column: n.column,
            offset: "number" == typeof n.offset && n.offset > -1 ? n.offset : void 0,
          }
      }
    }
    function bC(e) {
      const t = mC(e),
        n = fC(e)
      if (t && n) return { start: t, end: n }
    }
    const vC = new Set([
        "mdxFlowExpression",
        "mdxJsxFlowElement",
        "mdxJsxTextElement",
        "mdxTextExpression",
        "mdxjsEsm",
      ]),
      yC = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }
    function OC(e, t) {
      const n = (function (e) {
          const t = "root" === e.type ? e.children[0] : e
          return Boolean(t && ("doctype" === t.type || ("element" === t.type && "html" === t.tagName.toLowerCase())))
        })(e),
        r = pE("type", {
          handlers: { root: xC, element: kC, text: _C, comment: EC, doctype: SC, raw: TC },
          unknown: AC,
        }),
        a = {
          parser: n ? new gA(yC) : gA.getFragmentParser(void 0, yC),
          handle(e) {
            r(e, a)
          },
          stitches: !1,
          options: t || {},
        }
      r(e, a), CC(a, mC())
      const o = oE(n ? a.parser.document : a.parser.getFragment(), { file: a.options.file })
      return (
        a.stitches &&
          m_(o, "comment", function (e, t, n) {
            const r = e
            if (r.value.stitch && n && void 0 !== t) return (n.children[t] = r.value.stitch), t
          }),
        "root" === o.type && 1 === o.children.length && o.children[0].type === e.type ? o.children[0] : o
      )
    }
    function wC(e, t) {
      let n = -1
      if (e) for (; ++n < e.length; ) t.handle(e[n])
    }
    function xC(e, t) {
      wC(e.children, t)
    }
    function kC(e, t) {
      !(function (e, t) {
        const n = e.tagName.toLowerCase()
        if (t.parser.tokenizer.state === vT.PLAINTEXT) return
        CC(t, mC(e))
        const r = t.parser.openElements.current
        let a = "namespaceURI" in r ? r.namespaceURI : nE.html
        a === nE.html && "svg" === n && (a = nE.svg)
        const o = (function (e, t) {
            const n = (t || hE).space
            return mE(e, "svg" === n ? zS : FS)
          })({ ...e, children: [] }, { space: a === nE.svg ? "svg" : "html" }),
          i = {
            type: RE.START_TAG,
            tagName: n,
            tagID: uT(n),
            selfClosing: !1,
            ackSelfClosing: !1,
            attrs: "attrs" in o ? o.attrs : [],
            location: DC(e),
          }
        ;(t.parser.currentToken = i),
          t.parser._processToken(t.parser.currentToken),
          (t.parser.tokenizer.lastStartTagName = n)
      })(e, t),
        wC(e.children, t),
        (function (e, t) {
          const n = e.tagName.toLowerCase()
          if (!t.parser.tokenizer.inForeignNode && yE.includes(n)) return
          if (t.parser.tokenizer.state === vT.PLAINTEXT) return
          CC(t, fC(e))
          const r = {
            type: RE.END_TAG,
            tagName: n,
            tagID: uT(n),
            selfClosing: !1,
            ackSelfClosing: !1,
            attrs: [],
            location: DC(e),
          }
          ;(t.parser.currentToken = r),
            t.parser._processToken(t.parser.currentToken),
            n !== t.parser.tokenizer.lastStartTagName ||
              (t.parser.tokenizer.state !== vT.RCDATA &&
                t.parser.tokenizer.state !== vT.RAWTEXT &&
                t.parser.tokenizer.state !== vT.SCRIPT_DATA) ||
              (t.parser.tokenizer.state = vT.DATA)
        })(e, t)
    }
    function _C(e, t) {
      const n = { type: RE.CHARACTER, chars: e.value, location: DC(e) }
      CC(t, mC(e)), (t.parser.currentToken = n), t.parser._processToken(t.parser.currentToken)
    }
    function SC(e, t) {
      const n = { type: RE.DOCTYPE, name: "html", forceQuirks: !1, publicId: "", systemId: "", location: DC(e) }
      CC(t, mC(e)), (t.parser.currentToken = n), t.parser._processToken(t.parser.currentToken)
    }
    function EC(e, t) {
      const n = e.value,
        r = { type: RE.COMMENT, data: n, location: DC(e) }
      CC(t, mC(e)), (t.parser.currentToken = r), t.parser._processToken(t.parser.currentToken)
    }
    function TC(e, t) {
      if (
        ((t.parser.tokenizer.preprocessor.html = ""),
        (t.parser.tokenizer.preprocessor.pos = -1),
        (t.parser.tokenizer.preprocessor.lastGapPos = -2),
        (t.parser.tokenizer.preprocessor.gapStack = []),
        (t.parser.tokenizer.preprocessor.skipNextNewLine = !1),
        (t.parser.tokenizer.preprocessor.lastChunkWritten = !1),
        (t.parser.tokenizer.preprocessor.endOfChunkHit = !1),
        (t.parser.tokenizer.preprocessor.isEol = !1),
        PC(t, mC(e)),
        t.parser.tokenizer.write(e.value, !1),
        t.parser.tokenizer._runParsingLoop(),
        72 === t.parser.tokenizer.state || 78 === t.parser.tokenizer.state)
      ) {
        t.parser.tokenizer.preprocessor.lastChunkWritten = !0
        const e = t.parser.tokenizer._consume()
        t.parser.tokenizer._callState(e)
      }
    }
    function AC(e, t) {
      const n = e
      if (!t.options.passThrough || !t.options.passThrough.includes(n.type)) {
        let e = ""
        throw (
          (vC.has(n.type) &&
            (e =
              ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"),
          new Error("Cannot compile `" + n.type + "` node" + e))
        )
      }
      !(function (e, t) {
        t.stitches = !0
        const n = (function (e) {
          return E_("children" in e ? { ...e, children: [] } : e)
        })(e)
        if ("children" in e && "children" in n) {
          const r = OC({ type: "root", children: e.children }, t.options)
          n.children = r.children
        }
        EC({ type: "comment", value: { stitch: n } }, t)
      })(n, t)
    }
    function CC(e, t) {
      PC(e, t)
      const n = e.parser.tokenizer.currentCharacterToken
      n &&
        n.location &&
        ((n.location.endLine = e.parser.tokenizer.preprocessor.line),
        (n.location.endCol = e.parser.tokenizer.preprocessor.col + 1),
        (n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1),
        (e.parser.currentToken = n),
        e.parser._processToken(e.parser.currentToken)),
        (e.parser.tokenizer.paused = !1),
        (e.parser.tokenizer.inLoop = !1),
        (e.parser.tokenizer.active = !1),
        (e.parser.tokenizer.returnState = vT.DATA),
        (e.parser.tokenizer.charRefCode = -1),
        (e.parser.tokenizer.consumedAfterSnapshot = -1),
        (e.parser.tokenizer.currentLocation = null),
        (e.parser.tokenizer.currentCharacterToken = null),
        (e.parser.tokenizer.currentToken = null),
        (e.parser.tokenizer.currentAttr = { name: "", value: "" })
    }
    function PC(e, t) {
      if (t && void 0 !== t.offset) {
        const n = {
          startLine: t.line,
          startCol: t.column,
          startOffset: t.offset,
          endLine: -1,
          endCol: -1,
          endOffset: -1,
        }
        ;(e.parser.tokenizer.preprocessor.lineStartPos = 1 - t.column),
          (e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset),
          (e.parser.tokenizer.preprocessor.line = t.line),
          (e.parser.tokenizer.currentLocation = n)
      }
    }
    function DC(e) {
      const t = mC(e) || { line: void 0, column: void 0, offset: void 0 },
        n = fC(e) || { line: void 0, column: void 0, offset: void 0 }
      return {
        startLine: t.line,
        startCol: t.column,
        startOffset: t.offset,
        endLine: n.line,
        endCol: n.column,
        endOffset: n.offset,
      }
    }
    function RC(e) {
      return function (t, n) {
        return OC(t, { ...e, file: n })
      }
    }
    const NC = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"],
      $C = {
        ancestors: {
          tbody: ["table"],
          td: ["table"],
          th: ["table"],
          thead: ["table"],
          tfoot: ["table"],
          tr: ["table"],
        },
        attributes: {
          a: [...NC, "dataFootnoteBackref", "dataFootnoteRef", ["className", "data-footnote-backref"], "href"],
          blockquote: ["cite"],
          code: [["className", /^language-./]],
          del: ["cite"],
          div: ["itemScope", "itemType"],
          dl: [...NC],
          h2: [["className", "sr-only"]],
          img: [...NC, "longDesc", "src"],
          input: [
            ["disabled", !0],
            ["type", "checkbox"],
          ],
          ins: ["cite"],
          li: [["className", "task-list-item"]],
          ol: [...NC, ["className", "contains-task-list"]],
          q: ["cite"],
          section: ["dataFootnotes", ["className", "footnotes"]],
          source: ["srcSet"],
          summary: [...NC],
          table: [...NC],
          ul: [...NC, ["className", "contains-task-list"]],
          "*": [
            "abbr",
            "accept",
            "acceptCharset",
            "accessKey",
            "action",
            "align",
            "alt",
            "axis",
            "border",
            "cellPadding",
            "cellSpacing",
            "char",
            "charOff",
            "charSet",
            "checked",
            "clear",
            "colSpan",
            "color",
            "cols",
            "compact",
            "coords",
            "dateTime",
            "dir",
            "encType",
            "frame",
            "hSpace",
            "headers",
            "height",
            "hrefLang",
            "htmlFor",
            "id",
            "isMap",
            "itemProp",
            "label",
            "lang",
            "maxLength",
            "media",
            "method",
            "multiple",
            "name",
            "noHref",
            "noShade",
            "noWrap",
            "open",
            "prompt",
            "readOnly",
            "rev",
            "rowSpan",
            "rows",
            "rules",
            "scope",
            "selected",
            "shape",
            "size",
            "span",
            "start",
            "summary",
            "tabIndex",
            "title",
            "useMap",
            "vAlign",
            "value",
            "width",
          ],
        },
        clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
        clobberPrefix: "user-content-",
        protocols: {
          cite: ["http", "https"],
          href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
          longDesc: ["http", "https"],
          src: ["http", "https"],
        },
        required: { input: { disabled: !0, type: "checkbox" } },
        strip: ["script"],
        tagNames: [
          "a",
          "b",
          "blockquote",
          "br",
          "code",
          "dd",
          "del",
          "details",
          "div",
          "dl",
          "dt",
          "em",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "hr",
          "i",
          "img",
          "input",
          "ins",
          "kbd",
          "li",
          "ol",
          "p",
          "picture",
          "pre",
          "q",
          "rp",
          "rt",
          "ruby",
          "s",
          "samp",
          "section",
          "source",
          "span",
          "strike",
          "strong",
          "sub",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "tfoot",
          "th",
          "thead",
          "tr",
          "tt",
          "ul",
          "var",
        ],
      },
      IC = {}.hasOwnProperty
    function MC(e, t) {
      if (t && "object" == typeof t) {
        const n = t
        switch ("string" == typeof n.type ? n.type : "") {
          case "comment":
            return (function (e, t) {
              if (e.schema.allowComments) {
                const e = "string" == typeof t.value ? t.value : "",
                  n = e.indexOf("--\x3e"),
                  r = { type: "comment", value: n < 0 ? e : e.slice(0, n) }
                return jC(r, t), r
              }
            })(e, n)
          case "doctype":
            return (function (e, t) {
              if (e.schema.allowDoctypes) {
                const e = { type: "doctype" }
                return jC(e, t), e
              }
            })(e, n)
          case "element":
            return (function (e, t) {
              const n = "string" == typeof t.tagName ? t.tagName : ""
              e.stack.push(n)
              const r = LC(e, t.children),
                a = (function (e, t) {
                  const n = e.stack[e.stack.length - 1],
                    r = e.schema.attributes,
                    a = e.schema.required,
                    o = r && IC.call(r, n) ? r[n] : void 0,
                    i = r && IC.call(r, "*") ? r["*"] : void 0,
                    s = t && "object" == typeof t ? t : {},
                    l = {}
                  let c
                  for (c in s)
                    if (IC.call(s, c)) {
                      const t = s[c]
                      let n = QC(e, UC(o, c), c, t)
                      null == n && (n = QC(e, UC(i, c), c, t)), null != n && (l[c] = n)
                    }
                  if (a && IC.call(a, n)) {
                    const e = a[n]
                    for (c in e) IC.call(e, c) && !IC.call(l, c) && (l[c] = e[c])
                  }
                  return l
                })(e, t.properties)
              e.stack.pop()
              let o = !1
              if (
                n &&
                "*" !== n &&
                (!e.schema.tagNames || e.schema.tagNames.includes(n)) &&
                ((o = !0), e.schema.ancestors && IC.call(e.schema.ancestors, n))
              ) {
                const t = e.schema.ancestors[n]
                let r = -1
                for (o = !1; ++r < t.length; ) e.stack.includes(t[r]) && (o = !0)
              }
              if (!o) return e.schema.strip && !e.schema.strip.includes(n) ? r : void 0
              const i = { type: "element", tagName: n, properties: a, children: r }
              return jC(i, t), i
            })(e, n)
          case "root":
            return (function (e, t) {
              const n = { type: "root", children: LC(e, t.children) }
              return jC(n, t), n
            })(e, n)
          case "text":
            return (function (e, t) {
              const n = { type: "text", value: "string" == typeof t.value ? t.value : "" }
              return jC(n, t), n
            })(0, n)
        }
      }
    }
    function LC(e, t) {
      const n = []
      if (Array.isArray(t)) {
        const r = t
        let a = -1
        for (; ++a < r.length; ) {
          const t = MC(e, r[a])
          t && (Array.isArray(t) ? n.push(...t) : n.push(t))
        }
      }
      return n
    }
    function QC(e, t, n, r) {
      return t
        ? Array.isArray(r)
          ? (function (e, t, n, r) {
              let a = -1
              const o = []
              for (; ++a < r.length; ) {
                const i = BC(e, t, n, r[a])
                ;("number" != typeof i && "string" != typeof i) || o.push(i)
              }
              return o
            })(e, t, n, r)
          : BC(e, t, n, r)
        : void 0
    }
    function BC(e, t, n, r) {
      if (
        ("boolean" == typeof r || "number" == typeof r || "string" == typeof r) &&
        (function (e, t, n) {
          const r = e.schema.protocols && IC.call(e.schema.protocols, t) ? e.schema.protocols[t] : void 0
          if (!r || 0 === r.length) return !0
          const a = String(n),
            o = a.indexOf(":"),
            i = a.indexOf("?"),
            s = a.indexOf("#"),
            l = a.indexOf("/")
          if (o < 0 || (l > -1 && o > l) || (i > -1 && o > i) || (s > -1 && o > s)) return !0
          let c = -1
          for (; ++c < r.length; ) {
            const e = r[c]
            if (o === e.length && a.slice(0, e.length) === e) return !0
          }
          return !1
        })(e, n, r)
      ) {
        if ("object" == typeof t && t.length > 1) {
          let e = !1,
            n = 0
          for (; ++n < t.length; ) {
            const a = t[n]
            if (a && "object" == typeof a && "flags" in a) {
              if (a.test(String(r))) {
                e = !0
                break
              }
            } else if (a === r) {
              e = !0
              break
            }
          }
          if (!e) return
        }
        return e.schema.clobber && e.schema.clobberPrefix && e.schema.clobber.includes(n)
          ? e.schema.clobberPrefix + r
          : r
      }
    }
    function jC(e, t) {
      const n = bC(t)
      t.data && (e.data = E_(t.data)), n && (e.position = n)
    }
    function UC(e, t) {
      let n,
        r = -1
      if (e)
        for (; ++r < e.length; ) {
          const a = e[r],
            o = "string" == typeof a ? a : a[0]
          if (o === t) return a
          "data*" === o && (n = a)
        }
      if (t.length > 4 && "data" === t.slice(0, 4).toLowerCase()) return n
    }
    function FC(e) {
      return function (t) {
        const n = (function (e, t) {
          let n = { type: "root", children: [] }
          const r = MC({ schema: t ? { ...$C, ...t } : $C, stack: [] }, e)
          return r && (Array.isArray(r) ? (1 === r.length ? (n = r[0]) : (n.children = r)) : (n = r)), n
        })(t, e)
        return n
      }
    }
    const zC = /["&'<>`]/g,
      qC = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      ZC = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
      HC = /[|\\{}()[\]^$+*?.]/g,
      VC = new WeakMap()
    const WC = /[\dA-Fa-f]/,
      XC = /\d/,
      YC = [
        "AElig",
        "AMP",
        "Aacute",
        "Acirc",
        "Agrave",
        "Aring",
        "Atilde",
        "Auml",
        "COPY",
        "Ccedil",
        "ETH",
        "Eacute",
        "Ecirc",
        "Egrave",
        "Euml",
        "GT",
        "Iacute",
        "Icirc",
        "Igrave",
        "Iuml",
        "LT",
        "Ntilde",
        "Oacute",
        "Ocirc",
        "Ograve",
        "Oslash",
        "Otilde",
        "Ouml",
        "QUOT",
        "REG",
        "THORN",
        "Uacute",
        "Ucirc",
        "Ugrave",
        "Uuml",
        "Yacute",
        "aacute",
        "acirc",
        "acute",
        "aelig",
        "agrave",
        "amp",
        "aring",
        "atilde",
        "auml",
        "brvbar",
        "ccedil",
        "cedil",
        "cent",
        "copy",
        "curren",
        "deg",
        "divide",
        "eacute",
        "ecirc",
        "egrave",
        "eth",
        "euml",
        "frac12",
        "frac14",
        "frac34",
        "gt",
        "iacute",
        "icirc",
        "iexcl",
        "igrave",
        "iquest",
        "iuml",
        "laquo",
        "lt",
        "macr",
        "micro",
        "middot",
        "nbsp",
        "not",
        "ntilde",
        "oacute",
        "ocirc",
        "ograve",
        "ordf",
        "ordm",
        "oslash",
        "otilde",
        "ouml",
        "para",
        "plusmn",
        "pound",
        "quot",
        "raquo",
        "reg",
        "sect",
        "shy",
        "sup1",
        "sup2",
        "sup3",
        "szlig",
        "thorn",
        "times",
        "uacute",
        "ucirc",
        "ugrave",
        "uml",
        "uuml",
        "yacute",
        "yen",
        "yuml",
      ],
      GC = {
        nbsp: "",
        iexcl: "",
        cent: "",
        pound: "",
        curren: "",
        yen: "",
        brvbar: "",
        sect: "",
        uml: "",
        copy: "",
        ordf: "",
        laquo: "",
        not: "",
        shy: "",
        reg: "",
        macr: "",
        deg: "",
        plusmn: "",
        sup2: "",
        sup3: "",
        acute: "",
        micro: "",
        para: "",
        middot: "",
        cedil: "",
        sup1: "",
        ordm: "",
        raquo: "",
        frac14: "",
        frac12: "",
        frac34: "",
        iquest: "",
        Agrave: "",
        Aacute: "",
        Acirc: "",
        Atilde: "",
        Auml: "",
        Aring: "",
        AElig: "",
        Ccedil: "",
        Egrave: "",
        Eacute: "",
        Ecirc: "",
        Euml: "",
        Igrave: "",
        Iacute: "",
        Icirc: "",
        Iuml: "",
        ETH: "",
        Ntilde: "",
        Ograve: "",
        Oacute: "",
        Ocirc: "",
        Otilde: "",
        Ouml: "",
        times: "",
        Oslash: "",
        Ugrave: "",
        Uacute: "",
        Ucirc: "",
        Uuml: "",
        Yacute: "",
        THORN: "",
        szlig: "",
        agrave: "",
        aacute: "",
        acirc: "",
        atilde: "",
        auml: "",
        aring: "",
        aelig: "",
        ccedil: "",
        egrave: "",
        eacute: "",
        ecirc: "",
        euml: "",
        igrave: "",
        iacute: "",
        icirc: "",
        iuml: "",
        eth: "",
        ntilde: "",
        ograve: "",
        oacute: "",
        ocirc: "",
        otilde: "",
        ouml: "",
        divide: "",
        oslash: "",
        ugrave: "",
        uacute: "",
        ucirc: "",
        uuml: "",
        yacute: "",
        thorn: "",
        yuml: "",
        fnof: "",
        Alpha: "",
        Beta: "",
        Gamma: "",
        Delta: "",
        Epsilon: "",
        Zeta: "",
        Eta: "",
        Theta: "",
        Iota: "",
        Kappa: "",
        Lambda: "",
        Mu: "",
        Nu: "",
        Xi: "",
        Omicron: "",
        Pi: "",
        Rho: "",
        Sigma: "",
        Tau: "",
        Upsilon: "",
        Phi: "",
        Chi: "",
        Psi: "",
        Omega: "",
        alpha: "",
        beta: "",
        gamma: "",
        delta: "",
        epsilon: "",
        zeta: "",
        eta: "",
        theta: "",
        iota: "",
        kappa: "",
        lambda: "",
        mu: "",
        nu: "",
        xi: "",
        omicron: "",
        pi: "",
        rho: "",
        sigmaf: "",
        sigma: "",
        tau: "",
        upsilon: "",
        phi: "",
        chi: "",
        psi: "",
        omega: "",
        thetasym: "",
        upsih: "",
        piv: "",
        bull: "",
        hellip: "",
        prime: "",
        Prime: "",
        oline: "",
        frasl: "",
        weierp: "",
        image: "",
        real: "",
        trade: "",
        alefsym: "",
        larr: "",
        uarr: "",
        rarr: "",
        darr: "",
        harr: "",
        crarr: "",
        lArr: "",
        uArr: "",
        rArr: "",
        dArr: "",
        hArr: "",
        forall: "",
        part: "",
        exist: "",
        empty: "",
        nabla: "",
        isin: "",
        notin: "",
        ni: "",
        prod: "",
        sum: "",
        minus: "",
        lowast: "",
        radic: "",
        prop: "",
        infin: "",
        ang: "",
        and: "",
        or: "",
        cap: "",
        cup: "",
        int: "",
        there4: "",
        sim: "",
        cong: "",
        asymp: "",
        ne: "",
        equiv: "",
        le: "",
        ge: "",
        sub: "",
        sup: "",
        nsub: "",
        sube: "",
        supe: "",
        oplus: "",
        otimes: "",
        perp: "",
        sdot: "",
        lceil: "",
        rceil: "",
        lfloor: "",
        rfloor: "",
        lang: "",
        rang: "",
        loz: "",
        spades: "",
        clubs: "",
        hearts: "",
        diams: "",
        quot: '"',
        amp: "&",
        lt: "<",
        gt: ">",
        OElig: "",
        oelig: "",
        Scaron: "",
        scaron: "",
        Yuml: "",
        circ: "",
        tilde: "",
        ensp: "",
        emsp: "",
        thinsp: "",
        zwnj: "",
        zwj: "",
        lrm: "",
        rlm: "",
        ndash: "",
        mdash: "",
        lsquo: "",
        rsquo: "",
        sbquo: "",
        ldquo: "",
        rdquo: "",
        bdquo: "",
        dagger: "",
        Dagger: "",
        permil: "",
        lsaquo: "",
        rsaquo: "",
        euro: "",
      },
      KC = ["cent", "copy", "divide", "gt", "lt", "not", "para", "times"],
      JC = {}.hasOwnProperty,
      eP = {}
    let tP
    for (tP in GC) JC.call(GC, tP) && (eP[GC[tP]] = tP)
    const nP = /[^\dA-Za-z]/
    function rP(e, t, n) {
      let r,
        a = (function (e, t, n) {
          const r = "&#x" + e.toString(16).toUpperCase()
          return n && t && !WC.test(String.fromCharCode(t)) ? r : r + ";"
        })(e, t, n.omitOptionalSemicolons)
      if (
        ((n.useNamedReferences || n.useShortestReferences) &&
          (r = (function (e, t, n, r) {
            const a = String.fromCharCode(e)
            if (JC.call(eP, a)) {
              const e = eP[a],
                o = "&" + e
              return n &&
                YC.includes(e) &&
                !KC.includes(e) &&
                (!r || (t && 61 !== t && nP.test(String.fromCharCode(t))))
                ? o
                : o + ";"
            }
            return ""
          })(e, t, n.omitOptionalSemicolons, n.attribute)),
        (n.useShortestReferences || !r) && n.useShortestReferences)
      ) {
        const r = (function (e, t, n) {
          const r = "&#" + String(e)
          return n && t && !XC.test(String.fromCharCode(t)) ? r : r + ";"
        })(e, t, n.omitOptionalSemicolons)
        r.length < a.length && (a = r)
      }
      return r && (!n.useShortestReferences || r.length < a.length) ? r : a
    }
    function aP(e, t) {
      return (function (e, t) {
        return (
          (e = e.replace(
            t.subset
              ? (function (e) {
                  let t = VC.get(e)
                  return (
                    t ||
                      ((t = (function (e) {
                        const t = []
                        let n = -1
                        for (; ++n < e.length; ) t.push(e[n].replace(HC, "\\$&"))
                        return new RegExp("(?:" + t.join("|") + ")", "g")
                      })(e)),
                      VC.set(e, t)),
                    t
                  )
                })(t.subset)
              : zC,
            n,
          )),
          t.subset || t.escapeOnly
            ? e
            : e
                .replace(qC, function (e, n, r) {
                  return t.format(
                    1024 * (e.charCodeAt(0) - 55296) + e.charCodeAt(1) - 56320 + 65536,
                    r.charCodeAt(n + 2),
                    t,
                  )
                })
                .replace(ZC, n)
        )
        function n(e, n, r) {
          return t.format(e.charCodeAt(0), r.charCodeAt(n + 1), t)
        }
      })(e, Object.assign({ format: rP }, t))
    }
    const oP = /^>|^->|<!--|-->|--!>|<!-$/g,
      iP = [">"],
      sP = ["<", ">"]
    function lP(e, t) {
      const n = String(e)
      if ("string" != typeof t) throw new TypeError("Expected character")
      let r = 0,
        a = n.indexOf(t)
      for (; -1 !== a; ) r++, (a = n.indexOf(t, a + t.length))
      return r
    }
    const cP = pP(1),
      dP = pP(-1),
      uP = []
    function pP(e) {
      return function (t, n, r) {
        const a = t ? t.children : uP
        let o = (n || 0) + e,
          i = a[o]
        if (!r) for (; i && F_(i); ) (o += e), (i = a[o])
        return i
      }
    }
    const hP = {}.hasOwnProperty
    function fP(e) {
      return function (t, n, r) {
        return hP.call(e, t.tagName) && e[t.tagName](t, n, r)
      }
    }
    const mP = fP({
      body: function (e, t, n) {
        const r = cP(n, t)
        return !r || "comment" !== r.type
      },
      caption: gP,
      colgroup: gP,
      dd: function (e, t, n) {
        const r = cP(n, t)
        return !r || ("element" === r.type && ("dt" === r.tagName || "dd" === r.tagName))
      },
      dt: function (e, t, n) {
        const r = cP(n, t)
        return Boolean(r && "element" === r.type && ("dt" === r.tagName || "dd" === r.tagName))
      },
      head: gP,
      html: function (e, t, n) {
        const r = cP(n, t)
        return !r || "comment" !== r.type
      },
      li: function (e, t, n) {
        const r = cP(n, t)
        return !r || ("element" === r.type && "li" === r.tagName)
      },
      optgroup: function (e, t, n) {
        const r = cP(n, t)
        return !r || ("element" === r.type && "optgroup" === r.tagName)
      },
      option: function (e, t, n) {
        const r = cP(n, t)
        return !r || ("element" === r.type && ("option" === r.tagName || "optgroup" === r.tagName))
      },
      p: function (e, t, n) {
        const r = cP(n, t)
        return r
          ? "element" === r.type &&
              ("address" === r.tagName ||
                "article" === r.tagName ||
                "aside" === r.tagName ||
                "blockquote" === r.tagName ||
                "details" === r.tagName ||
                "div" === r.tagName ||
                "dl" === r.tagName ||
                "fieldset" === r.tagName ||
                "figcaption" === r.tagName ||
                "figure" === r.tagName ||
                "footer" === r.tagName ||
                "form" === r.tagName ||
                "h1" === r.tagName ||
                "h2" === r.tagName ||
                "h3" === r.tagName ||
                "h4" === r.tagName ||
                "h5" === r.tagName ||
                "h6" === r.tagName ||
                "header" === r.tagName ||
                "hgroup" === r.tagName ||
                "hr" === r.tagName ||
                "main" === r.tagName ||
                "menu" === r.tagName ||
                "nav" === r.tagName ||
                "ol" === r.tagName ||
                "p" === r.tagName ||
                "pre" === r.tagName ||
                "section" === r.tagName ||
                "table" === r.tagName ||
                "ul" === r.tagName)
          : !n ||
              !(
                "element" === n.type &&
                ("a" === n.tagName ||
                  "audio" === n.tagName ||
                  "del" === n.tagName ||
                  "ins" === n.tagName ||
                  "map" === n.tagName ||
                  "noscript" === n.tagName ||
                  "video" === n.tagName)
              )
      },
      rp: bP,
      rt: bP,
      tbody: function (e, t, n) {
        const r = cP(n, t)
        return !r || ("element" === r.type && ("tbody" === r.tagName || "tfoot" === r.tagName))
      },
      td: vP,
      tfoot: function (e, t, n) {
        return !cP(n, t)
      },
      th: vP,
      thead: function (e, t, n) {
        const r = cP(n, t)
        return Boolean(r && "element" === r.type && ("tbody" === r.tagName || "tfoot" === r.tagName))
      },
      tr: function (e, t, n) {
        const r = cP(n, t)
        return !r || ("element" === r.type && "tr" === r.tagName)
      },
    })
    function gP(e, t, n) {
      const r = cP(n, t, !0)
      return !r || ("comment" !== r.type && !("text" === r.type && F_(r.value.charAt(0))))
    }
    function bP(e, t, n) {
      const r = cP(n, t)
      return !r || ("element" === r.type && ("rp" === r.tagName || "rt" === r.tagName))
    }
    function vP(e, t, n) {
      const r = cP(n, t)
      return !r || ("element" === r.type && ("td" === r.tagName || "th" === r.tagName))
    }
    const yP = fP({
        body: function (e) {
          const t = cP(e, -1, !0)
          return !(
            t &&
            ("comment" === t.type ||
              ("text" === t.type && F_(t.value.charAt(0))) ||
              ("element" === t.type &&
                ("meta" === t.tagName ||
                  "link" === t.tagName ||
                  "script" === t.tagName ||
                  "style" === t.tagName ||
                  "template" === t.tagName)))
          )
        },
        colgroup: function (e, t, n) {
          const r = dP(n, t),
            a = cP(e, -1, !0)
          return (
            !(n && r && "element" === r.type && "colgroup" === r.tagName && mP(r, n.children.indexOf(r), n)) &&
            Boolean(a && "element" === a.type && "col" === a.tagName)
          )
        },
        head: function (e) {
          const t = e.children,
            n = []
          let r = -1
          for (; ++r < t.length; ) {
            const e = t[r]
            if ("element" === e.type && ("title" === e.tagName || "base" === e.tagName)) {
              if (n.includes(e.tagName)) return !1
              n.push(e.tagName)
            }
          }
          return t.length > 0
        },
        html: function (e) {
          const t = cP(e, -1)
          return !t || "comment" !== t.type
        },
        tbody: function (e, t, n) {
          const r = dP(n, t),
            a = cP(e, -1)
          return (
            (!n ||
              !r ||
              "element" !== r.type ||
              ("thead" !== r.tagName && "tbody" !== r.tagName) ||
              !mP(r, n.children.indexOf(r), n)) &&
            Boolean(a && "element" === a.type && "tr" === a.tagName)
          )
        },
      }),
      OP = {
        name: [
          ["\t\n\f\r &/=>".split(""), "\t\n\f\r \"&'/=>`".split("")],
          ["\0\t\n\f\r \"&'/<=>".split(""), "\0\t\n\f\r \"&'/<=>`".split("")],
        ],
        unquoted: [
          ["\t\n\f\r &>".split(""), "\0\t\n\f\r \"&'<=>`".split("")],
          ["\0\t\n\f\r \"&'<=>`".split(""), "\0\t\n\f\r \"&'<=>`".split("")],
        ],
        single: [
          ["&'".split(""), "\"&'`".split("")],
          ["\0&'".split(""), "\0\"&'`".split("")],
        ],
        double: [
          ['"&'.split(""), "\"&'`".split("")],
          ['\0"&'.split(""), "\0\"&'`".split("")],
        ],
      }
    function wP(e, t, n) {
      const r = BS(e.schema, t),
        a = e.settings.allowParseErrors && "html" === e.schema.space ? 0 : 1,
        o = e.settings.allowDangerousCharacters ? 0 : 1
      let i,
        s = e.quote
      if (
        (!r.overloadedBoolean || (n !== r.attribute && "" !== n)
          ? (r.boolean || (r.overloadedBoolean && "string" != typeof n)) && (n = Boolean(n))
          : (n = !0),
        null == n || !1 === n || ("number" == typeof n && Number.isNaN(n)))
      )
        return ""
      const l = aP(r.attribute, Object.assign({}, e.settings.characterReferences, { subset: OP.name[a][o] }))
      return !0 === n
        ? l
        : ((n = Array.isArray(n)
            ? (r.commaSeparated ? ZS : P_)(n, { padLeft: !e.settings.tightCommaSeparatedLists })
            : String(n)),
          e.settings.collapseEmptyAttributes && !n
            ? l
            : (e.settings.preferUnquoted &&
                (i = aP(
                  n,
                  Object.assign({}, e.settings.characterReferences, { attribute: !0, subset: OP.unquoted[a][o] }),
                )),
              i !== n &&
                (e.settings.quoteSmart && lP(n, s) > lP(n, e.alternative) && (s = e.alternative),
                (i =
                  s +
                  aP(
                    n,
                    Object.assign({}, e.settings.characterReferences, {
                      subset: ("'" === s ? OP.single : OP.double)[a][o],
                      attribute: !0,
                    }),
                  ) +
                  s)),
              l + (i ? "=" + i : i)))
    }
    const xP = ["<", "&"]
    function kP(e, t, n, r) {
      return !n || "element" !== n.type || ("script" !== n.tagName && "style" !== n.tagName)
        ? aP(e.value, Object.assign({}, r.settings.characterReferences, { subset: xP }))
        : e.value
    }
    const _P = pE("type", {
        invalid: function (e) {
          throw new Error("Expected node, not `" + e + "`")
        },
        unknown: function (e) {
          throw new Error("Cannot compile unknown node `" + e.type + "`")
        },
        handlers: {
          comment: function (e, t, n, r) {
            return r.settings.bogusComments
              ? "<?" + aP(e.value, Object.assign({}, r.settings.characterReferences, { subset: iP })) + ">"
              : "\x3c!--" +
                  e.value.replace(oP, function (e) {
                    return aP(e, Object.assign({}, r.settings.characterReferences, { subset: sP }))
                  }) +
                  "--\x3e"
          },
          doctype: function (e, t, n, r) {
            return (
              "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>"
            )
          },
          element: function (e, t, n, r) {
            const a = r.schema,
              o = "svg" !== a.space && r.settings.omitOptionalTags
            let i =
              "svg" === a.space ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase())
            const s = []
            let l
            "html" === a.space && "svg" === e.tagName && (r.schema = zS)
            const c = (function (e, t) {
                const n = []
                let r,
                  a = -1
                if (t)
                  for (r in t)
                    if (null !== t[r] && void 0 !== t[r]) {
                      const a = wP(e, r, t[r])
                      a && n.push(a)
                    }
                for (; ++a < n.length; ) {
                  const t = e.settings.tightAttributes ? n[a].charAt(n[a].length - 1) : void 0
                  a !== n.length - 1 && '"' !== t && "'" !== t && (n[a] += " ")
                }
                return n.join("")
              })(r, e.properties),
              d = r.all("html" === a.space && "template" === e.tagName ? e.content : e)
            return (
              (r.schema = a),
              d && (i = !1),
              (!c && o && yP(e, t, n)) ||
                (s.push("<", e.tagName, c ? " " + c : ""),
                i &&
                  ("svg" === a.space || r.settings.closeSelfClosing) &&
                  ((l = c.charAt(c.length - 1)),
                  (!r.settings.tightSelfClosing || "/" === l || (l && '"' !== l && "'" !== l)) && s.push(" "),
                  s.push("/")),
                s.push(">")),
              s.push(d),
              i || (o && mP(e, t, n)) || s.push("</" + e.tagName + ">"),
              s.join("")
            )
          },
          raw: function (e, t, n, r) {
            return r.settings.allowDangerousHtml ? e.value : kP(e, 0, n, r)
          },
          root: function (e, t, n, r) {
            return r.all(e)
          },
          text: kP,
        },
      }),
      SP = {},
      EP = {},
      TP = []
    function AP(e, t, n) {
      return _P(e, t, n, this)
    }
    function CP(e) {
      const t = [],
        n = (e && e.children) || TP
      let r = -1
      for (; ++r < n.length; ) t[r] = this.one(n[r], r, e)
      return t.join("")
    }
    function PP(e) {
      const t = { ...this.data("settings"), ...e }
      this.compiler = function (e) {
        return (function (e, t) {
          const n = t || SP,
            r = n.quote || '"',
            a = '"' === r ? "'" : '"'
          if ('"' !== r && "'" !== r) throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`")
          return {
            one: AP,
            all: CP,
            settings: {
              omitOptionalTags: n.omitOptionalTags || !1,
              allowParseErrors: n.allowParseErrors || !1,
              allowDangerousCharacters: n.allowDangerousCharacters || !1,
              quoteSmart: n.quoteSmart || !1,
              preferUnquoted: n.preferUnquoted || !1,
              tightAttributes: n.tightAttributes || !1,
              upperDoctype: n.upperDoctype || !1,
              tightDoctype: n.tightDoctype || !1,
              bogusComments: n.bogusComments || !1,
              tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
              tightSelfClosing: n.tightSelfClosing || !1,
              collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
              allowDangerousHtml: n.allowDangerousHtml || !1,
              voids: n.voids || yE,
              characterReferences: n.characterReferences || EP,
              closeSelfClosing: n.closeSelfClosing || !1,
              closeEmptyElements: n.closeEmptyElements || !1,
            },
            schema: "svg" === n.space ? zS : FS,
            quote: r,
            alternative: a,
          }.one(Array.isArray(e) ? { type: "root", children: e } : e, void 0, void 0)
        })(e, t)
      }
    }
    const DP = zP(/[A-Za-z]/),
      RP = zP(/[\dA-Za-z]/),
      NP = zP(/[#-'*+\--9=?A-Z^-~]/)
    function $P(e) {
      return null !== e && (e < 32 || 127 === e)
    }
    const IP = zP(/\d/),
      MP = zP(/[\dA-Fa-f]/),
      LP = zP(/[!-/:-@[-`{-~]/)
    function QP(e) {
      return null !== e && e < -2
    }
    function BP(e) {
      return null !== e && (e < 0 || 32 === e)
    }
    function jP(e) {
      return -2 === e || -1 === e || 32 === e
    }
    const UP = zP(new RegExp("\\p{P}|\\p{S}", "u")),
      FP = zP(/\s/)
    function zP(e) {
      return function (t) {
        return null !== t && t > -1 && e.test(String.fromCharCode(t))
      }
    }
    function qP(e) {
      return "string" == typeof e
        ? new RegExp(
            (function (e) {
              if ("string" != typeof e) throw new TypeError("Expected a string")
              return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
            })(e),
            "g",
          )
        : e
    }
    function ZP(e) {
      return "function" == typeof e
        ? e
        : function () {
            return e
          }
    }
    const HP = "phrasing",
      VP = ["autolink", "link", "image", "label"]
    function WP(e) {
      this.enter({ type: "link", title: null, url: "", children: [] }, e)
    }
    function XP(e) {
      this.config.enter.autolinkProtocol.call(this, e)
    }
    function YP(e) {
      this.config.exit.autolinkProtocol.call(this, e)
    }
    function GP(e) {
      this.config.exit.data.call(this, e)
      const t = this.stack[this.stack.length - 1]
      t.type, (t.url = "http://" + this.sliceSerialize(e))
    }
    function KP(e) {
      this.config.exit.autolinkEmail.call(this, e)
    }
    function JP(e) {
      this.exit(e)
    }
    function eD(e) {
      !(function (e, t, n) {
        const r = bw((n || {}).ignore || []),
          a = (function (e) {
            const t = []
            if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples")
            const n = !e[0] || Array.isArray(e[0]) ? e : [e]
            let r = -1
            for (; ++r < n.length; ) {
              const e = n[r]
              t.push([qP(e[0]), ZP(e[1])])
            }
            return t
          })(t)
        let o = -1
        for (; ++o < a.length; ) f_(e, "text", i)
        function i(e, t) {
          let n,
            i = -1
          for (; ++i < t.length; ) {
            const e = t[i],
              a = n ? n.children : void 0
            if (r(e, a ? a.indexOf(e) : void 0, n)) return
            n = e
          }
          if (n)
            return (function (e, t) {
              const n = t[t.length - 1],
                r = a[o][0],
                i = a[o][1]
              let s = 0
              const l = n.children.indexOf(e)
              let c = !1,
                d = []
              r.lastIndex = 0
              let u = r.exec(e.value)
              for (; u; ) {
                const n = u.index,
                  a = { index: u.index, input: u.input, stack: [...t, e] }
                let o = i(...u, a)
                if (
                  ("string" == typeof o && (o = o.length > 0 ? { type: "text", value: o } : void 0),
                  !1 === o
                    ? (r.lastIndex = n + 1)
                    : (s !== n && d.push({ type: "text", value: e.value.slice(s, n) }),
                      Array.isArray(o) ? d.push(...o) : o && d.push(o),
                      (s = n + u[0].length),
                      (c = !0)),
                  !r.global)
                )
                  break
                u = r.exec(e.value)
              }
              return (
                c
                  ? (s < e.value.length && d.push({ type: "text", value: e.value.slice(s) }),
                    n.children.splice(l, 1, ...d))
                  : (d = [e]),
                l + d.length
              )
            })(e, t)
        }
      })(
        e,
        [
          [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, tD],
          [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, nD],
        ],
        { ignore: ["link", "linkReference"] },
      )
    }
    function tD(e, t, n, r, a) {
      let o = ""
      if (!rD(a)) return !1
      if (
        (/^w/i.test(t) && ((n = t + n), (t = ""), (o = "http://")),
        !(function (e) {
          const t = e.split(".")
          return !(
            t.length < 2 ||
            (t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1]))) ||
            (t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])))
          )
        })(n))
      )
        return !1
      const i = (function (e) {
        const t = /[!"&'),.:;<>?\]}]+$/.exec(e)
        if (!t) return [e, void 0]
        e = e.slice(0, t.index)
        let n = t[0],
          r = n.indexOf(")")
        const a = lP(e, "(")
        let o = lP(e, ")")
        for (; -1 !== r && a > o; ) (e += n.slice(0, r + 1)), (n = n.slice(r + 1)), (r = n.indexOf(")")), o++
        return [e, n]
      })(n + r)
      if (!i[0]) return !1
      const s = { type: "link", title: null, url: o + t + i[0], children: [{ type: "text", value: t + i[0] }] }
      return i[1] ? [s, { type: "text", value: i[1] }] : s
    }
    function nD(e, t, n, r) {
      return (
        !(!rD(r, !0) || /[-\d_]$/.test(n)) && {
          type: "link",
          title: null,
          url: "mailto:" + t + "@" + n,
          children: [{ type: "text", value: t + "@" + n }],
        }
      )
    }
    function rD(e, t) {
      const n = e.input.charCodeAt(e.index - 1)
      return (0 === e.index || FP(n) || UP(n)) && (!t || 47 !== n)
    }
    function aD(e) {
      return e
        .replace(/[\t\n\r ]+/g, " ")
        .replace(/^ | $/g, "")
        .toLowerCase()
        .toUpperCase()
    }
    function oD(e) {
      this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e)
    }
    function iD() {
      this.buffer()
    }
    function sD(e) {
      const t = this.resume(),
        n = this.stack[this.stack.length - 1]
      n.type, (n.label = t), (n.identifier = aD(this.sliceSerialize(e)).toLowerCase())
    }
    function lD(e) {
      this.exit(e)
    }
    function cD(e) {
      this.enter({ type: "footnoteReference", identifier: "", label: "" }, e)
    }
    function dD() {
      this.buffer()
    }
    function uD(e) {
      const t = this.resume(),
        n = this.stack[this.stack.length - 1]
      n.type, (n.label = t), (n.identifier = aD(this.sliceSerialize(e)).toLowerCase())
    }
    function pD(e) {
      this.exit(e)
    }
    function hD(e, t, n, r) {
      const a = n.createTracker(r)
      let o = a.move("[^")
      const i = n.enter("footnoteReference"),
        s = n.enter("reference")
      return (
        (o += a.move(n.safe(n.associationId(e), { ...a.current(), before: o, after: "]" }))),
        s(),
        i(),
        (o += a.move("]")),
        o
      )
    }
    function fD(e, t, n, r) {
      const a = n.createTracker(r)
      let o = a.move("[^")
      const i = n.enter("footnoteDefinition"),
        s = n.enter("label")
      return (
        (o += a.move(n.safe(n.associationId(e), { ...a.current(), before: o, after: "]" }))),
        s(),
        (o += a.move("]:" + (e.children && e.children.length > 0 ? " " : ""))),
        a.shift(4),
        (o += a.move(n.indentLines(n.containerFlow(e, a.current()), mD))),
        i(),
        o
      )
    }
    function mD(e, t, n) {
      return 0 === t ? e : (n ? "" : "    ") + e
    }
    hD.peek = function () {
      return "["
    }
    const gD = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]
    function bD(e) {
      this.enter({ type: "delete", children: [] }, e)
    }
    function vD(e) {
      this.exit(e)
    }
    function yD(e, t, n, r) {
      const a = n.createTracker(r),
        o = n.enter("strikethrough")
      let i = a.move("~~")
      return (i += n.containerPhrasing(e, { ...a.current(), before: i, after: "~" })), (i += a.move("~~")), o(), i
    }
    function OD(e) {
      return e.length
    }
    function wD(e) {
      const t = "string" == typeof e ? e.codePointAt(0) : 0
      return 67 === t || 99 === t ? 99 : 76 === t || 108 === t ? 108 : 82 === t || 114 === t ? 114 : 0
    }
    function xD(e, t, n) {
      return ">" + (n ? "" : " ") + e
    }
    function kD(e, t, n) {
      if (("string" == typeof t && (t = [t]), !t || 0 === t.length)) return n
      let r = -1
      for (; ++r < t.length; ) if (e.includes(t[r])) return !0
      return !1
    }
    function _D(e, t, n, r) {
      let a = -1
      for (; ++a < n.unsafe.length; )
        if (
          "\n" === n.unsafe[a].character &&
          kD((o = n.stack), (i = n.unsafe[a]).inConstruct, !0) &&
          !kD(o, i.notInConstruct, !1)
        )
          return /[ \t]/.test(r.before) ? "" : " "
      var o, i
      return "\\\n"
    }
    function SD(e, t, n) {
      return (n ? "" : "    ") + e
    }
    function ED(e) {
      const t = e.options.quote || '"'
      if ('"' !== t && "'" !== t)
        throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`")
      return t
    }
    function TD(e, t, n, r) {
      const a = (function (e) {
          const t = e.options.emphasis || "*"
          if ("*" !== t && "_" !== t)
            throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`")
          return t
        })(n),
        o = n.enter("emphasis"),
        i = n.createTracker(r)
      let s = i.move(a)
      return (s += i.move(n.containerPhrasing(e, { before: s, after: a, ...i.current() }))), (s += i.move(a)), o(), s
    }
    ;(yD.peek = function () {
      return "~"
    }),
      (TD.peek = function (e, t, n) {
        return n.options.emphasis || "*"
      })
    const AD = {}
    function CD(e, t) {
      const n = AD
      return PD(
        e,
        "boolean" != typeof n.includeImageAlt || n.includeImageAlt,
        "boolean" != typeof n.includeHtml || n.includeHtml,
      )
    }
    function PD(e, t, n) {
      if (
        (function (e) {
          return Boolean(e && "object" == typeof e)
        })(e)
      ) {
        if ("value" in e) return "html" !== e.type || n ? e.value : ""
        if (t && "alt" in e && e.alt) return e.alt
        if ("children" in e) return DD(e.children, t, n)
      }
      return Array.isArray(e) ? DD(e, t, n) : ""
    }
    function DD(e, t, n) {
      const r = []
      let a = -1
      for (; ++a < e.length; ) r[a] = PD(e[a], t, n)
      return r.join("")
    }
    function RD(e) {
      return e.value || ""
    }
    function ND(e, t, n, r) {
      const a = ED(n),
        o = '"' === a ? "Quote" : "Apostrophe",
        i = n.enter("image")
      let s = n.enter("label")
      const l = n.createTracker(r)
      let c = l.move("![")
      return (
        (c += l.move(n.safe(e.alt, { before: c, after: "]", ...l.current() }))),
        (c += l.move("](")),
        s(),
        (!e.url && e.title) || /[\0- \u007F]/.test(e.url)
          ? ((s = n.enter("destinationLiteral")),
            (c += l.move("<")),
            (c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() }))),
            (c += l.move(">")))
          : ((s = n.enter("destinationRaw")),
            (c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...l.current() })))),
        s(),
        e.title &&
          ((s = n.enter(`title${o}`)),
          (c += l.move(" " + a)),
          (c += l.move(n.safe(e.title, { before: c, after: a, ...l.current() }))),
          (c += l.move(a)),
          s()),
        (c += l.move(")")),
        i(),
        c
      )
    }
    function $D(e, t, n, r) {
      const a = e.referenceType,
        o = n.enter("imageReference")
      let i = n.enter("label")
      const s = n.createTracker(r)
      let l = s.move("![")
      const c = n.safe(e.alt, { before: l, after: "]", ...s.current() })
      ;(l += s.move(c + "][")), i()
      const d = n.stack
      ;(n.stack = []), (i = n.enter("reference"))
      const u = n.safe(n.associationId(e), { before: l, after: "]", ...s.current() })
      return (
        i(),
        (n.stack = d),
        o(),
        "full" !== a && c && c === u
          ? "shortcut" === a
            ? (l = l.slice(0, -1))
            : (l += s.move("]"))
          : (l += s.move(u + "]")),
        l
      )
    }
    function ID(e, t, n) {
      let r = e.value || "",
        a = "`",
        o = -1
      for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r); ) a += "`"
      for (
        /[^ \r\n]/.test(r) && ((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) && (r = " " + r + " ");
        ++o < n.unsafe.length;

      ) {
        const e = n.unsafe[o],
          t = n.compilePattern(e)
        let a
        if (e.atBreak)
          for (; (a = t.exec(r)); ) {
            let e = a.index
            10 === r.charCodeAt(e) && 13 === r.charCodeAt(e - 1) && e--,
              (r = r.slice(0, e) + " " + r.slice(a.index + 1))
          }
      }
      return a + r + a
    }
    function MD(e, t) {
      const n = CD(e)
      return Boolean(
        !t.options.resourceLink &&
          e.url &&
          !e.title &&
          e.children &&
          1 === e.children.length &&
          "text" === e.children[0].type &&
          (n === e.url || "mailto:" + n === e.url) &&
          /^[a-z][a-z+.-]+:/i.test(e.url) &&
          !/[\0- <>\u007F]/.test(e.url),
      )
    }
    function LD(e, t, n, r) {
      const a = ED(n),
        o = '"' === a ? "Quote" : "Apostrophe",
        i = n.createTracker(r)
      let s, l
      if (MD(e, n)) {
        const t = n.stack
        ;(n.stack = []), (s = n.enter("autolink"))
        let r = i.move("<")
        return (
          (r += i.move(n.containerPhrasing(e, { before: r, after: ">", ...i.current() }))),
          (r += i.move(">")),
          s(),
          (n.stack = t),
          r
        )
      }
      ;(s = n.enter("link")), (l = n.enter("label"))
      let c = i.move("[")
      return (
        (c += i.move(n.containerPhrasing(e, { before: c, after: "](", ...i.current() }))),
        (c += i.move("](")),
        l(),
        (!e.url && e.title) || /[\0- \u007F]/.test(e.url)
          ? ((l = n.enter("destinationLiteral")),
            (c += i.move("<")),
            (c += i.move(n.safe(e.url, { before: c, after: ">", ...i.current() }))),
            (c += i.move(">")))
          : ((l = n.enter("destinationRaw")),
            (c += i.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...i.current() })))),
        l(),
        e.title &&
          ((l = n.enter(`title${o}`)),
          (c += i.move(" " + a)),
          (c += i.move(n.safe(e.title, { before: c, after: a, ...i.current() }))),
          (c += i.move(a)),
          l()),
        (c += i.move(")")),
        s(),
        c
      )
    }
    function QD(e, t, n, r) {
      const a = e.referenceType,
        o = n.enter("linkReference")
      let i = n.enter("label")
      const s = n.createTracker(r)
      let l = s.move("[")
      const c = n.containerPhrasing(e, { before: l, after: "]", ...s.current() })
      ;(l += s.move(c + "][")), i()
      const d = n.stack
      ;(n.stack = []), (i = n.enter("reference"))
      const u = n.safe(n.associationId(e), { before: l, after: "]", ...s.current() })
      return (
        i(),
        (n.stack = d),
        o(),
        "full" !== a && c && c === u
          ? "shortcut" === a
            ? (l = l.slice(0, -1))
            : (l += s.move("]"))
          : (l += s.move(u + "]")),
        l
      )
    }
    function BD(e) {
      const t = e.options.bullet || "*"
      if ("*" !== t && "+" !== t && "-" !== t)
        throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`")
      return t
    }
    function jD(e) {
      const t = e.options.rule || "*"
      if ("*" !== t && "-" !== t && "_" !== t)
        throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`")
      return t
    }
    ;(RD.peek = function () {
      return "<"
    }),
      (ND.peek = function () {
        return "!"
      }),
      ($D.peek = function () {
        return "!"
      }),
      (ID.peek = function () {
        return "`"
      }),
      (LD.peek = function (e, t, n) {
        return MD(e, n) ? "<" : "["
      }),
      (QD.peek = function () {
        return "["
      })
    const UD = bw([
      "break",
      "delete",
      "emphasis",
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      "inlineMath",
      "link",
      "linkReference",
      "mdxJsxTextElement",
      "mdxTextExpression",
      "strong",
      "text",
      "textDirective",
    ])
    function FD(e, t, n, r) {
      const a = (function (e) {
          const t = e.options.strong || "*"
          if ("*" !== t && "_" !== t)
            throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`")
          return t
        })(n),
        o = n.enter("strong"),
        i = n.createTracker(r)
      let s = i.move(a + a)
      return (
        (s += i.move(n.containerPhrasing(e, { before: s, after: a, ...i.current() }))), (s += i.move(a + a)), o(), s
      )
    }
    FD.peek = function (e, t, n) {
      return n.options.strong || "*"
    }
    const zD = {
        blockquote: function (e, t, n, r) {
          const a = n.enter("blockquote"),
            o = n.createTracker(r)
          o.move("> "), o.shift(2)
          const i = n.indentLines(n.containerFlow(e, o.current()), xD)
          return a(), i
        },
        break: _D,
        code: function (e, t, n, r) {
          const a = (function (e) {
              const t = e.options.fence || "`"
              if ("`" !== t && "~" !== t)
                throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`")
              return t
            })(n),
            o = e.value || "",
            i = "`" === a ? "GraveAccent" : "Tilde"
          if (
            (function (e, t) {
              return Boolean(
                !1 === t.options.fences &&
                  e.value &&
                  !e.lang &&
                  /[^ \r\n]/.test(e.value) &&
                  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value),
              )
            })(e, n)
          ) {
            const e = n.enter("codeIndented"),
              t = n.indentLines(o, SD)
            return e(), t
          }
          const s = n.createTracker(r),
            l = a.repeat(
              Math.max(
                (function (e, t) {
                  const n = String(e)
                  let r = n.indexOf(t),
                    a = r,
                    o = 0,
                    i = 0
                  if ("string" != typeof t) throw new TypeError("Expected substring")
                  for (; -1 !== r; ) r === a ? ++o > i && (i = o) : (o = 1), (a = r + t.length), (r = n.indexOf(t, a))
                  return i
                })(o, a) + 1,
                3,
              ),
            ),
            c = n.enter("codeFenced")
          let d = s.move(l)
          if (e.lang) {
            const t = n.enter(`codeFencedLang${i}`)
            ;(d += s.move(n.safe(e.lang, { before: d, after: " ", encode: ["`"], ...s.current() }))), t()
          }
          if (e.lang && e.meta) {
            const t = n.enter(`codeFencedMeta${i}`)
            ;(d += s.move(" ")),
              (d += s.move(n.safe(e.meta, { before: d, after: "\n", encode: ["`"], ...s.current() }))),
              t()
          }
          return (d += s.move("\n")), o && (d += s.move(o + "\n")), (d += s.move(l)), c(), d
        },
        definition: function (e, t, n, r) {
          const a = ED(n),
            o = '"' === a ? "Quote" : "Apostrophe",
            i = n.enter("definition")
          let s = n.enter("label")
          const l = n.createTracker(r)
          let c = l.move("[")
          return (
            (c += l.move(n.safe(n.associationId(e), { before: c, after: "]", ...l.current() }))),
            (c += l.move("]: ")),
            s(),
            !e.url || /[\0- \u007F]/.test(e.url)
              ? ((s = n.enter("destinationLiteral")),
                (c += l.move("<")),
                (c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() }))),
                (c += l.move(">")))
              : ((s = n.enter("destinationRaw")),
                (c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : "\n", ...l.current() })))),
            s(),
            e.title &&
              ((s = n.enter(`title${o}`)),
              (c += l.move(" " + a)),
              (c += l.move(n.safe(e.title, { before: c, after: a, ...l.current() }))),
              (c += l.move(a)),
              s()),
            i(),
            c
          )
        },
        emphasis: TD,
        hardBreak: _D,
        heading: function (e, t, n, r) {
          const a = Math.max(Math.min(6, e.depth || 1), 1),
            o = n.createTracker(r)
          if (
            (function (e, t) {
              let n = !1
              return (
                m_(e, function (e) {
                  if (("value" in e && /\r?\n|\r/.test(e.value)) || "break" === e.type) return (n = !0), p_
                }),
                Boolean((!e.depth || e.depth < 3) && CD(e) && (t.options.setext || n))
              )
            })(e, n)
          ) {
            const t = n.enter("headingSetext"),
              r = n.enter("phrasing"),
              i = n.containerPhrasing(e, { ...o.current(), before: "\n", after: "\n" })
            return (
              r(),
              t(),
              i +
                "\n" +
                (1 === a ? "=" : "-").repeat(i.length - (Math.max(i.lastIndexOf("\r"), i.lastIndexOf("\n")) + 1))
            )
          }
          const i = "#".repeat(a),
            s = n.enter("headingAtx"),
            l = n.enter("phrasing")
          o.move(i + " ")
          let c = n.containerPhrasing(e, { before: "# ", after: "\n", ...o.current() })
          return (
            /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)),
            (c = c ? i + " " + c : i),
            n.options.closeAtx && (c += " " + i),
            l(),
            s(),
            c
          )
        },
        html: RD,
        image: ND,
        imageReference: $D,
        inlineCode: ID,
        link: LD,
        linkReference: QD,
        list: function (e, t, n, r) {
          const a = n.enter("list"),
            o = n.bulletCurrent
          let i = e.ordered
            ? (function (e) {
                const t = e.options.bulletOrdered || "."
                if ("." !== t && ")" !== t)
                  throw new Error(
                    "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`",
                  )
                return t
              })(n)
            : BD(n)
          const s = e.ordered
            ? "." === i
              ? ")"
              : "."
            : (function (e) {
                const t = BD(e),
                  n = e.options.bulletOther
                if (!n) return "*" === t ? "-" : "*"
                if ("*" !== n && "+" !== n && "-" !== n)
                  throw new Error(
                    "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`",
                  )
                if (n === t)
                  throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different")
                return n
              })(n)
          let l = !(!t || !n.bulletLastUsed) && i === n.bulletLastUsed
          if (!e.ordered) {
            const t = e.children ? e.children[0] : void 0
            if (
              (("*" !== i && "-" !== i) ||
                !t ||
                (t.children && t.children[0]) ||
                "list" !== n.stack[n.stack.length - 1] ||
                "listItem" !== n.stack[n.stack.length - 2] ||
                "list" !== n.stack[n.stack.length - 3] ||
                "listItem" !== n.stack[n.stack.length - 4] ||
                0 !== n.indexStack[n.indexStack.length - 1] ||
                0 !== n.indexStack[n.indexStack.length - 2] ||
                0 !== n.indexStack[n.indexStack.length - 3] ||
                (l = !0),
              jD(n) === i && t)
            ) {
              let t = -1
              for (; ++t < e.children.length; ) {
                const n = e.children[t]
                if (
                  n &&
                  "listItem" === n.type &&
                  n.children &&
                  n.children[0] &&
                  "thematicBreak" === n.children[0].type
                ) {
                  l = !0
                  break
                }
              }
            }
          }
          l && (i = s), (n.bulletCurrent = i)
          const c = n.containerFlow(e, r)
          return (n.bulletLastUsed = i), (n.bulletCurrent = o), a(), c
        },
        listItem: function (e, t, n, r) {
          const a = (function (e) {
            const t = e.options.listItemIndent || "one"
            if ("tab" !== t && "one" !== t && "mixed" !== t)
              throw new Error(
                "Cannot serialize items with `" +
                  t +
                  "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`",
              )
            return t
          })(n)
          let o = n.bulletCurrent || BD(n)
          t &&
            "list" === t.type &&
            t.ordered &&
            (o =
              ("number" == typeof t.start && t.start > -1 ? t.start : 1) +
              (!1 === n.options.incrementListMarker ? 0 : t.children.indexOf(e)) +
              o)
          let i = o.length + 1
          ;("tab" === a || ("mixed" === a && ((t && "list" === t.type && t.spread) || e.spread))) &&
            (i = 4 * Math.ceil(i / 4))
          const s = n.createTracker(r)
          s.move(o + " ".repeat(i - o.length)), s.shift(i)
          const l = n.enter("listItem"),
            c = n.indentLines(n.containerFlow(e, s.current()), function (e, t, n) {
              return t ? (n ? "" : " ".repeat(i)) + e : (n ? o : o + " ".repeat(i - o.length)) + e
            })
          return l(), c
        },
        paragraph: function (e, t, n, r) {
          const a = n.enter("paragraph"),
            o = n.enter("phrasing"),
            i = n.containerPhrasing(e, r)
          return o(), a(), i
        },
        root: function (e, t, n, r) {
          return (
            e.children.some(function (e) {
              return UD(e)
            })
              ? n.containerPhrasing
              : n.containerFlow
          ).call(n, e, r)
        },
        strong: FD,
        text: function (e, t, n, r) {
          return n.safe(e.value, r)
        },
        thematicBreak: function (e, t, n) {
          const r = (jD(n) + (n.options.ruleSpaces ? " " : "")).repeat(
            (function (e) {
              const t = e.options.ruleRepetition || 3
              if (t < 3)
                throw new Error(
                  "Cannot serialize rules with repetition `" +
                    t +
                    "` for `options.ruleRepetition`, expected `3` or more",
                )
              return t
            })(n),
          )
          return n.options.ruleSpaces ? r.slice(0, -1) : r
        },
      },
      qD = document.createElement("i")
    function ZD(e) {
      const t = "&" + e + ";"
      qD.innerHTML = t
      const n = qD.textContent
      return (59 !== n.charCodeAt(n.length - 1) || "semi" === e) && n !== t && n
    }
    function HD(e, t) {
      const n = Number.parseInt(e, t)
      return n < 9 ||
        11 === n ||
        (n > 13 && n < 32) ||
        (n > 126 && n < 160) ||
        (n > 55295 && n < 57344) ||
        (n > 64975 && n < 65008) ||
        !(65535 & ~n) ||
        65534 == (65535 & n) ||
        n > 1114111
        ? ""
        : String.fromCodePoint(n)
    }
    const VD = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi
    function WD(e, t, n) {
      if (t) return t
      if (35 === n.charCodeAt(0)) {
        const e = n.charCodeAt(1),
          t = 120 === e || 88 === e
        return HD(n.slice(t ? 2 : 1), t ? 16 : 10)
      }
      return ZD(n) || e
    }
    function XD(e) {
      const t = e._align
      this.enter(
        {
          type: "table",
          align: t.map(function (e) {
            return "none" === e ? null : e
          }),
          children: [],
        },
        e,
      ),
        (this.data.inTable = !0)
    }
    function YD(e) {
      this.exit(e), (this.data.inTable = void 0)
    }
    function GD(e) {
      this.enter({ type: "tableRow", children: [] }, e)
    }
    function KD(e) {
      this.exit(e)
    }
    function JD(e) {
      this.enter({ type: "tableCell", children: [] }, e)
    }
    function eR(e) {
      let t = this.resume()
      this.data.inTable && (t = t.replace(/\\([\\|])/g, tR))
      const n = this.stack[this.stack.length - 1]
      n.type, (n.value = t), this.exit(e)
    }
    function tR(e, t) {
      return "|" === t ? t : e
    }
    function nR(e) {
      const t = e || {},
        n = t.tableCellPadding,
        r = t.tablePipeAlign,
        a = t.stringLength,
        o = n ? " " : "|"
      return {
        unsafe: [
          { character: "\r", inConstruct: "tableCell" },
          { character: "\n", inConstruct: "tableCell" },
          { atBreak: !0, character: "|", after: "[\t :-]" },
          { character: "|", inConstruct: "tableCell" },
          { atBreak: !0, character: ":", after: "-" },
          { atBreak: !0, character: "-", after: "[:|-]" },
        ],
        handlers: {
          inlineCode: function (e, t, n) {
            let r = zD.inlineCode(e, t, n)
            return n.stack.includes("tableCell") && (r = r.replace(/\|/g, "\\$&")), r
          },
          table: function (e, t, n, r) {
            return s(
              (function (e, t, n) {
                const r = e.children
                let a = -1
                const o = [],
                  i = t.enter("table")
                for (; ++a < r.length; ) o[a] = l(r[a], t, n)
                return i(), o
              })(e, n, r),
              e.align,
            )
          },
          tableCell: i,
          tableRow: function (e, t, n, r) {
            const a = s([l(e, n, r)])
            return a.slice(0, a.indexOf("\n"))
          },
        },
      }
      function i(e, t, n, r) {
        const a = n.enter("tableCell"),
          i = n.enter("phrasing"),
          s = n.containerPhrasing(e, { ...r, before: o, after: o })
        return i(), a(), s
      }
      function s(e, t) {
        return (function (e, t = {}) {
          const n = (t.align || []).concat(),
            r = t.stringLength || OD,
            a = [],
            o = [],
            i = [],
            s = []
          let l = 0,
            c = -1
          for (; ++c < e.length; ) {
            const n = [],
              a = []
            let u = -1
            for (e[c].length > l && (l = e[c].length); ++u < e[c].length; ) {
              const o = null == (d = e[c][u]) ? "" : String(d)
              if (!1 !== t.alignDelimiters) {
                const e = r(o)
                ;(a[u] = e), (void 0 === s[u] || e > s[u]) && (s[u] = e)
              }
              n.push(o)
            }
            ;(o[c] = n), (i[c] = a)
          }
          var d
          let u = -1
          if ("object" == typeof n && "length" in n) for (; ++u < l; ) a[u] = wD(n[u])
          else {
            const e = wD(n)
            for (; ++u < l; ) a[u] = e
          }
          u = -1
          const p = [],
            h = []
          for (; ++u < l; ) {
            const e = a[u]
            let n = "",
              r = ""
            99 === e ? ((n = ":"), (r = ":")) : 108 === e ? (n = ":") : 114 === e && (r = ":")
            let o = !1 === t.alignDelimiters ? 1 : Math.max(1, s[u] - n.length - r.length)
            const i = n + "-".repeat(o) + r
            !1 !== t.alignDelimiters && ((o = n.length + o + r.length), o > s[u] && (s[u] = o), (h[u] = o)), (p[u] = i)
          }
          o.splice(1, 0, p), i.splice(1, 0, h), (c = -1)
          const f = []
          for (; ++c < o.length; ) {
            const e = o[c],
              n = i[c]
            u = -1
            const r = []
            for (; ++u < l; ) {
              const o = e[u] || ""
              let i = "",
                c = ""
              if (!1 !== t.alignDelimiters) {
                const e = s[u] - (n[u] || 0),
                  t = a[u]
                114 === t
                  ? (i = " ".repeat(e))
                  : 99 === t
                    ? e % 2
                      ? ((i = " ".repeat(e / 2 + 0.5)), (c = " ".repeat(e / 2 - 0.5)))
                      : ((i = " ".repeat(e / 2)), (c = i))
                    : (c = " ".repeat(e))
              }
              !1 === t.delimiterStart || u || r.push("|"),
                !1 === t.padding ||
                  (!1 === t.alignDelimiters && "" === o) ||
                  (!1 === t.delimiterStart && !u) ||
                  r.push(" "),
                !1 !== t.alignDelimiters && r.push(i),
                r.push(o),
                !1 !== t.alignDelimiters && r.push(c),
                !1 !== t.padding && r.push(" "),
                (!1 === t.delimiterEnd && u === l - 1) || r.push("|")
            }
            f.push(!1 === t.delimiterEnd ? r.join("").replace(/ +$/, "") : r.join(""))
          }
          return f.join("\n")
        })(e, { align: t, alignDelimiters: r, padding: n, stringLength: a })
      }
      function l(e, t, n) {
        const r = e.children
        let a = -1
        const o = [],
          s = t.enter("tableRow")
        for (; ++a < r.length; ) o[a] = i(r[a], 0, t, n)
        return s(), o
      }
    }
    function rR(e) {
      const t = this.stack[this.stack.length - 2]
      t.type, (t.checked = "taskListCheckValueChecked" === e.type)
    }
    function aR(e) {
      const t = this.stack[this.stack.length - 2]
      if (t && "listItem" === t.type && "boolean" == typeof t.checked) {
        const e = this.stack[this.stack.length - 1]
        e.type
        const n = e.children[0]
        if (n && "text" === n.type) {
          const r = t.children
          let a,
            o = -1
          for (; ++o < r.length; ) {
            const e = r[o]
            if ("paragraph" === e.type) {
              a = e
              break
            }
          }
          a === e &&
            ((n.value = n.value.slice(1)),
            0 === n.value.length
              ? e.children.shift()
              : e.position &&
                n.position &&
                "number" == typeof n.position.start.offset &&
                (n.position.start.column++,
                n.position.start.offset++,
                (e.position.start = Object.assign({}, n.position.start))))
        }
      }
      this.exit(e)
    }
    function oR(e, t, n, r) {
      const a = e.children[0],
        o = "boolean" == typeof e.checked && a && "paragraph" === a.type,
        i = "[" + (e.checked ? "x" : " ") + "] ",
        s = n.createTracker(r)
      o && s.move(i)
      let l = zD.listItem(e, t, n, { ...r, ...s.current() })
      return (
        o &&
          (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, function (e) {
            return e + i
          })),
        l
      )
    }
    function iR(e, t, n, r) {
      const a = e.length
      let o,
        i = 0
      if (((t = t < 0 ? (-t > a ? 0 : a + t) : t > a ? a : t), (n = n > 0 ? n : 0), r.length < 1e4))
        (o = Array.from(r)), o.unshift(t, n), e.splice(...o)
      else
        for (n && e.splice(t, n); i < r.length; )
          (o = r.slice(i, i + 1e4)), o.unshift(t, 0), e.splice(...o), (i += 1e4), (t += 1e4)
    }
    function sR(e, t) {
      return e.length > 0 ? (iR(e, e.length, 0, t), e) : t
    }
    const lR = {}.hasOwnProperty
    function cR(e) {
      const t = {}
      let n = -1
      for (; ++n < e.length; ) dR(t, e[n])
      return t
    }
    function dR(e, t) {
      let n
      for (n in t) {
        const r = (lR.call(e, n) ? e[n] : void 0) || (e[n] = {}),
          a = t[n]
        let o
        if (a)
          for (o in a) {
            lR.call(r, o) || (r[o] = [])
            const e = a[o]
            uR(r[o], Array.isArray(e) ? e : e ? [e] : [])
          }
      }
    }
    function uR(e, t) {
      let n = -1
      const r = []
      for (; ++n < t.length; ) ("after" === t[n].add ? e : r).push(t[n])
      iR(e, 0, 0, r)
    }
    const pR = {
        tokenize: function (e, t, n) {
          let r = 0
          return function t(o) {
            return (87 === o || 119 === o) && r < 3
              ? (r++, e.consume(o), t)
              : 46 === o && 3 === r
                ? (e.consume(o), a)
                : n(o)
          }
          function a(e) {
            return null === e ? n(e) : t(e)
          }
        },
        partial: !0,
      },
      hR = {
        tokenize: function (e, t, n) {
          let r, a, o
          return i
          function i(t) {
            return 46 === t || 95 === t
              ? e.check(mR, l, s)(t)
              : null === t || BP(t) || FP(t) || (45 !== t && UP(t))
                ? l(t)
                : ((o = !0), e.consume(t), i)
          }
          function s(t) {
            return 95 === t ? (r = !0) : ((a = r), (r = void 0)), e.consume(t), i
          }
          function l(e) {
            return a || r || !o ? n(e) : t(e)
          }
        },
        partial: !0,
      },
      fR = {
        tokenize: function (e, t) {
          let n = 0,
            r = 0
          return a
          function a(i) {
            return 40 === i
              ? (n++, e.consume(i), a)
              : 41 === i && r < n
                ? o(i)
                : 33 === i ||
                    34 === i ||
                    38 === i ||
                    39 === i ||
                    41 === i ||
                    42 === i ||
                    44 === i ||
                    46 === i ||
                    58 === i ||
                    59 === i ||
                    60 === i ||
                    63 === i ||
                    93 === i ||
                    95 === i ||
                    126 === i
                  ? e.check(mR, t, o)(i)
                  : null === i || BP(i) || FP(i)
                    ? t(i)
                    : (e.consume(i), a)
          }
          function o(t) {
            return 41 === t && r++, e.consume(t), a
          }
        },
        partial: !0,
      },
      mR = {
        tokenize: function (e, t, n) {
          return r
          function r(i) {
            return 33 === i ||
              34 === i ||
              39 === i ||
              41 === i ||
              42 === i ||
              44 === i ||
              46 === i ||
              58 === i ||
              59 === i ||
              63 === i ||
              95 === i ||
              126 === i
              ? (e.consume(i), r)
              : 38 === i
                ? (e.consume(i), o)
                : 93 === i
                  ? (e.consume(i), a)
                  : 60 === i || null === i || BP(i) || FP(i)
                    ? t(i)
                    : n(i)
          }
          function a(e) {
            return null === e || 40 === e || 91 === e || BP(e) || FP(e) ? t(e) : r(e)
          }
          function o(e) {
            return DP(e) ? i(e) : n(e)
          }
          function i(t) {
            return 59 === t ? (e.consume(t), r) : DP(t) ? (e.consume(t), i) : n(t)
          }
        },
        partial: !0,
      },
      gR = {
        tokenize: function (e, t, n) {
          return function (t) {
            return e.consume(t), r
          }
          function r(e) {
            return RP(e) ? n(e) : t(e)
          }
        },
        partial: !0,
      },
      bR = {
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return (87 !== t && 119 !== t) || !xR.call(r, r.previous) || ER(r.events)
              ? n(t)
              : (e.enter("literalAutolink"),
                e.enter("literalAutolinkWww"),
                e.check(pR, e.attempt(hR, e.attempt(fR, a), n), n)(t))
          }
          function a(n) {
            return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(n)
          }
        },
        previous: xR,
      },
      vR = {
        tokenize: function (e, t, n) {
          const r = this
          let a = "",
            o = !1
          return function (t) {
            return (72 !== t && 104 !== t) || !kR.call(r, r.previous) || ER(r.events)
              ? n(t)
              : (e.enter("literalAutolink"),
                e.enter("literalAutolinkHttp"),
                (a += String.fromCodePoint(t)),
                e.consume(t),
                i)
          }
          function i(t) {
            if (DP(t) && a.length < 5) return (a += String.fromCodePoint(t)), e.consume(t), i
            if (58 === t) {
              const n = a.toLowerCase()
              if ("http" === n || "https" === n) return e.consume(t), s
            }
            return n(t)
          }
          function s(t) {
            return 47 === t ? (e.consume(t), o ? l : ((o = !0), s)) : n(t)
          }
          function l(t) {
            return null === t || $P(t) || BP(t) || FP(t) || UP(t) ? n(t) : e.attempt(hR, e.attempt(fR, c), n)(t)
          }
          function c(n) {
            return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(n)
          }
        },
        previous: kR,
      },
      yR = {
        tokenize: function (e, t, n) {
          const r = this
          let a, o
          return function (t) {
            return SR(t) && _R.call(r, r.previous) && !ER(r.events)
              ? (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), i(t))
              : n(t)
          }
          function i(t) {
            return SR(t) ? (e.consume(t), i) : 64 === t ? (e.consume(t), s) : n(t)
          }
          function s(t) {
            return 46 === t ? e.check(gR, c, l)(t) : 45 === t || 95 === t || RP(t) ? ((o = !0), e.consume(t), s) : c(t)
          }
          function l(t) {
            return e.consume(t), (a = !0), s
          }
          function c(i) {
            return o && a && DP(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(i)) : n(i)
          }
        },
        previous: _R,
      },
      OR = {}
    let wR = 48
    for (; wR < 123; ) (OR[wR] = yR), wR++, 58 === wR ? (wR = 65) : 91 === wR && (wR = 97)
    function xR(e) {
      return null === e || 40 === e || 42 === e || 95 === e || 91 === e || 93 === e || 126 === e || BP(e)
    }
    function kR(e) {
      return !DP(e)
    }
    function _R(e) {
      return !(47 === e || SR(e))
    }
    function SR(e) {
      return 43 === e || 45 === e || 46 === e || 95 === e || RP(e)
    }
    function ER(e) {
      let t = e.length,
        n = !1
      for (; t--; ) {
        const r = e[t][1]
        if (("labelLink" === r.type || "labelImage" === r.type) && !r._balanced) {
          n = !0
          break
        }
        if (r._gfmAutolinkLiteralWalkedInto) {
          n = !1
          break
        }
      }
      return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n
    }
    function TR(e) {
      const t = []
      let n = -1,
        r = 0,
        a = 0
      for (; ++n < e.length; ) {
        const o = e.charCodeAt(n)
        let i = ""
        if (37 === o && RP(e.charCodeAt(n + 1)) && RP(e.charCodeAt(n + 2))) a = 2
        else if (o < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (i = String.fromCharCode(o))
        else if (o > 55295 && o < 57344) {
          const t = e.charCodeAt(n + 1)
          o < 56320 && t > 56319 && t < 57344 ? ((i = String.fromCharCode(o, t)), (a = 1)) : (i = "")
        } else i = String.fromCharCode(o)
        i && (t.push(e.slice(r, n), encodeURIComponent(i)), (r = n + a + 1), (i = "")), a && ((n += a), (a = 0))
      }
      return t.join("") + e.slice(r)
    }
    function AR(e) {
      return null === e || BP(e) || FP(e) ? 1 : UP(e) ? 2 : void 0
    }
    function CR(e, t, n) {
      const r = []
      let a = -1
      for (; ++a < e.length; ) {
        const o = e[a].resolveAll
        o && !r.includes(o) && ((t = o(t, n)), r.push(o))
      }
      return t
    }
    ;(OR[43] = yR),
      (OR[45] = yR),
      (OR[46] = yR),
      (OR[95] = yR),
      (OR[72] = [yR, vR]),
      (OR[104] = [yR, vR]),
      (OR[87] = [yR, bR]),
      (OR[119] = [yR, bR])
    const PR = {
      name: "attention",
      tokenize: function (e, t) {
        const n = this.parser.constructs.attentionMarkers.null,
          r = this.previous,
          a = AR(r)
        let o
        return function (t) {
          return (o = t), e.enter("attentionSequence"), i(t)
        }
        function i(s) {
          if (s === o) return e.consume(s), i
          const l = e.exit("attentionSequence"),
            c = AR(s),
            d = !c || (2 === c && a) || n.includes(s),
            u = !a || (2 === a && c) || n.includes(r)
          return (
            (l._open = Boolean(42 === o ? d : d && (a || !u))),
            (l._close = Boolean(42 === o ? u : u && (c || !d))),
            t(s)
          )
        }
      },
      resolveAll: function (e, t) {
        let n,
          r,
          a,
          o,
          i,
          s,
          l,
          c,
          d = -1
        for (; ++d < e.length; )
          if ("enter" === e[d][0] && "attentionSequence" === e[d][1].type && e[d][1]._close)
            for (n = d; n--; )
              if (
                "exit" === e[n][0] &&
                "attentionSequence" === e[n][1].type &&
                e[n][1]._open &&
                t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[d][1]).charCodeAt(0)
              ) {
                if (
                  (e[n][1]._close || e[d][1]._open) &&
                  (e[d][1].end.offset - e[d][1].start.offset) % 3 &&
                  !((e[n][1].end.offset - e[n][1].start.offset + e[d][1].end.offset - e[d][1].start.offset) % 3)
                )
                  continue
                s =
                  e[n][1].end.offset - e[n][1].start.offset > 1 && e[d][1].end.offset - e[d][1].start.offset > 1 ? 2 : 1
                const u = Object.assign({}, e[n][1].end),
                  p = Object.assign({}, e[d][1].start)
                DR(u, -s),
                  DR(p, s),
                  (o = {
                    type: s > 1 ? "strongSequence" : "emphasisSequence",
                    start: u,
                    end: Object.assign({}, e[n][1].end),
                  }),
                  (i = {
                    type: s > 1 ? "strongSequence" : "emphasisSequence",
                    start: Object.assign({}, e[d][1].start),
                    end: p,
                  }),
                  (a = {
                    type: s > 1 ? "strongText" : "emphasisText",
                    start: Object.assign({}, e[n][1].end),
                    end: Object.assign({}, e[d][1].start),
                  }),
                  (r = {
                    type: s > 1 ? "strong" : "emphasis",
                    start: Object.assign({}, o.start),
                    end: Object.assign({}, i.end),
                  }),
                  (e[n][1].end = Object.assign({}, o.start)),
                  (e[d][1].start = Object.assign({}, i.end)),
                  (l = []),
                  e[n][1].end.offset - e[n][1].start.offset &&
                    (l = sR(l, [
                      ["enter", e[n][1], t],
                      ["exit", e[n][1], t],
                    ])),
                  (l = sR(l, [
                    ["enter", r, t],
                    ["enter", o, t],
                    ["exit", o, t],
                    ["enter", a, t],
                  ])),
                  (l = sR(l, CR(t.parser.constructs.insideSpan.null, e.slice(n + 1, d), t))),
                  (l = sR(l, [
                    ["exit", a, t],
                    ["enter", i, t],
                    ["exit", i, t],
                    ["exit", r, t],
                  ])),
                  e[d][1].end.offset - e[d][1].start.offset
                    ? ((c = 2),
                      (l = sR(l, [
                        ["enter", e[d][1], t],
                        ["exit", e[d][1], t],
                      ])))
                    : (c = 0),
                  iR(e, n - 1, d - n + 3, l),
                  (d = n + l.length - c - 2)
                break
              }
        for (d = -1; ++d < e.length; ) "attentionSequence" === e[d][1].type && (e[d][1].type = "data")
        return e
      },
    }
    function DR(e, t) {
      ;(e.column += t), (e.offset += t), (e._bufferIndex += t)
    }
    const RR = {
      name: "autolink",
      tokenize: function (e, t, n) {
        let r = 0
        return function (t) {
          return (
            e.enter("autolink"),
            e.enter("autolinkMarker"),
            e.consume(t),
            e.exit("autolinkMarker"),
            e.enter("autolinkProtocol"),
            a
          )
        }
        function a(t) {
          return DP(t) ? (e.consume(t), o) : 64 === t ? n(t) : l(t)
        }
        function o(e) {
          return 43 === e || 45 === e || 46 === e || RP(e) ? ((r = 1), i(e)) : l(e)
        }
        function i(t) {
          return 58 === t
            ? (e.consume(t), (r = 0), s)
            : (43 === t || 45 === t || 46 === t || RP(t)) && r++ < 32
              ? (e.consume(t), i)
              : ((r = 0), l(t))
        }
        function s(r) {
          return 62 === r
            ? (e.exit("autolinkProtocol"),
              e.enter("autolinkMarker"),
              e.consume(r),
              e.exit("autolinkMarker"),
              e.exit("autolink"),
              t)
            : null === r || 32 === r || 60 === r || $P(r)
              ? n(r)
              : (e.consume(r), s)
        }
        function l(t) {
          return 64 === t ? (e.consume(t), c) : NP(t) ? (e.consume(t), l) : n(t)
        }
        function c(e) {
          return RP(e) ? d(e) : n(e)
        }
        function d(n) {
          return 46 === n
            ? (e.consume(n), (r = 0), c)
            : 62 === n
              ? ((e.exit("autolinkProtocol").type = "autolinkEmail"),
                e.enter("autolinkMarker"),
                e.consume(n),
                e.exit("autolinkMarker"),
                e.exit("autolink"),
                t)
              : u(n)
        }
        function u(t) {
          if ((45 === t || RP(t)) && r++ < 63) {
            const n = 45 === t ? u : d
            return e.consume(t), n
          }
          return n(t)
        }
      },
    }
    function NR(e, t, n, r) {
      const a = r ? r - 1 : Number.POSITIVE_INFINITY
      let o = 0
      return function (r) {
        return jP(r) ? (e.enter(n), i(r)) : t(r)
      }
      function i(r) {
        return jP(r) && o++ < a ? (e.consume(r), i) : (e.exit(n), t(r))
      }
    }
    const $R = {
        tokenize: function (e, t, n) {
          return function (t) {
            return jP(t) ? NR(e, r, "linePrefix")(t) : r(t)
          }
          function r(e) {
            return null === e || QP(e) ? t(e) : n(e)
          }
        },
        partial: !0,
      },
      IR = {
        name: "blockQuote",
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            if (62 === t) {
              const n = r.containerState
              return (
                n.open || (e.enter("blockQuote", { _container: !0 }), (n.open = !0)),
                e.enter("blockQuotePrefix"),
                e.enter("blockQuoteMarker"),
                e.consume(t),
                e.exit("blockQuoteMarker"),
                a
              )
            }
            return n(t)
          }
          function a(n) {
            return jP(n)
              ? (e.enter("blockQuotePrefixWhitespace"),
                e.consume(n),
                e.exit("blockQuotePrefixWhitespace"),
                e.exit("blockQuotePrefix"),
                t)
              : (e.exit("blockQuotePrefix"), t(n))
          }
        },
        continuation: {
          tokenize: function (e, t, n) {
            const r = this
            return function (t) {
              return jP(t)
                ? NR(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t)
                : a(t)
            }
            function a(r) {
              return e.attempt(IR, t, n)(r)
            }
          },
        },
        exit: function (e) {
          e.exit("blockQuote")
        },
      },
      MR = {
        name: "characterEscape",
        tokenize: function (e, t, n) {
          return function (t) {
            return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(t), e.exit("escapeMarker"), r
          }
          function r(r) {
            return LP(r)
              ? (e.enter("characterEscapeValue"),
                e.consume(r),
                e.exit("characterEscapeValue"),
                e.exit("characterEscape"),
                t)
              : n(r)
          }
        },
      },
      LR = {
        name: "characterReference",
        tokenize: function (e, t, n) {
          const r = this
          let a,
            o,
            i = 0
          return function (t) {
            return (
              e.enter("characterReference"),
              e.enter("characterReferenceMarker"),
              e.consume(t),
              e.exit("characterReferenceMarker"),
              s
            )
          }
          function s(t) {
            return 35 === t
              ? (e.enter("characterReferenceMarkerNumeric"), e.consume(t), e.exit("characterReferenceMarkerNumeric"), l)
              : (e.enter("characterReferenceValue"), (a = 31), (o = RP), c(t))
          }
          function l(t) {
            return 88 === t || 120 === t
              ? (e.enter("characterReferenceMarkerHexadecimal"),
                e.consume(t),
                e.exit("characterReferenceMarkerHexadecimal"),
                e.enter("characterReferenceValue"),
                (a = 6),
                (o = MP),
                c)
              : (e.enter("characterReferenceValue"), (a = 7), (o = IP), c(t))
          }
          function c(s) {
            if (59 === s && i) {
              const a = e.exit("characterReferenceValue")
              return o !== RP || ZD(r.sliceSerialize(a))
                ? (e.enter("characterReferenceMarker"),
                  e.consume(s),
                  e.exit("characterReferenceMarker"),
                  e.exit("characterReference"),
                  t)
                : n(s)
            }
            return o(s) && i++ < a ? (e.consume(s), c) : n(s)
          }
        },
      },
      QR = {
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return null === t ? n(t) : (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), a)
          }
          function a(e) {
            return r.parser.lazy[r.now().line] ? n(e) : t(e)
          }
        },
        partial: !0,
      },
      BR = {
        name: "codeFenced",
        tokenize: function (e, t, n) {
          const r = this,
            a = {
              tokenize: function (e, t, n) {
                let a = 0
                return function (t) {
                  return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), i
                }
                function i(t) {
                  return (
                    e.enter("codeFencedFence"),
                    jP(t)
                      ? NR(
                          e,
                          l,
                          "linePrefix",
                          r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
                        )(t)
                      : l(t)
                  )
                }
                function l(t) {
                  return t === o ? (e.enter("codeFencedFenceSequence"), c(t)) : n(t)
                }
                function c(t) {
                  return t === o
                    ? (a++, e.consume(t), c)
                    : a >= s
                      ? (e.exit("codeFencedFenceSequence"), jP(t) ? NR(e, d, "whitespace")(t) : d(t))
                      : n(t)
                }
                function d(r) {
                  return null === r || QP(r) ? (e.exit("codeFencedFence"), t(r)) : n(r)
                }
              },
              partial: !0,
            }
          let o,
            i = 0,
            s = 0
          return function (t) {
            return (function (t) {
              const n = r.events[r.events.length - 1]
              return (
                (i = n && "linePrefix" === n[1].type ? n[2].sliceSerialize(n[1], !0).length : 0),
                (o = t),
                e.enter("codeFenced"),
                e.enter("codeFencedFence"),
                e.enter("codeFencedFenceSequence"),
                l(t)
              )
            })(t)
          }
          function l(t) {
            return t === o
              ? (s++, e.consume(t), l)
              : s < 3
                ? n(t)
                : (e.exit("codeFencedFenceSequence"), jP(t) ? NR(e, c, "whitespace")(t) : c(t))
          }
          function c(n) {
            return null === n || QP(n)
              ? (e.exit("codeFencedFence"), r.interrupt ? t(n) : e.check(QR, h, v)(n))
              : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), d(n))
          }
          function d(t) {
            return null === t || QP(t)
              ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), c(t))
              : jP(t)
                ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), NR(e, u, "whitespace")(t))
                : 96 === t && t === o
                  ? n(t)
                  : (e.consume(t), d)
          }
          function u(t) {
            return null === t || QP(t)
              ? c(t)
              : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), p(t))
          }
          function p(t) {
            return null === t || QP(t)
              ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), c(t))
              : 96 === t && t === o
                ? n(t)
                : (e.consume(t), p)
          }
          function h(t) {
            return e.attempt(a, v, f)(t)
          }
          function f(t) {
            return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), m
          }
          function m(t) {
            return i > 0 && jP(t) ? NR(e, g, "linePrefix", i + 1)(t) : g(t)
          }
          function g(t) {
            return null === t || QP(t) ? e.check(QR, h, v)(t) : (e.enter("codeFlowValue"), b(t))
          }
          function b(t) {
            return null === t || QP(t) ? (e.exit("codeFlowValue"), g(t)) : (e.consume(t), b)
          }
          function v(n) {
            return e.exit("codeFenced"), t(n)
          }
        },
        concrete: !0,
      },
      jR = {
        name: "codeIndented",
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return e.enter("codeIndented"), NR(e, a, "linePrefix", 5)(t)
          }
          function a(e) {
            const t = r.events[r.events.length - 1]
            return t && "linePrefix" === t[1].type && t[2].sliceSerialize(t[1], !0).length >= 4 ? o(e) : n(e)
          }
          function o(t) {
            return null === t ? s(t) : QP(t) ? e.attempt(UR, o, s)(t) : (e.enter("codeFlowValue"), i(t))
          }
          function i(t) {
            return null === t || QP(t) ? (e.exit("codeFlowValue"), o(t)) : (e.consume(t), i)
          }
          function s(n) {
            return e.exit("codeIndented"), t(n)
          }
        },
      },
      UR = {
        tokenize: function (e, t, n) {
          const r = this
          return a
          function a(t) {
            return r.parser.lazy[r.now().line]
              ? n(t)
              : QP(t)
                ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), a)
                : NR(e, o, "linePrefix", 5)(t)
          }
          function o(e) {
            const o = r.events[r.events.length - 1]
            return o && "linePrefix" === o[1].type && o[2].sliceSerialize(o[1], !0).length >= 4
              ? t(e)
              : QP(e)
                ? a(e)
                : n(e)
          }
        },
        partial: !0,
      },
      FR = {
        name: "codeText",
        tokenize: function (e, t, n) {
          let r,
            a,
            o = 0
          return function (t) {
            return e.enter("codeText"), e.enter("codeTextSequence"), i(t)
          }
          function i(t) {
            return 96 === t ? (e.consume(t), o++, i) : (e.exit("codeTextSequence"), s(t))
          }
          function s(t) {
            return null === t
              ? n(t)
              : 32 === t
                ? (e.enter("space"), e.consume(t), e.exit("space"), s)
                : 96 === t
                  ? ((a = e.enter("codeTextSequence")), (r = 0), c(t))
                  : QP(t)
                    ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s)
                    : (e.enter("codeTextData"), l(t))
          }
          function l(t) {
            return null === t || 32 === t || 96 === t || QP(t) ? (e.exit("codeTextData"), s(t)) : (e.consume(t), l)
          }
          function c(n) {
            return 96 === n
              ? (e.consume(n), r++, c)
              : r === o
                ? (e.exit("codeTextSequence"), e.exit("codeText"), t(n))
                : ((a.type = "codeTextData"), l(n))
          }
        },
        resolve: function (e) {
          let t,
            n,
            r = e.length - 4,
            a = 3
          if (
            !(
              ("lineEnding" !== e[a][1].type && "space" !== e[a][1].type) ||
              ("lineEnding" !== e[r][1].type && "space" !== e[r][1].type)
            )
          )
            for (t = a; ++t < r; )
              if ("codeTextData" === e[t][1].type) {
                ;(e[a][1].type = "codeTextPadding"), (e[r][1].type = "codeTextPadding"), (a += 2), (r -= 2)
                break
              }
          for (t = a - 1, r++; ++t <= r; )
            void 0 === n
              ? t !== r && "lineEnding" !== e[t][1].type && (n = t)
              : (t !== r && "lineEnding" !== e[t][1].type) ||
                ((e[n][1].type = "codeTextData"),
                t !== n + 2 &&
                  ((e[n][1].end = e[t - 1][1].end), e.splice(n + 2, t - n - 2), (r -= t - n - 2), (t = n + 2)),
                (n = void 0))
          return e
        },
        previous: function (e) {
          return 96 !== e || "characterEscape" === this.events[this.events.length - 1][1].type
        },
      }
    class zR {
      constructor(e) {
        ;(this.left = e ? [...e] : []), (this.right = [])
      }
      get(e) {
        if (e < 0 || e >= this.left.length + this.right.length)
          throw new RangeError(
            "Cannot access index `" +
              e +
              "` in a splice buffer of size `" +
              (this.left.length + this.right.length) +
              "`",
          )
        return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1]
      }
      get length() {
        return this.left.length + this.right.length
      }
      shift() {
        return this.setCursor(0), this.right.pop()
      }
      slice(e, t) {
        const n = null == t ? Number.POSITIVE_INFINITY : t
        return n < this.left.length
          ? this.left.slice(e, n)
          : e > this.left.length
            ? this.right
                .slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length)
                .reverse()
            : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse())
      }
      splice(e, t, n) {
        const r = t || 0
        this.setCursor(Math.trunc(e))
        const a = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY)
        return n && qR(this.left, n), a.reverse()
      }
      pop() {
        return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop()
      }
      push(e) {
        this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e)
      }
      pushMany(e) {
        this.setCursor(Number.POSITIVE_INFINITY), qR(this.left, e)
      }
      unshift(e) {
        this.setCursor(0), this.right.push(e)
      }
      unshiftMany(e) {
        this.setCursor(0), qR(this.right, e.reverse())
      }
      setCursor(e) {
        if (
          !(
            e === this.left.length ||
            (e > this.left.length && 0 === this.right.length) ||
            (e < 0 && 0 === this.left.length)
          )
        )
          if (e < this.left.length) {
            const t = this.left.splice(e, Number.POSITIVE_INFINITY)
            qR(this.right, t.reverse())
          } else {
            const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY)
            qR(this.left, t.reverse())
          }
      }
    }
    function qR(e, t) {
      let n = 0
      if (t.length < 1e4) e.push(...t)
      else for (; n < t.length; ) e.push(...t.slice(n, n + 1e4)), (n += 1e4)
    }
    function ZR(e) {
      const t = {}
      let n,
        r,
        a,
        o,
        i,
        s,
        l,
        c = -1
      const d = new zR(e)
      for (; ++c < d.length; ) {
        for (; c in t; ) c = t[c]
        if (
          ((n = d.get(c)),
          c &&
            "chunkFlow" === n[1].type &&
            "listItemPrefix" === d.get(c - 1)[1].type &&
            ((s = n[1]._tokenizer.events),
            (a = 0),
            a < s.length && "lineEndingBlank" === s[a][1].type && (a += 2),
            a < s.length && "content" === s[a][1].type))
        )
          for (; ++a < s.length && "content" !== s[a][1].type; )
            "chunkText" === s[a][1].type && ((s[a][1]._isInFirstContentOfListItem = !0), a++)
        if ("enter" === n[0]) n[1].contentType && (Object.assign(t, HR(d, c)), (c = t[c]), (l = !0))
        else if (n[1]._container) {
          for (
            a = c, r = void 0;
            a-- && ((o = d.get(a)), "lineEnding" === o[1].type || "lineEndingBlank" === o[1].type);

          )
            "enter" === o[0] && (r && (d.get(r)[1].type = "lineEndingBlank"), (o[1].type = "lineEnding"), (r = a))
          r &&
            ((n[1].end = Object.assign({}, d.get(r)[1].start)),
            (i = d.slice(r, c)),
            i.unshift(n),
            d.splice(r, c - r + 1, i))
        }
      }
      return iR(e, 0, Number.POSITIVE_INFINITY, d.slice(0)), !l
    }
    function HR(e, t) {
      const n = e.get(t)[1],
        r = e.get(t)[2]
      let a = t - 1
      const o = [],
        i = n._tokenizer || r.parser[n.contentType](n.start),
        s = i.events,
        l = [],
        c = {}
      let d,
        u,
        p = -1,
        h = n,
        f = 0,
        m = 0
      const g = [m]
      for (; h; ) {
        for (; e.get(++a)[1] !== h; );
        o.push(a),
          h._tokenizer ||
            ((d = r.sliceStream(h)),
            h.next || d.push(null),
            u && i.defineSkip(h.start),
            h._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0),
            i.write(d),
            h._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)),
          (u = h),
          (h = h.next)
      }
      for (h = n; ++p < s.length; )
        "exit" === s[p][0] &&
          "enter" === s[p - 1][0] &&
          s[p][1].type === s[p - 1][1].type &&
          s[p][1].start.line !== s[p][1].end.line &&
          ((m = p + 1), g.push(m), (h._tokenizer = void 0), (h.previous = void 0), (h = h.next))
      for (i.events = [], h ? ((h._tokenizer = void 0), (h.previous = void 0)) : g.pop(), p = g.length; p--; ) {
        const t = s.slice(g[p], g[p + 1]),
          n = o.pop()
        l.push([n, n + t.length - 1]), e.splice(n, 2, t)
      }
      for (l.reverse(), p = -1; ++p < l.length; ) (c[f + l[p][0]] = f + l[p][1]), (f += l[p][1] - l[p][0] - 1)
      return c
    }
    const VR = {
        tokenize: function (e, t) {
          let n
          return function (t) {
            return e.enter("content"), (n = e.enter("chunkContent", { contentType: "content" })), r(t)
          }
          function r(t) {
            return null === t ? a(t) : QP(t) ? e.check(WR, o, a)(t) : (e.consume(t), r)
          }
          function a(n) {
            return e.exit("chunkContent"), e.exit("content"), t(n)
          }
          function o(t) {
            return (
              e.consume(t),
              e.exit("chunkContent"),
              (n.next = e.enter("chunkContent", { contentType: "content", previous: n })),
              (n = n.next),
              r
            )
          }
        },
        resolve: function (e) {
          return ZR(e), e
        },
      },
      WR = {
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return (
              e.exit("chunkContent"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), NR(e, a, "linePrefix")
            )
          }
          function a(a) {
            if (null === a || QP(a)) return n(a)
            const o = r.events[r.events.length - 1]
            return !r.parser.constructs.disable.null.includes("codeIndented") &&
              o &&
              "linePrefix" === o[1].type &&
              o[2].sliceSerialize(o[1], !0).length >= 4
              ? t(a)
              : e.interrupt(r.parser.constructs.flow, n, t)(a)
          }
        },
        partial: !0,
      }
    function XR(e, t, n, r, a, o, i, s, l) {
      const c = l || Number.POSITIVE_INFINITY
      let d = 0
      return function (t) {
        return 60 === t
          ? (e.enter(r), e.enter(a), e.enter(o), e.consume(t), e.exit(o), u)
          : null === t || 32 === t || 41 === t || $P(t)
            ? n(t)
            : (e.enter(r), e.enter(i), e.enter(s), e.enter("chunkString", { contentType: "string" }), f(t))
      }
      function u(n) {
        return 62 === n
          ? (e.enter(o), e.consume(n), e.exit(o), e.exit(a), e.exit(r), t)
          : (e.enter(s), e.enter("chunkString", { contentType: "string" }), p(n))
      }
      function p(t) {
        return 62 === t
          ? (e.exit("chunkString"), e.exit(s), u(t))
          : null === t || 60 === t || QP(t)
            ? n(t)
            : (e.consume(t), 92 === t ? h : p)
      }
      function h(t) {
        return 60 === t || 62 === t || 92 === t ? (e.consume(t), p) : p(t)
      }
      function f(a) {
        return d || (null !== a && 41 !== a && !BP(a))
          ? d < c && 40 === a
            ? (e.consume(a), d++, f)
            : 41 === a
              ? (e.consume(a), d--, f)
              : null === a || 32 === a || 40 === a || $P(a)
                ? n(a)
                : (e.consume(a), 92 === a ? m : f)
          : (e.exit("chunkString"), e.exit(s), e.exit(i), e.exit(r), t(a))
      }
      function m(t) {
        return 40 === t || 41 === t || 92 === t ? (e.consume(t), f) : f(t)
      }
    }
    function YR(e, t, n, r, a, o) {
      const i = this
      let s,
        l = 0
      return function (t) {
        return e.enter(r), e.enter(a), e.consume(t), e.exit(a), e.enter(o), c
      }
      function c(u) {
        return l > 999 ||
          null === u ||
          91 === u ||
          (93 === u && !s) ||
          (94 === u && !l && "_hiddenFootnoteSupport" in i.parser.constructs)
          ? n(u)
          : 93 === u
            ? (e.exit(o), e.enter(a), e.consume(u), e.exit(a), e.exit(r), t)
            : QP(u)
              ? (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), c)
              : (e.enter("chunkString", { contentType: "string" }), d(u))
      }
      function d(t) {
        return null === t || 91 === t || 93 === t || QP(t) || l++ > 999
          ? (e.exit("chunkString"), c(t))
          : (e.consume(t), s || (s = !jP(t)), 92 === t ? u : d)
      }
      function u(t) {
        return 91 === t || 92 === t || 93 === t ? (e.consume(t), l++, d) : d(t)
      }
    }
    function GR(e, t, n, r, a, o) {
      let i
      return function (t) {
        return 34 === t || 39 === t || 40 === t
          ? (e.enter(r), e.enter(a), e.consume(t), e.exit(a), (i = 40 === t ? 41 : t), s)
          : n(t)
      }
      function s(n) {
        return n === i ? (e.enter(a), e.consume(n), e.exit(a), e.exit(r), t) : (e.enter(o), l(n))
      }
      function l(t) {
        return t === i
          ? (e.exit(o), s(i))
          : null === t
            ? n(t)
            : QP(t)
              ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), NR(e, l, "linePrefix"))
              : (e.enter("chunkString", { contentType: "string" }), c(t))
      }
      function c(t) {
        return t === i || null === t || QP(t) ? (e.exit("chunkString"), l(t)) : (e.consume(t), 92 === t ? d : c)
      }
      function d(t) {
        return t === i || 92 === t ? (e.consume(t), c) : c(t)
      }
    }
    function KR(e, t) {
      let n
      return function r(a) {
        return QP(a)
          ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), (n = !0), r)
          : jP(a)
            ? NR(e, r, n ? "linePrefix" : "lineSuffix")(a)
            : t(a)
      }
    }
    const JR = {
        name: "definition",
        tokenize: function (e, t, n) {
          const r = this
          let a
          return function (t) {
            return (
              e.enter("definition"),
              (function (t) {
                return YR.call(r, e, o, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t)
              })(t)
            )
          }
          function o(t) {
            return (
              (a = aD(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))),
              58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), i) : n(t)
            )
          }
          function i(t) {
            return BP(t) ? KR(e, s)(t) : s(t)
          }
          function s(t) {
            return XR(
              e,
              l,
              n,
              "definitionDestination",
              "definitionDestinationLiteral",
              "definitionDestinationLiteralMarker",
              "definitionDestinationRaw",
              "definitionDestinationString",
            )(t)
          }
          function l(t) {
            return e.attempt(eN, c, c)(t)
          }
          function c(t) {
            return jP(t) ? NR(e, d, "whitespace")(t) : d(t)
          }
          function d(o) {
            return null === o || QP(o) ? (e.exit("definition"), r.parser.defined.push(a), t(o)) : n(o)
          }
        },
      },
      eN = {
        tokenize: function (e, t, n) {
          return function (t) {
            return BP(t) ? KR(e, r)(t) : n(t)
          }
          function r(t) {
            return GR(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t)
          }
          function a(t) {
            return jP(t) ? NR(e, o, "whitespace")(t) : o(t)
          }
          function o(e) {
            return null === e || QP(e) ? t(e) : n(e)
          }
        },
        partial: !0,
      },
      tN = {
        name: "hardBreakEscape",
        tokenize: function (e, t, n) {
          return function (t) {
            return e.enter("hardBreakEscape"), e.consume(t), r
          }
          function r(r) {
            return QP(r) ? (e.exit("hardBreakEscape"), t(r)) : n(r)
          }
        },
      },
      nN = {
        name: "headingAtx",
        tokenize: function (e, t, n) {
          let r = 0
          return function (t) {
            return (
              e.enter("atxHeading"),
              (function (t) {
                return e.enter("atxHeadingSequence"), a(t)
              })(t)
            )
          }
          function a(t) {
            return 35 === t && r++ < 6
              ? (e.consume(t), a)
              : null === t || BP(t)
                ? (e.exit("atxHeadingSequence"), o(t))
                : n(t)
          }
          function o(n) {
            return 35 === n
              ? (e.enter("atxHeadingSequence"), i(n))
              : null === n || QP(n)
                ? (e.exit("atxHeading"), t(n))
                : jP(n)
                  ? NR(e, o, "whitespace")(n)
                  : (e.enter("atxHeadingText"), s(n))
          }
          function i(t) {
            return 35 === t ? (e.consume(t), i) : (e.exit("atxHeadingSequence"), o(t))
          }
          function s(t) {
            return null === t || 35 === t || BP(t) ? (e.exit("atxHeadingText"), o(t)) : (e.consume(t), s)
          }
        },
        resolve: function (e, t) {
          let n,
            r,
            a = e.length - 2,
            o = 3
          return (
            "whitespace" === e[o][1].type && (o += 2),
            a - 2 > o && "whitespace" === e[a][1].type && (a -= 2),
            "atxHeadingSequence" === e[a][1].type &&
              (o === a - 1 || (a - 4 > o && "whitespace" === e[a - 2][1].type)) &&
              (a -= o + 1 === a ? 2 : 4),
            a > o &&
              ((n = { type: "atxHeadingText", start: e[o][1].start, end: e[a][1].end }),
              (r = { type: "chunkText", start: e[o][1].start, end: e[a][1].end, contentType: "text" }),
              iR(e, o, a - o + 1, [
                ["enter", n, t],
                ["enter", r, t],
                ["exit", r, t],
                ["exit", n, t],
              ])),
            e
          )
        },
      },
      rN = [
        "address",
        "article",
        "aside",
        "base",
        "basefont",
        "blockquote",
        "body",
        "caption",
        "center",
        "col",
        "colgroup",
        "dd",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hr",
        "html",
        "iframe",
        "legend",
        "li",
        "link",
        "main",
        "menu",
        "menuitem",
        "nav",
        "noframes",
        "ol",
        "optgroup",
        "option",
        "p",
        "param",
        "search",
        "section",
        "summary",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "title",
        "tr",
        "track",
        "ul",
      ],
      aN = ["pre", "script", "style", "textarea"],
      oN = {
        name: "htmlFlow",
        tokenize: function (e, t, n) {
          const r = this
          let a, o, i, s, l
          return function (t) {
            return (function (t) {
              return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(t), c
            })(t)
          }
          function c(s) {
            return 33 === s
              ? (e.consume(s), d)
              : 47 === s
                ? (e.consume(s), (o = !0), h)
                : 63 === s
                  ? (e.consume(s), (a = 3), r.interrupt ? t : $)
                  : DP(s)
                    ? (e.consume(s), (i = String.fromCharCode(s)), f)
                    : n(s)
          }
          function d(o) {
            return 45 === o
              ? (e.consume(o), (a = 2), u)
              : 91 === o
                ? (e.consume(o), (a = 5), (s = 0), p)
                : DP(o)
                  ? (e.consume(o), (a = 4), r.interrupt ? t : $)
                  : n(o)
          }
          function u(a) {
            return 45 === a ? (e.consume(a), r.interrupt ? t : $) : n(a)
          }
          function p(a) {
            return a === "CDATA[".charCodeAt(s++) ? (e.consume(a), 6 === s ? (r.interrupt ? t : E) : p) : n(a)
          }
          function h(t) {
            return DP(t) ? (e.consume(t), (i = String.fromCharCode(t)), f) : n(t)
          }
          function f(s) {
            if (null === s || 47 === s || 62 === s || BP(s)) {
              const l = 47 === s,
                c = i.toLowerCase()
              return l || o || !aN.includes(c)
                ? rN.includes(i.toLowerCase())
                  ? ((a = 6), l ? (e.consume(s), m) : r.interrupt ? t(s) : E(s))
                  : ((a = 7), r.interrupt && !r.parser.lazy[r.now().line] ? n(s) : o ? g(s) : b(s))
                : ((a = 1), r.interrupt ? t(s) : E(s))
            }
            return 45 === s || RP(s) ? (e.consume(s), (i += String.fromCharCode(s)), f) : n(s)
          }
          function m(a) {
            return 62 === a ? (e.consume(a), r.interrupt ? t : E) : n(a)
          }
          function g(t) {
            return jP(t) ? (e.consume(t), g) : _(t)
          }
          function b(t) {
            return 47 === t
              ? (e.consume(t), _)
              : 58 === t || 95 === t || DP(t)
                ? (e.consume(t), v)
                : jP(t)
                  ? (e.consume(t), b)
                  : _(t)
          }
          function v(t) {
            return 45 === t || 46 === t || 58 === t || 95 === t || RP(t) ? (e.consume(t), v) : y(t)
          }
          function y(t) {
            return 61 === t ? (e.consume(t), O) : jP(t) ? (e.consume(t), y) : b(t)
          }
          function O(t) {
            return null === t || 60 === t || 61 === t || 62 === t || 96 === t
              ? n(t)
              : 34 === t || 39 === t
                ? (e.consume(t), (l = t), w)
                : jP(t)
                  ? (e.consume(t), O)
                  : x(t)
          }
          function w(t) {
            return t === l ? (e.consume(t), (l = null), k) : null === t || QP(t) ? n(t) : (e.consume(t), w)
          }
          function x(t) {
            return null === t ||
              34 === t ||
              39 === t ||
              47 === t ||
              60 === t ||
              61 === t ||
              62 === t ||
              96 === t ||
              BP(t)
              ? y(t)
              : (e.consume(t), x)
          }
          function k(e) {
            return 47 === e || 62 === e || jP(e) ? b(e) : n(e)
          }
          function _(t) {
            return 62 === t ? (e.consume(t), S) : n(t)
          }
          function S(t) {
            return null === t || QP(t) ? E(t) : jP(t) ? (e.consume(t), S) : n(t)
          }
          function E(t) {
            return 45 === t && 2 === a
              ? (e.consume(t), P)
              : 60 === t && 1 === a
                ? (e.consume(t), D)
                : 62 === t && 4 === a
                  ? (e.consume(t), I)
                  : 63 === t && 3 === a
                    ? (e.consume(t), $)
                    : 93 === t && 5 === a
                      ? (e.consume(t), N)
                      : !QP(t) || (6 !== a && 7 !== a)
                        ? null === t || QP(t)
                          ? (e.exit("htmlFlowData"), T(t))
                          : (e.consume(t), E)
                        : (e.exit("htmlFlowData"), e.check(iN, M, T)(t))
          }
          function T(t) {
            return e.check(sN, A, M)(t)
          }
          function A(t) {
            return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), C
          }
          function C(t) {
            return null === t || QP(t) ? T(t) : (e.enter("htmlFlowData"), E(t))
          }
          function P(t) {
            return 45 === t ? (e.consume(t), $) : E(t)
          }
          function D(t) {
            return 47 === t ? (e.consume(t), (i = ""), R) : E(t)
          }
          function R(t) {
            if (62 === t) {
              const n = i.toLowerCase()
              return aN.includes(n) ? (e.consume(t), I) : E(t)
            }
            return DP(t) && i.length < 8 ? (e.consume(t), (i += String.fromCharCode(t)), R) : E(t)
          }
          function N(t) {
            return 93 === t ? (e.consume(t), $) : E(t)
          }
          function $(t) {
            return 62 === t ? (e.consume(t), I) : 45 === t && 2 === a ? (e.consume(t), $) : E(t)
          }
          function I(t) {
            return null === t || QP(t) ? (e.exit("htmlFlowData"), M(t)) : (e.consume(t), I)
          }
          function M(n) {
            return e.exit("htmlFlow"), t(n)
          }
        },
        resolveTo: function (e) {
          let t = e.length
          for (; t-- && ("enter" !== e[t][0] || "htmlFlow" !== e[t][1].type); );
          return (
            t > 1 &&
              "linePrefix" === e[t - 2][1].type &&
              ((e[t][1].start = e[t - 2][1].start), (e[t + 1][1].start = e[t - 2][1].start), e.splice(t - 2, 2)),
            e
          )
        },
        concrete: !0,
      },
      iN = {
        tokenize: function (e, t, n) {
          return function (r) {
            return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), e.attempt($R, t, n)
          }
        },
        partial: !0,
      },
      sN = {
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return QP(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), a) : n(t)
          }
          function a(e) {
            return r.parser.lazy[r.now().line] ? n(e) : t(e)
          }
        },
        partial: !0,
      },
      lN = {
        name: "htmlText",
        tokenize: function (e, t, n) {
          const r = this
          let a, o, i
          return function (t) {
            return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(t), s
          }
          function s(t) {
            return 33 === t
              ? (e.consume(t), l)
              : 47 === t
                ? (e.consume(t), O)
                : 63 === t
                  ? (e.consume(t), v)
                  : DP(t)
                    ? (e.consume(t), k)
                    : n(t)
          }
          function l(t) {
            return 45 === t
              ? (e.consume(t), c)
              : 91 === t
                ? (e.consume(t), (o = 0), h)
                : DP(t)
                  ? (e.consume(t), b)
                  : n(t)
          }
          function c(t) {
            return 45 === t ? (e.consume(t), p) : n(t)
          }
          function d(t) {
            return null === t ? n(t) : 45 === t ? (e.consume(t), u) : QP(t) ? ((i = d), R(t)) : (e.consume(t), d)
          }
          function u(t) {
            return 45 === t ? (e.consume(t), p) : d(t)
          }
          function p(e) {
            return 62 === e ? D(e) : 45 === e ? u(e) : d(e)
          }
          function h(t) {
            return t === "CDATA[".charCodeAt(o++) ? (e.consume(t), 6 === o ? f : h) : n(t)
          }
          function f(t) {
            return null === t ? n(t) : 93 === t ? (e.consume(t), m) : QP(t) ? ((i = f), R(t)) : (e.consume(t), f)
          }
          function m(t) {
            return 93 === t ? (e.consume(t), g) : f(t)
          }
          function g(t) {
            return 62 === t ? D(t) : 93 === t ? (e.consume(t), g) : f(t)
          }
          function b(t) {
            return null === t || 62 === t ? D(t) : QP(t) ? ((i = b), R(t)) : (e.consume(t), b)
          }
          function v(t) {
            return null === t ? n(t) : 63 === t ? (e.consume(t), y) : QP(t) ? ((i = v), R(t)) : (e.consume(t), v)
          }
          function y(e) {
            return 62 === e ? D(e) : v(e)
          }
          function O(t) {
            return DP(t) ? (e.consume(t), w) : n(t)
          }
          function w(t) {
            return 45 === t || RP(t) ? (e.consume(t), w) : x(t)
          }
          function x(t) {
            return QP(t) ? ((i = x), R(t)) : jP(t) ? (e.consume(t), x) : D(t)
          }
          function k(t) {
            return 45 === t || RP(t) ? (e.consume(t), k) : 47 === t || 62 === t || BP(t) ? _(t) : n(t)
          }
          function _(t) {
            return 47 === t
              ? (e.consume(t), D)
              : 58 === t || 95 === t || DP(t)
                ? (e.consume(t), S)
                : QP(t)
                  ? ((i = _), R(t))
                  : jP(t)
                    ? (e.consume(t), _)
                    : D(t)
          }
          function S(t) {
            return 45 === t || 46 === t || 58 === t || 95 === t || RP(t) ? (e.consume(t), S) : E(t)
          }
          function E(t) {
            return 61 === t ? (e.consume(t), T) : QP(t) ? ((i = E), R(t)) : jP(t) ? (e.consume(t), E) : _(t)
          }
          function T(t) {
            return null === t || 60 === t || 61 === t || 62 === t || 96 === t
              ? n(t)
              : 34 === t || 39 === t
                ? (e.consume(t), (a = t), A)
                : QP(t)
                  ? ((i = T), R(t))
                  : jP(t)
                    ? (e.consume(t), T)
                    : (e.consume(t), C)
          }
          function A(t) {
            return t === a
              ? (e.consume(t), (a = void 0), P)
              : null === t
                ? n(t)
                : QP(t)
                  ? ((i = A), R(t))
                  : (e.consume(t), A)
          }
          function C(t) {
            return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 96 === t
              ? n(t)
              : 47 === t || 62 === t || BP(t)
                ? _(t)
                : (e.consume(t), C)
          }
          function P(e) {
            return 47 === e || 62 === e || BP(e) ? _(e) : n(e)
          }
          function D(r) {
            return 62 === r ? (e.consume(r), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(r)
          }
          function R(t) {
            return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), N
          }
          function N(t) {
            return jP(t)
              ? NR(e, $, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t)
              : $(t)
          }
          function $(t) {
            return e.enter("htmlTextData"), i(t)
          }
        },
      },
      cN = {
        name: "labelEnd",
        tokenize: function (e, t, n) {
          const r = this
          let a,
            o,
            i = r.events.length
          for (; i--; )
            if (
              ("labelImage" === r.events[i][1].type || "labelLink" === r.events[i][1].type) &&
              !r.events[i][1]._balanced
            ) {
              a = r.events[i][1]
              break
            }
          return function (t) {
            return a
              ? a._inactive
                ? d(t)
                : ((o = r.parser.defined.includes(aD(r.sliceSerialize({ start: a.end, end: r.now() })))),
                  e.enter("labelEnd"),
                  e.enter("labelMarker"),
                  e.consume(t),
                  e.exit("labelMarker"),
                  e.exit("labelEnd"),
                  s)
              : n(t)
          }
          function s(t) {
            return 40 === t
              ? e.attempt(dN, c, o ? c : d)(t)
              : 91 === t
                ? e.attempt(uN, c, o ? l : d)(t)
                : o
                  ? c(t)
                  : d(t)
          }
          function l(t) {
            return e.attempt(pN, c, d)(t)
          }
          function c(e) {
            return t(e)
          }
          function d(e) {
            return (a._balanced = !0), n(e)
          }
        },
        resolveTo: function (e, t) {
          let n,
            r,
            a,
            o,
            i = e.length,
            s = 0
          for (; i--; )
            if (((n = e[i][1]), r)) {
              if ("link" === n.type || ("labelLink" === n.type && n._inactive)) break
              "enter" === e[i][0] && "labelLink" === n.type && (n._inactive = !0)
            } else if (a) {
              if (
                "enter" === e[i][0] &&
                ("labelImage" === n.type || "labelLink" === n.type) &&
                !n._balanced &&
                ((r = i), "labelLink" !== n.type)
              ) {
                s = 2
                break
              }
            } else "labelEnd" === n.type && (a = i)
          const l = {
              type: "labelLink" === e[r][1].type ? "link" : "image",
              start: Object.assign({}, e[r][1].start),
              end: Object.assign({}, e[e.length - 1][1].end),
            },
            c = { type: "label", start: Object.assign({}, e[r][1].start), end: Object.assign({}, e[a][1].end) },
            d = {
              type: "labelText",
              start: Object.assign({}, e[r + s + 2][1].end),
              end: Object.assign({}, e[a - 2][1].start),
            }
          return (
            (o = [
              ["enter", l, t],
              ["enter", c, t],
            ]),
            (o = sR(o, e.slice(r + 1, r + s + 3))),
            (o = sR(o, [["enter", d, t]])),
            (o = sR(o, CR(t.parser.constructs.insideSpan.null, e.slice(r + s + 4, a - 3), t))),
            (o = sR(o, [["exit", d, t], e[a - 2], e[a - 1], ["exit", c, t]])),
            (o = sR(o, e.slice(a + 1))),
            (o = sR(o, [["exit", l, t]])),
            iR(e, r, e.length, o),
            e
          )
        },
        resolveAll: function (e) {
          let t = -1
          for (; ++t < e.length; ) {
            const n = e[t][1]
            ;("labelImage" !== n.type && "labelLink" !== n.type && "labelEnd" !== n.type) ||
              (e.splice(t + 1, "labelImage" === n.type ? 4 : 2), (n.type = "data"), t++)
          }
          return e
        },
      },
      dN = {
        tokenize: function (e, t, n) {
          return function (t) {
            return e.enter("resource"), e.enter("resourceMarker"), e.consume(t), e.exit("resourceMarker"), r
          }
          function r(t) {
            return BP(t) ? KR(e, a)(t) : a(t)
          }
          function a(t) {
            return 41 === t
              ? c(t)
              : XR(
                  e,
                  o,
                  i,
                  "resourceDestination",
                  "resourceDestinationLiteral",
                  "resourceDestinationLiteralMarker",
                  "resourceDestinationRaw",
                  "resourceDestinationString",
                  32,
                )(t)
          }
          function o(t) {
            return BP(t) ? KR(e, s)(t) : c(t)
          }
          function i(e) {
            return n(e)
          }
          function s(t) {
            return 34 === t || 39 === t || 40 === t
              ? GR(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t)
              : c(t)
          }
          function l(t) {
            return BP(t) ? KR(e, c)(t) : c(t)
          }
          function c(r) {
            return 41 === r
              ? (e.enter("resourceMarker"), e.consume(r), e.exit("resourceMarker"), e.exit("resource"), t)
              : n(r)
          }
        },
      },
      uN = {
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return YR.call(r, e, a, o, "reference", "referenceMarker", "referenceString")(t)
          }
          function a(e) {
            return r.parser.defined.includes(aD(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)))
              ? t(e)
              : n(e)
          }
          function o(e) {
            return n(e)
          }
        },
      },
      pN = {
        tokenize: function (e, t, n) {
          return function (t) {
            return e.enter("reference"), e.enter("referenceMarker"), e.consume(t), e.exit("referenceMarker"), r
          }
          function r(r) {
            return 93 === r
              ? (e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), e.exit("reference"), t)
              : n(r)
          }
        },
      },
      hN = {
        name: "labelStartImage",
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(t), e.exit("labelImageMarker"), a
          }
          function a(t) {
            return 91 === t
              ? (e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelImage"), o)
              : n(t)
          }
          function o(e) {
            return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e)
          }
        },
        resolveAll: cN.resolveAll,
      },
      fN = {
        name: "labelStartLink",
        tokenize: function (e, t, n) {
          const r = this
          return function (t) {
            return (
              e.enter("labelLink"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelLink"), a
            )
          }
          function a(e) {
            return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e)
          }
        },
        resolveAll: cN.resolveAll,
      },
      mN = {
        name: "lineEnding",
        tokenize: function (e, t) {
          return function (n) {
            return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), NR(e, t, "linePrefix")
          }
        },
      },
      gN = {
        name: "thematicBreak",
        tokenize: function (e, t, n) {
          let r,
            a = 0
          return function (t) {
            return (
              e.enter("thematicBreak"),
              (function (e) {
                return (r = e), o(e)
              })(t)
            )
          }
          function o(o) {
            return o === r
              ? (e.enter("thematicBreakSequence"), i(o))
              : a >= 3 && (null === o || QP(o))
                ? (e.exit("thematicBreak"), t(o))
                : n(o)
          }
          function i(t) {
            return t === r
              ? (e.consume(t), a++, i)
              : (e.exit("thematicBreakSequence"), jP(t) ? NR(e, o, "whitespace")(t) : o(t))
          }
        },
      },
      bN = {
        name: "list",
        tokenize: function (e, t, n) {
          const r = this,
            a = r.events[r.events.length - 1]
          let o = a && "linePrefix" === a[1].type ? a[2].sliceSerialize(a[1], !0).length : 0,
            i = 0
          return function (t) {
            const a = r.containerState.type || (42 === t || 43 === t || 45 === t ? "listUnordered" : "listOrdered")
            if ("listUnordered" === a ? !r.containerState.marker || t === r.containerState.marker : IP(t)) {
              if (
                (r.containerState.type || ((r.containerState.type = a), e.enter(a, { _container: !0 })),
                "listUnordered" === a)
              )
                return e.enter("listItemPrefix"), 42 === t || 45 === t ? e.check(gN, n, l)(t) : l(t)
              if (!r.interrupt || 49 === t) return e.enter("listItemPrefix"), e.enter("listItemValue"), s(t)
            }
            return n(t)
          }
          function s(t) {
            return IP(t) && ++i < 10
              ? (e.consume(t), s)
              : (!r.interrupt || i < 2) &&
                  (r.containerState.marker ? t === r.containerState.marker : 41 === t || 46 === t)
                ? (e.exit("listItemValue"), l(t))
                : n(t)
          }
          function l(t) {
            return (
              e.enter("listItemMarker"),
              e.consume(t),
              e.exit("listItemMarker"),
              (r.containerState.marker = r.containerState.marker || t),
              e.check($R, r.interrupt ? n : c, e.attempt(vN, u, d))
            )
          }
          function c(e) {
            return (r.containerState.initialBlankLine = !0), o++, u(e)
          }
          function d(t) {
            return jP(t)
              ? (e.enter("listItemPrefixWhitespace"), e.consume(t), e.exit("listItemPrefixWhitespace"), u)
              : n(t)
          }
          function u(n) {
            return (r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length), t(n)
          }
        },
        continuation: {
          tokenize: function (e, t, n) {
            const r = this
            return (
              (r.containerState._closeFlow = void 0),
              e.check(
                $R,
                function (n) {
                  return (
                    (r.containerState.furtherBlankLines =
                      r.containerState.furtherBlankLines || r.containerState.initialBlankLine),
                    NR(e, t, "listItemIndent", r.containerState.size + 1)(n)
                  )
                },
                function (n) {
                  return r.containerState.furtherBlankLines || !jP(n)
                    ? ((r.containerState.furtherBlankLines = void 0),
                      (r.containerState.initialBlankLine = void 0),
                      a(n))
                    : ((r.containerState.furtherBlankLines = void 0),
                      (r.containerState.initialBlankLine = void 0),
                      e.attempt(yN, t, a)(n))
                },
              )
            )
            function a(a) {
              return (
                (r.containerState._closeFlow = !0),
                (r.interrupt = void 0),
                NR(
                  e,
                  e.attempt(bN, t, n),
                  "linePrefix",
                  r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
                )(a)
              )
            }
          },
        },
        exit: function (e) {
          e.exit(this.containerState.type)
        },
      },
      vN = {
        tokenize: function (e, t, n) {
          const r = this
          return NR(
            e,
            function (e) {
              const a = r.events[r.events.length - 1]
              return !jP(e) && a && "listItemPrefixWhitespace" === a[1].type ? t(e) : n(e)
            },
            "listItemPrefixWhitespace",
            r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5,
          )
        },
        partial: !0,
      },
      yN = {
        tokenize: function (e, t, n) {
          const r = this
          return NR(
            e,
            function (e) {
              const a = r.events[r.events.length - 1]
              return a &&
                "listItemIndent" === a[1].type &&
                a[2].sliceSerialize(a[1], !0).length === r.containerState.size
                ? t(e)
                : n(e)
            },
            "listItemIndent",
            r.containerState.size + 1,
          )
        },
        partial: !0,
      },
      ON = {
        name: "setextUnderline",
        tokenize: function (e, t, n) {
          const r = this
          let a
          return function (t) {
            let i,
              s = r.events.length
            for (; s--; )
              if (
                "lineEnding" !== r.events[s][1].type &&
                "linePrefix" !== r.events[s][1].type &&
                "content" !== r.events[s][1].type
              ) {
                i = "paragraph" === r.events[s][1].type
                break
              }
            return r.parser.lazy[r.now().line] || (!r.interrupt && !i)
              ? n(t)
              : (e.enter("setextHeadingLine"),
                (a = t),
                (function (t) {
                  return e.enter("setextHeadingLineSequence"), o(t)
                })(t))
          }
          function o(t) {
            return t === a
              ? (e.consume(t), o)
              : (e.exit("setextHeadingLineSequence"), jP(t) ? NR(e, i, "lineSuffix")(t) : i(t))
          }
          function i(r) {
            return null === r || QP(r) ? (e.exit("setextHeadingLine"), t(r)) : n(r)
          }
        },
        resolveTo: function (e, t) {
          let n,
            r,
            a,
            o = e.length
          for (; o--; )
            if ("enter" === e[o][0]) {
              if ("content" === e[o][1].type) {
                n = o
                break
              }
              "paragraph" === e[o][1].type && (r = o)
            } else "content" === e[o][1].type && e.splice(o, 1), a || "definition" !== e[o][1].type || (a = o)
          const i = {
            type: "setextHeading",
            start: Object.assign({}, e[r][1].start),
            end: Object.assign({}, e[e.length - 1][1].end),
          }
          return (
            (e[r][1].type = "setextHeadingText"),
            a
              ? (e.splice(r, 0, ["enter", i, t]),
                e.splice(a + 1, 0, ["exit", e[n][1], t]),
                (e[n][1].end = Object.assign({}, e[a][1].end)))
              : (e[n][1] = i),
            e.push(["exit", i, t]),
            e
          )
        },
      },
      wN = {
        tokenize: function (e, t, n) {
          const r = this
          return NR(
            e,
            function (e) {
              const a = r.events[r.events.length - 1]
              return a && "gfmFootnoteDefinitionIndent" === a[1].type && 4 === a[2].sliceSerialize(a[1], !0).length
                ? t(e)
                : n(e)
            },
            "gfmFootnoteDefinitionIndent",
            5,
          )
        },
        partial: !0,
      }
    function xN(e, t, n) {
      const r = this
      let a = r.events.length
      const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
      let i
      for (; a--; ) {
        const e = r.events[a][1]
        if ("labelImage" === e.type) {
          i = e
          break
        }
        if (
          "gfmFootnoteCall" === e.type ||
          "labelLink" === e.type ||
          "label" === e.type ||
          "image" === e.type ||
          "link" === e.type
        )
          break
      }
      return function (a) {
        if (!i || !i._balanced) return n(a)
        const s = aD(r.sliceSerialize({ start: i.end, end: r.now() }))
        return 94 === s.codePointAt(0) && o.includes(s.slice(1))
          ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(a), e.exit("gfmFootnoteCallLabelMarker"), t(a))
          : n(a)
      }
    }
    function kN(e, t) {
      let n = e.length
      for (; n--; )
        if ("labelImage" === e[n][1].type && "enter" === e[n][0]) {
          e[n][1]
          break
        }
      ;(e[n + 1][1].type = "data"), (e[n + 3][1].type = "gfmFootnoteCallLabelMarker")
      const r = {
          type: "gfmFootnoteCall",
          start: Object.assign({}, e[n + 3][1].start),
          end: Object.assign({}, e[e.length - 1][1].end),
        },
        a = {
          type: "gfmFootnoteCallMarker",
          start: Object.assign({}, e[n + 3][1].end),
          end: Object.assign({}, e[n + 3][1].end),
        }
      a.end.column++, a.end.offset++, a.end._bufferIndex++
      const o = {
          type: "gfmFootnoteCallString",
          start: Object.assign({}, a.end),
          end: Object.assign({}, e[e.length - 1][1].start),
        },
        i = {
          type: "chunkString",
          contentType: "string",
          start: Object.assign({}, o.start),
          end: Object.assign({}, o.end),
        },
        s = [
          e[n + 1],
          e[n + 2],
          ["enter", r, t],
          e[n + 3],
          e[n + 4],
          ["enter", a, t],
          ["exit", a, t],
          ["enter", o, t],
          ["enter", i, t],
          ["exit", i, t],
          ["exit", o, t],
          e[e.length - 2],
          e[e.length - 1],
          ["exit", r, t],
        ]
      return e.splice(n, e.length - n + 1, ...s), e
    }
    function _N(e, t, n) {
      const r = this,
        a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
      let o,
        i = 0
      return function (t) {
        return (
          e.enter("gfmFootnoteCall"),
          e.enter("gfmFootnoteCallLabelMarker"),
          e.consume(t),
          e.exit("gfmFootnoteCallLabelMarker"),
          s
        )
      }
      function s(t) {
        return 94 !== t
          ? n(t)
          : (e.enter("gfmFootnoteCallMarker"),
            e.consume(t),
            e.exit("gfmFootnoteCallMarker"),
            e.enter("gfmFootnoteCallString"),
            (e.enter("chunkString").contentType = "string"),
            l)
      }
      function l(s) {
        if (i > 999 || (93 === s && !o) || null === s || 91 === s || BP(s)) return n(s)
        if (93 === s) {
          e.exit("chunkString")
          const o = e.exit("gfmFootnoteCallString")
          return a.includes(aD(r.sliceSerialize(o)))
            ? (e.enter("gfmFootnoteCallLabelMarker"),
              e.consume(s),
              e.exit("gfmFootnoteCallLabelMarker"),
              e.exit("gfmFootnoteCall"),
              t)
            : n(s)
        }
        return BP(s) || (o = !0), i++, e.consume(s), 92 === s ? c : l
      }
      function c(t) {
        return 91 === t || 92 === t || 93 === t ? (e.consume(t), i++, l) : l(t)
      }
    }
    function SN(e, t, n) {
      const r = this,
        a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
      let o,
        i,
        s = 0
      return function (t) {
        return (
          (e.enter("gfmFootnoteDefinition")._container = !0),
          e.enter("gfmFootnoteDefinitionLabel"),
          e.enter("gfmFootnoteDefinitionLabelMarker"),
          e.consume(t),
          e.exit("gfmFootnoteDefinitionLabelMarker"),
          l
        )
      }
      function l(t) {
        return 94 === t
          ? (e.enter("gfmFootnoteDefinitionMarker"),
            e.consume(t),
            e.exit("gfmFootnoteDefinitionMarker"),
            e.enter("gfmFootnoteDefinitionLabelString"),
            (e.enter("chunkString").contentType = "string"),
            c)
          : n(t)
      }
      function c(t) {
        if (s > 999 || (93 === t && !i) || null === t || 91 === t || BP(t)) return n(t)
        if (93 === t) {
          e.exit("chunkString")
          const n = e.exit("gfmFootnoteDefinitionLabelString")
          return (
            (o = aD(r.sliceSerialize(n))),
            e.enter("gfmFootnoteDefinitionLabelMarker"),
            e.consume(t),
            e.exit("gfmFootnoteDefinitionLabelMarker"),
            e.exit("gfmFootnoteDefinitionLabel"),
            u
          )
        }
        return BP(t) || (i = !0), s++, e.consume(t), 92 === t ? d : c
      }
      function d(t) {
        return 91 === t || 92 === t || 93 === t ? (e.consume(t), s++, c) : c(t)
      }
      function u(t) {
        return 58 === t
          ? (e.enter("definitionMarker"),
            e.consume(t),
            e.exit("definitionMarker"),
            a.includes(o) || a.push(o),
            NR(e, p, "gfmFootnoteDefinitionWhitespace"))
          : n(t)
      }
      function p(e) {
        return t(e)
      }
    }
    function EN(e, t, n) {
      return e.check($R, t, e.attempt(wN, t, n))
    }
    function TN(e) {
      e.exit("gfmFootnoteDefinition")
    }
    function AN(e) {
      let t = (e || {}).singleTilde
      const n = {
        tokenize: function (e, n, r) {
          const a = this.previous,
            o = this.events
          let i = 0
          return function (t) {
            return 126 === a && "characterEscape" !== o[o.length - 1][1].type
              ? r(t)
              : (e.enter("strikethroughSequenceTemporary"), s(t))
          }
          function s(o) {
            const l = AR(a)
            if (126 === o) return i > 1 ? r(o) : (e.consume(o), i++, s)
            if (i < 2 && !t) return r(o)
            const c = e.exit("strikethroughSequenceTemporary"),
              d = AR(o)
            return (c._open = !d || (2 === d && Boolean(l))), (c._close = !l || (2 === l && Boolean(d))), n(o)
          }
        },
        resolveAll: function (e, t) {
          let n = -1
          for (; ++n < e.length; )
            if ("enter" === e[n][0] && "strikethroughSequenceTemporary" === e[n][1].type && e[n][1]._close) {
              let r = n
              for (; r--; )
                if (
                  "exit" === e[r][0] &&
                  "strikethroughSequenceTemporary" === e[r][1].type &&
                  e[r][1]._open &&
                  e[n][1].end.offset - e[n][1].start.offset == e[r][1].end.offset - e[r][1].start.offset
                ) {
                  ;(e[n][1].type = "strikethroughSequence"), (e[r][1].type = "strikethroughSequence")
                  const a = {
                      type: "strikethrough",
                      start: Object.assign({}, e[r][1].start),
                      end: Object.assign({}, e[n][1].end),
                    },
                    o = {
                      type: "strikethroughText",
                      start: Object.assign({}, e[r][1].end),
                      end: Object.assign({}, e[n][1].start),
                    },
                    i = [
                      ["enter", a, t],
                      ["enter", e[r][1], t],
                      ["exit", e[r][1], t],
                      ["enter", o, t],
                    ],
                    s = t.parser.constructs.insideSpan.null
                  s && iR(i, i.length, 0, CR(s, e.slice(r + 1, n), t)),
                    iR(i, i.length, 0, [
                      ["exit", o, t],
                      ["enter", e[n][1], t],
                      ["exit", e[n][1], t],
                      ["exit", a, t],
                    ]),
                    iR(e, r - 1, n - r + 3, i),
                    (n = r + i.length - 2)
                  break
                }
            }
          for (n = -1; ++n < e.length; ) "strikethroughSequenceTemporary" === e[n][1].type && (e[n][1].type = "data")
          return e
        },
      }
      return null == t && (t = !0), { text: { 126: n }, insideSpan: { null: [n] }, attentionMarkers: { null: [126] } }
    }
    class CN {
      constructor() {
        this.map = []
      }
      add(e, t, n) {
        !(function (e, t, n, r) {
          let a = 0
          if (0 !== n || 0 !== r.length) {
            for (; a < e.map.length; ) {
              if (e.map[a][0] === t) return (e.map[a][1] += n), void e.map[a][2].push(...r)
              a += 1
            }
            e.map.push([t, n, r])
          }
        })(this, e, t, n)
      }
      consume(e) {
        if (
          (this.map.sort(function (e, t) {
            return e[0] - t[0]
          }),
          0 === this.map.length)
        )
          return
        let t = this.map.length
        const n = []
        for (; t > 0; )
          (t -= 1), n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), (e.length = this.map[t][0])
        n.push([...e]), (e.length = 0)
        let r = n.pop()
        for (; r; ) e.push(...r), (r = n.pop())
        this.map.length = 0
      }
    }
    function PN(e, t) {
      let n = !1
      const r = []
      for (; t < e.length; ) {
        const a = e[t]
        if (n) {
          if ("enter" === a[0])
            "tableContent" === a[1].type && r.push("tableDelimiterMarker" === e[t + 1][1].type ? "left" : "none")
          else if ("tableContent" === a[1].type) {
            if ("tableDelimiterMarker" === e[t - 1][1].type) {
              const e = r.length - 1
              r[e] = "left" === r[e] ? "center" : "right"
            }
          } else if ("tableDelimiterRow" === a[1].type) break
        } else "enter" === a[0] && "tableDelimiterRow" === a[1].type && (n = !0)
        t += 1
      }
      return r
    }
    function DN(e, t, n) {
      const r = this
      let a,
        o = 0,
        i = 0
      return function (e) {
        let t = r.events.length - 1
        for (; t > -1; ) {
          const e = r.events[t][1].type
          if ("lineEnding" !== e && "linePrefix" !== e) break
          t--
        }
        const a = t > -1 ? r.events[t][1].type : null,
          o = "tableHead" === a || "tableRow" === a ? O : s
        return o === O && r.parser.lazy[r.now().line] ? n(e) : o(e)
      }
      function s(t) {
        return (
          e.enter("tableHead"),
          e.enter("tableRow"),
          (function (e) {
            return 124 === e || ((a = !0), (i += 1)), l(e)
          })(t)
        )
      }
      function l(t) {
        return null === t
          ? n(t)
          : QP(t)
            ? i > 1
              ? ((i = 0),
                (r.interrupt = !0),
                e.exit("tableRow"),
                e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                u)
              : n(t)
            : jP(t)
              ? NR(e, l, "whitespace")(t)
              : ((i += 1),
                a && ((a = !1), (o += 1)),
                124 === t
                  ? (e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), (a = !0), l)
                  : (e.enter("data"), c(t)))
      }
      function c(t) {
        return null === t || 124 === t || BP(t) ? (e.exit("data"), l(t)) : (e.consume(t), 92 === t ? d : c)
      }
      function d(t) {
        return 92 === t || 124 === t ? (e.consume(t), c) : c(t)
      }
      function u(t) {
        return (
          (r.interrupt = !1),
          r.parser.lazy[r.now().line]
            ? n(t)
            : (e.enter("tableDelimiterRow"),
              (a = !1),
              jP(t)
                ? NR(e, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t)
                : p(t))
        )
      }
      function p(t) {
        return 45 === t || 58 === t
          ? f(t)
          : 124 === t
            ? ((a = !0), e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), h)
            : y(t)
      }
      function h(t) {
        return jP(t) ? NR(e, f, "whitespace")(t) : f(t)
      }
      function f(t) {
        return 58 === t
          ? ((i += 1), (a = !0), e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), m)
          : 45 === t
            ? ((i += 1), m(t))
            : null === t || QP(t)
              ? v(t)
              : y(t)
      }
      function m(t) {
        return 45 === t ? (e.enter("tableDelimiterFiller"), g(t)) : y(t)
      }
      function g(t) {
        return 45 === t
          ? (e.consume(t), g)
          : 58 === t
            ? ((a = !0),
              e.exit("tableDelimiterFiller"),
              e.enter("tableDelimiterMarker"),
              e.consume(t),
              e.exit("tableDelimiterMarker"),
              b)
            : (e.exit("tableDelimiterFiller"), b(t))
      }
      function b(t) {
        return jP(t) ? NR(e, v, "whitespace")(t) : v(t)
      }
      function v(n) {
        return 124 === n
          ? p(n)
          : (null === n || QP(n)) && a && o === i
            ? (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(n))
            : y(n)
      }
      function y(e) {
        return n(e)
      }
      function O(t) {
        return e.enter("tableRow"), w(t)
      }
      function w(n) {
        return 124 === n
          ? (e.enter("tableCellDivider"), e.consume(n), e.exit("tableCellDivider"), w)
          : null === n || QP(n)
            ? (e.exit("tableRow"), t(n))
            : jP(n)
              ? NR(e, w, "whitespace")(n)
              : (e.enter("data"), x(n))
      }
      function x(t) {
        return null === t || 124 === t || BP(t) ? (e.exit("data"), w(t)) : (e.consume(t), 92 === t ? k : x)
      }
      function k(t) {
        return 92 === t || 124 === t ? (e.consume(t), x) : x(t)
      }
    }
    function RN(e, t) {
      let n,
        r,
        a,
        o = -1,
        i = !0,
        s = 0,
        l = [0, 0, 0, 0],
        c = [0, 0, 0, 0],
        d = !1,
        u = 0
      const p = new CN()
      for (; ++o < e.length; ) {
        const h = e[o],
          f = h[1]
        "enter" === h[0]
          ? "tableHead" === f.type
            ? ((d = !1),
              0 !== u && ($N(p, t, u, n, r), (r = void 0), (u = 0)),
              (n = { type: "table", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }),
              p.add(o, 0, [["enter", n, t]]))
            : "tableRow" === f.type || "tableDelimiterRow" === f.type
              ? ((i = !0),
                (a = void 0),
                (l = [0, 0, 0, 0]),
                (c = [0, o + 1, 0, 0]),
                d &&
                  ((d = !1),
                  (r = { type: "tableBody", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }),
                  p.add(o, 0, [["enter", r, t]])),
                (s = "tableDelimiterRow" === f.type ? 2 : r ? 3 : 1))
              : !s || ("data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type)
                ? "tableCellDivider" === f.type &&
                  (i
                    ? (i = !1)
                    : (0 !== l[1] && ((c[0] = c[1]), (a = NN(p, t, l, s, void 0, a))), (l = c), (c = [l[1], o, 0, 0])))
                : ((i = !1),
                  0 === c[2] &&
                    (0 !== l[1] && ((c[0] = c[1]), (a = NN(p, t, l, s, void 0, a)), (l = [0, 0, 0, 0])), (c[2] = o)))
          : "tableHead" === f.type
            ? ((d = !0), (u = o))
            : "tableRow" === f.type || "tableDelimiterRow" === f.type
              ? ((u = o),
                0 !== l[1] ? ((c[0] = c[1]), (a = NN(p, t, l, s, o, a))) : 0 !== c[1] && (a = NN(p, t, c, s, o, a)),
                (s = 0))
              : !s ||
                ("data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type) ||
                (c[3] = o)
      }
      for (0 !== u && $N(p, t, u, n, r), p.consume(t.events), o = -1; ++o < t.events.length; ) {
        const e = t.events[o]
        "enter" === e[0] && "table" === e[1].type && (e[1]._align = PN(t.events, o))
      }
      return e
    }
    function NN(e, t, n, r, a, o) {
      const i = 1 === r ? "tableHeader" : 2 === r ? "tableDelimiter" : "tableData"
      0 !== n[0] && ((o.end = Object.assign({}, IN(t.events, n[0]))), e.add(n[0], 0, [["exit", o, t]]))
      const s = IN(t.events, n[1])
      if (
        ((o = { type: i, start: Object.assign({}, s), end: Object.assign({}, s) }),
        e.add(n[1], 0, [["enter", o, t]]),
        0 !== n[2])
      ) {
        const a = IN(t.events, n[2]),
          o = IN(t.events, n[3]),
          i = { type: "tableContent", start: Object.assign({}, a), end: Object.assign({}, o) }
        if ((e.add(n[2], 0, [["enter", i, t]]), 2 !== r)) {
          const r = t.events[n[2]],
            a = t.events[n[3]]
          if (
            ((r[1].end = Object.assign({}, a[1].end)),
            (r[1].type = "chunkText"),
            (r[1].contentType = "text"),
            n[3] > n[2] + 1)
          ) {
            const t = n[2] + 1,
              r = n[3] - n[2] - 1
            e.add(t, r, [])
          }
        }
        e.add(n[3] + 1, 0, [["exit", i, t]])
      }
      return (
        void 0 !== a && ((o.end = Object.assign({}, IN(t.events, a))), e.add(a, 0, [["exit", o, t]]), (o = void 0)), o
      )
    }
    function $N(e, t, n, r, a) {
      const o = [],
        i = IN(t.events, n)
      a && ((a.end = Object.assign({}, i)), o.push(["exit", a, t])),
        (r.end = Object.assign({}, i)),
        o.push(["exit", r, t]),
        e.add(n + 1, 0, o)
    }
    function IN(e, t) {
      const n = e[t],
        r = "enter" === n[0] ? "start" : "end"
      return n[1][r]
    }
    const MN = {
      tokenize: function (e, t, n) {
        const r = this
        return function (t) {
          return null === r.previous && r._gfmTasklistFirstContentOfListItem
            ? (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), a)
            : n(t)
        }
        function a(t) {
          return BP(t)
            ? (e.enter("taskListCheckValueUnchecked"), e.consume(t), e.exit("taskListCheckValueUnchecked"), o)
            : 88 === t || 120 === t
              ? (e.enter("taskListCheckValueChecked"), e.consume(t), e.exit("taskListCheckValueChecked"), o)
              : n(t)
        }
        function o(t) {
          return 93 === t
            ? (e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), i)
            : n(t)
        }
        function i(r) {
          return QP(r) ? t(r) : jP(r) ? e.check({ tokenize: LN }, t, n)(r) : n(r)
        }
      },
    }
    function LN(e, t, n) {
      return NR(
        e,
        function (e) {
          return null === e ? n(e) : t(e)
        },
        "whitespace",
      )
    }
    const QN = {}
    function BN(e) {
      const t = e || QN,
        n = this.data(),
        r = n.micromarkExtensions || (n.micromarkExtensions = []),
        a = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []),
        o = n.toMarkdownExtensions || (n.toMarkdownExtensions = [])
      r.push(
        (function (e) {
          return cR([
            { text: OR },
            {
              document: { 91: { tokenize: SN, continuation: { tokenize: EN }, exit: TN } },
              text: { 91: { tokenize: _N }, 93: { add: "after", tokenize: xN, resolveTo: kN } },
            },
            AN(e),
            { flow: { null: { tokenize: DN, resolveAll: RN } } },
            { text: { 91: MN } },
          ])
        })(t),
      ),
        a.push([
          {
            transforms: [eD],
            enter: { literalAutolink: WP, literalAutolinkEmail: XP, literalAutolinkHttp: XP, literalAutolinkWww: XP },
            exit: { literalAutolink: JP, literalAutolinkEmail: KP, literalAutolinkHttp: YP, literalAutolinkWww: GP },
          },
          {
            enter: {
              gfmFootnoteDefinition: oD,
              gfmFootnoteDefinitionLabelString: iD,
              gfmFootnoteCall: cD,
              gfmFootnoteCallString: dD,
            },
            exit: {
              gfmFootnoteDefinition: lD,
              gfmFootnoteDefinitionLabelString: sD,
              gfmFootnoteCall: pD,
              gfmFootnoteCallString: uD,
            },
          },
          { canContainEols: ["delete"], enter: { strikethrough: bD }, exit: { strikethrough: vD } },
          {
            enter: { table: XD, tableData: JD, tableHeader: JD, tableRow: GD },
            exit: { codeText: eR, table: YD, tableData: KD, tableHeader: KD, tableRow: KD },
          },
          { exit: { taskListCheckValueChecked: rR, taskListCheckValueUnchecked: rR, paragraph: aR } },
        ]),
        o.push(
          (function (e) {
            return {
              extensions: [
                {
                  unsafe: [
                    { character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: HP, notInConstruct: VP },
                    { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: HP, notInConstruct: VP },
                    { character: ":", before: "[ps]", after: "\\/", inConstruct: HP, notInConstruct: VP },
                  ],
                },
                {
                  unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
                  handlers: { footnoteDefinition: fD, footnoteReference: hD },
                },
                { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: gD }], handlers: { delete: yD } },
                nR(e),
                { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: oR } },
              ],
            }
          })(t),
        )
    }
    const jN = {
        tokenize: function (e) {
          const t = e.attempt(
            this.parser.constructs.contentInitial,
            function (n) {
              if (null !== n) return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), NR(e, t, "linePrefix")
              e.consume(n)
            },
            function (t) {
              return e.enter("paragraph"), r(t)
            },
          )
          let n
          return t
          function r(t) {
            const r = e.enter("chunkText", { contentType: "text", previous: n })
            return n && (n.next = r), (n = r), a(t)
          }
          function a(t) {
            return null === t
              ? (e.exit("chunkText"), e.exit("paragraph"), void e.consume(t))
              : QP(t)
                ? (e.consume(t), e.exit("chunkText"), r)
                : (e.consume(t), a)
          }
        },
      },
      UN = {
        tokenize: function (e) {
          const t = this,
            n = []
          let r,
            a,
            o,
            i = 0
          return s
          function s(r) {
            if (i < n.length) {
              const a = n[i]
              return (t.containerState = a[1]), e.attempt(a[0].continuation, l, c)(r)
            }
            return c(r)
          }
          function l(e) {
            if ((i++, t.containerState._closeFlow)) {
              ;(t.containerState._closeFlow = void 0), r && v()
              const n = t.events.length
              let a,
                o = n
              for (; o--; )
                if ("exit" === t.events[o][0] && "chunkFlow" === t.events[o][1].type) {
                  a = t.events[o][1].end
                  break
                }
              b(i)
              let s = n
              for (; s < t.events.length; ) (t.events[s][1].end = Object.assign({}, a)), s++
              return iR(t.events, o + 1, 0, t.events.slice(n)), (t.events.length = s), c(e)
            }
            return s(e)
          }
          function c(a) {
            if (i === n.length) {
              if (!r) return p(a)
              if (r.currentConstruct && r.currentConstruct.concrete) return f(a)
              t.interrupt = Boolean(r.currentConstruct && !r._gfmTableDynamicInterruptHack)
            }
            return (t.containerState = {}), e.check(FN, d, u)(a)
          }
          function d(e) {
            return r && v(), b(i), p(e)
          }
          function u(e) {
            return (t.parser.lazy[t.now().line] = i !== n.length), (o = t.now().offset), f(e)
          }
          function p(n) {
            return (t.containerState = {}), e.attempt(FN, h, f)(n)
          }
          function h(e) {
            return i++, n.push([t.currentConstruct, t.containerState]), p(e)
          }
          function f(n) {
            return null === n
              ? (r && v(), b(0), void e.consume(n))
              : ((r = r || t.parser.flow(t.now())),
                e.enter("chunkFlow", { contentType: "flow", previous: a, _tokenizer: r }),
                m(n))
          }
          function m(n) {
            return null === n
              ? (g(e.exit("chunkFlow"), !0), b(0), void e.consume(n))
              : QP(n)
                ? (e.consume(n), g(e.exit("chunkFlow")), (i = 0), (t.interrupt = void 0), s)
                : (e.consume(n), m)
          }
          function g(e, n) {
            const s = t.sliceStream(e)
            if (
              (n && s.push(null),
              (e.previous = a),
              a && (a.next = e),
              (a = e),
              r.defineSkip(e.start),
              r.write(s),
              t.parser.lazy[e.start.line])
            ) {
              let e = r.events.length
              for (; e--; )
                if (r.events[e][1].start.offset < o && (!r.events[e][1].end || r.events[e][1].end.offset > o)) return
              const n = t.events.length
              let a,
                s,
                l = n
              for (; l--; )
                if ("exit" === t.events[l][0] && "chunkFlow" === t.events[l][1].type) {
                  if (a) {
                    s = t.events[l][1].end
                    break
                  }
                  a = !0
                }
              for (b(i), e = n; e < t.events.length; ) (t.events[e][1].end = Object.assign({}, s)), e++
              iR(t.events, l + 1, 0, t.events.slice(n)), (t.events.length = e)
            }
          }
          function b(r) {
            let a = n.length
            for (; a-- > r; ) {
              const r = n[a]
              ;(t.containerState = r[1]), r[0].exit.call(t, e)
            }
            n.length = r
          }
          function v() {
            r.write([null]), (a = void 0), (r = void 0), (t.containerState._closeFlow = void 0)
          }
        },
      },
      FN = {
        tokenize: function (e, t, n) {
          return NR(
            e,
            e.attempt(this.parser.constructs.document, t, n),
            "linePrefix",
            this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
          )
        },
      },
      zN = {
        tokenize: function (e) {
          const t = this,
            n = e.attempt(
              $R,
              function (r) {
                if (null !== r)
                  return (
                    e.enter("lineEndingBlank"),
                    e.consume(r),
                    e.exit("lineEndingBlank"),
                    (t.currentConstruct = void 0),
                    n
                  )
                e.consume(r)
              },
              e.attempt(
                this.parser.constructs.flowInitial,
                r,
                NR(e, e.attempt(this.parser.constructs.flow, r, e.attempt(VR, r)), "linePrefix"),
              ),
            )
          return n
          function r(r) {
            if (null !== r)
              return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), (t.currentConstruct = void 0), n
            e.consume(r)
          }
        },
      },
      qN = { resolveAll: WN() },
      ZN = VN("string"),
      HN = VN("text")
    function VN(e) {
      return {
        tokenize: function (t) {
          const n = this,
            r = this.parser.constructs[e],
            a = t.attempt(r, o, i)
          return o
          function o(e) {
            return l(e) ? a(e) : i(e)
          }
          function i(e) {
            if (null !== e) return t.enter("data"), t.consume(e), s
            t.consume(e)
          }
          function s(e) {
            return l(e) ? (t.exit("data"), a(e)) : (t.consume(e), s)
          }
          function l(e) {
            if (null === e) return !0
            const t = r[e]
            let a = -1
            if (t)
              for (; ++a < t.length; ) {
                const e = t[a]
                if (!e.previous || e.previous.call(n, n.previous)) return !0
              }
            return !1
          }
        },
        resolveAll: WN("text" === e ? XN : void 0),
      }
    }
    function WN(e) {
      return function (t, n) {
        let r,
          a = -1
        for (; ++a <= t.length; )
          void 0 === r
            ? t[a] && "data" === t[a][1].type && ((r = a), a++)
            : (t[a] && "data" === t[a][1].type) ||
              (a !== r + 2 && ((t[r][1].end = t[a - 1][1].end), t.splice(r + 2, a - r - 2), (a = r + 2)), (r = void 0))
        return e ? e(t, n) : t
      }
    }
    function XN(e, t) {
      let n = 0
      for (; ++n <= e.length; )
        if ((n === e.length || "lineEnding" === e[n][1].type) && "data" === e[n - 1][1].type) {
          const r = e[n - 1][1],
            a = t.sliceStream(r)
          let o,
            i = a.length,
            s = -1,
            l = 0
          for (; i--; ) {
            const e = a[i]
            if ("string" == typeof e) {
              for (s = e.length; 32 === e.charCodeAt(s - 1); ) l++, s--
              if (s) break
              s = -1
            } else if (-2 === e) (o = !0), l++
            else if (-1 !== e) {
              i++
              break
            }
          }
          if (l) {
            const a = {
              type: n === e.length || o || l < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: r.end.line,
                column: r.end.column - l,
                offset: r.end.offset - l,
                _index: r.start._index + i,
                _bufferIndex: i ? s : r.start._bufferIndex + s,
              },
              end: Object.assign({}, r.end),
            }
            ;(r.end = Object.assign({}, a.start)),
              r.start.offset === r.end.offset
                ? Object.assign(r, a)
                : (e.splice(n, 0, ["enter", a, t], ["exit", a, t]), (n += 2))
          }
          n++
        }
      return e
    }
    function YN(e, t, n) {
      let r = Object.assign(n ? Object.assign({}, n) : { line: 1, column: 1, offset: 0 }, {
        _index: 0,
        _bufferIndex: -1,
      })
      const a = {},
        o = []
      let i = [],
        s = []
      const l = {
          consume: function (e) {
            QP(e)
              ? (r.line++, (r.column = 1), (r.offset += -3 === e ? 2 : 1), b())
              : -1 !== e && (r.column++, r.offset++),
              r._bufferIndex < 0
                ? r._index++
                : (r._bufferIndex++, r._bufferIndex === i[r._index].length && ((r._bufferIndex = -1), r._index++)),
              (c.previous = e)
          },
          enter: function (e, t) {
            const n = t || {}
            return (n.type = e), (n.start = p()), c.events.push(["enter", n, c]), s.push(n), n
          },
          exit: function (e) {
            const t = s.pop()
            return (t.end = p()), c.events.push(["exit", t, c]), t
          },
          attempt: m(function (e, t) {
            g(e, t.from)
          }),
          check: m(f),
          interrupt: m(f, { interrupt: !0 }),
        },
        c = {
          previous: null,
          code: null,
          containerState: {},
          events: [],
          parser: e,
          sliceStream: u,
          sliceSerialize: function (e, t) {
            return (function (e, t) {
              let n = -1
              const r = []
              let a
              for (; ++n < e.length; ) {
                const o = e[n]
                let i
                if ("string" == typeof o) i = o
                else
                  switch (o) {
                    case -5:
                      i = "\r"
                      break
                    case -4:
                      i = "\n"
                      break
                    case -3:
                      i = "\r\n"
                      break
                    case -2:
                      i = t ? " " : "\t"
                      break
                    case -1:
                      if (!t && a) continue
                      i = " "
                      break
                    default:
                      i = String.fromCharCode(o)
                  }
                ;(a = -2 === o), r.push(i)
              }
              return r.join("")
            })(u(e), t)
          },
          now: p,
          defineSkip: function (e) {
            ;(a[e.line] = e.column), b()
          },
          write: function (e) {
            return (
              (i = sR(i, e)),
              (function () {
                let e
                for (; r._index < i.length; ) {
                  const t = i[r._index]
                  if ("string" == typeof t)
                    for (
                      e = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0);
                      r._index === e && r._bufferIndex < t.length;

                    )
                      h(t.charCodeAt(r._bufferIndex))
                  else h(t)
                }
              })(),
              null !== i[i.length - 1] ? [] : (g(t, 0), (c.events = CR(o, c.events, c)), c.events)
            )
          },
        }
      let d = t.tokenize.call(c, l)
      return t.resolveAll && o.push(t), c
      function u(e) {
        return (function (e, t) {
          const n = t.start._index,
            r = t.start._bufferIndex,
            a = t.end._index,
            o = t.end._bufferIndex
          let i
          if (n === a) i = [e[n].slice(r, o)]
          else {
            if (((i = e.slice(n, a)), r > -1)) {
              const e = i[0]
              "string" == typeof e ? (i[0] = e.slice(r)) : i.shift()
            }
            o > 0 && i.push(e[a].slice(0, o))
          }
          return i
        })(i, e)
      }
      function p() {
        const { line: e, column: t, offset: n, _index: a, _bufferIndex: o } = r
        return { line: e, column: t, offset: n, _index: a, _bufferIndex: o }
      }
      function h(e) {
        d = d(e)
      }
      function f(e, t) {
        t.restore()
      }
      function m(e, t) {
        return function (n, a, o) {
          let i, d, u, h
          return Array.isArray(n)
            ? f(n)
            : "tokenize" in n
              ? f([n])
              : (function (e) {
                  return function (t) {
                    const n = null !== t && e[t],
                      r = null !== t && e.null
                    return f([...(Array.isArray(n) ? n : n ? [n] : []), ...(Array.isArray(r) ? r : r ? [r] : [])])(t)
                  }
                })(n)
          function f(e) {
            return (i = e), (d = 0), 0 === e.length ? o : m(e[d])
          }
          function m(e) {
            return function (n) {
              return (
                (h = (function () {
                  const e = p(),
                    t = c.previous,
                    n = c.currentConstruct,
                    a = c.events.length,
                    o = Array.from(s)
                  return {
                    restore: function () {
                      ;(r = e), (c.previous = t), (c.currentConstruct = n), (c.events.length = a), (s = o), b()
                    },
                    from: a,
                  }
                })()),
                (u = e),
                e.partial || (c.currentConstruct = e),
                e.name && c.parser.constructs.disable.null.includes(e.name)
                  ? v()
                  : e.tokenize.call(t ? Object.assign(Object.create(c), t) : c, l, g, v)(n)
              )
            }
          }
          function g(t) {
            return e(u, h), a
          }
          function v(e) {
            return h.restore(), ++d < i.length ? m(i[d]) : o
          }
        }
      }
      function g(e, t) {
        e.resolveAll && !o.includes(e) && o.push(e),
          e.resolve && iR(c.events, t, c.events.length - t, e.resolve(c.events.slice(t), c)),
          e.resolveTo && (c.events = e.resolveTo(c.events, c))
      }
      function b() {
        r.line in a && r.column < 2 && ((r.column = a[r.line]), (r.offset += a[r.line] - 1))
      }
    }
    const GN = {
        42: bN,
        43: bN,
        45: bN,
        48: bN,
        49: bN,
        50: bN,
        51: bN,
        52: bN,
        53: bN,
        54: bN,
        55: bN,
        56: bN,
        57: bN,
        62: IR,
      },
      KN = { 91: JR },
      JN = { [-2]: jR, [-1]: jR, 32: jR },
      e$ = { 35: nN, 42: gN, 45: [ON, gN], 60: oN, 61: ON, 95: gN, 96: BR, 126: BR },
      t$ = { 38: LR, 92: MR },
      n$ = {
        [-5]: mN,
        [-4]: mN,
        [-3]: mN,
        33: hN,
        38: LR,
        42: PR,
        60: [RR, lN],
        91: fN,
        92: [tN, MR],
        93: cN,
        95: PR,
        96: FR,
      },
      r$ = { null: [PR, qN] },
      a$ = Object.freeze(
        Object.defineProperty(
          {
            __proto__: null,
            attentionMarkers: { null: [42, 95] },
            contentInitial: KN,
            disable: { null: [] },
            document: GN,
            flow: e$,
            flowInitial: JN,
            insideSpan: r$,
            string: t$,
            text: n$,
          },
          Symbol.toStringTag,
          { value: "Module" },
        ),
      ),
      o$ = /[\0\t\n\r]/g
    function i$(e) {
      return e && "object" == typeof e
        ? "position" in e || "type" in e
          ? l$(e.position)
          : "start" in e || "end" in e
            ? l$(e)
            : "line" in e || "column" in e
              ? s$(e)
              : ""
        : ""
    }
    function s$(e) {
      return c$(e && e.line) + ":" + c$(e && e.column)
    }
    function l$(e) {
      return s$(e && e.start) + "-" + s$(e && e.end)
    }
    function c$(e) {
      return e && "number" == typeof e ? e : 1
    }
    const d$ = {}.hasOwnProperty
    function u$(e, t, n) {
      return (
        "string" != typeof t && ((n = t), (t = void 0)),
        (function (e) {
          const t = {
            transforms: [],
            canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
            enter: {
              autolink: a(v),
              autolinkProtocol: d,
              autolinkEmail: d,
              atxHeading: a(m),
              blockQuote: a(function () {
                return { type: "blockquote", children: [] }
              }),
              characterEscape: d,
              characterReference: d,
              codeFenced: a(f),
              codeFencedFenceInfo: o,
              codeFencedFenceMeta: o,
              codeIndented: a(f, o),
              codeText: a(function () {
                return { type: "inlineCode", value: "" }
              }, o),
              codeTextData: d,
              data: d,
              codeFlowValue: d,
              definition: a(function () {
                return { type: "definition", identifier: "", label: null, title: null, url: "" }
              }),
              definitionDestinationString: o,
              definitionLabelString: o,
              definitionTitleString: o,
              emphasis: a(function () {
                return { type: "emphasis", children: [] }
              }),
              hardBreakEscape: a(g),
              hardBreakTrailing: a(g),
              htmlFlow: a(b, o),
              htmlFlowData: d,
              htmlText: a(b, o),
              htmlTextData: d,
              image: a(function () {
                return { type: "image", title: null, url: "", alt: null }
              }),
              label: o,
              link: a(v),
              listItem: a(function (e) {
                return { type: "listItem", spread: e._spread, checked: null, children: [] }
              }),
              listItemValue: function (e) {
                this.data.expectingFirstListItemValue &&
                  ((this.stack[this.stack.length - 2].start = Number.parseInt(this.sliceSerialize(e), 10)),
                  (this.data.expectingFirstListItemValue = void 0))
              },
              listOrdered: a(y, function () {
                this.data.expectingFirstListItemValue = !0
              }),
              listUnordered: a(y),
              paragraph: a(function () {
                return { type: "paragraph", children: [] }
              }),
              reference: function () {
                this.data.referenceType = "collapsed"
              },
              referenceString: o,
              resourceDestinationString: o,
              resourceTitleString: o,
              setextHeading: a(m),
              strong: a(function () {
                return { type: "strong", children: [] }
              }),
              thematicBreak: a(function () {
                return { type: "thematicBreak" }
              }),
            },
            exit: {
              atxHeading: s(),
              atxHeadingSequence: function (e) {
                const t = this.stack[this.stack.length - 1]
                if (!t.depth) {
                  const n = this.sliceSerialize(e).length
                  t.depth = n
                }
              },
              autolink: s(),
              autolinkEmail: function (e) {
                u.call(this, e), (this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(e))
              },
              autolinkProtocol: function (e) {
                u.call(this, e), (this.stack[this.stack.length - 1].url = this.sliceSerialize(e))
              },
              blockQuote: s(),
              characterEscapeValue: u,
              characterReferenceMarkerHexadecimal: h,
              characterReferenceMarkerNumeric: h,
              characterReferenceValue: function (e) {
                const t = this.sliceSerialize(e),
                  n = this.data.characterReferenceType
                let r
                n
                  ? ((r = HD(t, "characterReferenceMarkerNumeric" === n ? 10 : 16)),
                    (this.data.characterReferenceType = void 0))
                  : (r = ZD(t))
                this.stack[this.stack.length - 1].value += r
              },
              characterReference: function (e) {
                this.stack.pop().position.end = p$(e.end)
              },
              codeFenced: s(function () {
                const e = this.resume()
                ;(this.stack[this.stack.length - 1].value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")),
                  (this.data.flowCodeInside = void 0)
              }),
              codeFencedFence: function () {
                this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0))
              },
              codeFencedFenceInfo: function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].lang = e
              },
              codeFencedFenceMeta: function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].meta = e
              },
              codeFlowValue: u,
              codeIndented: s(function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].value = e.replace(/(\r?\n|\r)$/g, "")
              }),
              codeText: s(function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].value = e
              }),
              codeTextData: u,
              data: u,
              definition: s(),
              definitionDestinationString: function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].url = e
              },
              definitionLabelString: function (e) {
                const t = this.resume(),
                  n = this.stack[this.stack.length - 1]
                ;(n.label = t), (n.identifier = aD(this.sliceSerialize(e)).toLowerCase())
              },
              definitionTitleString: function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].title = e
              },
              emphasis: s(),
              hardBreakEscape: s(p),
              hardBreakTrailing: s(p),
              htmlFlow: s(function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].value = e
              }),
              htmlFlowData: u,
              htmlText: s(function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].value = e
              }),
              htmlTextData: u,
              image: s(function () {
                const e = this.stack[this.stack.length - 1]
                if (this.data.inReference) {
                  const t = this.data.referenceType || "shortcut"
                  ;(e.type += "Reference"), (e.referenceType = t), delete e.url, delete e.title
                } else delete e.identifier, delete e.label
                this.data.referenceType = void 0
              }),
              label: function () {
                const e = this.stack[this.stack.length - 1],
                  t = this.resume(),
                  n = this.stack[this.stack.length - 1]
                if (((this.data.inReference = !0), "link" === n.type)) {
                  const t = e.children
                  n.children = t
                } else n.alt = t
              },
              labelText: function (e) {
                const t = this.sliceSerialize(e),
                  n = this.stack[this.stack.length - 2]
                ;(n.label = (function (e) {
                  return e.replace(VD, WD)
                })(t)),
                  (n.identifier = aD(t).toLowerCase())
              },
              lineEnding: function (e) {
                const n = this.stack[this.stack.length - 1]
                if (this.data.atHardBreak)
                  return (
                    (n.children[n.children.length - 1].position.end = p$(e.end)), void (this.data.atHardBreak = void 0)
                  )
                !this.data.setextHeadingSlurpLineEnding &&
                  t.canContainEols.includes(n.type) &&
                  (d.call(this, e), u.call(this, e))
              },
              link: s(function () {
                const e = this.stack[this.stack.length - 1]
                if (this.data.inReference) {
                  const t = this.data.referenceType || "shortcut"
                  ;(e.type += "Reference"), (e.referenceType = t), delete e.url, delete e.title
                } else delete e.identifier, delete e.label
                this.data.referenceType = void 0
              }),
              listItem: s(),
              listOrdered: s(),
              listUnordered: s(),
              paragraph: s(),
              referenceString: function (e) {
                const t = this.resume(),
                  n = this.stack[this.stack.length - 1]
                ;(n.label = t),
                  (n.identifier = aD(this.sliceSerialize(e)).toLowerCase()),
                  (this.data.referenceType = "full")
              },
              resourceDestinationString: function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].url = e
              },
              resourceTitleString: function () {
                const e = this.resume()
                this.stack[this.stack.length - 1].title = e
              },
              resource: function () {
                this.data.inReference = void 0
              },
              setextHeading: s(function () {
                this.data.setextHeadingSlurpLineEnding = void 0
              }),
              setextHeadingLineSequence: function (e) {
                this.stack[this.stack.length - 1].depth = 61 === this.sliceSerialize(e).codePointAt(0) ? 1 : 2
              },
              setextHeadingText: function () {
                this.data.setextHeadingSlurpLineEnding = !0
              },
              strong: s(),
              thematicBreak: s(),
            },
          }
          h$(t, (e || {}).mdastExtensions || [])
          const n = {}
          return function (e) {
            let a = { type: "root", children: [] }
            const s = { stack: [a], tokenStack: [], config: t, enter: i, exit: l, buffer: o, resume: c, data: n },
              d = []
            let u = -1
            for (; ++u < e.length; )
              ("listOrdered" !== e[u][1].type && "listUnordered" !== e[u][1].type) ||
                ("enter" === e[u][0] ? d.push(u) : (u = r(e, d.pop(), u)))
            for (u = -1; ++u < e.length; ) {
              const n = t[e[u][0]]
              d$.call(n, e[u][1].type) &&
                n[e[u][1].type].call(Object.assign({ sliceSerialize: e[u][2].sliceSerialize }, s), e[u][1])
            }
            if (s.tokenStack.length > 0) {
              const e = s.tokenStack[s.tokenStack.length - 1]
              ;(e[1] || m$).call(s, void 0, e[0])
            }
            for (
              a.position = {
                start: p$(e.length > 0 ? e[0][1].start : { line: 1, column: 1, offset: 0 }),
                end: p$(e.length > 0 ? e[e.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
              },
                u = -1;
              ++u < t.transforms.length;

            )
              a = t.transforms[u](a) || a
            return a
          }
          function r(e, t, n) {
            let r,
              a,
              o,
              i,
              s = t - 1,
              l = -1,
              c = !1
            for (; ++s <= n; ) {
              const t = e[s]
              switch (t[1].type) {
                case "listUnordered":
                case "listOrdered":
                case "blockQuote":
                  "enter" === t[0] ? l++ : l--, (i = void 0)
                  break
                case "lineEndingBlank":
                  "enter" === t[0] && (!r || i || l || o || (o = s), (i = void 0))
                  break
                case "linePrefix":
                case "listItemValue":
                case "listItemMarker":
                case "listItemPrefix":
                case "listItemPrefixWhitespace":
                  break
                default:
                  i = void 0
              }
              if (
                (!l && "enter" === t[0] && "listItemPrefix" === t[1].type) ||
                (-1 === l && "exit" === t[0] && ("listUnordered" === t[1].type || "listOrdered" === t[1].type))
              ) {
                if (r) {
                  let i = s
                  for (a = void 0; i--; ) {
                    const t = e[i]
                    if ("lineEnding" === t[1].type || "lineEndingBlank" === t[1].type) {
                      if ("exit" === t[0]) continue
                      a && ((e[a][1].type = "lineEndingBlank"), (c = !0)), (t[1].type = "lineEnding"), (a = i)
                    } else if (
                      "linePrefix" !== t[1].type &&
                      "blockQuotePrefix" !== t[1].type &&
                      "blockQuotePrefixWhitespace" !== t[1].type &&
                      "blockQuoteMarker" !== t[1].type &&
                      "listItemIndent" !== t[1].type
                    )
                      break
                  }
                  o && (!a || o < a) && (r._spread = !0),
                    (r.end = Object.assign({}, a ? e[a][1].start : t[1].end)),
                    e.splice(a || s, 0, ["exit", r, t[2]]),
                    s++,
                    n++
                }
                if ("listItemPrefix" === t[1].type) {
                  const a = { type: "listItem", _spread: !1, start: Object.assign({}, t[1].start), end: void 0 }
                  ;(r = a), e.splice(s, 0, ["enter", a, t[2]]), s++, n++, (o = void 0), (i = !0)
                }
              }
            }
            return (e[t][1]._spread = c), n
          }
          function a(e, t) {
            return function (n) {
              i.call(this, e(n), n), t && t.call(this, n)
            }
          }
          function o() {
            this.stack.push({ type: "fragment", children: [] })
          }
          function i(e, t, n) {
            this.stack[this.stack.length - 1].children.push(e),
              this.stack.push(e),
              this.tokenStack.push([t, n]),
              (e.position = { start: p$(t.start), end: void 0 })
          }
          function s(e) {
            return function (t) {
              e && e.call(this, t), l.call(this, t)
            }
          }
          function l(e, t) {
            const n = this.stack.pop(),
              r = this.tokenStack.pop()
            if (!r)
              throw new Error(
                "Cannot close `" + e.type + "` (" + i$({ start: e.start, end: e.end }) + "): its not open",
              )
            r[0].type !== e.type && (t ? t.call(this, e, r[0]) : (r[1] || m$).call(this, e, r[0])),
              (n.position.end = p$(e.end))
          }
          function c() {
            return CD(this.stack.pop())
          }
          function d(e) {
            const t = this.stack[this.stack.length - 1].children
            let n = t[t.length - 1]
            ;(n && "text" === n.type) ||
              ((n = { type: "text", value: "" }), (n.position = { start: p$(e.start), end: void 0 }), t.push(n)),
              this.stack.push(n)
          }
          function u(e) {
            const t = this.stack.pop()
            ;(t.value += this.sliceSerialize(e)), (t.position.end = p$(e.end))
          }
          function p() {
            this.data.atHardBreak = !0
          }
          function h(e) {
            this.data.characterReferenceType = e.type
          }
          function f() {
            return { type: "code", lang: null, meta: null, value: "" }
          }
          function m() {
            return { type: "heading", depth: 0, children: [] }
          }
          function g() {
            return { type: "break" }
          }
          function b() {
            return { type: "html", value: "" }
          }
          function v() {
            return { type: "link", title: null, url: "", children: [] }
          }
          function y(e) {
            return { type: "list", ordered: "listOrdered" === e.type, start: null, spread: e._spread, children: [] }
          }
        })(n)(
          (function (e) {
            for (; !ZR(e); );
            return e
          })(
            (function (e) {
              const t = {
                defined: [],
                lazy: {},
                constructs: cR([a$, ...((e || {}).extensions || [])]),
                content: n(jN),
                document: n(UN),
                flow: n(zN),
                string: n(ZN),
                text: n(HN),
              }
              return t
              function n(e) {
                return function (n) {
                  return YN(t, e, n)
                }
              }
            })(n)
              .document()
              .write(
                (function () {
                  let e,
                    t = 1,
                    n = "",
                    r = !0
                  return function (a, o, i) {
                    const s = []
                    let l, c, d, u, p
                    for (
                      a = n + ("string" == typeof a ? a.toString() : new TextDecoder(o || void 0).decode(a)),
                        d = 0,
                        n = "",
                        r && (65279 === a.charCodeAt(0) && d++, (r = void 0));
                      d < a.length;

                    ) {
                      if (
                        ((o$.lastIndex = d),
                        (l = o$.exec(a)),
                        (u = l && void 0 !== l.index ? l.index : a.length),
                        (p = a.charCodeAt(u)),
                        !l)
                      ) {
                        n = a.slice(d)
                        break
                      }
                      if (10 === p && d === u && e) s.push(-3), (e = void 0)
                      else
                        switch ((e && (s.push(-5), (e = void 0)), d < u && (s.push(a.slice(d, u)), (t += u - d)), p)) {
                          case 0:
                            s.push(65533), t++
                            break
                          case 9:
                            for (c = 4 * Math.ceil(t / 4), s.push(-2); t++ < c; ) s.push(-1)
                            break
                          case 10:
                            s.push(-4), (t = 1)
                            break
                          default:
                            ;(e = !0), (t = 1)
                        }
                      d = u + 1
                    }
                    return i && (e && s.push(-5), n && s.push(n), s.push(null)), s
                  }
                })()(e, t, !0),
              ),
          ),
        )
      )
    }
    function p$(e) {
      return { line: e.line, column: e.column, offset: e.offset }
    }
    function h$(e, t) {
      let n = -1
      for (; ++n < t.length; ) {
        const r = t[n]
        Array.isArray(r) ? h$(e, r) : f$(e, r)
      }
    }
    function f$(e, t) {
      let n
      for (n in t)
        if (d$.call(t, n))
          switch (n) {
            case "canContainEols": {
              const r = t[n]
              r && e[n].push(...r)
              break
            }
            case "transforms": {
              const r = t[n]
              r && e[n].push(...r)
              break
            }
            case "enter":
            case "exit": {
              const r = t[n]
              r && Object.assign(e[n], r)
              break
            }
          }
    }
    function m$(e, t) {
      throw e
        ? new Error(
            "Cannot close `" +
              e.type +
              "` (" +
              i$({ start: e.start, end: e.end }) +
              "): a different token (`" +
              t.type +
              "`, " +
              i$({ start: t.start, end: t.end }) +
              ") is open",
          )
        : new Error(
            "Cannot close document, a token (`" +
              t.type +
              "`, " +
              i$({ start: t.start, end: t.end }) +
              ") is still open",
          )
    }
    function g$(e) {
      const t = this
      t.parser = function (n) {
        return u$(n, {
          ...t.data("settings"),
          ...e,
          extensions: t.data("micromarkExtensions") || [],
          mdastExtensions: t.data("fromMarkdownExtensions") || [],
        })
      }
    }
    function b$(e, t) {
      const n = t.referenceType
      let r = "]"
      if (
        ("collapsed" === n ? (r += "[]") : "full" === n && (r += "[" + (t.label || t.identifier) + "]"),
        "imageReference" === t.type)
      )
        return [{ type: "text", value: "![" + t.alt + r }]
      const a = e.all(t),
        o = a[0]
      o && "text" === o.type ? (o.value = "[" + o.value) : a.unshift({ type: "text", value: "[" })
      const i = a[a.length - 1]
      return i && "text" === i.type ? (i.value += r) : a.push({ type: "text", value: r }), a
    }
    function v$(e) {
      const t = e.spread
      return null == t ? e.children.length > 1 : t
    }
    const y$ = 9,
      O$ = 32
    function w$(e) {
      const t = String(e),
        n = /\r?\n|\r/g
      let r = n.exec(t),
        a = 0
      const o = []
      for (; r; ) o.push(x$(t.slice(a, r.index), a > 0, !0), r[0]), (a = r.index + r[0].length), (r = n.exec(t))
      return o.push(x$(t.slice(a), a > 0, !1)), o.join("")
    }
    function x$(e, t, n) {
      let r = 0,
        a = e.length
      if (t) {
        let t = e.codePointAt(r)
        for (; t === y$ || t === O$; ) r++, (t = e.codePointAt(r))
      }
      if (n) {
        let t = e.codePointAt(a - 1)
        for (; t === y$ || t === O$; ) a--, (t = e.codePointAt(a - 1))
      }
      return a > r ? e.slice(r, a) : ""
    }
    const k$ = {
      blockquote: function (e, t) {
        const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }
        return e.patch(t, n), e.applyData(t, n)
      },
      break: function (e, t) {
        const n = { type: "element", tagName: "br", properties: {}, children: [] }
        return e.patch(t, n), [e.applyData(t, n), { type: "text", value: "\n" }]
      },
      code: function (e, t) {
        const n = t.value ? t.value + "\n" : "",
          r = {}
        t.lang && (r.className = ["language-" + t.lang])
        let a = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }
        return (
          t.meta && (a.data = { meta: t.meta }),
          e.patch(t, a),
          (a = e.applyData(t, a)),
          (a = { type: "element", tagName: "pre", properties: {}, children: [a] }),
          e.patch(t, a),
          a
        )
      },
      delete: function (e, t) {
        const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }
        return e.patch(t, n), e.applyData(t, n)
      },
      emphasis: function (e, t) {
        const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }
        return e.patch(t, n), e.applyData(t, n)
      },
      footnoteReference: function (e, t) {
        const n = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-",
          r = String(t.identifier).toUpperCase(),
          a = TR(r.toLowerCase()),
          o = e.footnoteOrder.indexOf(r)
        let i,
          s = e.footnoteCounts.get(r)
        void 0 === s ? ((s = 0), e.footnoteOrder.push(r), (i = e.footnoteOrder.length)) : (i = o + 1),
          (s += 1),
          e.footnoteCounts.set(r, s)
        const l = {
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + n + "fn-" + a,
            id: n + "fnref-" + a + (s > 1 ? "-" + s : ""),
            dataFootnoteRef: !0,
            ariaDescribedBy: ["footnote-label"],
          },
          children: [{ type: "text", value: String(i) }],
        }
        e.patch(t, l)
        const c = { type: "element", tagName: "sup", properties: {}, children: [l] }
        return e.patch(t, c), e.applyData(t, c)
      },
      heading: function (e, t) {
        const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }
        return e.patch(t, n), e.applyData(t, n)
      },
      html: function (e, t) {
        if (e.options.allowDangerousHtml) {
          const n = { type: "raw", value: t.value }
          return e.patch(t, n), e.applyData(t, n)
        }
      },
      imageReference: function (e, t) {
        const n = String(t.identifier).toUpperCase(),
          r = e.definitionById.get(n)
        if (!r) return b$(e, t)
        const a = { src: TR(r.url || ""), alt: t.alt }
        null !== r.title && void 0 !== r.title && (a.title = r.title)
        const o = { type: "element", tagName: "img", properties: a, children: [] }
        return e.patch(t, o), e.applyData(t, o)
      },
      image: function (e, t) {
        const n = { src: TR(t.url) }
        null !== t.alt && void 0 !== t.alt && (n.alt = t.alt),
          null !== t.title && void 0 !== t.title && (n.title = t.title)
        const r = { type: "element", tagName: "img", properties: n, children: [] }
        return e.patch(t, r), e.applyData(t, r)
      },
      inlineCode: function (e, t) {
        const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }
        e.patch(t, n)
        const r = { type: "element", tagName: "code", properties: {}, children: [n] }
        return e.patch(t, r), e.applyData(t, r)
      },
      linkReference: function (e, t) {
        const n = String(t.identifier).toUpperCase(),
          r = e.definitionById.get(n)
        if (!r) return b$(e, t)
        const a = { href: TR(r.url || "") }
        null !== r.title && void 0 !== r.title && (a.title = r.title)
        const o = { type: "element", tagName: "a", properties: a, children: e.all(t) }
        return e.patch(t, o), e.applyData(t, o)
      },
      link: function (e, t) {
        const n = { href: TR(t.url) }
        null !== t.title && void 0 !== t.title && (n.title = t.title)
        const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }
        return e.patch(t, r), e.applyData(t, r)
      },
      listItem: function (e, t, n) {
        const r = e.all(t),
          a = n
            ? (function (e) {
                let t = !1
                if ("list" === e.type) {
                  t = e.spread || !1
                  const n = e.children
                  let r = -1
                  for (; !t && ++r < n.length; ) t = v$(n[r])
                }
                return t
              })(n)
            : v$(t),
          o = {},
          i = []
        if ("boolean" == typeof t.checked) {
          const e = r[0]
          let n
          e && "element" === e.type && "p" === e.tagName
            ? (n = e)
            : ((n = { type: "element", tagName: "p", properties: {}, children: [] }), r.unshift(n)),
            n.children.length > 0 && n.children.unshift({ type: "text", value: " " }),
            n.children.unshift({
              type: "element",
              tagName: "input",
              properties: { type: "checkbox", checked: t.checked, disabled: !0 },
              children: [],
            }),
            (o.className = ["task-list-item"])
        }
        let s = -1
        for (; ++s < r.length; ) {
          const e = r[s]
          ;(a || 0 !== s || "element" !== e.type || "p" !== e.tagName) && i.push({ type: "text", value: "\n" }),
            "element" !== e.type || "p" !== e.tagName || a ? i.push(e) : i.push(...e.children)
        }
        const l = r[r.length - 1]
        l && (a || "element" !== l.type || "p" !== l.tagName) && i.push({ type: "text", value: "\n" })
        const c = { type: "element", tagName: "li", properties: o, children: i }
        return e.patch(t, c), e.applyData(t, c)
      },
      list: function (e, t) {
        const n = {},
          r = e.all(t)
        let a = -1
        for ("number" == typeof t.start && 1 !== t.start && (n.start = t.start); ++a < r.length; ) {
          const e = r[a]
          if (
            "element" === e.type &&
            "li" === e.tagName &&
            e.properties &&
            Array.isArray(e.properties.className) &&
            e.properties.className.includes("task-list-item")
          ) {
            n.className = ["contains-task-list"]
            break
          }
        }
        const o = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }
        return e.patch(t, o), e.applyData(t, o)
      },
      paragraph: function (e, t) {
        const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }
        return e.patch(t, n), e.applyData(t, n)
      },
      root: function (e, t) {
        const n = { type: "root", children: e.wrap(e.all(t)) }
        return e.patch(t, n), e.applyData(t, n)
      },
      strong: function (e, t) {
        const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }
        return e.patch(t, n), e.applyData(t, n)
      },
      table: function (e, t) {
        const n = e.all(t),
          r = n.shift(),
          a = []
        if (r) {
          const n = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }
          e.patch(t.children[0], n), a.push(n)
        }
        if (n.length > 0) {
          const r = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) },
            o = mC(t.children[1]),
            i = fC(t.children[t.children.length - 1])
          o && i && (r.position = { start: o, end: i }), a.push(r)
        }
        const o = { type: "element", tagName: "table", properties: {}, children: e.wrap(a, !0) }
        return e.patch(t, o), e.applyData(t, o)
      },
      tableCell: function (e, t) {
        const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }
        return e.patch(t, n), e.applyData(t, n)
      },
      tableRow: function (e, t, n) {
        const r = n ? n.children : void 0,
          a = 0 === (r ? r.indexOf(t) : 1) ? "th" : "td",
          o = n && "table" === n.type ? n.align : void 0,
          i = o ? o.length : t.children.length
        let s = -1
        const l = []
        for (; ++s < i; ) {
          const n = t.children[s],
            r = {},
            i = o ? o[s] : void 0
          i && (r.align = i)
          let c = { type: "element", tagName: a, properties: r, children: [] }
          n && ((c.children = e.all(n)), e.patch(n, c), (c = e.applyData(n, c))), l.push(c)
        }
        const c = { type: "element", tagName: "tr", properties: {}, children: e.wrap(l, !0) }
        return e.patch(t, c), e.applyData(t, c)
      },
      text: function (e, t) {
        const n = { type: "text", value: w$(String(t.value)) }
        return e.patch(t, n), e.applyData(t, n)
      },
      thematicBreak: function (e, t) {
        const n = { type: "element", tagName: "hr", properties: {}, children: [] }
        return e.patch(t, n), e.applyData(t, n)
      },
      toml: _$,
      yaml: _$,
      definition: _$,
      footnoteDefinition: _$,
    }
    function _$() {}
    function S$(e, t) {
      const n = [{ type: "text", value: "" }]
      return (
        t > 1 &&
          n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }),
        n
      )
    }
    function E$(e, t) {
      return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "")
    }
    const T$ = {}.hasOwnProperty,
      A$ = {}
    function C$(e, t) {
      e.position && (t.position = bC(e))
    }
    function P$(e, t) {
      let n = t
      if (e && e.data) {
        const t = e.data.hName,
          r = e.data.hChildren,
          a = e.data.hProperties
        "string" == typeof t &&
          ("element" === n.type
            ? (n.tagName = t)
            : (n = { type: "element", tagName: t, properties: {}, children: "children" in n ? n.children : [n] })),
          "element" === n.type && a && Object.assign(n.properties, E_(a)),
          "children" in n && n.children && null != r && (n.children = r)
      }
      return n
    }
    function D$(e, t) {
      const n = t.data || {},
        r =
          !("value" in t) || T$.call(n, "hProperties") || T$.call(n, "hChildren")
            ? { type: "element", tagName: "div", properties: {}, children: e.all(t) }
            : { type: "text", value: t.value }
      return e.patch(t, r), e.applyData(t, r)
    }
    function R$(e, t) {
      const n = []
      let r = -1
      for (t && n.push({ type: "text", value: "\n" }); ++r < e.length; )
        r && n.push({ type: "text", value: "\n" }), n.push(e[r])
      return t && e.length > 0 && n.push({ type: "text", value: "\n" }), n
    }
    function N$(e) {
      let t = 0,
        n = e.charCodeAt(t)
      for (; 9 === n || 32 === n; ) t++, (n = e.charCodeAt(t))
      return e.slice(t)
    }
    function $$(e, t) {
      const n = (function (e, t) {
          const n = t || A$,
            r = new Map(),
            a = new Map(),
            o = new Map(),
            i = { ...k$, ...n.handlers },
            s = {
              all: function (e) {
                const t = []
                if ("children" in e) {
                  const n = e.children
                  let r = -1
                  for (; ++r < n.length; ) {
                    const a = s.one(n[r], e)
                    if (a) {
                      if (
                        r &&
                        "break" === n[r - 1].type &&
                        (Array.isArray(a) || "text" !== a.type || (a.value = N$(a.value)),
                        !Array.isArray(a) && "element" === a.type)
                      ) {
                        const e = a.children[0]
                        e && "text" === e.type && (e.value = N$(e.value))
                      }
                      Array.isArray(a) ? t.push(...a) : t.push(a)
                    }
                  }
                }
                return t
              },
              applyData: P$,
              definitionById: r,
              footnoteById: a,
              footnoteCounts: o,
              footnoteOrder: [],
              handlers: i,
              one: function (e, t) {
                const n = e.type,
                  r = s.handlers[n]
                if (T$.call(s.handlers, n) && r) return r(s, e, t)
                if (s.options.passThrough && s.options.passThrough.includes(n)) {
                  if ("children" in e) {
                    const { children: t, ...n } = e,
                      r = E_(n)
                    return (r.children = s.all(e)), r
                  }
                  return E_(e)
                }
                return (s.options.unknownHandler || D$)(s, e, t)
              },
              options: n,
              patch: C$,
              wrap: R$,
            }
          return (
            m_(e, function (e) {
              if ("definition" === e.type || "footnoteDefinition" === e.type) {
                const t = "definition" === e.type ? r : a,
                  n = String(e.identifier).toUpperCase()
                t.has(n) || t.set(n, e)
              }
            }),
            s
          )
        })(e, t),
        r = n.one(e, void 0),
        a = (function (e) {
          const t = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-",
            n = e.options.footnoteBackContent || S$,
            r = e.options.footnoteBackLabel || E$,
            a = e.options.footnoteLabel || "Footnotes",
            o = e.options.footnoteLabelTagName || "h2",
            i = e.options.footnoteLabelProperties || { className: ["sr-only"] },
            s = []
          let l = -1
          for (; ++l < e.footnoteOrder.length; ) {
            const a = e.footnoteById.get(e.footnoteOrder[l])
            if (!a) continue
            const o = e.all(a),
              i = String(a.identifier).toUpperCase(),
              c = TR(i.toLowerCase())
            let d = 0
            const u = [],
              p = e.footnoteCounts.get(i)
            for (; void 0 !== p && ++d <= p; ) {
              u.length > 0 && u.push({ type: "text", value: " " })
              let e = "string" == typeof n ? n : n(l, d)
              "string" == typeof e && (e = { type: "text", value: e }),
                u.push({
                  type: "element",
                  tagName: "a",
                  properties: {
                    href: "#" + t + "fnref-" + c + (d > 1 ? "-" + d : ""),
                    dataFootnoteBackref: "",
                    ariaLabel: "string" == typeof r ? r : r(l, d),
                    className: ["data-footnote-backref"],
                  },
                  children: Array.isArray(e) ? e : [e],
                })
            }
            const h = o[o.length - 1]
            if (h && "element" === h.type && "p" === h.tagName) {
              const e = h.children[h.children.length - 1]
              e && "text" === e.type ? (e.value += " ") : h.children.push({ type: "text", value: " " }),
                h.children.push(...u)
            } else o.push(...u)
            const f = { type: "element", tagName: "li", properties: { id: t + "fn-" + c }, children: e.wrap(o, !0) }
            e.patch(a, f), s.push(f)
          }
          if (0 !== s.length)
            return {
              type: "element",
              tagName: "section",
              properties: { dataFootnotes: !0, className: ["footnotes"] },
              children: [
                {
                  type: "element",
                  tagName: o,
                  properties: { ...E_(i), id: "footnote-label" },
                  children: [{ type: "text", value: a }],
                },
                { type: "text", value: "\n" },
                { type: "element", tagName: "ol", properties: {}, children: e.wrap(s, !0) },
                { type: "text", value: "\n" },
              ],
            }
        })(n),
        o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }
      return a && o.children.push({ type: "text", value: "\n" }, a), o
    }
    function I$(e, t) {
      return e && "run" in e
        ? async function (n, r) {
            const a = $$(n, { file: r, ...t })
            await e.run(a, r)
          }
        : function (n, r) {
            return $$(n, { file: r, ...(t || e) })
          }
    }
    function M$(e) {
      if (e) throw e
    }
    var L$ = Object.prototype.hasOwnProperty,
      Q$ = Object.prototype.toString,
      B$ = Object.defineProperty,
      j$ = Object.getOwnPropertyDescriptor,
      U$ = function (e) {
        return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === Q$.call(e)
      },
      F$ = function (e) {
        if (!e || "[object Object]" !== Q$.call(e)) return !1
        var t,
          n = L$.call(e, "constructor"),
          r = e.constructor && e.constructor.prototype && L$.call(e.constructor.prototype, "isPrototypeOf")
        if (e.constructor && !n && !r) return !1
        for (t in e);
        return void 0 === t || L$.call(e, t)
      },
      z$ = function (e, t) {
        B$ && "__proto__" === t.name
          ? B$(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 })
          : (e[t.name] = t.newValue)
      },
      q$ = function (e, t) {
        if ("__proto__" === t) {
          if (!L$.call(e, t)) return
          if (j$) return j$(e, t).value
        }
        return e[t]
      }
    const Z$ = em(function e() {
      var t,
        n,
        r,
        a,
        o,
        i,
        s = arguments[0],
        l = 1,
        c = arguments.length,
        d = !1
      for (
        "boolean" == typeof s && ((d = s), (s = arguments[1] || {}), (l = 2)),
          (null == s || ("object" != typeof s && "function" != typeof s)) && (s = {});
        l < c;
        ++l
      )
        if (null != (t = arguments[l]))
          for (n in t)
            (r = q$(s, n)),
              s !== (a = q$(t, n)) &&
                (d && a && (F$(a) || (o = U$(a)))
                  ? (o ? ((o = !1), (i = r && U$(r) ? r : [])) : (i = r && F$(r) ? r : {}),
                    z$(s, { name: n, newValue: e(d, i, a) }))
                  : void 0 !== a && z$(s, { name: n, newValue: a }))
      return s
    })
    function H$(e) {
      if ("object" != typeof e || null === e) return !1
      const t = Object.getPrototypeOf(e)
      return !(
        (null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t)) ||
        Symbol.toStringTag in e ||
        Symbol.iterator in e
      )
    }
    class V$ extends Error {
      constructor(e, t, n) {
        super(), "string" == typeof t && ((n = t), (t = void 0))
        let r = "",
          a = {},
          o = !1
        if (
          (t &&
            (a =
              ("line" in t && "column" in t) || ("start" in t && "end" in t)
                ? { place: t }
                : "type" in t
                  ? { ancestors: [t], place: t.position }
                  : { ...t }),
          "string" == typeof e ? (r = e) : !a.cause && e && ((o = !0), (r = e.message), (a.cause = e)),
          !a.ruleId && !a.source && "string" == typeof n)
        ) {
          const e = n.indexOf(":")
          ;-1 === e ? (a.ruleId = n) : ((a.source = n.slice(0, e)), (a.ruleId = n.slice(e + 1)))
        }
        if (!a.place && a.ancestors && a.ancestors) {
          const e = a.ancestors[a.ancestors.length - 1]
          e && (a.place = e.position)
        }
        const i = a.place && "start" in a.place ? a.place.start : a.place
        ;(this.ancestors = a.ancestors || void 0),
          (this.cause = a.cause || void 0),
          (this.column = i ? i.column : void 0),
          (this.fatal = void 0),
          this.file,
          (this.message = r),
          (this.line = i ? i.line : void 0),
          (this.name = i$(a.place) || "1:1"),
          (this.place = a.place || void 0),
          (this.reason = this.message),
          (this.ruleId = a.ruleId || void 0),
          (this.source = a.source || void 0),
          (this.stack = o && a.cause && "string" == typeof a.cause.stack ? a.cause.stack : ""),
          this.actual,
          this.expected,
          this.note,
          this.url
      }
    }
    ;(V$.prototype.file = ""),
      (V$.prototype.name = ""),
      (V$.prototype.reason = ""),
      (V$.prototype.message = ""),
      (V$.prototype.stack = ""),
      (V$.prototype.column = void 0),
      (V$.prototype.line = void 0),
      (V$.prototype.ancestors = void 0),
      (V$.prototype.cause = void 0),
      (V$.prototype.fatal = void 0),
      (V$.prototype.place = void 0),
      (V$.prototype.ruleId = void 0),
      (V$.prototype.source = void 0)
    const W$ = function (e, t) {
        if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string')
        J$(e)
        let n,
          r = 0,
          a = -1,
          o = e.length
        if (void 0 === t || 0 === t.length || t.length > e.length) {
          for (; o--; )
            if (47 === e.codePointAt(o)) {
              if (n) {
                r = o + 1
                break
              }
            } else a < 0 && ((n = !0), (a = o + 1))
          return a < 0 ? "" : e.slice(r, a)
        }
        if (t === e) return ""
        let i = -1,
          s = t.length - 1
        for (; o--; )
          if (47 === e.codePointAt(o)) {
            if (n) {
              r = o + 1
              break
            }
          } else
            i < 0 && ((n = !0), (i = o + 1)),
              s > -1 && (e.codePointAt(o) === t.codePointAt(s--) ? s < 0 && (a = o) : ((s = -1), (a = i)))
        return r === a ? (a = i) : a < 0 && (a = e.length), e.slice(r, a)
      },
      X$ = function (e) {
        if ((J$(e), 0 === e.length)) return "."
        let t,
          n = -1,
          r = e.length
        for (; --r; )
          if (47 === e.codePointAt(r)) {
            if (t) {
              n = r
              break
            }
          } else t || (t = !0)
        return n < 0 ? (47 === e.codePointAt(0) ? "/" : ".") : 1 === n && 47 === e.codePointAt(0) ? "//" : e.slice(0, n)
      },
      Y$ = function (e) {
        J$(e)
        let t,
          n = e.length,
          r = -1,
          a = 0,
          o = -1,
          i = 0
        for (; n--; ) {
          const s = e.codePointAt(n)
          if (47 !== s)
            r < 0 && ((t = !0), (r = n + 1)), 46 === s ? (o < 0 ? (o = n) : 1 !== i && (i = 1)) : o > -1 && (i = -1)
          else if (t) {
            a = n + 1
            break
          }
        }
        return o < 0 || r < 0 || 0 === i || (1 === i && o === r - 1 && o === a + 1) ? "" : e.slice(o, r)
      },
      G$ = function (...e) {
        let t,
          n = -1
        for (; ++n < e.length; ) J$(e[n]), e[n] && (t = void 0 === t ? e[n] : t + "/" + e[n])
        return void 0 === t
          ? "."
          : (function (e) {
              J$(e)
              const t = 47 === e.codePointAt(0)
              let n = (function (e, t) {
                let n,
                  r,
                  a = "",
                  o = 0,
                  i = -1,
                  s = 0,
                  l = -1
                for (; ++l <= e.length; ) {
                  if (l < e.length) n = e.codePointAt(l)
                  else {
                    if (47 === n) break
                    n = 47
                  }
                  if (47 === n) {
                    if (i === l - 1 || 1 === s);
                    else if (i !== l - 1 && 2 === s) {
                      if (
                        a.length < 2 ||
                        2 !== o ||
                        46 !== a.codePointAt(a.length - 1) ||
                        46 !== a.codePointAt(a.length - 2)
                      )
                        if (a.length > 2) {
                          if (((r = a.lastIndexOf("/")), r !== a.length - 1)) {
                            r < 0
                              ? ((a = ""), (o = 0))
                              : ((a = a.slice(0, r)), (o = a.length - 1 - a.lastIndexOf("/"))),
                              (i = l),
                              (s = 0)
                            continue
                          }
                        } else if (a.length > 0) {
                          ;(a = ""), (o = 0), (i = l), (s = 0)
                          continue
                        }
                      t && ((a = a.length > 0 ? a + "/.." : ".."), (o = 2))
                    } else a.length > 0 ? (a += "/" + e.slice(i + 1, l)) : (a = e.slice(i + 1, l)), (o = l - i - 1)
                    ;(i = l), (s = 0)
                  } else 46 === n && s > -1 ? s++ : (s = -1)
                }
                return a
              })(e, !t)
              return (
                0 !== n.length || t || (n = "."),
                n.length > 0 && 47 === e.codePointAt(e.length - 1) && (n += "/"),
                t ? "/" + n : n
              )
            })(t)
      },
      K$ = "/"
    function J$(e) {
      if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e))
    }
    const eI = function () {
      return "/"
    }
    function tI(e) {
      return Boolean(
        null !== e &&
          "object" == typeof e &&
          "href" in e &&
          e.href &&
          "protocol" in e &&
          e.protocol &&
          void 0 === e.auth,
      )
    }
    const nI = ["history", "path", "basename", "stem", "extname", "dirname"]
    class rI {
      constructor(e) {
        let t
        ;(t = e
          ? tI(e)
            ? { path: e }
            : "string" == typeof e ||
                (function (e) {
                  return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e)
                })(e)
              ? { value: e }
              : e
          : {}),
          (this.cwd = eI()),
          (this.data = {}),
          (this.history = []),
          (this.messages = []),
          this.value,
          this.map,
          this.result,
          this.stored
        let n,
          r = -1
        for (; ++r < nI.length; ) {
          const e = nI[r]
          e in t && void 0 !== t[e] && null !== t[e] && (this[e] = "history" === e ? [...t[e]] : t[e])
        }
        for (n in t) nI.includes(n) || (this[n] = t[n])
      }
      get basename() {
        return "string" == typeof this.path ? W$(this.path) : void 0
      }
      set basename(e) {
        oI(e, "basename"), aI(e, "basename"), (this.path = G$(this.dirname || "", e))
      }
      get dirname() {
        return "string" == typeof this.path ? X$(this.path) : void 0
      }
      set dirname(e) {
        iI(this.basename, "dirname"), (this.path = G$(e || "", this.basename))
      }
      get extname() {
        return "string" == typeof this.path ? Y$(this.path) : void 0
      }
      set extname(e) {
        if ((aI(e, "extname"), iI(this.dirname, "extname"), e)) {
          if (46 !== e.codePointAt(0)) throw new Error("`extname` must start with `.`")
          if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots")
        }
        this.path = G$(this.dirname, this.stem + (e || ""))
      }
      get path() {
        return this.history[this.history.length - 1]
      }
      set path(e) {
        tI(e) &&
          (e = (function (e) {
            if ("string" == typeof e) e = new URL(e)
            else if (!tI(e)) {
              const t = new TypeError(
                'The "path" argument must be of type string or an instance of URL. Received `' + e + "`",
              )
              throw ((t.code = "ERR_INVALID_ARG_TYPE"), t)
            }
            if ("file:" !== e.protocol) {
              const e = new TypeError("The URL must be of scheme file")
              throw ((e.code = "ERR_INVALID_URL_SCHEME"), e)
            }
            return (function (e) {
              if ("" !== e.hostname) {
                const e = new TypeError('File URL host must be "localhost" or empty on darwin')
                throw ((e.code = "ERR_INVALID_FILE_URL_HOST"), e)
              }
              const t = e.pathname
              let n = -1
              for (; ++n < t.length; )
                if (37 === t.codePointAt(n) && 50 === t.codePointAt(n + 1)) {
                  const e = t.codePointAt(n + 2)
                  if (70 === e || 102 === e) {
                    const e = new TypeError("File URL path must not include encoded / characters")
                    throw ((e.code = "ERR_INVALID_FILE_URL_PATH"), e)
                  }
                }
              return decodeURIComponent(t)
            })(e)
          })(e)),
          oI(e, "path"),
          this.path !== e && this.history.push(e)
      }
      get stem() {
        return "string" == typeof this.path ? W$(this.path, this.extname) : void 0
      }
      set stem(e) {
        oI(e, "stem"), aI(e, "stem"), (this.path = G$(this.dirname || "", e + (this.extname || "")))
      }
      fail(e, t, n) {
        const r = this.message(e, t, n)
        throw ((r.fatal = !0), r)
      }
      info(e, t, n) {
        const r = this.message(e, t, n)
        return (r.fatal = void 0), r
      }
      message(e, t, n) {
        const r = new V$(e, t, n)
        return (
          this.path && ((r.name = this.path + ":" + r.name), (r.file = this.path)),
          (r.fatal = !1),
          this.messages.push(r),
          r
        )
      }
      toString(e) {
        return void 0 === this.value
          ? ""
          : "string" == typeof this.value
            ? this.value
            : new TextDecoder(e || void 0).decode(this.value)
      }
    }
    function aI(e, t) {
      if (e && e.includes(K$)) throw new Error("`" + t + "` cannot be a path: did not expect `" + K$ + "`")
    }
    function oI(e, t) {
      if (!e) throw new Error("`" + t + "` cannot be empty")
    }
    function iI(e, t) {
      if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too")
    }
    const sI = function (e) {
        const t = this.constructor.prototype,
          n = t[e],
          r = function () {
            return n.apply(r, arguments)
          }
        Object.setPrototypeOf(r, t)
        const a = Object.getOwnPropertyNames(n)
        for (const e of a) {
          const t = Object.getOwnPropertyDescriptor(n, e)
          t && Object.defineProperty(r, e, t)
        }
        return r
      },
      lI = {}.hasOwnProperty
    class cI extends sI {
      constructor() {
        super("copy"),
          (this.Compiler = void 0),
          (this.Parser = void 0),
          (this.attachers = []),
          (this.compiler = void 0),
          (this.freezeIndex = -1),
          (this.frozen = void 0),
          (this.namespace = {}),
          (this.parser = void 0),
          (this.transformers = (function () {
            const e = [],
              t = {
                run: function (...t) {
                  let n = -1
                  const r = t.pop()
                  if ("function" != typeof r) throw new TypeError("Expected function as last argument, not " + r)
                  !(function a(o, ...i) {
                    const s = e[++n]
                    let l = -1
                    if (o) r(o)
                    else {
                      for (; ++l < t.length; ) (null !== i[l] && void 0 !== i[l]) || (i[l] = t[l])
                      ;(t = i),
                        s
                          ? (function (e, t) {
                              let n
                              return function (...t) {
                                const o = e.length > t.length
                                let i
                                o && t.push(r)
                                try {
                                  i = e.apply(this, t)
                                } catch (e) {
                                  if (o && n) throw e
                                  return r(e)
                                }
                                o ||
                                  (i && i.then && "function" == typeof i.then
                                    ? i.then(a, r)
                                    : i instanceof Error
                                      ? r(i)
                                      : a(i))
                              }
                              function r(e, ...r) {
                                n || ((n = !0), t(e, ...r))
                              }
                              function a(e) {
                                r(null, e)
                              }
                            })(
                              s,
                              a,
                            )(...i)
                          : r(null, ...i)
                    }
                  })(null, ...t)
                },
                use: function (n) {
                  if ("function" != typeof n) throw new TypeError("Expected `middelware` to be a function, not " + n)
                  return e.push(n), t
                },
              }
            return t
          })())
      }
      copy() {
        const e = new cI()
        let t = -1
        for (; ++t < this.attachers.length; ) {
          const n = this.attachers[t]
          e.use(...n)
        }
        return e.data(Z$(!0, {}, this.namespace)), e
      }
      data(e, t) {
        return "string" == typeof e
          ? 2 === arguments.length
            ? (hI("data", this.frozen), (this.namespace[e] = t), this)
            : (lI.call(this.namespace, e) && this.namespace[e]) || void 0
          : e
            ? (hI("data", this.frozen), (this.namespace = e), this)
            : this.namespace
      }
      freeze() {
        if (this.frozen) return this
        const e = this
        for (; ++this.freezeIndex < this.attachers.length; ) {
          const [t, ...n] = this.attachers[this.freezeIndex]
          if (!1 === n[0]) continue
          !0 === n[0] && (n[0] = void 0)
          const r = t.call(e, ...n)
          "function" == typeof r && this.transformers.use(r)
        }
        return (this.frozen = !0), (this.freezeIndex = Number.POSITIVE_INFINITY), this
      }
      parse(e) {
        this.freeze()
        const t = gI(e),
          n = this.parser || this.Parser
        return uI("parse", n), n(String(t), t)
      }
      process(e, t) {
        const n = this
        return (
          this.freeze(),
          uI("process", this.parser || this.Parser),
          pI("process", this.compiler || this.Compiler),
          t ? r(void 0, t) : new Promise(r)
        )
        function r(r, a) {
          const o = gI(e),
            i = n.parse(o)
          function s(e, n) {
            e || !n ? a(e) : r ? r(n) : t(void 0, n)
          }
          n.run(i, o, function (e, t, r) {
            if (e || !t || !r) return s(e)
            const a = t,
              o = n.stringify(a, r)
            var i
            "string" == typeof (i = o) ||
            (function (e) {
              return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e)
            })(i)
              ? (r.value = o)
              : (r.result = o),
              s(e, r)
          })
        }
      }
      processSync(e) {
        let t,
          n = !1
        return (
          this.freeze(),
          uI("processSync", this.parser || this.Parser),
          pI("processSync", this.compiler || this.Compiler),
          this.process(e, function (e, r) {
            ;(n = !0), M$(e), (t = r)
          }),
          mI("processSync", "process", n),
          t
        )
      }
      run(e, t, n) {
        fI(e), this.freeze()
        const r = this.transformers
        return n || "function" != typeof t || ((n = t), (t = void 0)), n ? a(void 0, n) : new Promise(a)
        function a(a, o) {
          const i = gI(t)
          r.run(e, i, function (t, r, i) {
            const s = r || e
            t ? o(t) : a ? a(s) : n(void 0, s, i)
          })
        }
      }
      runSync(e, t) {
        let n,
          r = !1
        return (
          this.run(e, t, function (e, t) {
            M$(e), (n = t), (r = !0)
          }),
          mI("runSync", "run", r),
          n
        )
      }
      stringify(e, t) {
        this.freeze()
        const n = gI(t),
          r = this.compiler || this.Compiler
        return pI("stringify", r), fI(e), r(e, n)
      }
      use(e, ...t) {
        const n = this.attachers,
          r = this.namespace
        if ((hI("use", this.frozen), null == e));
        else if ("function" == typeof e) s(e, t)
        else {
          if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`")
          Array.isArray(e) ? i(e) : o(e)
        }
        return this
        function a(e) {
          if ("function" == typeof e) s(e, [])
          else {
            if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`")
            if (Array.isArray(e)) {
              const [t, ...n] = e
              s(t, n)
            } else o(e)
          }
        }
        function o(e) {
          if (!("plugins" in e) && !("settings" in e))
            throw new Error(
              "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither",
            )
          i(e.plugins), e.settings && (r.settings = Z$(!0, r.settings, e.settings))
        }
        function i(e) {
          let t = -1
          if (null == e);
          else {
            if (!Array.isArray(e)) throw new TypeError("Expected a list of plugins, not `" + e + "`")
            for (; ++t < e.length; ) a(e[t])
          }
        }
        function s(e, t) {
          let r = -1,
            a = -1
          for (; ++r < n.length; )
            if (n[r][0] === e) {
              a = r
              break
            }
          if (-1 === a) n.push([e, ...t])
          else if (t.length > 0) {
            let [r, ...o] = t
            const i = n[a][1]
            H$(i) && H$(r) && (r = Z$(!0, i, r)), (n[a] = [e, r, ...o])
          }
        }
      }
    }
    const dI = new cI().freeze()
    function uI(e, t) {
      if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `parser`")
    }
    function pI(e, t) {
      if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `compiler`")
    }
    function hI(e, t) {
      if (t)
        throw new Error(
          "Cannot call `" +
            e +
            "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.",
        )
    }
    function fI(e) {
      if (!H$(e) || "string" != typeof e.type) throw new TypeError("Expected node, got `" + e + "`")
    }
    function mI(e, t, n) {
      if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead")
    }
    function gI(e) {
      return (function (e) {
        return Boolean(e && "object" == typeof e && "message" in e && "messages" in e)
      })(e)
        ? e
        : new rI(e)
    }
    const bI = {
        bash: function (e) {
          const t = e.regex,
            n = {},
            r = { begin: /\$\{/, end: /\}/, contains: ["self", { begin: /:-/, contains: [n] }] }
          Object.assign(n, {
            className: "variable",
            variants: [{ begin: t.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") }, r],
          })
          const a = { className: "subst", begin: /\$\(/, end: /\)/, contains: [e.BACKSLASH_ESCAPE] },
            o = {
              begin: /<<-?\s*(?=\w+)/,
              starts: { contains: [e.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: "string" })] },
            },
            i = { className: "string", begin: /"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, n, a] }
          a.contains.push(i)
          const s = {
              begin: /\$?\(\(/,
              end: /\)\)/,
              contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, e.NUMBER_MODE, n],
            },
            l = e.SHEBANG({
              binary: `(${["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"].join("|")})`,
              relevance: 10,
            }),
            c = {
              className: "function",
              begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
              returnBegin: !0,
              contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
              relevance: 0,
            }
          return {
            name: "Bash",
            aliases: ["sh"],
            keywords: {
              $pattern: /\b[a-z][a-z0-9._-]+\b/,
              keyword: [
                "if",
                "then",
                "else",
                "elif",
                "fi",
                "for",
                "while",
                "until",
                "in",
                "do",
                "done",
                "case",
                "esac",
                "function",
                "select",
              ],
              literal: ["true", "false"],
              built_in: [
                "break",
                "cd",
                "continue",
                "eval",
                "exec",
                "exit",
                "export",
                "getopts",
                "hash",
                "pwd",
                "readonly",
                "return",
                "shift",
                "test",
                "times",
                "trap",
                "umask",
                "unset",
                "alias",
                "bind",
                "builtin",
                "caller",
                "command",
                "declare",
                "echo",
                "enable",
                "help",
                "let",
                "local",
                "logout",
                "mapfile",
                "printf",
                "read",
                "readarray",
                "source",
                "type",
                "typeset",
                "ulimit",
                "unalias",
                "set",
                "shopt",
                "autoload",
                "bg",
                "bindkey",
                "bye",
                "cap",
                "chdir",
                "clone",
                "comparguments",
                "compcall",
                "compctl",
                "compdescribe",
                "compfiles",
                "compgroups",
                "compquote",
                "comptags",
                "comptry",
                "compvalues",
                "dirs",
                "disable",
                "disown",
                "echotc",
                "echoti",
                "emulate",
                "fc",
                "fg",
                "float",
                "functions",
                "getcap",
                "getln",
                "history",
                "integer",
                "jobs",
                "kill",
                "limit",
                "log",
                "noglob",
                "popd",
                "print",
                "pushd",
                "pushln",
                "rehash",
                "sched",
                "setcap",
                "setopt",
                "stat",
                "suspend",
                "ttyctl",
                "unfunction",
                "unhash",
                "unlimit",
                "unsetopt",
                "vared",
                "wait",
                "whence",
                "where",
                "which",
                "zcompile",
                "zformat",
                "zftp",
                "zle",
                "zmodload",
                "zparseopts",
                "zprof",
                "zpty",
                "zregexparse",
                "zsocket",
                "zstyle",
                "ztcp",
                "chcon",
                "chgrp",
                "chown",
                "chmod",
                "cp",
                "dd",
                "df",
                "dir",
                "dircolors",
                "ln",
                "ls",
                "mkdir",
                "mkfifo",
                "mknod",
                "mktemp",
                "mv",
                "realpath",
                "rm",
                "rmdir",
                "shred",
                "sync",
                "touch",
                "truncate",
                "vdir",
                "b2sum",
                "base32",
                "base64",
                "cat",
                "cksum",
                "comm",
                "csplit",
                "cut",
                "expand",
                "fmt",
                "fold",
                "head",
                "join",
                "md5sum",
                "nl",
                "numfmt",
                "od",
                "paste",
                "ptx",
                "pr",
                "sha1sum",
                "sha224sum",
                "sha256sum",
                "sha384sum",
                "sha512sum",
                "shuf",
                "sort",
                "split",
                "sum",
                "tac",
                "tail",
                "tr",
                "tsort",
                "unexpand",
                "uniq",
                "wc",
                "arch",
                "basename",
                "chroot",
                "date",
                "dirname",
                "du",
                "echo",
                "env",
                "expr",
                "factor",
                "groups",
                "hostid",
                "id",
                "link",
                "logname",
                "nice",
                "nohup",
                "nproc",
                "pathchk",
                "pinky",
                "printenv",
                "printf",
                "pwd",
                "readlink",
                "runcon",
                "seq",
                "sleep",
                "stat",
                "stdbuf",
                "stty",
                "tee",
                "test",
                "timeout",
                "tty",
                "uname",
                "unlink",
                "uptime",
                "users",
                "who",
                "whoami",
                "yes",
              ],
            },
            contains: [
              l,
              e.SHEBANG(),
              c,
              s,
              e.HASH_COMMENT_MODE,
              o,
              { match: /(\/[a-z._-]+)+/ },
              i,
              { match: /\\"/ },
              { className: "string", begin: /'/, end: /'/ },
              { match: /\\'/ },
              n,
            ],
          }
        },
        c: function (e) {
          const t = e.regex,
            n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
            r = "decltype\\(auto\\)",
            a = "[a-zA-Z_]\\w*::",
            o = "(" + r + "|" + t.optional(a) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")",
            i = { className: "type", variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, { match: /\batomic_[a-z]{3,6}\b/ }] },
            s = {
              className: "string",
              variants: [
                { begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [e.BACKSLASH_ESCAPE] },
                {
                  begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                  end: "'",
                  illegal: ".",
                },
                e.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ }),
              ],
            },
            l = {
              className: "number",
              variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
              ],
              relevance: 0,
            },
            c = {
              className: "meta",
              begin: /#\s*[a-z]+\b/,
              end: /$/,
              keywords: {
                keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include",
              },
              contains: [
                { begin: /\\\n/, relevance: 0 },
                e.inherit(s, { className: "string" }),
                { className: "string", begin: /<.*?>/ },
                n,
                e.C_BLOCK_COMMENT_MODE,
              ],
            },
            d = { className: "title", begin: t.optional(a) + e.IDENT_RE, relevance: 0 },
            u = t.optional(a) + e.IDENT_RE + "\\s*\\(",
            p = {
              keyword: [
                "asm",
                "auto",
                "break",
                "case",
                "continue",
                "default",
                "do",
                "else",
                "enum",
                "extern",
                "for",
                "fortran",
                "goto",
                "if",
                "inline",
                "register",
                "restrict",
                "return",
                "sizeof",
                "struct",
                "switch",
                "typedef",
                "union",
                "volatile",
                "while",
                "_Alignas",
                "_Alignof",
                "_Atomic",
                "_Generic",
                "_Noreturn",
                "_Static_assert",
                "_Thread_local",
                "alignas",
                "alignof",
                "noreturn",
                "static_assert",
                "thread_local",
                "_Pragma",
              ],
              type: [
                "float",
                "double",
                "signed",
                "unsigned",
                "int",
                "short",
                "long",
                "char",
                "void",
                "_Bool",
                "_Complex",
                "_Imaginary",
                "_Decimal32",
                "_Decimal64",
                "_Decimal128",
                "const",
                "static",
                "complex",
                "bool",
                "imaginary",
              ],
              literal: "true false NULL",
              built_in:
                "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",
            },
            h = [c, i, n, e.C_BLOCK_COMMENT_MODE, l, s],
            f = {
              variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: "new throw return else", end: /;/ },
              ],
              keywords: p,
              contains: h.concat([{ begin: /\(/, end: /\)/, keywords: p, contains: h.concat(["self"]), relevance: 0 }]),
              relevance: 0,
            },
            m = {
              begin: "(" + o + "[\\*&\\s]+)+" + u,
              returnBegin: !0,
              end: /[{;=]/,
              excludeEnd: !0,
              keywords: p,
              illegal: /[^\w\s\*&:<>.]/,
              contains: [
                { begin: r, keywords: p, relevance: 0 },
                { begin: u, returnBegin: !0, contains: [e.inherit(d, { className: "title.function" })], relevance: 0 },
                { relevance: 0, match: /,/ },
                {
                  className: "params",
                  begin: /\(/,
                  end: /\)/,
                  keywords: p,
                  relevance: 0,
                  contains: [
                    n,
                    e.C_BLOCK_COMMENT_MODE,
                    s,
                    l,
                    i,
                    {
                      begin: /\(/,
                      end: /\)/,
                      keywords: p,
                      relevance: 0,
                      contains: ["self", n, e.C_BLOCK_COMMENT_MODE, s, l, i],
                    },
                  ],
                },
                i,
                n,
                e.C_BLOCK_COMMENT_MODE,
                c,
              ],
            }
          return {
            name: "C",
            aliases: ["h"],
            keywords: p,
            disableAutodetect: !0,
            illegal: "</",
            contains: [].concat(f, m, h, [
              c,
              { begin: e.IDENT_RE + "::", keywords: p },
              {
                className: "class",
                beginKeywords: "enum class struct union",
                end: /[{;:<>=]/,
                contains: [{ beginKeywords: "final class struct" }, e.TITLE_MODE],
              },
            ]),
            exports: { preprocessor: c, strings: s, keywords: p },
          }
        },
        clojure: function (e) {
          const t = "a-zA-Z_\\-!.?+*=<>&'",
            n = "[#]?[" + t + "][" + t + "0-9/;:$#]*",
            r = "def defonce defprotocol defstruct defmulti defmethod defn- defn defmacro deftype defrecord",
            a = {
              $pattern: n,
              built_in:
                r +
                " cond apply if-not if-let if not not= =|0 <|0 >|0 <=|0 >=|0 ==|0 +|0 /|0 *|0 -|0 rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy first rest cons cast coll last butlast sigs reify second ffirst fnext nfirst nnext meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize",
            },
            o = { begin: n, relevance: 0 },
            i = {
              scope: "number",
              relevance: 0,
              variants: [
                { match: /[-+]?0[xX][0-9a-fA-F]+N?/ },
                { match: /[-+]?0[0-7]+N?/ },
                { match: /[-+]?[1-9][0-9]?[rR][0-9a-zA-Z]+N?/ },
                { match: /[-+]?[0-9]+\/[0-9]+N?/ },
                { match: /[-+]?[0-9]+((\.[0-9]*([eE][+-]?[0-9]+)?M?)|([eE][+-]?[0-9]+M?|M))/ },
                { match: /[-+]?([1-9][0-9]*|0)N?/ },
              ],
            },
            s = {
              scope: "character",
              variants: [
                { match: /\\o[0-3]?[0-7]{1,2}/ },
                { match: /\\u[0-9a-fA-F]{4}/ },
                { match: /\\(newline|space|tab|formfeed|backspace|return)/ },
                { match: /\\\S/, relevance: 0 },
              ],
            },
            l = { scope: "regex", begin: /#"/, end: /"/, contains: [e.BACKSLASH_ESCAPE] },
            c = e.inherit(e.QUOTE_STRING_MODE, { illegal: null }),
            d = { scope: "punctuation", match: /,/, relevance: 0 },
            u = e.COMMENT(";", "$", { relevance: 0 }),
            p = { className: "literal", begin: /\b(true|false|nil)\b/ },
            h = { begin: "\\[|(#::?" + n + ")?\\{", end: "[\\]\\}]", relevance: 0 },
            f = { className: "symbol", begin: "[:]{1,2}" + n },
            m = { begin: "\\(", end: "\\)" },
            g = { endsWithParent: !0, relevance: 0 },
            b = { keywords: a, className: "name", begin: n, relevance: 0, starts: g },
            v = [d, m, s, l, c, u, f, h, i, p, o],
            y = {
              beginKeywords: r,
              keywords: { $pattern: n, keyword: r },
              end: '(\\[|#|\\d|"|:|\\{|\\)|\\(|$)',
              contains: [{ className: "title", begin: n, relevance: 0, excludeEnd: !0, endsParent: !0 }].concat(v),
            }
          return (
            (m.contains = [y, b, g]),
            (g.contains = v),
            (h.contains = v),
            { name: "Clojure", aliases: ["clj", "edn"], illegal: /\S/, contains: [d, m, s, l, c, u, f, h, i, p] }
          )
        },
        cpp: function (e) {
          const t = e.regex,
            n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
            r = "decltype\\(auto\\)",
            a = "[a-zA-Z_]\\w*::",
            o = "(?!struct)(" + r + "|" + t.optional(a) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")",
            i = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" },
            s = {
              className: "string",
              variants: [
                { begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [e.BACKSLASH_ESCAPE] },
                {
                  begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                  end: "'",
                  illegal: ".",
                },
                e.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ }),
              ],
            },
            l = {
              className: "number",
              variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
              ],
              relevance: 0,
            },
            c = {
              className: "meta",
              begin: /#\s*[a-z]+\b/,
              end: /$/,
              keywords: {
                keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include",
              },
              contains: [
                { begin: /\\\n/, relevance: 0 },
                e.inherit(s, { className: "string" }),
                { className: "string", begin: /<.*?>/ },
                n,
                e.C_BLOCK_COMMENT_MODE,
              ],
            },
            d = { className: "title", begin: t.optional(a) + e.IDENT_RE, relevance: 0 },
            u = t.optional(a) + e.IDENT_RE + "\\s*\\(",
            p = {
              type: [
                "bool",
                "char",
                "char16_t",
                "char32_t",
                "char8_t",
                "double",
                "float",
                "int",
                "long",
                "short",
                "void",
                "wchar_t",
                "unsigned",
                "signed",
                "const",
                "static",
              ],
              keyword: [
                "alignas",
                "alignof",
                "and",
                "and_eq",
                "asm",
                "atomic_cancel",
                "atomic_commit",
                "atomic_noexcept",
                "auto",
                "bitand",
                "bitor",
                "break",
                "case",
                "catch",
                "class",
                "co_await",
                "co_return",
                "co_yield",
                "compl",
                "concept",
                "const_cast|10",
                "consteval",
                "constexpr",
                "constinit",
                "continue",
                "decltype",
                "default",
                "delete",
                "do",
                "dynamic_cast|10",
                "else",
                "enum",
                "explicit",
                "export",
                "extern",
                "false",
                "final",
                "for",
                "friend",
                "goto",
                "if",
                "import",
                "inline",
                "module",
                "mutable",
                "namespace",
                "new",
                "noexcept",
                "not",
                "not_eq",
                "nullptr",
                "operator",
                "or",
                "or_eq",
                "override",
                "private",
                "protected",
                "public",
                "reflexpr",
                "register",
                "reinterpret_cast|10",
                "requires",
                "return",
                "sizeof",
                "static_assert",
                "static_cast|10",
                "struct",
                "switch",
                "synchronized",
                "template",
                "this",
                "thread_local",
                "throw",
                "transaction_safe",
                "transaction_safe_dynamic",
                "true",
                "try",
                "typedef",
                "typeid",
                "typename",
                "union",
                "using",
                "virtual",
                "volatile",
                "while",
                "xor",
                "xor_eq",
              ],
              literal: ["NULL", "false", "nullopt", "nullptr", "true"],
              built_in: ["_Pragma"],
              _type_hints: [
                "any",
                "auto_ptr",
                "barrier",
                "binary_semaphore",
                "bitset",
                "complex",
                "condition_variable",
                "condition_variable_any",
                "counting_semaphore",
                "deque",
                "false_type",
                "future",
                "imaginary",
                "initializer_list",
                "istringstream",
                "jthread",
                "latch",
                "lock_guard",
                "multimap",
                "multiset",
                "mutex",
                "optional",
                "ostringstream",
                "packaged_task",
                "pair",
                "promise",
                "priority_queue",
                "queue",
                "recursive_mutex",
                "recursive_timed_mutex",
                "scoped_lock",
                "set",
                "shared_future",
                "shared_lock",
                "shared_mutex",
                "shared_timed_mutex",
                "shared_ptr",
                "stack",
                "string_view",
                "stringstream",
                "timed_mutex",
                "thread",
                "true_type",
                "tuple",
                "unique_lock",
                "unique_ptr",
                "unordered_map",
                "unordered_multimap",
                "unordered_multiset",
                "unordered_set",
                "variant",
                "vector",
                "weak_ptr",
                "wstring",
                "wstring_view",
              ],
            },
            h = {
              className: "function.dispatch",
              relevance: 0,
              keywords: {
                _hint: [
                  "abort",
                  "abs",
                  "acos",
                  "apply",
                  "as_const",
                  "asin",
                  "atan",
                  "atan2",
                  "calloc",
                  "ceil",
                  "cerr",
                  "cin",
                  "clog",
                  "cos",
                  "cosh",
                  "cout",
                  "declval",
                  "endl",
                  "exchange",
                  "exit",
                  "exp",
                  "fabs",
                  "floor",
                  "fmod",
                  "forward",
                  "fprintf",
                  "fputs",
                  "free",
                  "frexp",
                  "fscanf",
                  "future",
                  "invoke",
                  "isalnum",
                  "isalpha",
                  "iscntrl",
                  "isdigit",
                  "isgraph",
                  "islower",
                  "isprint",
                  "ispunct",
                  "isspace",
                  "isupper",
                  "isxdigit",
                  "labs",
                  "launder",
                  "ldexp",
                  "log",
                  "log10",
                  "make_pair",
                  "make_shared",
                  "make_shared_for_overwrite",
                  "make_tuple",
                  "make_unique",
                  "malloc",
                  "memchr",
                  "memcmp",
                  "memcpy",
                  "memset",
                  "modf",
                  "move",
                  "pow",
                  "printf",
                  "putchar",
                  "puts",
                  "realloc",
                  "scanf",
                  "sin",
                  "sinh",
                  "snprintf",
                  "sprintf",
                  "sqrt",
                  "sscanf",
                  "std",
                  "stderr",
                  "stdin",
                  "stdout",
                  "strcat",
                  "strchr",
                  "strcmp",
                  "strcpy",
                  "strcspn",
                  "strlen",
                  "strncat",
                  "strncmp",
                  "strncpy",
                  "strpbrk",
                  "strrchr",
                  "strspn",
                  "strstr",
                  "swap",
                  "tan",
                  "tanh",
                  "terminate",
                  "to_underlying",
                  "tolower",
                  "toupper",
                  "vfprintf",
                  "visit",
                  "vprintf",
                  "vsprintf",
                ],
              },
              begin: t.concat(
                /\b/,
                /(?!decltype)/,
                /(?!if)/,
                /(?!for)/,
                /(?!switch)/,
                /(?!while)/,
                e.IDENT_RE,
                t.lookahead(/(<[^<>]+>|)\s*\(/),
              ),
            },
            f = [h, c, i, n, e.C_BLOCK_COMMENT_MODE, l, s],
            m = {
              variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: "new throw return else", end: /;/ },
              ],
              keywords: p,
              contains: f.concat([{ begin: /\(/, end: /\)/, keywords: p, contains: f.concat(["self"]), relevance: 0 }]),
              relevance: 0,
            },
            g = {
              className: "function",
              begin: "(" + o + "[\\*&\\s]+)+" + u,
              returnBegin: !0,
              end: /[{;=]/,
              excludeEnd: !0,
              keywords: p,
              illegal: /[^\w\s\*&:<>.]/,
              contains: [
                { begin: r, keywords: p, relevance: 0 },
                { begin: u, returnBegin: !0, contains: [d], relevance: 0 },
                { begin: /::/, relevance: 0 },
                { begin: /:/, endsWithParent: !0, contains: [s, l] },
                { relevance: 0, match: /,/ },
                {
                  className: "params",
                  begin: /\(/,
                  end: /\)/,
                  keywords: p,
                  relevance: 0,
                  contains: [
                    n,
                    e.C_BLOCK_COMMENT_MODE,
                    s,
                    l,
                    i,
                    {
                      begin: /\(/,
                      end: /\)/,
                      keywords: p,
                      relevance: 0,
                      contains: ["self", n, e.C_BLOCK_COMMENT_MODE, s, l, i],
                    },
                  ],
                },
                i,
                n,
                e.C_BLOCK_COMMENT_MODE,
                c,
              ],
            }
          return {
            name: "C++",
            aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
            keywords: p,
            illegal: "</",
            classNameAliases: { "function.dispatch": "built_in" },
            contains: [].concat(m, g, h, f, [
              c,
              {
                begin:
                  "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
                end: ">",
                keywords: p,
                contains: ["self", i],
              },
              { begin: e.IDENT_RE + "::", keywords: p },
              {
                match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
                className: { 1: "keyword", 3: "title.class" },
              },
            ]),
          }
        },
        css: function (e) {
          const t = e.regex,
            n = ((e) => ({
              IMPORTANT: { scope: "meta", begin: "!important" },
              BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
              HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
              FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
              ATTRIBUTE_SELECTOR_MODE: {
                scope: "selector-attr",
                begin: /\[/,
                end: /\]/,
                illegal: "$",
                contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
              },
              CSS_NUMBER_MODE: {
                scope: "number",
                begin:
                  e.NUMBER_RE +
                  "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
                relevance: 0,
              },
              CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
            }))(e),
            r = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
          return {
            name: "CSS",
            case_insensitive: !0,
            illegal: /[=|'\$]/,
            keywords: { keyframePosition: "from to" },
            classNameAliases: { keyframePosition: "selector-tag" },
            contains: [
              n.BLOCK_COMMENT,
              { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ },
              n.CSS_NUMBER_MODE,
              { className: "selector-id", begin: /#[A-Za-z0-9_-]+/, relevance: 0 },
              { className: "selector-class", begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*", relevance: 0 },
              n.ATTRIBUTE_SELECTOR_MODE,
              {
                className: "selector-pseudo",
                variants: [{ begin: ":(" + Uw.join("|") + ")" }, { begin: ":(:)?(" + Fw.join("|") + ")" }],
              },
              n.CSS_VARIABLE,
              { className: "attribute", begin: "\\b(" + zw.join("|") + ")\\b" },
              {
                begin: /:/,
                end: /[;}{]/,
                contains: [
                  n.BLOCK_COMMENT,
                  n.HEXCOLOR,
                  n.IMPORTANT,
                  n.CSS_NUMBER_MODE,
                  ...r,
                  {
                    begin: /(url|data-uri)\(/,
                    end: /\)/,
                    relevance: 0,
                    keywords: { built_in: "url data-uri" },
                    contains: [...r, { className: "string", begin: /[^)]/, endsWithParent: !0, excludeEnd: !0 }],
                  },
                  n.FUNCTION_DISPATCH,
                ],
              },
              {
                begin: t.lookahead(/@/),
                end: "[{;]",
                relevance: 0,
                illegal: /:/,
                contains: [
                  { className: "keyword", begin: /@-?\w[\w]*(-\w+)*/ },
                  {
                    begin: /\s/,
                    endsWithParent: !0,
                    excludeEnd: !0,
                    relevance: 0,
                    keywords: { $pattern: /[a-z-]+/, keyword: "and or not only", attribute: jw.join(" ") },
                    contains: [{ begin: /[a-z-]+(?=:)/, className: "attribute" }, ...r, n.CSS_NUMBER_MODE],
                  },
                ],
              },
              { className: "selector-tag", begin: "\\b(" + Bw.join("|") + ")\\b" },
            ],
          }
        },
        curl: em(function (e) {
          const t = {
              className: "string",
              begin: /"/,
              end: /"/,
              contains: [
                e.BACKSLASH_ESCAPE,
                { className: "variable", begin: /\$\(/, end: /\)/, contains: [e.BACKSLASH_ESCAPE] },
              ],
              relevance: 0,
            },
            n = { className: "number", variants: [{ begin: e.C_NUMBER_RE }], relevance: 0 }
          return {
            name: "curl",
            aliases: ["curl"],
            keywords: "curl",
            case_insensitive: !0,
            contains: [
              {
                className: "literal",
                begin: /(--request|-X)\s/,
                contains: [
                  {
                    className: "symbol",
                    begin: /(get|post|delete|options|head|put|patch|trace|connect)/,
                    end: /\s/,
                    returnEnd: !0,
                  },
                ],
                returnEnd: !0,
                relevance: 10,
              },
              { className: "literal", begin: /--/, end: /[\s"]/, returnEnd: !0, relevance: 0 },
              { className: "literal", begin: /-\w/, end: /[\s"]/, returnEnd: !0, relevance: 0 },
              t,
              { className: "string", begin: /\\"/, relevance: 0 },
              { className: "string", begin: /'/, end: /'/, relevance: 0 },
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              n,
              { match: /(\/[a-z._-]+)+/ },
            ],
          }
        }),
        csharp: function (e) {
          const t = {
              keyword: [
                "abstract",
                "as",
                "base",
                "break",
                "case",
                "catch",
                "class",
                "const",
                "continue",
                "do",
                "else",
                "event",
                "explicit",
                "extern",
                "finally",
                "fixed",
                "for",
                "foreach",
                "goto",
                "if",
                "implicit",
                "in",
                "interface",
                "internal",
                "is",
                "lock",
                "namespace",
                "new",
                "operator",
                "out",
                "override",
                "params",
                "private",
                "protected",
                "public",
                "readonly",
                "record",
                "ref",
                "return",
                "scoped",
                "sealed",
                "sizeof",
                "stackalloc",
                "static",
                "struct",
                "switch",
                "this",
                "throw",
                "try",
                "typeof",
                "unchecked",
                "unsafe",
                "using",
                "virtual",
                "void",
                "volatile",
                "while",
              ].concat([
                "add",
                "alias",
                "and",
                "ascending",
                "async",
                "await",
                "by",
                "descending",
                "equals",
                "from",
                "get",
                "global",
                "group",
                "init",
                "into",
                "join",
                "let",
                "nameof",
                "not",
                "notnull",
                "on",
                "or",
                "orderby",
                "partial",
                "remove",
                "select",
                "set",
                "unmanaged",
                "value|0",
                "var",
                "when",
                "where",
                "with",
                "yield",
              ]),
              built_in: [
                "bool",
                "byte",
                "char",
                "decimal",
                "delegate",
                "double",
                "dynamic",
                "enum",
                "float",
                "int",
                "long",
                "nint",
                "nuint",
                "object",
                "sbyte",
                "short",
                "string",
                "ulong",
                "uint",
                "ushort",
              ],
              literal: ["default", "false", "null", "true"],
            },
            n = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }),
            r = {
              className: "number",
              variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
              ],
              relevance: 0,
            },
            a = { className: "string", begin: '@"', end: '"', contains: [{ begin: '""' }] },
            o = e.inherit(a, { illegal: /\n/ }),
            i = { className: "subst", begin: /\{/, end: /\}/, keywords: t },
            s = e.inherit(i, { illegal: /\n/ }),
            l = {
              className: "string",
              begin: /\$"/,
              end: '"',
              illegal: /\n/,
              contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, e.BACKSLASH_ESCAPE, s],
            },
            c = {
              className: "string",
              begin: /\$@"/,
              end: '"',
              contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, i],
            },
            d = e.inherit(c, { illegal: /\n/, contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, s] })
          ;(i.contains = [c, l, a, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, r, e.C_BLOCK_COMMENT_MODE]),
            (s.contains = [
              d,
              l,
              o,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              r,
              e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ }),
            ])
          const u = { variants: [c, l, a, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE] },
            p = { begin: "<", end: ">", contains: [{ beginKeywords: "in out" }, n] },
            h = e.IDENT_RE + "(<" + e.IDENT_RE + "(\\s*,\\s*" + e.IDENT_RE + ")*>)?(\\[\\])?",
            f = { begin: "@" + e.IDENT_RE, relevance: 0 }
          return {
            name: "C#",
            aliases: ["cs", "c#"],
            keywords: t,
            illegal: /::/,
            contains: [
              e.COMMENT("///", "$", {
                returnBegin: !0,
                contains: [
                  {
                    className: "doctag",
                    variants: [{ begin: "///", relevance: 0 }, { begin: "\x3c!--|--\x3e" }, { begin: "</?", end: ">" }],
                  },
                ],
              }),
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              {
                className: "meta",
                begin: "#",
                end: "$",
                keywords: {
                  keyword: "if else elif endif define undef warning error line region endregion pragma checksum",
                },
              },
              u,
              r,
              {
                beginKeywords: "class interface",
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:,]/,
                contains: [{ beginKeywords: "where class" }, n, p, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              {
                beginKeywords: "namespace",
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:]/,
                contains: [n, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              {
                beginKeywords: "record",
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:]/,
                contains: [n, p, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              {
                className: "meta",
                begin: "^\\s*\\[(?=[\\w])",
                excludeBegin: !0,
                end: "\\]",
                excludeEnd: !0,
                contains: [{ className: "string", begin: /"/, end: /"/ }],
              },
              { beginKeywords: "new return throw await else", relevance: 0 },
              {
                className: "function",
                begin: "(" + h + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: !0,
                end: /\s*[{;=]/,
                excludeEnd: !0,
                keywords: t,
                contains: [
                  {
                    beginKeywords: [
                      "public",
                      "private",
                      "protected",
                      "static",
                      "internal",
                      "protected",
                      "abstract",
                      "async",
                      "extern",
                      "override",
                      "unsafe",
                      "virtual",
                      "new",
                      "sealed",
                      "partial",
                    ].join(" "),
                    relevance: 0,
                  },
                  {
                    begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                    returnBegin: !0,
                    contains: [e.TITLE_MODE, p],
                    relevance: 0,
                  },
                  { match: /\(\)/ },
                  {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: t,
                    relevance: 0,
                    contains: [u, r, e.C_BLOCK_COMMENT_MODE],
                  },
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              f,
            ],
          }
        },
        elixir: function (e) {
          const t = e.regex,
            n = "[a-zA-Z_][a-zA-Z0-9_.]*(!|\\?)?",
            r = {
              $pattern: n,
              keyword: [
                "after",
                "alias",
                "and",
                "case",
                "catch",
                "cond",
                "defstruct",
                "defguard",
                "do",
                "else",
                "end",
                "fn",
                "for",
                "if",
                "import",
                "in",
                "not",
                "or",
                "quote",
                "raise",
                "receive",
                "require",
                "reraise",
                "rescue",
                "try",
                "unless",
                "unquote",
                "unquote_splicing",
                "use",
                "when",
                "with|0",
              ],
              literal: ["false", "nil", "true"],
            },
            a = { className: "subst", begin: /#\{/, end: /\}/, keywords: r },
            o = { match: /\\[\s\S]/, scope: "char.escape", relevance: 0 },
            i = "[/|([{<\"']",
            s = [
              { begin: /"/, end: /"/ },
              { begin: /'/, end: /'/ },
              { begin: /\//, end: /\// },
              { begin: /\|/, end: /\|/ },
              { begin: /\(/, end: /\)/ },
              { begin: /\[/, end: /\]/ },
              { begin: /\{/, end: /\}/ },
              { begin: /</, end: />/ },
            ],
            l = (e) => ({ scope: "char.escape", begin: t.concat(/\\/, e), relevance: 0 }),
            c = {
              className: "string",
              begin: "~[a-z](?=" + i + ")",
              contains: s.map((t) => e.inherit(t, { contains: [l(t.end), o, a] })),
            },
            d = {
              className: "string",
              begin: "~[A-Z](?=" + i + ")",
              contains: s.map((t) => e.inherit(t, { contains: [l(t.end)] })),
            },
            u = {
              className: "regex",
              variants: [
                {
                  begin: "~r(?=" + i + ")",
                  contains: s.map((n) =>
                    e.inherit(n, { end: t.concat(n.end, /[uismxfU]{0,7}/), contains: [l(n.end), o, a] }),
                  ),
                },
                {
                  begin: "~R(?=" + i + ")",
                  contains: s.map((n) =>
                    e.inherit(n, { end: t.concat(n.end, /[uismxfU]{0,7}/), contains: [l(n.end)] }),
                  ),
                },
              ],
            },
            p = {
              className: "string",
              contains: [e.BACKSLASH_ESCAPE, a],
              variants: [
                { begin: /"""/, end: /"""/ },
                { begin: /'''/, end: /'''/ },
                { begin: /~S"""/, end: /"""/, contains: [] },
                { begin: /~S"/, end: /"/, contains: [] },
                { begin: /~S'''/, end: /'''/, contains: [] },
                { begin: /~S'/, end: /'/, contains: [] },
                { begin: /'/, end: /'/ },
                { begin: /"/, end: /"/ },
              ],
            },
            h = {
              className: "function",
              beginKeywords: "def defp defmacro defmacrop",
              end: /\B\b/,
              contains: [e.inherit(e.TITLE_MODE, { begin: n, endsParent: !0 })],
            },
            f = e.inherit(h, {
              className: "class",
              beginKeywords: "defimpl defmodule defprotocol defrecord",
              end: /\bdo\b|$|;/,
            }),
            m = [
              p,
              u,
              d,
              c,
              e.HASH_COMMENT_MODE,
              f,
              h,
              { begin: "::" },
              {
                className: "symbol",
                begin: ":(?![\\s:])",
                contains: [
                  p,
                  { begin: "[a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?" },
                ],
                relevance: 0,
              },
              { className: "symbol", begin: n + ":(?!:)", relevance: 0 },
              { className: "title.class", begin: /(\b[A-Z][a-zA-Z0-9_]+)/, relevance: 0 },
              {
                className: "number",
                begin:
                  "(\\b0o[0-7_]+)|(\\b0b[01_]+)|(\\b0x[0-9a-fA-F_]+)|(-?\\b[0-9][0-9_]*(\\.[0-9_]+([eE][-+]?[0-9]+)?)?)",
                relevance: 0,
              },
              { className: "variable", begin: "(\\$\\W)|((\\$|@@?)(\\w+))" },
            ]
          return (a.contains = m), { name: "Elixir", aliases: ["ex", "exs"], keywords: r, contains: m }
        },
        go: function (e) {
          const t = {
            keyword: [
              "break",
              "case",
              "chan",
              "const",
              "continue",
              "default",
              "defer",
              "else",
              "fallthrough",
              "for",
              "func",
              "go",
              "goto",
              "if",
              "import",
              "interface",
              "map",
              "package",
              "range",
              "return",
              "select",
              "struct",
              "switch",
              "type",
              "var",
            ],
            type: [
              "bool",
              "byte",
              "complex64",
              "complex128",
              "error",
              "float32",
              "float64",
              "int8",
              "int16",
              "int32",
              "int64",
              "string",
              "uint8",
              "uint16",
              "uint32",
              "uint64",
              "int",
              "uint",
              "uintptr",
              "rune",
            ],
            literal: ["true", "false", "iota", "nil"],
            built_in: [
              "append",
              "cap",
              "close",
              "complex",
              "copy",
              "imag",
              "len",
              "make",
              "new",
              "panic",
              "print",
              "println",
              "real",
              "recover",
              "delete",
            ],
          }
          return {
            name: "Go",
            aliases: ["golang"],
            keywords: t,
            illegal: "</",
            contains: [
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              { className: "string", variants: [e.QUOTE_STRING_MODE, e.APOS_STRING_MODE, { begin: "`", end: "`" }] },
              { className: "number", variants: [{ begin: e.C_NUMBER_RE + "[i]", relevance: 1 }, e.C_NUMBER_MODE] },
              { begin: /:=/ },
              {
                className: "function",
                beginKeywords: "func",
                end: "\\s*(\\{|$)",
                excludeEnd: !0,
                contains: [
                  e.TITLE_MODE,
                  { className: "params", begin: /\(/, end: /\)/, endsParent: !0, keywords: t, illegal: /["']/ },
                ],
              },
            ],
          }
        },
        graphql: function (e) {
          const t = e.regex
          return {
            name: "GraphQL",
            aliases: ["gql"],
            case_insensitive: !0,
            disableAutodetect: !1,
            keywords: {
              keyword: [
                "query",
                "mutation",
                "subscription",
                "type",
                "input",
                "schema",
                "directive",
                "interface",
                "union",
                "scalar",
                "fragment",
                "enum",
                "on",
              ],
              literal: ["true", "false", "null"],
            },
            contains: [
              e.HASH_COMMENT_MODE,
              e.QUOTE_STRING_MODE,
              e.NUMBER_MODE,
              { scope: "punctuation", match: /[.]{3}/, relevance: 0 },
              { scope: "punctuation", begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/, relevance: 0 },
              { scope: "variable", begin: /\$/, end: /\W/, excludeEnd: !0, relevance: 0 },
              { scope: "meta", match: /@\w+/, excludeEnd: !0 },
              { scope: "symbol", begin: t.concat(/[_A-Za-z][_0-9A-Za-z]*/, t.lookahead(/\s*:/)), relevance: 0 },
            ],
            illegal: [/[;<']/, /BEGIN/],
          }
        },
        html: Wx,
        java: function (e) {
          const t = e.regex,
            n = "[-a-zA-Z_$][-a-zA-Z_$0-9]*",
            r = n + Ww("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2),
            a = {
              keyword: [
                "synchronized",
                "abstract",
                "private",
                "var",
                "static",
                "if",
                "const ",
                "for",
                "while",
                "strictfp",
                "finally",
                "protected",
                "import",
                "native",
                "final",
                "void",
                "enum",
                "else",
                "break",
                "transient",
                "catch",
                "instanceof",
                "volatile",
                "case",
                "assert",
                "package",
                "default",
                "public",
                "try",
                "switch",
                "continue",
                "throws",
                "protected",
                "public",
                "private",
                "module",
                "requires",
                "exports",
                "do",
                "sealed",
                "yield",
                "permits",
              ],
              literal: ["false", "true", "null"],
              type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"],
              built_in: ["super", "this"],
            },
            o = { className: "meta", begin: "@" + n, contains: [{ begin: /\(/, end: /\)/, contains: ["self"] }] },
            i = {
              className: "params",
              begin: /\(/,
              end: /\)/,
              keywords: a,
              relevance: 0,
              contains: [e.C_BLOCK_COMMENT_MODE],
              endsParent: !0,
            }
          return {
            name: "Java",
            aliases: ["jsp"],
            keywords: a,
            illegal: /<\/|#/,
            contains: [
              e.COMMENT("/\\*\\*", "\\*/", {
                relevance: 0,
                contains: [
                  { begin: /\w+@/, relevance: 0 },
                  { className: "doctag", begin: "@[A-Za-z]+" },
                ],
              }),
              { begin: /import java\.[a-z]+\./, keywords: "import", relevance: 2 },
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              { begin: /"""/, end: /"""/, className: "string", contains: [e.BACKSLASH_ESCAPE] },
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              {
                match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, n],
                className: { 1: "keyword", 3: "title.class" },
              },
              { match: /non-sealed/, scope: "keyword" },
              {
                begin: [t.concat(/(?!else)/, n), /\s+/, n, /\s+/, /=(?!=)/],
                className: { 1: "type", 3: "variable", 5: "operator" },
              },
              {
                begin: [/record/, /\s+/, n],
                className: { 1: "keyword", 3: "title.class" },
                contains: [i, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              { beginKeywords: "new throw return else", relevance: 0 },
              {
                begin: ["(?:" + r + "\\s+)", e.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
                className: { 2: "title.function" },
                keywords: a,
                contains: [
                  {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    keywords: a,
                    relevance: 0,
                    contains: [o, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, Vw, e.C_BLOCK_COMMENT_MODE],
                  },
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              Vw,
              o,
            ],
          }
        },
        javascript: function (e) {
          const t = e.regex,
            n = Xw,
            r = {
              begin: /<[A-Za-z0-9\\._:-]+/,
              end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
              isTrulyOpeningTag: (e, t) => {
                const n = e[0].length + e.index,
                  r = e.input[n]
                if ("<" === r || "," === r) return void t.ignoreMatch()
                let a
                ">" === r &&
                  (((e, { after: t }) => {
                    const n = "</" + e[0].slice(1)
                    return -1 !== e.input.indexOf(n, t)
                  })(e, { after: n }) ||
                    t.ignoreMatch())
                const o = e.input.substring(n)
                ;((a = o.match(/^\s*=/)) || ((a = o.match(/^\s+extends\s+/)) && 0 === a.index)) && t.ignoreMatch()
              },
            },
            a = { $pattern: Xw, keyword: Yw, literal: Gw, built_in: nx, "variable.language": tx },
            o = "[0-9](_?[0-9])*",
            i = `\\.(${o})`,
            s = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
            l = {
              className: "number",
              variants: [
                { begin: `(\\b(${s})((${i})|\\.)?|(${i}))[eE][+-]?(${o})\\b` },
                { begin: `\\b(${s})\\b((${i})\\b|\\.)?|(${i})\\b` },
                { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
                { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
                { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
                { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
                { begin: "\\b0[0-7]+n?\\b" },
              ],
              relevance: 0,
            },
            c = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: a, contains: [] },
            d = {
              begin: "html`",
              end: "",
              starts: { end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "xml" },
            },
            u = {
              begin: "css`",
              end: "",
              starts: { end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "css" },
            },
            p = {
              begin: "gql`",
              end: "",
              starts: { end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "graphql" },
            },
            h = { className: "string", begin: "`", end: "`", contains: [e.BACKSLASH_ESCAPE, c] },
            f = {
              className: "comment",
              variants: [
                e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                  relevance: 0,
                  contains: [
                    {
                      begin: "(?=@[A-Za-z]+)",
                      relevance: 0,
                      contains: [
                        { className: "doctag", begin: "@[A-Za-z]+" },
                        { className: "type", begin: "\\{", end: "\\}", excludeEnd: !0, excludeBegin: !0, relevance: 0 },
                        { className: "variable", begin: n + "(?=\\s*(-)|$)", endsParent: !0, relevance: 0 },
                        { begin: /(?=[^\n])\s/, relevance: 0 },
                      ],
                    },
                  ],
                }),
                e.C_BLOCK_COMMENT_MODE,
                e.C_LINE_COMMENT_MODE,
              ],
            },
            m = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, d, u, p, h, { match: /\$\d+/ }, l]
          c.contains = m.concat({ begin: /\{/, end: /\}/, keywords: a, contains: ["self"].concat(m) })
          const g = [].concat(f, c.contains),
            b = g.concat([{ begin: /\(/, end: /\)/, keywords: a, contains: ["self"].concat(g) }]),
            v = {
              className: "params",
              begin: /\(/,
              end: /\)/,
              excludeBegin: !0,
              excludeEnd: !0,
              keywords: a,
              contains: b,
            },
            y = {
              variants: [
                {
                  match: [/class/, /\s+/, n, /\s+/, /extends/, /\s+/, t.concat(n, "(", t.concat(/\./, n), ")*")],
                  scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" },
                },
                { match: [/class/, /\s+/, n], scope: { 1: "keyword", 3: "title.class" } },
              ],
            },
            O = {
              relevance: 0,
              match: t.either(
                /\bJSON/,
                /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
                /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
                /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/,
              ),
              className: "title.class",
              keywords: { _: [...Kw, ...Jw] },
            },
            w = {
              variants: [{ match: [/function/, /\s+/, n, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }],
              className: { 1: "keyword", 3: "title.function" },
              label: "func.def",
              contains: [v],
              illegal: /%/,
            },
            x = {
              match: t.concat(
                /\b/,
                ((k = [...ex, "super", "import"]), t.concat("(?!", k.join("|"), ")")),
                n,
                t.lookahead(/\(/),
              ),
              className: "title.function",
              relevance: 0,
            }
          var k
          const _ = {
              begin: t.concat(/\./, t.lookahead(t.concat(n, /(?![0-9A-Za-z$_(])/))),
              end: n,
              excludeBegin: !0,
              keywords: "prototype",
              className: "property",
              relevance: 0,
            },
            S = {
              match: [/get|set/, /\s+/, n, /(?=\()/],
              className: { 1: "keyword", 3: "title.function" },
              contains: [{ begin: /\(\)/ }, v],
            },
            E = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>",
            T = {
              match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(E)],
              keywords: "async",
              className: { 1: "keyword", 3: "title.function" },
              contains: [v],
            }
          return {
            name: "JavaScript",
            aliases: ["js", "jsx", "mjs", "cjs"],
            keywords: a,
            exports: { PARAMS_CONTAINS: b, CLASS_REFERENCE: O },
            illegal: /#(?![$_A-z])/,
            contains: [
              e.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
              { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ },
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              d,
              u,
              p,
              h,
              f,
              { match: /\$\d+/ },
              l,
              O,
              { className: "attr", begin: n + t.lookahead(":"), relevance: 0 },
              T,
              {
                begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
                keywords: "return throw case",
                relevance: 0,
                contains: [
                  f,
                  e.REGEXP_MODE,
                  {
                    className: "function",
                    begin: E,
                    returnBegin: !0,
                    end: "\\s*=>",
                    contains: [
                      {
                        className: "params",
                        variants: [
                          { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                          { className: null, begin: /\(\s*\)/, skip: !0 },
                          { begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: a, contains: b },
                        ],
                      },
                    ],
                  },
                  { begin: /,/, relevance: 0 },
                  { match: /\s+/, relevance: 0 },
                  {
                    variants: [
                      { begin: "<>", end: "</>" },
                      { match: /<[A-Za-z0-9\\._:-]+\s*\/>/ },
                      { begin: r.begin, "on:begin": r.isTrulyOpeningTag, end: r.end },
                    ],
                    subLanguage: "xml",
                    contains: [{ begin: r.begin, end: r.end, skip: !0, contains: ["self"] }],
                  },
                ],
              },
              w,
              { beginKeywords: "while if switch catch for" },
              {
                begin:
                  "\\b(?!function)" +
                  e.UNDERSCORE_IDENT_RE +
                  "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
                returnBegin: !0,
                label: "func.def",
                contains: [v, e.inherit(e.TITLE_MODE, { begin: n, className: "title.function" })],
              },
              { match: /\.\.\./, relevance: 0 },
              _,
              { match: "\\$" + n, relevance: 0 },
              { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [v] },
              x,
              { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" },
              y,
              S,
              { match: /\$[(.]/ },
            ],
          }
        },
        json: function (e) {
          const t = ["true", "false", "null"],
            n = { scope: "literal", beginKeywords: t.join(" ") }
          return {
            name: "JSON",
            keywords: { literal: t },
            contains: [
              { className: "attr", begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/, relevance: 1.01 },
              { match: /[{}[\],:]/, className: "punctuation", relevance: 0 },
              e.QUOTE_STRING_MODE,
              n,
              e.C_NUMBER_MODE,
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
            ],
            illegal: "\\S",
          }
        },
        kotlin: function (e) {
          const t = {
              keyword:
                "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
              built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
              literal: "true false null",
            },
            n = { className: "symbol", begin: e.UNDERSCORE_IDENT_RE + "@" },
            r = { className: "subst", begin: /\$\{/, end: /\}/, contains: [e.C_NUMBER_MODE] },
            a = { className: "variable", begin: "\\$" + e.UNDERSCORE_IDENT_RE },
            o = {
              className: "string",
              variants: [
                { begin: '"""', end: '"""(?=[^"])', contains: [a, r] },
                { begin: "'", end: "'", illegal: /\n/, contains: [e.BACKSLASH_ESCAPE] },
                { begin: '"', end: '"', illegal: /\n/, contains: [e.BACKSLASH_ESCAPE, a, r] },
              ],
            }
          r.contains.push(o)
          const i = {
              className: "meta",
              begin:
                "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" +
                e.UNDERSCORE_IDENT_RE +
                ")?",
            },
            s = {
              className: "meta",
              begin: "@" + e.UNDERSCORE_IDENT_RE,
              contains: [{ begin: /\(/, end: /\)/, contains: [e.inherit(o, { className: "string" }), "self"] }],
            },
            l = ix,
            c = e.COMMENT("/\\*", "\\*/", { contains: [e.C_BLOCK_COMMENT_MODE] }),
            d = {
              variants: [
                { className: "type", begin: e.UNDERSCORE_IDENT_RE },
                { begin: /\(/, end: /\)/, contains: [] },
              ],
            },
            u = d
          return (
            (u.variants[1].contains = [d]),
            (d.variants[1].contains = [u]),
            {
              name: "Kotlin",
              aliases: ["kt", "kts"],
              keywords: t,
              contains: [
                e.COMMENT("/\\*\\*", "\\*/", {
                  relevance: 0,
                  contains: [{ className: "doctag", begin: "@[A-Za-z]+" }],
                }),
                e.C_LINE_COMMENT_MODE,
                c,
                {
                  className: "keyword",
                  begin: /\b(break|continue|return|this)\b/,
                  starts: { contains: [{ className: "symbol", begin: /@\w+/ }] },
                },
                n,
                i,
                s,
                {
                  className: "function",
                  beginKeywords: "fun",
                  end: "[(]|$",
                  returnBegin: !0,
                  excludeEnd: !0,
                  keywords: t,
                  relevance: 5,
                  contains: [
                    {
                      begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
                      returnBegin: !0,
                      relevance: 0,
                      contains: [e.UNDERSCORE_TITLE_MODE],
                    },
                    { className: "type", begin: /</, end: />/, keywords: "reified", relevance: 0 },
                    {
                      className: "params",
                      begin: /\(/,
                      end: /\)/,
                      endsParent: !0,
                      keywords: t,
                      relevance: 0,
                      contains: [
                        {
                          begin: /:/,
                          end: /[=,\/]/,
                          endsWithParent: !0,
                          contains: [d, e.C_LINE_COMMENT_MODE, c],
                          relevance: 0,
                        },
                        e.C_LINE_COMMENT_MODE,
                        c,
                        i,
                        s,
                        o,
                        e.C_NUMBER_MODE,
                      ],
                    },
                    c,
                  ],
                },
                {
                  begin: [/class|interface|trait/, /\s+/, e.UNDERSCORE_IDENT_RE],
                  beginScope: { 3: "title.class" },
                  keywords: "class interface trait",
                  end: /[:\{(]|$/,
                  excludeEnd: !0,
                  illegal: "extends implements",
                  contains: [
                    { beginKeywords: "public protected internal private constructor" },
                    e.UNDERSCORE_TITLE_MODE,
                    { className: "type", begin: /</, end: />/, excludeBegin: !0, excludeEnd: !0, relevance: 0 },
                    { className: "type", begin: /[,:]\s*/, end: /[<\(,){\s]|$/, excludeBegin: !0, returnEnd: !0 },
                    i,
                    s,
                  ],
                },
                o,
                { className: "meta", begin: "^#!/usr/bin/env", end: "$", illegal: "\n" },
                l,
              ],
            }
          )
        },
        less: function (e) {
          const t = ((e) => ({
              IMPORTANT: { scope: "meta", begin: "!important" },
              BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
              HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
              FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
              ATTRIBUTE_SELECTOR_MODE: {
                scope: "selector-attr",
                begin: /\[/,
                end: /\]/,
                illegal: "$",
                contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
              },
              CSS_NUMBER_MODE: {
                scope: "number",
                begin:
                  e.NUMBER_RE +
                  "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
                relevance: 0,
              },
              CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
            }))(e),
            n = px,
            r = "[\\w-]+",
            a = "(" + r + "|@\\{" + r + "\\})",
            o = [],
            i = [],
            s = function (e) {
              return { className: "string", begin: "~?" + e + ".*?" + e }
            },
            l = function (e, t, n) {
              return { className: e, begin: t, relevance: n }
            },
            c = { $pattern: /[a-z-]+/, keyword: "and or not only", attribute: lx.join(" ") },
            d = { begin: "\\(", end: "\\)", contains: i, keywords: c, relevance: 0 }
          i.push(
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE,
            s("'"),
            s('"'),
            t.CSS_NUMBER_MODE,
            { begin: "(url|data-uri)\\(", starts: { className: "string", end: "[\\)\\n]", excludeEnd: !0 } },
            t.HEXCOLOR,
            d,
            l("variable", "@@?" + r, 10),
            l("variable", "@\\{" + r + "\\}"),
            l("built_in", "~?`[^`]*?`"),
            { className: "attribute", begin: r + "\\s*:", end: ":", returnBegin: !0, excludeEnd: !0 },
            t.IMPORTANT,
            { beginKeywords: "and not" },
            t.FUNCTION_DISPATCH,
          )
          const u = i.concat({ begin: /\{/, end: /\}/, contains: o }),
            p = { beginKeywords: "when", endsWithParent: !0, contains: [{ beginKeywords: "and not" }].concat(i) },
            h = {
              begin: a + "\\s*:",
              returnBegin: !0,
              end: /[;}]/,
              relevance: 0,
              contains: [
                { begin: /-(webkit|moz|ms|o)-/ },
                t.CSS_VARIABLE,
                {
                  className: "attribute",
                  begin: "\\b(" + ux.join("|") + ")\\b",
                  end: /(?=:)/,
                  starts: { endsWithParent: !0, illegal: "[<=$]", relevance: 0, contains: i },
                },
              ],
            },
            f = {
              className: "keyword",
              begin:
                "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
              starts: { end: "[;{}]", keywords: c, returnEnd: !0, contains: i, relevance: 0 },
            },
            m = {
              className: "variable",
              variants: [{ begin: "@" + r + "\\s*:", relevance: 15 }, { begin: "@" + r }],
              starts: { end: "[;}]", returnEnd: !0, contains: u },
            },
            g = {
              variants: [
                { begin: "[\\.#:&\\[>]", end: "[;{}]" },
                { begin: a, end: /\{/ },
              ],
              returnBegin: !0,
              returnEnd: !0,
              illegal: "[<='$\"]",
              relevance: 0,
              contains: [
                e.C_LINE_COMMENT_MODE,
                e.C_BLOCK_COMMENT_MODE,
                p,
                l("keyword", "all\\b"),
                l("variable", "@\\{" + r + "\\}"),
                { begin: "\\b(" + sx.join("|") + ")\\b", className: "selector-tag" },
                t.CSS_NUMBER_MODE,
                l("selector-tag", a, 0),
                l("selector-id", "#" + a),
                l("selector-class", "\\." + a, 0),
                l("selector-tag", "&", 0),
                t.ATTRIBUTE_SELECTOR_MODE,
                { className: "selector-pseudo", begin: ":(" + cx.join("|") + ")" },
                { className: "selector-pseudo", begin: ":(:)?(" + dx.join("|") + ")" },
                { begin: /\(/, end: /\)/, relevance: 0, contains: u },
                { begin: "!important" },
                t.FUNCTION_DISPATCH,
              ],
            },
            b = { begin: r + `:(:)?(${n.join("|")})`, returnBegin: !0, contains: [g] }
          return (
            o.push(e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, f, m, b, h, g, p, t.FUNCTION_DISPATCH),
            { name: "Less", case_insensitive: !0, illegal: "[=>'/<($\"]", contains: o }
          )
        },
        makefile: function (e) {
          const t = {
              className: "variable",
              variants: [
                { begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)", contains: [e.BACKSLASH_ESCAPE] },
                { begin: /\$[@%<?\^\+\*]/ },
              ],
            },
            n = { className: "string", begin: /"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, t] },
            r = {
              className: "variable",
              begin: /\$\([\w-]+\s/,
              end: /\)/,
              keywords: {
                built_in:
                  "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value",
              },
              contains: [t],
            },
            a = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" },
            o = { className: "section", begin: /^[^\s]+:/, end: /$/, contains: [t] }
          return {
            name: "Makefile",
            aliases: ["mk", "mak", "make"],
            keywords: {
              $pattern: /[\w-]+/,
              keyword:
                "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath",
            },
            contains: [
              e.HASH_COMMENT_MODE,
              t,
              n,
              r,
              a,
              { className: "meta", begin: /^\.PHONY:/, end: /$/, keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" } },
              o,
            ],
          }
        },
        markdown: function (e) {
          const t = { begin: /<\/?[A-Za-z_]/, end: ">", subLanguage: "xml", relevance: 0 },
            n = {
              variants: [
                { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
                { begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/, relevance: 2 },
                { begin: e.regex.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/), relevance: 2 },
                { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
                { begin: /\[.*?\]\(.*?\)/, relevance: 0 },
              ],
              returnBegin: !0,
              contains: [
                { match: /\[(?=\])/ },
                { className: "string", relevance: 0, begin: "\\[", end: "\\]", excludeBegin: !0, returnEnd: !0 },
                { className: "link", relevance: 0, begin: "\\]\\(", end: "\\)", excludeBegin: !0, excludeEnd: !0 },
                { className: "symbol", relevance: 0, begin: "\\]\\[", end: "\\]", excludeBegin: !0, excludeEnd: !0 },
              ],
            },
            r = {
              className: "strong",
              contains: [],
              variants: [
                { begin: /_{2}(?!\s)/, end: /_{2}/ },
                { begin: /\*{2}(?!\s)/, end: /\*{2}/ },
              ],
            },
            a = {
              className: "emphasis",
              contains: [],
              variants: [
                { begin: /\*(?![*\s])/, end: /\*/ },
                { begin: /_(?![_\s])/, end: /_/, relevance: 0 },
              ],
            },
            o = e.inherit(r, { contains: [] }),
            i = e.inherit(a, { contains: [] })
          r.contains.push(i), a.contains.push(o)
          let s = [t, n]
          return (
            [r, a, o, i].forEach((e) => {
              e.contains = e.contains.concat(s)
            }),
            (s = s.concat(r, a)),
            {
              name: "Markdown",
              aliases: ["md", "mkdown", "mkd"],
              contains: [
                {
                  className: "section",
                  variants: [
                    { begin: "^#{1,6}", end: "$", contains: s },
                    {
                      begin: "(?=^.+?\\n[=-]{2,}$)",
                      contains: [{ begin: "^[=-]*$" }, { begin: "^", end: "\\n", contains: s }],
                    },
                  ],
                },
                t,
                { className: "bullet", begin: "^[ \t]*([*+-]|(\\d+\\.))(?=\\s+)", end: "\\s+", excludeEnd: !0 },
                r,
                a,
                { className: "quote", begin: "^>\\s+", contains: s, end: "$" },
                {
                  className: "code",
                  variants: [
                    { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
                    { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
                    { begin: "```", end: "```+[ ]*$" },
                    { begin: "~~~", end: "~~~+[ ]*$" },
                    { begin: "`.+?`" },
                    { begin: "(?=^( {4}|\\t))", contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }], relevance: 0 },
                  ],
                },
                { begin: "^[-\\*]{3,}", end: "$" },
                n,
                {
                  begin: /^\[[^\n]+\]:/,
                  returnBegin: !0,
                  contains: [
                    { className: "symbol", begin: /\[/, end: /\]/, excludeBegin: !0, excludeEnd: !0 },
                    { className: "link", begin: /:\s*/, end: /$/, excludeBegin: !0 },
                  ],
                },
              ],
            }
          )
        },
        matlab: function (e) {
          const t = "('|\\.')+",
            n = { relevance: 0, contains: [{ begin: t }] }
          return {
            name: "Matlab",
            keywords: {
              keyword:
                "arguments break case catch classdef continue else elseif end enumeration events for function global if methods otherwise parfor persistent properties return spmd switch try while",
              built_in:
                "sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i|0 inf nan isnan isinf isfinite j|0 why compan gallery hadamard hankel hilb invhilb magic pascal rosser toeplitz vander wilkinson max min nanmax nanmin mean nanmean type table readtable writetable sortrows sort figure plot plot3 scatter scatter3 cellfun legend intersect ismember procrustes hold num2cell ",
            },
            illegal: '(//|"|#|/\\*|\\s+/\\w+)',
            contains: [
              {
                className: "function",
                beginKeywords: "function",
                end: "$",
                contains: [
                  e.UNDERSCORE_TITLE_MODE,
                  {
                    className: "params",
                    variants: [
                      { begin: "\\(", end: "\\)" },
                      { begin: "\\[", end: "\\]" },
                    ],
                  },
                ],
              },
              { className: "built_in", begin: /true|false/, relevance: 0, starts: n },
              { begin: "[a-zA-Z][a-zA-Z_0-9]*" + t, relevance: 0 },
              { className: "number", begin: e.C_NUMBER_RE, relevance: 0, starts: n },
              { className: "string", begin: "'", end: "'", contains: [{ begin: "''" }] },
              { begin: /\]|\}|\)/, relevance: 0, starts: n },
              { className: "string", begin: '"', end: '"', contains: [{ begin: '""' }], starts: n },
              e.COMMENT("^\\s*%\\{\\s*$", "^\\s*%\\}\\s*$"),
              e.COMMENT("%", "$"),
            ],
          }
        },
        nginx: function (e) {
          const t = e.regex,
            n = {
              className: "variable",
              variants: [
                { begin: /\$\d+/ },
                { begin: /\$\{\w+\}/ },
                { begin: t.concat(/[$@]/, e.UNDERSCORE_IDENT_RE) },
              ],
            },
            r = {
              endsWithParent: !0,
              keywords: {
                $pattern: /[a-z_]{2,}|\/dev\/poll/,
                literal: [
                  "on",
                  "off",
                  "yes",
                  "no",
                  "true",
                  "false",
                  "none",
                  "blocked",
                  "debug",
                  "info",
                  "notice",
                  "warn",
                  "error",
                  "crit",
                  "select",
                  "break",
                  "last",
                  "permanent",
                  "redirect",
                  "kqueue",
                  "rtsig",
                  "epoll",
                  "poll",
                  "/dev/poll",
                ],
              },
              relevance: 0,
              illegal: "=>",
              contains: [
                e.HASH_COMMENT_MODE,
                {
                  className: "string",
                  contains: [e.BACKSLASH_ESCAPE, n],
                  variants: [
                    { begin: /"/, end: /"/ },
                    { begin: /'/, end: /'/ },
                  ],
                },
                { begin: "([a-z]+):/", end: "\\s", endsWithParent: !0, excludeEnd: !0, contains: [n] },
                {
                  className: "regexp",
                  contains: [e.BACKSLASH_ESCAPE, n],
                  variants: [
                    { begin: "\\s\\^", end: "\\s|\\{|;", returnEnd: !0 },
                    { begin: "~\\*?\\s+", end: "\\s|\\{|;", returnEnd: !0 },
                    { begin: "\\*(\\.[a-z\\-]+)+" },
                    { begin: "([a-z\\-]+\\.)+\\*" },
                  ],
                },
                { className: "number", begin: "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b" },
                { className: "number", begin: "\\b\\d+[kKmMgGdshdwy]?\\b", relevance: 0 },
                n,
              ],
            }
          return {
            name: "Nginx config",
            aliases: ["nginxconf"],
            contains: [
              e.HASH_COMMENT_MODE,
              {
                beginKeywords: "upstream location",
                end: /;|\{/,
                contains: r.contains,
                keywords: { section: "upstream location" },
              },
              { className: "section", begin: t.concat(e.UNDERSCORE_IDENT_RE + t.lookahead(/\s+\{/)), relevance: 0 },
              {
                begin: t.lookahead(e.UNDERSCORE_IDENT_RE + "\\s"),
                end: ";|\\{",
                contains: [{ className: "attribute", begin: e.UNDERSCORE_IDENT_RE, starts: r }],
                relevance: 0,
              },
            ],
            illegal: "[^\\s\\}\\{]",
          }
        },
        objectivec: function (e) {
          const t = /[a-zA-Z@][a-zA-Z0-9_]*/,
            n = { $pattern: t, keyword: ["@interface", "@class", "@protocol", "@implementation"] }
          return {
            name: "Objective-C",
            aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
            keywords: {
              "variable.language": ["this", "super"],
              $pattern: t,
              keyword: [
                "while",
                "export",
                "sizeof",
                "typedef",
                "const",
                "struct",
                "for",
                "union",
                "volatile",
                "static",
                "mutable",
                "if",
                "do",
                "return",
                "goto",
                "enum",
                "else",
                "break",
                "extern",
                "asm",
                "case",
                "default",
                "register",
                "explicit",
                "typename",
                "switch",
                "continue",
                "inline",
                "readonly",
                "assign",
                "readwrite",
                "self",
                "@synchronized",
                "id",
                "typeof",
                "nonatomic",
                "IBOutlet",
                "IBAction",
                "strong",
                "weak",
                "copy",
                "in",
                "out",
                "inout",
                "bycopy",
                "byref",
                "oneway",
                "__strong",
                "__weak",
                "__block",
                "__autoreleasing",
                "@private",
                "@protected",
                "@public",
                "@try",
                "@property",
                "@end",
                "@throw",
                "@catch",
                "@finally",
                "@autoreleasepool",
                "@synthesize",
                "@dynamic",
                "@selector",
                "@optional",
                "@required",
                "@encode",
                "@package",
                "@import",
                "@defs",
                "@compatibility_alias",
                "__bridge",
                "__bridge_transfer",
                "__bridge_retained",
                "__bridge_retain",
                "__covariant",
                "__contravariant",
                "__kindof",
                "_Nonnull",
                "_Nullable",
                "_Null_unspecified",
                "__FUNCTION__",
                "__PRETTY_FUNCTION__",
                "__attribute__",
                "getter",
                "setter",
                "retain",
                "unsafe_unretained",
                "nonnull",
                "nullable",
                "null_unspecified",
                "null_resettable",
                "class",
                "instancetype",
                "NS_DESIGNATED_INITIALIZER",
                "NS_UNAVAILABLE",
                "NS_REQUIRES_SUPER",
                "NS_RETURNS_INNER_POINTER",
                "NS_INLINE",
                "NS_AVAILABLE",
                "NS_DEPRECATED",
                "NS_ENUM",
                "NS_OPTIONS",
                "NS_SWIFT_UNAVAILABLE",
                "NS_ASSUME_NONNULL_BEGIN",
                "NS_ASSUME_NONNULL_END",
                "NS_REFINED_FOR_SWIFT",
                "NS_SWIFT_NAME",
                "NS_SWIFT_NOTHROW",
                "NS_DURING",
                "NS_HANDLER",
                "NS_ENDHANDLER",
                "NS_VALUERETURN",
                "NS_VOIDRETURN",
              ],
              literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"],
              built_in: ["dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"],
              type: [
                "int",
                "float",
                "char",
                "unsigned",
                "signed",
                "short",
                "long",
                "double",
                "wchar_t",
                "unichar",
                "void",
                "bool",
                "BOOL",
                "id|0",
                "_Bool",
              ],
            },
            illegal: "</",
            contains: [
              { className: "built_in", begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+" },
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              e.C_NUMBER_MODE,
              e.QUOTE_STRING_MODE,
              e.APOS_STRING_MODE,
              {
                className: "string",
                variants: [{ begin: '@"', end: '"', illegal: "\\n", contains: [e.BACKSLASH_ESCAPE] }],
              },
              {
                className: "meta",
                begin: /#\s*[a-z]+\b/,
                end: /$/,
                keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
                contains: [
                  { begin: /\\\n/, relevance: 0 },
                  e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
                  { className: "string", begin: /<.*?>/, end: /$/, illegal: "\\n" },
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              {
                className: "class",
                begin: "(" + n.keyword.join("|") + ")\\b",
                end: /(\{|$)/,
                excludeEnd: !0,
                keywords: n,
                contains: [e.UNDERSCORE_TITLE_MODE],
              },
              { begin: "\\." + e.UNDERSCORE_IDENT_RE, relevance: 0 },
            ],
          }
        },
        ocaml: function (e) {
          return {
            name: "OCaml",
            aliases: ["ml"],
            keywords: {
              $pattern: "[a-z_]\\w*!?",
              keyword:
                "and as assert asr begin class constraint do done downto else end exception external for fun function functor if in include inherit! inherit initializer land lazy let lor lsl lsr lxor match method!|10 method mod module mutable new object of open! open or private rec sig struct then to try type val! val virtual when while with parser value",
              built_in:
                "array bool bytes char exn|5 float int int32 int64 list lazy_t|5 nativeint|5 string unit in_channel out_channel ref",
              literal: "true false",
            },
            illegal: /\/\/|>>/,
            contains: [
              { className: "literal", begin: "\\[(\\|\\|)?\\]|\\(\\)", relevance: 0 },
              e.COMMENT("\\(\\*", "\\*\\)", { contains: ["self"] }),
              { className: "symbol", begin: "'[A-Za-z_](?!')[\\w']*" },
              { className: "type", begin: "`[A-Z][\\w']*" },
              { className: "type", begin: "\\b[A-Z][\\w']*", relevance: 0 },
              { begin: "[a-z_]\\w*'[\\w']*", relevance: 0 },
              e.inherit(e.APOS_STRING_MODE, { className: "string", relevance: 0 }),
              e.inherit(e.QUOTE_STRING_MODE, { illegal: null }),
              {
                className: "number",
                begin:
                  "\\b(0[xX][a-fA-F0-9_]+[Lln]?|0[oO][0-7_]+[Lln]?|0[bB][01_]+[Lln]?|[0-9][0-9_]*([Lln]|(\\.[0-9_]*)?([eE][-+]?[0-9_]+)?)?)",
                relevance: 0,
              },
              { begin: /->/ },
            ],
          }
        },
        php: function (e) {
          const t = e.regex,
            n = /(?![A-Za-z0-9])(?![$])/,
            r = t.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, n),
            a = t.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, n),
            o = { scope: "variable", match: "\\$+" + r },
            i = { scope: "subst", variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }] },
            s = e.inherit(e.APOS_STRING_MODE, { illegal: null }),
            l = "[ \t\n]",
            c = {
              scope: "string",
              variants: [
                e.inherit(e.QUOTE_STRING_MODE, { illegal: null, contains: e.QUOTE_STRING_MODE.contains.concat(i) }),
                s,
                {
                  begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
                  end: /[ \t]*(\w+)\b/,
                  contains: e.QUOTE_STRING_MODE.contains.concat(i),
                  "on:begin": (e, t) => {
                    t.data._beginMatch = e[1] || e[2]
                  },
                  "on:end": (e, t) => {
                    t.data._beginMatch !== e[1] && t.ignoreMatch()
                  },
                },
                e.END_SAME_AS_BEGIN({ begin: /<<<[ \t]*'(\w+)'\n/, end: /[ \t]*(\w+)\b/ }),
              ],
            },
            d = {
              scope: "number",
              variants: [
                { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
                { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
                { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
                { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" },
              ],
              relevance: 0,
            },
            u = ["false", "null", "true"],
            p = [
              "__CLASS__",
              "__DIR__",
              "__FILE__",
              "__FUNCTION__",
              "__COMPILER_HALT_OFFSET__",
              "__LINE__",
              "__METHOD__",
              "__NAMESPACE__",
              "__TRAIT__",
              "die",
              "echo",
              "exit",
              "include",
              "include_once",
              "print",
              "require",
              "require_once",
              "array",
              "abstract",
              "and",
              "as",
              "binary",
              "bool",
              "boolean",
              "break",
              "callable",
              "case",
              "catch",
              "class",
              "clone",
              "const",
              "continue",
              "declare",
              "default",
              "do",
              "double",
              "else",
              "elseif",
              "empty",
              "enddeclare",
              "endfor",
              "endforeach",
              "endif",
              "endswitch",
              "endwhile",
              "enum",
              "eval",
              "extends",
              "final",
              "finally",
              "float",
              "for",
              "foreach",
              "from",
              "global",
              "goto",
              "if",
              "implements",
              "instanceof",
              "insteadof",
              "int",
              "integer",
              "interface",
              "isset",
              "iterable",
              "list",
              "match|0",
              "mixed",
              "new",
              "never",
              "object",
              "or",
              "private",
              "protected",
              "public",
              "readonly",
              "real",
              "return",
              "string",
              "switch",
              "throw",
              "trait",
              "try",
              "unset",
              "use",
              "var",
              "void",
              "while",
              "xor",
              "yield",
            ],
            h = [
              "Error|0",
              "AppendIterator",
              "ArgumentCountError",
              "ArithmeticError",
              "ArrayIterator",
              "ArrayObject",
              "AssertionError",
              "BadFunctionCallException",
              "BadMethodCallException",
              "CachingIterator",
              "CallbackFilterIterator",
              "CompileError",
              "Countable",
              "DirectoryIterator",
              "DivisionByZeroError",
              "DomainException",
              "EmptyIterator",
              "ErrorException",
              "Exception",
              "FilesystemIterator",
              "FilterIterator",
              "GlobIterator",
              "InfiniteIterator",
              "InvalidArgumentException",
              "IteratorIterator",
              "LengthException",
              "LimitIterator",
              "LogicException",
              "MultipleIterator",
              "NoRewindIterator",
              "OutOfBoundsException",
              "OutOfRangeException",
              "OuterIterator",
              "OverflowException",
              "ParentIterator",
              "ParseError",
              "RangeException",
              "RecursiveArrayIterator",
              "RecursiveCachingIterator",
              "RecursiveCallbackFilterIterator",
              "RecursiveDirectoryIterator",
              "RecursiveFilterIterator",
              "RecursiveIterator",
              "RecursiveIteratorIterator",
              "RecursiveRegexIterator",
              "RecursiveTreeIterator",
              "RegexIterator",
              "RuntimeException",
              "SeekableIterator",
              "SplDoublyLinkedList",
              "SplFileInfo",
              "SplFileObject",
              "SplFixedArray",
              "SplHeap",
              "SplMaxHeap",
              "SplMinHeap",
              "SplObjectStorage",
              "SplObserver",
              "SplPriorityQueue",
              "SplQueue",
              "SplStack",
              "SplSubject",
              "SplTempFileObject",
              "TypeError",
              "UnderflowException",
              "UnexpectedValueException",
              "UnhandledMatchError",
              "ArrayAccess",
              "BackedEnum",
              "Closure",
              "Fiber",
              "Generator",
              "Iterator",
              "IteratorAggregate",
              "Serializable",
              "Stringable",
              "Throwable",
              "Traversable",
              "UnitEnum",
              "WeakReference",
              "WeakMap",
              "Directory",
              "__PHP_Incomplete_Class",
              "parent",
              "php_user_filter",
              "self",
              "static",
              "stdClass",
            ],
            f = {
              keyword: p,
              literal: ((e) => {
                const t = []
                return (
                  e.forEach((e) => {
                    t.push(e), e.toLowerCase() === e ? t.push(e.toUpperCase()) : t.push(e.toLowerCase())
                  }),
                  t
                )
              })(u),
              built_in: h,
            },
            m = (e) => e.map((e) => e.replace(/\|\d+$/, "")),
            g = {
              variants: [
                {
                  match: [/new/, t.concat(l, "+"), t.concat("(?!", m(h).join("\\b|"), "\\b)"), a],
                  scope: { 1: "keyword", 4: "title.class" },
                },
              ],
            },
            b = t.concat(r, "\\b(?!\\()"),
            v = {
              variants: [
                { match: [t.concat(/::/, t.lookahead(/(?!class\b)/)), b], scope: { 2: "variable.constant" } },
                { match: [/::/, /class/], scope: { 2: "variable.language" } },
                {
                  match: [a, t.concat(/::/, t.lookahead(/(?!class\b)/)), b],
                  scope: { 1: "title.class", 3: "variable.constant" },
                },
                { match: [a, t.concat("::", t.lookahead(/(?!class\b)/))], scope: { 1: "title.class" } },
                { match: [a, /::/, /class/], scope: { 1: "title.class", 3: "variable.language" } },
              ],
            },
            y = { scope: "attr", match: t.concat(r, t.lookahead(":"), t.lookahead(/(?!::)/)) },
            O = {
              relevance: 0,
              begin: /\(/,
              end: /\)/,
              keywords: f,
              contains: [y, o, v, e.C_BLOCK_COMMENT_MODE, c, d, g],
            },
            w = {
              relevance: 0,
              match: [
                /\b/,
                t.concat("(?!fn\\b|function\\b|", m(p).join("\\b|"), "|", m(h).join("\\b|"), "\\b)"),
                r,
                t.concat(l, "*"),
                t.lookahead(/(?=\()/),
              ],
              scope: { 3: "title.function.invoke" },
              contains: [O],
            }
          O.contains.push(w)
          const x = [y, v, e.C_BLOCK_COMMENT_MODE, c, d, g]
          return {
            case_insensitive: !1,
            keywords: f,
            contains: [
              {
                begin: t.concat(/#\[\s*/, a),
                beginScope: "meta",
                end: /]/,
                endScope: "meta",
                keywords: { literal: u, keyword: ["new", "array"] },
                contains: [
                  {
                    begin: /\[/,
                    end: /]/,
                    keywords: { literal: u, keyword: ["new", "array"] },
                    contains: ["self", ...x],
                  },
                  ...x,
                  { scope: "meta", match: a },
                ],
              },
              e.HASH_COMMENT_MODE,
              e.COMMENT("//", "$"),
              e.COMMENT("/\\*", "\\*/", { contains: [{ scope: "doctag", match: "@[A-Za-z]+" }] }),
              {
                match: /__halt_compiler\(\);/,
                keywords: "__halt_compiler",
                starts: {
                  scope: "comment",
                  end: e.MATCH_NOTHING_RE,
                  contains: [{ match: /\?>/, scope: "meta", endsParent: !0 }],
                },
              },
              {
                scope: "meta",
                variants: [
                  { begin: /<\?php/, relevance: 10 },
                  { begin: /<\?=/ },
                  { begin: /<\?/, relevance: 0.1 },
                  { begin: /\?>/ },
                ],
              },
              { scope: "variable.language", match: /\$this\b/ },
              o,
              w,
              v,
              { match: [/const/, /\s/, r], scope: { 1: "keyword", 3: "variable.constant" } },
              g,
              {
                scope: "function",
                relevance: 0,
                beginKeywords: "fn function",
                end: /[;{]/,
                excludeEnd: !0,
                illegal: "[$%\\[]",
                contains: [
                  { beginKeywords: "use" },
                  e.UNDERSCORE_TITLE_MODE,
                  { begin: "=>", endsParent: !0 },
                  {
                    scope: "params",
                    begin: "\\(",
                    end: "\\)",
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: f,
                    contains: ["self", o, v, e.C_BLOCK_COMMENT_MODE, c, d],
                  },
                ],
              },
              {
                scope: "class",
                variants: [
                  { beginKeywords: "enum", illegal: /[($"]/ },
                  { beginKeywords: "class interface trait", illegal: /[:($"]/ },
                ],
                relevance: 0,
                end: /\{/,
                excludeEnd: !0,
                contains: [{ beginKeywords: "extends implements" }, e.UNDERSCORE_TITLE_MODE],
              },
              {
                beginKeywords: "namespace",
                relevance: 0,
                end: ";",
                illegal: /[.']/,
                contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" })],
              },
              {
                beginKeywords: "use",
                relevance: 0,
                end: ";",
                contains: [{ match: /\b(as|const|function)\b/, scope: "keyword" }, e.UNDERSCORE_TITLE_MODE],
              },
              c,
              d,
            ],
          }
        },
        plaintext: function (e) {
          return { name: "Plain text", aliases: ["text", "txt"], disableAutodetect: !0 }
        },
        powershell: function (e) {
          const t = {
              $pattern: /-?[A-z\.\-]+\b/,
              keyword:
                "if else foreach return do while until elseif begin for trap data dynamicparam end break throw param continue finally in switch exit filter try process catch hidden static parameter",
              built_in:
                "ac asnp cat cd CFS chdir clc clear clhy cli clp cls clv cnsn compare copy cp cpi cpp curl cvpa dbp del diff dir dnsn ebp echo|0 epal epcsv epsn erase etsn exsn fc fhx fl ft fw gal gbp gc gcb gci gcm gcs gdr gerr ghy gi gin gjb gl gm gmo gp gps gpv group gsn gsnp gsv gtz gu gv gwmi h history icm iex ihy ii ipal ipcsv ipmo ipsn irm ise iwmi iwr kill lp ls man md measure mi mount move mp mv nal ndr ni nmo npssc nsn nv ogv oh popd ps pushd pwd r rbp rcjb rcsn rd rdr ren ri rjb rm rmdir rmo rni rnp rp rsn rsnp rujb rv rvpa rwmi sajb sal saps sasv sbp sc scb select set shcm si sl sleep sls sort sp spjb spps spsv start stz sujb sv swmi tee trcm type wget where wjb write",
            },
            n = { begin: "`[\\s\\S]", relevance: 0 },
            r = {
              className: "variable",
              variants: [{ begin: /\$\B/ }, { className: "keyword", begin: /\$this/ }, { begin: /\$[\w\d][\w\d_:]*/ }],
            },
            a = {
              className: "string",
              variants: [
                { begin: /"/, end: /"/ },
                { begin: /@"/, end: /^"@/ },
              ],
              contains: [n, r, { className: "variable", begin: /\$[A-z]/, end: /[^A-z]/ }],
            },
            o = {
              className: "string",
              variants: [
                { begin: /'/, end: /'/ },
                { begin: /@'/, end: /^'@/ },
              ],
            },
            i = e.inherit(e.COMMENT(null, null), {
              variants: [
                { begin: /#/, end: /$/ },
                { begin: /<#/, end: /#>/ },
              ],
              contains: [
                {
                  className: "doctag",
                  variants: [
                    {
                      begin: /\.(synopsis|description|example|inputs|outputs|notes|link|component|role|functionality)/,
                    },
                    {
                      begin:
                        /\.(parameter|forwardhelptargetname|forwardhelpcategory|remotehelprunspace|externalhelp)\s+\S+/,
                    },
                  ],
                },
              ],
            }),
            s = {
              className: "built_in",
              variants: [
                {
                  begin: "(".concat(
                    "Add|Clear|Close|Copy|Enter|Exit|Find|Format|Get|Hide|Join|Lock|Move|New|Open|Optimize|Pop|Push|Redo|Remove|Rename|Reset|Resize|Search|Select|Set|Show|Skip|Split|Step|Switch|Undo|Unlock|Watch|Backup|Checkpoint|Compare|Compress|Convert|ConvertFrom|ConvertTo|Dismount|Edit|Expand|Export|Group|Import|Initialize|Limit|Merge|Mount|Out|Publish|Restore|Save|Sync|Unpublish|Update|Approve|Assert|Build|Complete|Confirm|Deny|Deploy|Disable|Enable|Install|Invoke|Register|Request|Restart|Resume|Start|Stop|Submit|Suspend|Uninstall|Unregister|Wait|Debug|Measure|Ping|Repair|Resolve|Test|Trace|Connect|Disconnect|Read|Receive|Send|Write|Block|Grant|Protect|Revoke|Unblock|Unprotect|Use|ForEach|Sort|Tee|Where",
                    ")+(-)[\\w\\d]+",
                  ),
                },
              ],
            },
            l = {
              className: "class",
              beginKeywords: "class enum",
              end: /\s*[{]/,
              excludeEnd: !0,
              relevance: 0,
              contains: [e.TITLE_MODE],
            },
            c = {
              className: "function",
              begin: /function\s+/,
              end: /\s*\{|$/,
              excludeEnd: !0,
              returnBegin: !0,
              relevance: 0,
              contains: [
                { begin: "function", relevance: 0, className: "keyword" },
                { className: "title", begin: /\w[\w\d]*((-)[\w\d]+)*/, relevance: 0 },
                { begin: /\(/, end: /\)/, className: "params", relevance: 0, contains: [r] },
              ],
            },
            d = {
              begin: /using\s/,
              end: /$/,
              returnBegin: !0,
              contains: [a, o, { className: "keyword", begin: /(using|assembly|command|module|namespace|type)/ }],
            },
            u = {
              variants: [
                {
                  className: "operator",
                  begin: "(".concat(
                    "-and|-as|-band|-bnot|-bor|-bxor|-casesensitive|-ccontains|-ceq|-cge|-cgt|-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|-creplace|-csplit|-eq|-exact|-f|-file|-ge|-gt|-icontains|-ieq|-ige|-igt|-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-not|-notcontains|-notin|-notlike|-notmatch|-or|-regex|-replace|-shl|-shr|-split|-wildcard|-xor",
                    ")\\b",
                  ),
                },
                { className: "literal", begin: /(-){1,2}[\w\d-]+/, relevance: 0 },
              ],
            },
            p = {
              className: "function",
              begin: /\[.*\]\s*[\w]+[ ]??\(/,
              end: /$/,
              returnBegin: !0,
              relevance: 0,
              contains: [
                {
                  className: "keyword",
                  begin: "(".concat(t.keyword.toString().replace(/\s/g, "|"), ")\\b"),
                  endsParent: !0,
                  relevance: 0,
                },
                e.inherit(e.TITLE_MODE, { endsParent: !0 }),
              ],
            },
            h = [
              p,
              i,
              n,
              e.NUMBER_MODE,
              a,
              o,
              s,
              r,
              { className: "literal", begin: /\$(null|true|false)\b/ },
              { className: "selector-tag", begin: /@\B/, relevance: 0 },
            ],
            f = {
              begin: /\[/,
              end: /\]/,
              excludeBegin: !0,
              excludeEnd: !0,
              relevance: 0,
              contains: [].concat(
                "self",
                h,
                {
                  begin:
                    "(" +
                    [
                      "string",
                      "char",
                      "byte",
                      "int",
                      "long",
                      "bool",
                      "decimal",
                      "single",
                      "double",
                      "DateTime",
                      "xml",
                      "array",
                      "hashtable",
                      "void",
                    ].join("|") +
                    ")",
                  className: "built_in",
                  relevance: 0,
                },
                { className: "type", begin: /[\.\w\d]+/, relevance: 0 },
              ),
            }
          return (
            p.contains.unshift(f),
            {
              name: "PowerShell",
              aliases: ["pwsh", "ps", "ps1"],
              case_insensitive: !0,
              keywords: t,
              contains: h.concat(l, c, d, u, f),
            }
          )
        },
        python: function (e) {
          const t = e.regex,
            n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"),
            r = [
              "and",
              "as",
              "assert",
              "async",
              "await",
              "break",
              "case",
              "class",
              "continue",
              "def",
              "del",
              "elif",
              "else",
              "except",
              "finally",
              "for",
              "from",
              "global",
              "if",
              "import",
              "in",
              "is",
              "lambda",
              "match",
              "nonlocal|10",
              "not",
              "or",
              "pass",
              "raise",
              "return",
              "try",
              "while",
              "with",
              "yield",
            ],
            a = {
              $pattern: /[A-Za-z]\w+|__\w+__/,
              keyword: r,
              built_in: [
                "__import__",
                "abs",
                "all",
                "any",
                "ascii",
                "bin",
                "bool",
                "breakpoint",
                "bytearray",
                "bytes",
                "callable",
                "chr",
                "classmethod",
                "compile",
                "complex",
                "delattr",
                "dict",
                "dir",
                "divmod",
                "enumerate",
                "eval",
                "exec",
                "filter",
                "float",
                "format",
                "frozenset",
                "getattr",
                "globals",
                "hasattr",
                "hash",
                "help",
                "hex",
                "id",
                "input",
                "int",
                "isinstance",
                "issubclass",
                "iter",
                "len",
                "list",
                "locals",
                "map",
                "max",
                "memoryview",
                "min",
                "next",
                "object",
                "oct",
                "open",
                "ord",
                "pow",
                "print",
                "property",
                "range",
                "repr",
                "reversed",
                "round",
                "set",
                "setattr",
                "slice",
                "sorted",
                "staticmethod",
                "str",
                "sum",
                "super",
                "tuple",
                "type",
                "vars",
                "zip",
              ],
              literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"],
              type: [
                "Any",
                "Callable",
                "Coroutine",
                "Dict",
                "List",
                "Literal",
                "Generic",
                "Optional",
                "Sequence",
                "Set",
                "Tuple",
                "Type",
                "Union",
              ],
            },
            o = { className: "meta", begin: /^(>>>|\.\.\.) / },
            i = { className: "subst", begin: /\{/, end: /\}/, keywords: a, illegal: /#/ },
            s = { begin: /\{\{/, relevance: 0 },
            l = {
              className: "string",
              contains: [e.BACKSLASH_ESCAPE],
              variants: [
                {
                  begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
                  end: /'''/,
                  contains: [e.BACKSLASH_ESCAPE, o],
                  relevance: 10,
                },
                {
                  begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
                  end: /"""/,
                  contains: [e.BACKSLASH_ESCAPE, o],
                  relevance: 10,
                },
                { begin: /([fF][rR]|[rR][fF]|[fF])'''/, end: /'''/, contains: [e.BACKSLASH_ESCAPE, o, s, i] },
                { begin: /([fF][rR]|[rR][fF]|[fF])"""/, end: /"""/, contains: [e.BACKSLASH_ESCAPE, o, s, i] },
                { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
                { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
                { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
                { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
                { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [e.BACKSLASH_ESCAPE, s, i] },
                { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, s, i] },
                e.APOS_STRING_MODE,
                e.QUOTE_STRING_MODE,
              ],
            },
            c = "[0-9](_?[0-9])*",
            d = `(\\b(${c}))?\\.(${c})|\\b(${c})\\.`,
            u = `\\b|${r.join("|")}`,
            p = {
              className: "number",
              relevance: 0,
              variants: [
                { begin: `(\\b(${c})|(${d}))[eE][+-]?(${c})[jJ]?(?=${u})` },
                { begin: `(${d})[jJ]?` },
                { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${u})` },
                { begin: `\\b0[bB](_?[01])+[lL]?(?=${u})` },
                { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${u})` },
                { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${u})` },
                { begin: `\\b(${c})[jJ](?=${u})` },
              ],
            },
            h = {
              className: "comment",
              begin: t.lookahead(/# type:/),
              end: /$/,
              keywords: a,
              contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: !0 }],
            },
            f = {
              className: "params",
              variants: [
                { className: "", begin: /\(\s*\)/, skip: !0 },
                {
                  begin: /\(/,
                  end: /\)/,
                  excludeBegin: !0,
                  excludeEnd: !0,
                  keywords: a,
                  contains: ["self", o, p, l, e.HASH_COMMENT_MODE],
                },
              ],
            }
          return (
            (i.contains = [l, p, o]),
            {
              name: "Python",
              aliases: ["py", "gyp", "ipython"],
              unicodeRegex: !0,
              keywords: a,
              illegal: /(<\/|\?)|=>/,
              contains: [
                o,
                p,
                { begin: /\bself\b/ },
                { beginKeywords: "if", relevance: 0 },
                l,
                h,
                e.HASH_COMMENT_MODE,
                { match: [/\bdef/, /\s+/, n], scope: { 1: "keyword", 3: "title.function" }, contains: [f] },
                {
                  variants: [
                    { match: [/\bclass/, /\s+/, n, /\s*/, /\(\s*/, n, /\s*\)/] },
                    { match: [/\bclass/, /\s+/, n] },
                  ],
                  scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" },
                },
                { className: "meta", begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [p, f, l] },
              ],
            }
          )
        },
        r: function (e) {
          const t = e.regex,
            n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/,
            r = t.either(
              /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
              /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
              /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/,
            ),
            a = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/,
            o = t.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/)
          return {
            name: "R",
            keywords: {
              $pattern: n,
              keyword: "function if in break next repeat else for while",
              literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
              built_in:
                "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm",
            },
            contains: [
              e.COMMENT(/#'/, /$/, {
                contains: [
                  {
                    scope: "doctag",
                    match: /@examples/,
                    starts: { end: t.lookahead(t.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)), endsParent: !0 },
                  },
                  {
                    scope: "doctag",
                    begin: "@param",
                    end: /$/,
                    contains: [
                      { scope: "variable", variants: [{ match: n }, { match: /`(?:\\.|[^`\\])+`/ }], endsParent: !0 },
                    ],
                  },
                  { scope: "doctag", match: /@[a-zA-Z]+/ },
                  { scope: "keyword", match: /\\[a-zA-Z]+/ },
                ],
              }),
              e.HASH_COMMENT_MODE,
              {
                scope: "string",
                contains: [e.BACKSLASH_ESCAPE],
                variants: [
                  e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }),
                  { begin: '"', end: '"', relevance: 0 },
                  { begin: "'", end: "'", relevance: 0 },
                ],
              },
              {
                relevance: 0,
                variants: [
                  { scope: { 1: "operator", 2: "number" }, match: [a, r] },
                  { scope: { 1: "operator", 2: "number" }, match: [/%[^%]*%/, r] },
                  { scope: { 1: "punctuation", 2: "number" }, match: [o, r] },
                  { scope: { 2: "number" }, match: [/[^a-zA-Z0-9._]|^/, r] },
                ],
              },
              { scope: { 3: "operator" }, match: [n, /\s+/, /<-/, /\s+/] },
              { scope: "operator", relevance: 0, variants: [{ match: a }, { match: /%[^%]*%/ }] },
              { scope: "punctuation", relevance: 0, match: o },
              { begin: "`", end: "`", contains: [{ begin: /\\./ }] },
            ],
          }
        },
        ruby: function (e) {
          const t = e.regex,
            n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)",
            r = t.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/),
            a = t.concat(r, /(::\w+)*/),
            o = {
              "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"],
              "variable.language": ["self", "super"],
              keyword: [
                "alias",
                "and",
                "begin",
                "BEGIN",
                "break",
                "case",
                "class",
                "defined",
                "do",
                "else",
                "elsif",
                "end",
                "END",
                "ensure",
                "for",
                "if",
                "in",
                "module",
                "next",
                "not",
                "or",
                "redo",
                "require",
                "rescue",
                "retry",
                "return",
                "then",
                "undef",
                "unless",
                "until",
                "when",
                "while",
                "yield",
                "include",
                "extend",
                "prepend",
                "public",
                "private",
                "protected",
                "raise",
                "throw",
              ],
              built_in: [
                "proc",
                "lambda",
                "attr_accessor",
                "attr_reader",
                "attr_writer",
                "define_method",
                "private_constant",
                "module_function",
              ],
              literal: ["true", "false", "nil"],
            },
            i = { className: "doctag", begin: "@[A-Za-z]+" },
            s = { begin: "#<", end: ">" },
            l = [
              e.COMMENT("#", "$", { contains: [i] }),
              e.COMMENT("^=begin", "^=end", { contains: [i], relevance: 10 }),
              e.COMMENT("^__END__", e.MATCH_NOTHING_RE),
            ],
            c = { className: "subst", begin: /#\{/, end: /\}/, keywords: o },
            d = {
              className: "string",
              contains: [e.BACKSLASH_ESCAPE, c],
              variants: [
                { begin: /'/, end: /'/ },
                { begin: /"/, end: /"/ },
                { begin: /`/, end: /`/ },
                { begin: /%[qQwWx]?\(/, end: /\)/ },
                { begin: /%[qQwWx]?\[/, end: /\]/ },
                { begin: /%[qQwWx]?\{/, end: /\}/ },
                { begin: /%[qQwWx]?</, end: />/ },
                { begin: /%[qQwWx]?\//, end: /\// },
                { begin: /%[qQwWx]?%/, end: /%/ },
                { begin: /%[qQwWx]?-/, end: /-/ },
                { begin: /%[qQwWx]?\|/, end: /\|/ },
                { begin: /\B\?(\\\d{1,3})/ },
                { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
                { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
                { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
                { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
                { begin: /\B\?\\?\S/ },
                {
                  begin: t.concat(/<<[-~]?'?/, t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
                  contains: [e.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, contains: [e.BACKSLASH_ESCAPE, c] })],
                },
              ],
            },
            u = "[0-9](_?[0-9])*",
            p = {
              className: "number",
              relevance: 0,
              variants: [
                { begin: `\\b([1-9](_?[0-9])*|0)(\\.(${u}))?([eE][+-]?(${u})|r)?i?\\b` },
                { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
                { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
                { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
                { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
                { begin: "\\b0(_?[0-7])+r?i?\\b" },
              ],
            },
            h = {
              variants: [
                { match: /\(\)/ },
                { className: "params", begin: /\(/, end: /(?=\))/, excludeBegin: !0, endsParent: !0, keywords: o },
              ],
            },
            f = [
              d,
              {
                variants: [{ match: [/class\s+/, a, /\s+<\s+/, a] }, { match: [/\b(class|module)\s+/, a] }],
                scope: { 2: "title.class", 4: "title.class.inherited" },
                keywords: o,
              },
              { match: [/(include|extend)\s+/, a], scope: { 2: "title.class" }, keywords: o },
              { relevance: 0, match: [a, /\.new[. (]/], scope: { 1: "title.class" } },
              { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" },
              { relevance: 0, match: r, scope: "title.class" },
              { match: [/def/, /\s+/, n], scope: { 1: "keyword", 3: "title.function" }, contains: [h] },
              { begin: e.IDENT_RE + "::" },
              { className: "symbol", begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:", relevance: 0 },
              { className: "symbol", begin: ":(?!\\s)", contains: [d, { begin: n }], relevance: 0 },
              p,
              { className: "variable", begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])" },
              {
                className: "params",
                begin: /\|/,
                end: /\|/,
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
                keywords: o,
              },
              {
                begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
                keywords: "unless",
                contains: [
                  {
                    className: "regexp",
                    contains: [e.BACKSLASH_ESCAPE, c],
                    illegal: /\n/,
                    variants: [
                      { begin: "/", end: "/[a-z]*" },
                      { begin: /%r\{/, end: /\}[a-z]*/ },
                      { begin: "%r\\(", end: "\\)[a-z]*" },
                      { begin: "%r!", end: "![a-z]*" },
                      { begin: "%r\\[", end: "\\][a-z]*" },
                    ],
                  },
                ].concat(s, l),
                relevance: 0,
              },
            ].concat(s, l)
          ;(c.contains = f), (h.contains = f)
          const m = [
            { begin: /^\s*=>/, starts: { end: "$", contains: f } },
            {
              className: "meta.prompt",
              begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
              starts: { end: "$", keywords: o, contains: f },
            },
          ]
          return (
            l.unshift(s),
            {
              name: "Ruby",
              aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
              keywords: o,
              illegal: /\/\*/,
              contains: [e.SHEBANG({ binary: "ruby" })].concat(m).concat(l).concat(f),
            }
          )
        },
        rust: function (e) {
          const t = e.regex,
            n = {
              className: "title.function.invoke",
              relevance: 0,
              begin: t.concat(/\b/, /(?!let|for|while|if|else|match\b)/, e.IDENT_RE, t.lookahead(/\s*\(/)),
            },
            r = "([ui](8|16|32|64|128|size)|f(32|64))?",
            a = [
              "drop ",
              "Copy",
              "Send",
              "Sized",
              "Sync",
              "Drop",
              "Fn",
              "FnMut",
              "FnOnce",
              "ToOwned",
              "Clone",
              "Debug",
              "PartialEq",
              "PartialOrd",
              "Eq",
              "Ord",
              "AsRef",
              "AsMut",
              "Into",
              "From",
              "Default",
              "Iterator",
              "Extend",
              "IntoIterator",
              "DoubleEndedIterator",
              "ExactSizeIterator",
              "SliceConcatExt",
              "ToString",
              "assert!",
              "assert_eq!",
              "bitflags!",
              "bytes!",
              "cfg!",
              "col!",
              "concat!",
              "concat_idents!",
              "debug_assert!",
              "debug_assert_eq!",
              "env!",
              "eprintln!",
              "panic!",
              "file!",
              "format!",
              "format_args!",
              "include_bytes!",
              "include_str!",
              "line!",
              "local_data_key!",
              "module_path!",
              "option_env!",
              "print!",
              "println!",
              "select!",
              "stringify!",
              "try!",
              "unimplemented!",
              "unreachable!",
              "vec!",
              "write!",
              "writeln!",
              "macro_rules!",
              "assert_ne!",
              "debug_assert_ne!",
            ],
            o = [
              "i8",
              "i16",
              "i32",
              "i64",
              "i128",
              "isize",
              "u8",
              "u16",
              "u32",
              "u64",
              "u128",
              "usize",
              "f32",
              "f64",
              "str",
              "char",
              "bool",
              "Box",
              "Option",
              "Result",
              "String",
              "Vec",
            ]
          return {
            name: "Rust",
            aliases: ["rs"],
            keywords: {
              $pattern: e.IDENT_RE + "!?",
              type: o,
              keyword: [
                "abstract",
                "as",
                "async",
                "await",
                "become",
                "box",
                "break",
                "const",
                "continue",
                "crate",
                "do",
                "dyn",
                "else",
                "enum",
                "extern",
                "false",
                "final",
                "fn",
                "for",
                "if",
                "impl",
                "in",
                "let",
                "loop",
                "macro",
                "match",
                "mod",
                "move",
                "mut",
                "override",
                "priv",
                "pub",
                "ref",
                "return",
                "self",
                "Self",
                "static",
                "struct",
                "super",
                "trait",
                "true",
                "try",
                "type",
                "typeof",
                "unsafe",
                "unsized",
                "use",
                "virtual",
                "where",
                "while",
                "yield",
              ],
              literal: ["true", "false", "Some", "None", "Ok", "Err"],
              built_in: a,
            },
            illegal: "</",
            contains: [
              e.C_LINE_COMMENT_MODE,
              e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
              e.inherit(e.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
              {
                className: "string",
                variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }],
              },
              { className: "symbol", begin: /'[a-zA-Z_][a-zA-Z0-9_]*/ },
              {
                className: "number",
                variants: [
                  { begin: "\\b0b([01_]+)" + r },
                  { begin: "\\b0o([0-7_]+)" + r },
                  { begin: "\\b0x([A-Fa-f0-9_]+)" + r },
                  { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + r },
                ],
                relevance: 0,
              },
              { begin: [/fn/, /\s+/, e.UNDERSCORE_IDENT_RE], className: { 1: "keyword", 3: "title.function" } },
              {
                className: "meta",
                begin: "#!?\\[",
                end: "\\]",
                contains: [{ className: "string", begin: /"/, end: /"/ }],
              },
              {
                begin: [/let/, /\s+/, /(?:mut\s+)?/, e.UNDERSCORE_IDENT_RE],
                className: { 1: "keyword", 3: "keyword", 4: "variable" },
              },
              {
                begin: [/for/, /\s+/, e.UNDERSCORE_IDENT_RE, /\s+/, /in/],
                className: { 1: "keyword", 3: "variable", 5: "keyword" },
              },
              { begin: [/type/, /\s+/, e.UNDERSCORE_IDENT_RE], className: { 1: "keyword", 3: "title.class" } },
              {
                begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, e.UNDERSCORE_IDENT_RE],
                className: { 1: "keyword", 3: "title.class" },
              },
              { begin: e.IDENT_RE + "::", keywords: { keyword: "Self", built_in: a, type: o } },
              { className: "punctuation", begin: "->" },
              n,
            ],
          }
        },
        scss: function (e) {
          const t = ((e) => ({
              IMPORTANT: { scope: "meta", begin: "!important" },
              BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
              HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
              FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
              ATTRIBUTE_SELECTOR_MODE: {
                scope: "selector-attr",
                begin: /\[/,
                end: /\]/,
                illegal: "$",
                contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
              },
              CSS_NUMBER_MODE: {
                scope: "number",
                begin:
                  e.NUMBER_RE +
                  "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
                relevance: 0,
              },
              CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
            }))(e),
            n = gx,
            r = mx,
            a = "@[a-z-]+",
            o = { className: "variable", begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b", relevance: 0 }
          return {
            name: "SCSS",
            case_insensitive: !0,
            illegal: "[=/|']",
            contains: [
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              t.CSS_NUMBER_MODE,
              { className: "selector-id", begin: "#[A-Za-z0-9_-]+", relevance: 0 },
              { className: "selector-class", begin: "\\.[A-Za-z0-9_-]+", relevance: 0 },
              t.ATTRIBUTE_SELECTOR_MODE,
              { className: "selector-tag", begin: "\\b(" + hx.join("|") + ")\\b", relevance: 0 },
              { className: "selector-pseudo", begin: ":(" + r.join("|") + ")" },
              { className: "selector-pseudo", begin: ":(:)?(" + n.join("|") + ")" },
              o,
              { begin: /\(/, end: /\)/, contains: [t.CSS_NUMBER_MODE] },
              t.CSS_VARIABLE,
              { className: "attribute", begin: "\\b(" + bx.join("|") + ")\\b" },
              {
                begin:
                  "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b",
              },
              {
                begin: /:/,
                end: /[;}{]/,
                relevance: 0,
                contains: [
                  t.BLOCK_COMMENT,
                  o,
                  t.HEXCOLOR,
                  t.CSS_NUMBER_MODE,
                  e.QUOTE_STRING_MODE,
                  e.APOS_STRING_MODE,
                  t.IMPORTANT,
                  t.FUNCTION_DISPATCH,
                ],
              },
              { begin: "@(page|font-face)", keywords: { $pattern: a, keyword: "@page @font-face" } },
              {
                begin: "@",
                end: "[{;]",
                returnBegin: !0,
                keywords: { $pattern: /[a-z-]+/, keyword: "and or not only", attribute: fx.join(" ") },
                contains: [
                  { begin: a, className: "keyword" },
                  { begin: /[a-z-]+(?=:)/, className: "attribute" },
                  o,
                  e.QUOTE_STRING_MODE,
                  e.APOS_STRING_MODE,
                  t.HEXCOLOR,
                  t.CSS_NUMBER_MODE,
                ],
              },
              t.FUNCTION_DISPATCH,
            ],
          }
        },
        shell: function (e) {
          return {
            name: "Shell Session",
            aliases: ["console", "shellsession"],
            contains: [
              {
                className: "meta.prompt",
                begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
                starts: { end: /[^\\](?=\s*$)/, subLanguage: "bash" },
              },
            ],
          }
        },
        sql: function (e) {
          const t = e.regex,
            n = e.COMMENT("--", "$"),
            r = ["true", "false", "unknown"],
            a = [
              "bigint",
              "binary",
              "blob",
              "boolean",
              "char",
              "character",
              "clob",
              "date",
              "dec",
              "decfloat",
              "decimal",
              "float",
              "int",
              "integer",
              "interval",
              "nchar",
              "nclob",
              "national",
              "numeric",
              "real",
              "row",
              "smallint",
              "time",
              "timestamp",
              "varchar",
              "varying",
              "varbinary",
            ],
            o = [
              "abs",
              "acos",
              "array_agg",
              "asin",
              "atan",
              "avg",
              "cast",
              "ceil",
              "ceiling",
              "coalesce",
              "corr",
              "cos",
              "cosh",
              "count",
              "covar_pop",
              "covar_samp",
              "cume_dist",
              "dense_rank",
              "deref",
              "element",
              "exp",
              "extract",
              "first_value",
              "floor",
              "json_array",
              "json_arrayagg",
              "json_exists",
              "json_object",
              "json_objectagg",
              "json_query",
              "json_table",
              "json_table_primitive",
              "json_value",
              "lag",
              "last_value",
              "lead",
              "listagg",
              "ln",
              "log",
              "log10",
              "lower",
              "max",
              "min",
              "mod",
              "nth_value",
              "ntile",
              "nullif",
              "percent_rank",
              "percentile_cont",
              "percentile_disc",
              "position",
              "position_regex",
              "power",
              "rank",
              "regr_avgx",
              "regr_avgy",
              "regr_count",
              "regr_intercept",
              "regr_r2",
              "regr_slope",
              "regr_sxx",
              "regr_sxy",
              "regr_syy",
              "row_number",
              "sin",
              "sinh",
              "sqrt",
              "stddev_pop",
              "stddev_samp",
              "substring",
              "substring_regex",
              "sum",
              "tan",
              "tanh",
              "translate",
              "translate_regex",
              "treat",
              "trim",
              "trim_array",
              "unnest",
              "upper",
              "value_of",
              "var_pop",
              "var_samp",
              "width_bucket",
            ],
            i = [
              "create table",
              "insert into",
              "primary key",
              "foreign key",
              "not null",
              "alter table",
              "add constraint",
              "grouping sets",
              "on overflow",
              "character set",
              "respect nulls",
              "ignore nulls",
              "nulls first",
              "nulls last",
              "depth first",
              "breadth first",
            ],
            s = o,
            l = [
              "abs",
              "acos",
              "all",
              "allocate",
              "alter",
              "and",
              "any",
              "are",
              "array",
              "array_agg",
              "array_max_cardinality",
              "as",
              "asensitive",
              "asin",
              "asymmetric",
              "at",
              "atan",
              "atomic",
              "authorization",
              "avg",
              "begin",
              "begin_frame",
              "begin_partition",
              "between",
              "bigint",
              "binary",
              "blob",
              "boolean",
              "both",
              "by",
              "call",
              "called",
              "cardinality",
              "cascaded",
              "case",
              "cast",
              "ceil",
              "ceiling",
              "char",
              "char_length",
              "character",
              "character_length",
              "check",
              "classifier",
              "clob",
              "close",
              "coalesce",
              "collate",
              "collect",
              "column",
              "commit",
              "condition",
              "connect",
              "constraint",
              "contains",
              "convert",
              "copy",
              "corr",
              "corresponding",
              "cos",
              "cosh",
              "count",
              "covar_pop",
              "covar_samp",
              "create",
              "cross",
              "cube",
              "cume_dist",
              "current",
              "current_catalog",
              "current_date",
              "current_default_transform_group",
              "current_path",
              "current_role",
              "current_row",
              "current_schema",
              "current_time",
              "current_timestamp",
              "current_path",
              "current_role",
              "current_transform_group_for_type",
              "current_user",
              "cursor",
              "cycle",
              "date",
              "day",
              "deallocate",
              "dec",
              "decimal",
              "decfloat",
              "declare",
              "default",
              "define",
              "delete",
              "dense_rank",
              "deref",
              "describe",
              "deterministic",
              "disconnect",
              "distinct",
              "double",
              "drop",
              "dynamic",
              "each",
              "element",
              "else",
              "empty",
              "end",
              "end_frame",
              "end_partition",
              "end-exec",
              "equals",
              "escape",
              "every",
              "except",
              "exec",
              "execute",
              "exists",
              "exp",
              "external",
              "extract",
              "false",
              "fetch",
              "filter",
              "first_value",
              "float",
              "floor",
              "for",
              "foreign",
              "frame_row",
              "free",
              "from",
              "full",
              "function",
              "fusion",
              "get",
              "global",
              "grant",
              "group",
              "grouping",
              "groups",
              "having",
              "hold",
              "hour",
              "identity",
              "in",
              "indicator",
              "initial",
              "inner",
              "inout",
              "insensitive",
              "insert",
              "int",
              "integer",
              "intersect",
              "intersection",
              "interval",
              "into",
              "is",
              "join",
              "json_array",
              "json_arrayagg",
              "json_exists",
              "json_object",
              "json_objectagg",
              "json_query",
              "json_table",
              "json_table_primitive",
              "json_value",
              "lag",
              "language",
              "large",
              "last_value",
              "lateral",
              "lead",
              "leading",
              "left",
              "like",
              "like_regex",
              "listagg",
              "ln",
              "local",
              "localtime",
              "localtimestamp",
              "log",
              "log10",
              "lower",
              "match",
              "match_number",
              "match_recognize",
              "matches",
              "max",
              "member",
              "merge",
              "method",
              "min",
              "minute",
              "mod",
              "modifies",
              "module",
              "month",
              "multiset",
              "national",
              "natural",
              "nchar",
              "nclob",
              "new",
              "no",
              "none",
              "normalize",
              "not",
              "nth_value",
              "ntile",
              "null",
              "nullif",
              "numeric",
              "octet_length",
              "occurrences_regex",
              "of",
              "offset",
              "old",
              "omit",
              "on",
              "one",
              "only",
              "open",
              "or",
              "order",
              "out",
              "outer",
              "over",
              "overlaps",
              "overlay",
              "parameter",
              "partition",
              "pattern",
              "per",
              "percent",
              "percent_rank",
              "percentile_cont",
              "percentile_disc",
              "period",
              "portion",
              "position",
              "position_regex",
              "power",
              "precedes",
              "precision",
              "prepare",
              "primary",
              "procedure",
              "ptf",
              "range",
              "rank",
              "reads",
              "real",
              "recursive",
              "ref",
              "references",
              "referencing",
              "regr_avgx",
              "regr_avgy",
              "regr_count",
              "regr_intercept",
              "regr_r2",
              "regr_slope",
              "regr_sxx",
              "regr_sxy",
              "regr_syy",
              "release",
              "result",
              "return",
              "returns",
              "revoke",
              "right",
              "rollback",
              "rollup",
              "row",
              "row_number",
              "rows",
              "running",
              "savepoint",
              "scope",
              "scroll",
              "search",
              "second",
              "seek",
              "select",
              "sensitive",
              "session_user",
              "set",
              "show",
              "similar",
              "sin",
              "sinh",
              "skip",
              "smallint",
              "some",
              "specific",
              "specifictype",
              "sql",
              "sqlexception",
              "sqlstate",
              "sqlwarning",
              "sqrt",
              "start",
              "static",
              "stddev_pop",
              "stddev_samp",
              "submultiset",
              "subset",
              "substring",
              "substring_regex",
              "succeeds",
              "sum",
              "symmetric",
              "system",
              "system_time",
              "system_user",
              "table",
              "tablesample",
              "tan",
              "tanh",
              "then",
              "time",
              "timestamp",
              "timezone_hour",
              "timezone_minute",
              "to",
              "trailing",
              "translate",
              "translate_regex",
              "translation",
              "treat",
              "trigger",
              "trim",
              "trim_array",
              "true",
              "truncate",
              "uescape",
              "union",
              "unique",
              "unknown",
              "unnest",
              "update",
              "upper",
              "user",
              "using",
              "value",
              "values",
              "value_of",
              "var_pop",
              "var_samp",
              "varbinary",
              "varchar",
              "varying",
              "versioning",
              "when",
              "whenever",
              "where",
              "width_bucket",
              "window",
              "with",
              "within",
              "without",
              "year",
              "add",
              "asc",
              "collation",
              "desc",
              "final",
              "first",
              "last",
              "view",
            ].filter((e) => !o.includes(e)),
            c = { begin: t.concat(/\b/, t.either(...s), /\s*\(/), relevance: 0, keywords: { built_in: s } }
          return {
            name: "SQL",
            case_insensitive: !0,
            illegal: /[{}]|<\//,
            keywords: {
              $pattern: /\b[\w\.]+/,
              keyword: (function (e, { exceptions: t, when: n } = {}) {
                const r = n
                return (t = t || []), e.map((e) => (e.match(/\|\d+$/) || t.includes(e) ? e : r(e) ? `${e}|0` : e))
              })(l, { when: (e) => e.length < 3 }),
              literal: r,
              type: a,
              built_in: [
                "current_catalog",
                "current_date",
                "current_default_transform_group",
                "current_path",
                "current_role",
                "current_schema",
                "current_transform_group_for_type",
                "current_user",
                "session_user",
                "system_time",
                "system_user",
                "current_time",
                "localtime",
                "current_timestamp",
                "localtimestamp",
              ],
            },
            contains: [
              {
                begin: t.either(...i),
                relevance: 0,
                keywords: { $pattern: /[\w\.]+/, keyword: l.concat(i), literal: r, type: a },
              },
              {
                className: "type",
                begin: t.either("double precision", "large object", "with timezone", "without timezone"),
              },
              c,
              { className: "variable", begin: /@[a-z0-9][a-z0-9_]*/ },
              { className: "string", variants: [{ begin: /'/, end: /'/, contains: [{ begin: /''/ }] }] },
              { begin: /"/, end: /"/, contains: [{ begin: /""/ }] },
              e.C_NUMBER_MODE,
              e.C_BLOCK_COMMENT_MODE,
              n,
              { className: "operator", begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/, relevance: 0 },
            ],
          }
        },
        swift: function (e) {
          const t = { match: /\s+/, relevance: 0 },
            n = e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
            r = [e.C_LINE_COMMENT_MODE, n],
            a = { match: [/\./, wx(...kx, ..._x)], className: { 2: "keyword" } },
            o = { match: Ox(/\./, wx(...Ex)), relevance: 0 },
            i = Ex.filter((e) => "string" == typeof e).concat(["_|0"]),
            s = {
              variants: [
                {
                  className: "keyword",
                  match: wx(
                    ...Ex.filter((e) => "string" != typeof e)
                      .concat(Sx)
                      .map(xx),
                    ..._x,
                  ),
                },
              ],
            },
            l = { $pattern: wx(/\b\w+/, /#\w+/), keyword: i.concat(Cx), literal: Tx },
            c = [a, o, s],
            d = [
              { match: Ox(/\./, wx(...Px)), relevance: 0 },
              { className: "built_in", match: Ox(/\b/, wx(...Px), /(?=\()/) },
            ],
            u = { match: /->/, relevance: 0 },
            p = [u, { className: "operator", relevance: 0, variants: [{ match: Nx }, { match: `\\.(\\.|${Rx})+` }] }],
            h = "([0-9]_*)+",
            f = "([0-9a-fA-F]_*)+",
            m = {
              className: "number",
              relevance: 0,
              variants: [
                { match: `\\b(${h})(\\.(${h}))?([eE][+-]?(${h}))?\\b` },
                { match: `\\b0x(${f})(\\.(${f}))?([pP][+-]?(${h}))?\\b` },
                { match: /\b0o([0-7]_*)+\b/ },
                { match: /\b0b([01]_*)+\b/ },
              ],
            },
            g = (e = "") => ({
              className: "subst",
              variants: [{ match: Ox(/\\/, e, /[0\\tnr"']/) }, { match: Ox(/\\/, e, /u\{[0-9a-fA-F]{1,8}\}/) }],
            }),
            b = (e = "") => ({ className: "subst", match: Ox(/\\/, e, /[\t ]*(?:[\r\n]|\r\n)/) }),
            v = (e = "") => ({ className: "subst", label: "interpol", begin: Ox(/\\/, e, /\(/), end: /\)/ }),
            y = (e = "") => ({ begin: Ox(e, /"""/), end: Ox(/"""/, e), contains: [g(e), b(e), v(e)] }),
            O = (e = "") => ({ begin: Ox(e, /"/), end: Ox(/"/, e), contains: [g(e), v(e)] }),
            w = { className: "string", variants: [y(), y("#"), y("##"), y("###"), O(), O("#"), O("##"), O("###")] },
            x = [e.BACKSLASH_ESCAPE, { begin: /\[/, end: /\]/, relevance: 0, contains: [e.BACKSLASH_ESCAPE] }],
            k = { begin: /\/[^\s](?=[^/\n]*\/)/, end: /\//, contains: x },
            _ = (e) => {
              const t = Ox(e, /\//),
                n = Ox(/\//, e)
              return { begin: t, end: n, contains: [...x, { scope: "comment", begin: `#(?!.*${n})`, end: /$/ }] }
            },
            S = { scope: "regexp", variants: [_("###"), _("##"), _("#"), k] },
            E = { match: Ox(/`/, Mx, /`/) },
            T = [E, { className: "variable", match: /\$\d+/ }, { className: "variable", match: `\\$${Ix}+` }],
            A = [
              {
                match: /(@|#(un)?)available/,
                scope: "keyword",
                starts: { contains: [{ begin: /\(/, end: /\)/, keywords: Bx, contains: [...p, m, w] }] },
              },
              { scope: "keyword", match: Ox(/@/, wx(...Qx)) },
              { scope: "meta", match: Ox(/@/, Mx) },
            ],
            C = {
              match: yx(/\b[A-Z]/),
              relevance: 0,
              contains: [
                {
                  className: "type",
                  match: Ox(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Ix, "+"),
                },
                { className: "type", match: Lx, relevance: 0 },
                { match: /[?!]+/, relevance: 0 },
                { match: /\.\.\./, relevance: 0 },
                { match: Ox(/\s+&\s+/, yx(Lx)), relevance: 0 },
              ],
            },
            P = { begin: /</, end: />/, keywords: l, contains: [...r, ...c, ...A, u, C] }
          C.contains.push(P)
          const D = {
              begin: /\(/,
              end: /\)/,
              relevance: 0,
              keywords: l,
              contains: [
                "self",
                { match: Ox(Mx, /\s*:/), keywords: "_|0", relevance: 0 },
                ...r,
                S,
                ...c,
                ...d,
                ...p,
                m,
                w,
                ...T,
                ...A,
                C,
              ],
            },
            R = { begin: /</, end: />/, keywords: "repeat each", contains: [...r, C] },
            N = {
              begin: /\(/,
              end: /\)/,
              keywords: l,
              contains: [
                {
                  begin: wx(yx(Ox(Mx, /\s*:/)), yx(Ox(Mx, /\s+/, Mx, /\s*:/))),
                  end: /:/,
                  relevance: 0,
                  contains: [
                    { className: "keyword", match: /\b_\b/ },
                    { className: "params", match: Mx },
                  ],
                },
                ...r,
                ...c,
                ...p,
                m,
                w,
                ...A,
                C,
                D,
              ],
              endsParent: !0,
              illegal: /["']/,
            },
            $ = {
              match: [/(func|macro)/, /\s+/, wx(E.match, Mx, Nx)],
              className: { 1: "keyword", 3: "title.function" },
              contains: [R, N, t],
              illegal: [/\[/, /%/],
            },
            I = {
              match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
              className: { 1: "keyword" },
              contains: [R, N, t],
              illegal: /\[|%/,
            },
            M = { match: [/operator/, /\s+/, Nx], className: { 1: "keyword", 3: "title" } },
            L = {
              begin: [/precedencegroup/, /\s+/, Lx],
              className: { 1: "keyword", 3: "title" },
              contains: [C],
              keywords: [...Ax, ...Tx],
              end: /}/,
            }
          for (const e of w.variants) {
            const t = e.contains.find((e) => "interpol" === e.label)
            t.keywords = l
            const n = [...c, ...d, ...p, m, w, ...T]
            t.contains = [...n, { begin: /\(/, end: /\)/, contains: ["self", ...n] }]
          }
          return {
            name: "Swift",
            keywords: l,
            contains: [
              ...r,
              $,
              I,
              {
                beginKeywords: "struct protocol class extension enum actor",
                end: "\\{",
                excludeEnd: !0,
                keywords: l,
                contains: [
                  e.inherit(e.TITLE_MODE, { className: "title.class", begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/ }),
                  ...c,
                ],
              },
              M,
              L,
              { beginKeywords: "import", end: /$/, contains: [...r], relevance: 0 },
              S,
              ...c,
              ...d,
              ...p,
              m,
              w,
              ...T,
              ...A,
              C,
              D,
            ],
          }
        },
        typescript: function (e) {
          const t = (function (e) {
              const t = e.regex,
                n = jx,
                r = {
                  begin: /<[A-Za-z0-9\\._:-]+/,
                  end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
                  isTrulyOpeningTag: (e, t) => {
                    const n = e[0].length + e.index,
                      r = e.input[n]
                    if ("<" === r || "," === r) return void t.ignoreMatch()
                    let a
                    ">" === r &&
                      (((e, { after: t }) => {
                        const n = "</" + e[0].slice(1)
                        return -1 !== e.input.indexOf(n, t)
                      })(e, { after: n }) ||
                        t.ignoreMatch())
                    const o = e.input.substring(n)
                    ;((a = o.match(/^\s*=/)) || ((a = o.match(/^\s+extends\s+/)) && 0 === a.index)) && t.ignoreMatch()
                  },
                },
                a = { $pattern: jx, keyword: Ux, literal: Fx, built_in: Vx, "variable.language": Hx },
                o = "[0-9](_?[0-9])*",
                i = `\\.(${o})`,
                s = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
                l = {
                  className: "number",
                  variants: [
                    { begin: `(\\b(${s})((${i})|\\.)?|(${i}))[eE][+-]?(${o})\\b` },
                    { begin: `\\b(${s})\\b((${i})\\b|\\.)?|(${i})\\b` },
                    { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
                    { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
                    { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
                    { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
                    { begin: "\\b0[0-7]+n?\\b" },
                  ],
                  relevance: 0,
                },
                c = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: a, contains: [] },
                d = {
                  begin: "html`",
                  end: "",
                  starts: { end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "xml" },
                },
                u = {
                  begin: "css`",
                  end: "",
                  starts: { end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "css" },
                },
                p = {
                  begin: "gql`",
                  end: "",
                  starts: { end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "graphql" },
                },
                h = { className: "string", begin: "`", end: "`", contains: [e.BACKSLASH_ESCAPE, c] },
                f = {
                  className: "comment",
                  variants: [
                    e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                      relevance: 0,
                      contains: [
                        {
                          begin: "(?=@[A-Za-z]+)",
                          relevance: 0,
                          contains: [
                            { className: "doctag", begin: "@[A-Za-z]+" },
                            {
                              className: "type",
                              begin: "\\{",
                              end: "\\}",
                              excludeEnd: !0,
                              excludeBegin: !0,
                              relevance: 0,
                            },
                            { className: "variable", begin: n + "(?=\\s*(-)|$)", endsParent: !0, relevance: 0 },
                            { begin: /(?=[^\n])\s/, relevance: 0 },
                          ],
                        },
                      ],
                    }),
                    e.C_BLOCK_COMMENT_MODE,
                    e.C_LINE_COMMENT_MODE,
                  ],
                },
                m = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, d, u, p, h, { match: /\$\d+/ }, l]
              c.contains = m.concat({ begin: /\{/, end: /\}/, keywords: a, contains: ["self"].concat(m) })
              const g = [].concat(f, c.contains),
                b = g.concat([{ begin: /\(/, end: /\)/, keywords: a, contains: ["self"].concat(g) }]),
                v = {
                  className: "params",
                  begin: /\(/,
                  end: /\)/,
                  excludeBegin: !0,
                  excludeEnd: !0,
                  keywords: a,
                  contains: b,
                },
                y = {
                  variants: [
                    {
                      match: [/class/, /\s+/, n, /\s+/, /extends/, /\s+/, t.concat(n, "(", t.concat(/\./, n), ")*")],
                      scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" },
                    },
                    { match: [/class/, /\s+/, n], scope: { 1: "keyword", 3: "title.class" } },
                  ],
                },
                O = {
                  relevance: 0,
                  match: t.either(
                    /\bJSON/,
                    /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
                    /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
                    /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/,
                  ),
                  className: "title.class",
                  keywords: { _: [...zx, ...qx] },
                },
                w = {
                  variants: [{ match: [/function/, /\s+/, n, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }],
                  className: { 1: "keyword", 3: "title.function" },
                  label: "func.def",
                  contains: [v],
                  illegal: /%/,
                },
                x = {
                  match: t.concat(
                    /\b/,
                    ((k = [...Zx, "super", "import"]), t.concat("(?!", k.join("|"), ")")),
                    n,
                    t.lookahead(/\(/),
                  ),
                  className: "title.function",
                  relevance: 0,
                }
              var k
              const _ = {
                  begin: t.concat(/\./, t.lookahead(t.concat(n, /(?![0-9A-Za-z$_(])/))),
                  end: n,
                  excludeBegin: !0,
                  keywords: "prototype",
                  className: "property",
                  relevance: 0,
                },
                S = {
                  match: [/get|set/, /\s+/, n, /(?=\()/],
                  className: { 1: "keyword", 3: "title.function" },
                  contains: [{ begin: /\(\)/ }, v],
                },
                E = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>",
                T = {
                  match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(E)],
                  keywords: "async",
                  className: { 1: "keyword", 3: "title.function" },
                  contains: [v],
                }
              return {
                name: "JavaScript",
                aliases: ["js", "jsx", "mjs", "cjs"],
                keywords: a,
                exports: { PARAMS_CONTAINS: b, CLASS_REFERENCE: O },
                illegal: /#(?![$_A-z])/,
                contains: [
                  e.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
                  { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ },
                  e.APOS_STRING_MODE,
                  e.QUOTE_STRING_MODE,
                  d,
                  u,
                  p,
                  h,
                  f,
                  { match: /\$\d+/ },
                  l,
                  O,
                  { className: "attr", begin: n + t.lookahead(":"), relevance: 0 },
                  T,
                  {
                    begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
                    keywords: "return throw case",
                    relevance: 0,
                    contains: [
                      f,
                      e.REGEXP_MODE,
                      {
                        className: "function",
                        begin: E,
                        returnBegin: !0,
                        end: "\\s*=>",
                        contains: [
                          {
                            className: "params",
                            variants: [
                              { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                              { className: null, begin: /\(\s*\)/, skip: !0 },
                              { begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: a, contains: b },
                            ],
                          },
                        ],
                      },
                      { begin: /,/, relevance: 0 },
                      { match: /\s+/, relevance: 0 },
                      {
                        variants: [
                          { begin: "<>", end: "</>" },
                          { match: /<[A-Za-z0-9\\._:-]+\s*\/>/ },
                          { begin: r.begin, "on:begin": r.isTrulyOpeningTag, end: r.end },
                        ],
                        subLanguage: "xml",
                        contains: [{ begin: r.begin, end: r.end, skip: !0, contains: ["self"] }],
                      },
                    ],
                  },
                  w,
                  { beginKeywords: "while if switch catch for" },
                  {
                    begin:
                      "\\b(?!function)" +
                      e.UNDERSCORE_IDENT_RE +
                      "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
                    returnBegin: !0,
                    label: "func.def",
                    contains: [v, e.inherit(e.TITLE_MODE, { begin: n, className: "title.function" })],
                  },
                  { match: /\.\.\./, relevance: 0 },
                  _,
                  { match: "\\$" + n, relevance: 0 },
                  { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [v] },
                  x,
                  { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" },
                  y,
                  S,
                  { match: /\$[(.]/ },
                ],
              }
            })(e),
            n = jx,
            r = ["any", "void", "number", "boolean", "string", "object", "never", "symbol", "bigint", "unknown"],
            a = { beginKeywords: "namespace", end: /\{/, excludeEnd: !0, contains: [t.exports.CLASS_REFERENCE] },
            o = {
              beginKeywords: "interface",
              end: /\{/,
              excludeEnd: !0,
              keywords: { keyword: "interface extends", built_in: r },
              contains: [t.exports.CLASS_REFERENCE],
            },
            i = {
              $pattern: jx,
              keyword: Ux.concat([
                "type",
                "namespace",
                "interface",
                "public",
                "private",
                "protected",
                "implements",
                "declare",
                "abstract",
                "readonly",
                "enum",
                "override",
              ]),
              literal: Fx,
              built_in: Vx.concat(r),
              "variable.language": Hx,
            },
            s = { className: "meta", begin: "@" + n },
            l = (e, t, n) => {
              const r = e.contains.findIndex((e) => e.label === t)
              if (-1 === r) throw new Error("can not find mode to replace")
              e.contains.splice(r, 1, n)
            }
          return (
            Object.assign(t.keywords, i),
            t.exports.PARAMS_CONTAINS.push(s),
            (t.contains = t.contains.concat([s, a, o])),
            l(t, "shebang", e.SHEBANG()),
            l(t, "use_strict", { className: "meta", relevance: 10, begin: /^\s*['"]use strict['"]/ }),
            (t.contains.find((e) => "func.def" === e.label).relevance = 0),
            Object.assign(t, { name: "TypeScript", aliases: ["ts", "tsx", "mts", "cts"] }),
            t
          )
        },
        xml: Wx,
        yaml: function (e) {
          const t = "true false yes no null",
            n = "[\\w#;/?:@&=+$,.~*'()[\\]]+",
            r = {
              className: "string",
              relevance: 0,
              variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /\S+/ }],
              contains: [
                e.BACKSLASH_ESCAPE,
                {
                  className: "template-variable",
                  variants: [
                    { begin: /\{\{/, end: /\}\}/ },
                    { begin: /%\{/, end: /\}/ },
                  ],
                },
              ],
            },
            a = e.inherit(r, {
              variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /[^\s,{}[\]]+/ }],
            }),
            o = { end: ",", endsWithParent: !0, excludeEnd: !0, keywords: t, relevance: 0 },
            i = { begin: /\{/, end: /\}/, contains: [o], illegal: "\\n", relevance: 0 },
            s = { begin: "\\[", end: "\\]", contains: [o], illegal: "\\n", relevance: 0 },
            l = [
              {
                className: "attr",
                variants: [
                  { begin: "\\w[\\w :\\/.-]*:(?=[ \t]|$)" },
                  { begin: '"\\w[\\w :\\/.-]*":(?=[ \t]|$)' },
                  { begin: "'\\w[\\w :\\/.-]*':(?=[ \t]|$)" },
                ],
              },
              { className: "meta", begin: "^---\\s*$", relevance: 10 },
              { className: "string", begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*" },
              {
                begin: "<%[%=-]?",
                end: "[%-]?%>",
                subLanguage: "ruby",
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
              },
              { className: "type", begin: "!\\w+!" + n },
              { className: "type", begin: "!<" + n + ">" },
              { className: "type", begin: "!" + n },
              { className: "type", begin: "!!" + n },
              { className: "meta", begin: "&" + e.UNDERSCORE_IDENT_RE + "$" },
              { className: "meta", begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$" },
              { className: "bullet", begin: "-(?=[ ]|$)", relevance: 0 },
              e.HASH_COMMENT_MODE,
              { beginKeywords: t, keywords: { literal: t } },
              {
                className: "number",
                begin:
                  "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b",
              },
              { className: "number", begin: e.C_NUMBER_RE + "\\b", relevance: 0 },
              i,
              s,
              r,
            ],
            c = [...l]
          return (
            c.pop(), c.push(a), (o.contains = c), { name: "YAML", case_insensitive: !0, aliases: ["yml"], contains: l }
          )
        },
      },
      vI = {
        abandonedHeadElementChild: {
          reason: "Unexpected metadata element after head",
          description: "Unexpected element after head. Expected the element before `</head>`",
          url: !1,
        },
        abruptClosingOfEmptyComment: {
          reason: "Unexpected abruptly closed empty comment",
          description: "Unexpected `>` or `->`. Expected `--\x3e` to close comments",
        },
        abruptDoctypePublicIdentifier: {
          reason: "Unexpected abruptly closed public identifier",
          description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier",
        },
        abruptDoctypeSystemIdentifier: {
          reason: "Unexpected abruptly closed system identifier",
          description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier",
        },
        absenceOfDigitsInNumericCharacterReference: {
          reason: "Unexpected non-digit at start of numeric character reference",
          description:
            "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references",
        },
        cdataInHtmlContent: {
          reason: "Unexpected CDATA section in HTML",
          description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead",
        },
        characterReferenceOutsideUnicodeRange: {
          reason: "Unexpected too big numeric character reference",
          description:
            "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)",
        },
        closingOfElementWithOpenChildElements: {
          reason: "Unexpected closing tag with open child elements",
          description: "Unexpectedly closing tag. Expected other tags to be closed first",
          url: !1,
        },
        controlCharacterInInputStream: {
          reason: "Unexpected control character",
          description:
            "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace",
        },
        controlCharacterReference: {
          reason: "Unexpected control character reference",
          description:
            "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace",
        },
        disallowedContentInNoscriptInHead: {
          reason: "Disallowed content inside `<noscript>` in `<head>`",
          description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
          url: !1,
        },
        duplicateAttribute: {
          reason: "Unexpected duplicate attribute",
          description: "Unexpectedly double attribute. Expected attributes to occur only once",
        },
        endTagWithAttributes: {
          reason: "Unexpected attribute on closing tag",
          description: "Unexpected attribute. Expected `>` instead",
        },
        endTagWithTrailingSolidus: {
          reason: "Unexpected slash at end of closing tag",
          description: "Unexpected `%c-1`. Expected `>` instead",
        },
        endTagWithoutMatchingOpenElement: {
          reason: "Unexpected unopened end tag",
          description: "Unexpected end tag. Expected no end tag or another end tag",
          url: !1,
        },
        eofBeforeTagName: {
          reason: "Unexpected end of file",
          description: "Unexpected end of file. Expected tag name instead",
        },
        eofInCdata: {
          reason: "Unexpected end of file in CDATA",
          description: "Unexpected end of file. Expected `]]>` to close the CDATA",
        },
        eofInComment: {
          reason: "Unexpected end of file in comment",
          description: "Unexpected end of file. Expected `--\x3e` to close the comment",
        },
        eofInDoctype: {
          reason: "Unexpected end of file in doctype",
          description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)",
        },
        eofInElementThatCanContainOnlyText: {
          reason: "Unexpected end of file in element that can only contain text",
          description: "Unexpected end of file. Expected text or a closing tag",
          url: !1,
        },
        eofInScriptHtmlCommentLikeText: {
          reason: "Unexpected end of file in comment inside script",
          description: "Unexpected end of file. Expected `--\x3e` to close the comment",
        },
        eofInTag: {
          reason: "Unexpected end of file in tag",
          description: "Unexpected end of file. Expected `>` to close the tag",
        },
        incorrectlyClosedComment: {
          reason: "Incorrectly closed comment",
          description: "Unexpected `%c-1`. Expected `--\x3e` to close the comment",
        },
        incorrectlyOpenedComment: {
          reason: "Incorrectly opened comment",
          description: "Unexpected `%c`. Expected `\x3c!--` to open the comment",
        },
        invalidCharacterSequenceAfterDoctypeName: {
          reason: "Invalid sequence after doctype name",
          description: "Unexpected sequence at `%c`. Expected `public` or `system`",
        },
        invalidFirstCharacterOfTagName: {
          reason: "Invalid first character in tag name",
          description: "Unexpected `%c`. Expected an ASCII letter instead",
        },
        misplacedDoctype: {
          reason: "Misplaced doctype",
          description: "Unexpected doctype. Expected doctype before head",
          url: !1,
        },
        misplacedStartTagForHeadElement: {
          reason: "Misplaced `<head>` start tag",
          description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
          url: !1,
        },
        missingAttributeValue: {
          reason: "Missing attribute value",
          description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead",
        },
        missingDoctype: {
          reason: "Missing doctype before other content",
          description: "Expected a `<!doctype html>` before anything else",
          url: !1,
        },
        missingDoctypeName: {
          reason: "Missing doctype name",
          description: "Unexpected doctype end at `%c`. Expected `html` instead",
        },
        missingDoctypePublicIdentifier: {
          reason: "Missing public identifier in doctype",
          description: "Unexpected `%c`. Expected identifier for `public` instead",
        },
        missingDoctypeSystemIdentifier: {
          reason: "Missing system identifier in doctype",
          description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)',
        },
        missingEndTagName: {
          reason: "Missing name in end tag",
          description: "Unexpected `%c`. Expected an ASCII letter instead",
        },
        missingQuoteBeforeDoctypePublicIdentifier: {
          reason: "Missing quote before public identifier in doctype",
          description: "Unexpected `%c`. Expected `\"` or `'` instead",
        },
        missingQuoteBeforeDoctypeSystemIdentifier: {
          reason: "Missing quote before system identifier in doctype",
          description: "Unexpected `%c`. Expected `\"` or `'` instead",
        },
        missingSemicolonAfterCharacterReference: {
          reason: "Missing semicolon after character reference",
          description: "Unexpected `%c`. Expected `;` instead",
        },
        missingWhitespaceAfterDoctypePublicKeyword: {
          reason: "Missing whitespace after public identifier in doctype",
          description: "Unexpected `%c`. Expected ASCII whitespace instead",
        },
        missingWhitespaceAfterDoctypeSystemKeyword: {
          reason: "Missing whitespace after system identifier in doctype",
          description: "Unexpected `%c`. Expected ASCII whitespace instead",
        },
        missingWhitespaceBeforeDoctypeName: {
          reason: "Missing whitespace before doctype name",
          description: "Unexpected `%c`. Expected ASCII whitespace instead",
        },
        missingWhitespaceBetweenAttributes: {
          reason: "Missing whitespace between attributes",
          description: "Unexpected `%c`. Expected ASCII whitespace instead",
        },
        missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
          reason: "Missing whitespace between public and system identifiers in doctype",
          description: "Unexpected `%c`. Expected ASCII whitespace instead",
        },
        nestedComment: { reason: "Unexpected nested comment", description: "Unexpected `\x3c!--`. Expected `--\x3e`" },
        nestedNoscriptInHead: {
          reason: "Unexpected nested `<noscript>` in `<head>`",
          description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
          url: !1,
        },
        nonConformingDoctype: {
          reason: "Unexpected non-conforming doctype declaration",
          description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
          url: !1,
        },
        nonVoidHtmlElementStartTagWithTrailingSolidus: {
          reason: "Unexpected trailing slash on start tag of non-void element",
          description: "Unexpected `/`. Expected `>` instead",
        },
        noncharacterCharacterReference: {
          reason: "Unexpected noncharacter code point referenced by character reference",
          description: "Unexpected code point. Do not use noncharacters in HTML",
        },
        noncharacterInInputStream: {
          reason: "Unexpected noncharacter character",
          description: "Unexpected code point `%x`. Do not use noncharacters in HTML",
        },
        nullCharacterReference: {
          reason: "Unexpected NULL character referenced by character reference",
          description: "Unexpected code point. Do not use NULL characters in HTML",
        },
        openElementsLeftAfterEof: {
          reason: "Unexpected end of file",
          description: "Unexpected end of file. Expected closing tag instead",
          url: !1,
        },
        surrogateCharacterReference: {
          reason: "Unexpected surrogate character referenced by character reference",
          description: "Unexpected code point. Do not use lone surrogate characters in HTML",
        },
        surrogateInInputStream: {
          reason: "Unexpected surrogate character",
          description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML",
        },
        unexpectedCharacterAfterDoctypeSystemIdentifier: {
          reason: "Invalid character after system identifier in doctype",
          description: "Unexpected character at `%c`. Expected `>`",
        },
        unexpectedCharacterInAttributeName: {
          reason: "Unexpected character in attribute name",
          description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter",
        },
        unexpectedCharacterInUnquotedAttributeValue: {
          reason: "Unexpected character in unquoted attribute value",
          description: "Unexpected `%c`. Quote the attribute value to include it",
        },
        unexpectedEqualsSignBeforeAttributeName: {
          reason: "Unexpected equals sign before attribute name",
          description: "Unexpected `%c`. Add an attribute name before it",
        },
        unexpectedNullCharacter: {
          reason: "Unexpected NULL character",
          description: "Unexpected code point `%x`. Do not use NULL characters in HTML",
        },
        unexpectedQuestionMarkInsteadOfTagName: {
          reason: "Unexpected question mark instead of tag name",
          description: "Unexpected `%c`. Expected an ASCII letter instead",
        },
        unexpectedSolidusInTag: {
          reason: "Unexpected slash in tag",
          description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value",
        },
        unknownNamedCharacterReference: {
          reason: "Unexpected unknown named character reference",
          description: "Unexpected character reference. Expected known named character references",
        },
      },
      yI = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-",
      OI = /-[a-z]/g,
      wI = /%c(?:([-+])(\d+))?/g,
      xI = /%x/g,
      kI = { 2: !0, 1: !1, 0: null },
      _I = {}
    function SI(e) {
      return e.charAt(1).toUpperCase()
    }
    function EI(e) {
      const { emitParseErrors: t, ...n } = { ...this.data("settings"), ...e }
      this.parser = function (e, r) {
        return (function (e, t) {
          const n = t || _I,
            r = n.onerror,
            a = e instanceof rI ? e : new rI(e),
            o = n.fragment ? hC : pC,
            i = String(a),
            s = o(i, {
              sourceCodeLocationInfo: !0,
              onParseError: n.onerror
                ? function (e) {
                    const t = e.code,
                      o = (function (e) {
                        return e.replace(OI, SI)
                      })(t),
                      s = n[o],
                      l = null == s || s,
                      c = "number" == typeof l ? l : l ? 1 : 0
                    if (c) {
                      const n = vI[o],
                        i = new V$(d(n.reason), {
                          place: {
                            start: { line: e.startLine, column: e.startCol, offset: e.startOffset },
                            end: { line: e.endLine, column: e.endCol, offset: e.endOffset },
                          },
                          ruleId: t,
                          source: "hast-util-from-html",
                        })
                      a.path && ((i.file = a.path), (i.name = a.path + ":" + i.name)),
                        (i.fatal = kI[c]),
                        (i.note = d(n.description)),
                        (i.url = !1 === n.url ? void 0 : yI + t),
                        r(i)
                    }
                    function d(t) {
                      return t
                        .replace(wI, function (t, n, r) {
                          const a = (r ? Number.parseInt(r, 10) : 0) * ("-" === n ? -1 : 1)
                          return (function (e) {
                            return "`" === e ? "` ` `" : e
                          })(i.charAt(e.startOffset + a))
                        })
                        .replace(xI, function () {
                          return "0x" + i.charCodeAt(e.startOffset).toString(16).toUpperCase()
                        })
                    }
                  }
                : null,
              scriptingEnabled: !1,
            })
          return oE(s, { file: a, space: n.space, verbose: n.verbose })
        })(e, {
          ...n,
          onerror: t
            ? function (e) {
                r.path && ((e.name = r.path + ":" + e.name), (e.file = r.path)), r.messages.push(e)
              }
            : void 0,
        })
      }
    }
    function TI(e) {
      return "text" === (null == e ? void 0 : e.type)
    }
    function AI(e) {
      return "element" === (null == e ? void 0 : e.type)
    }
    function CI(e) {
      return { type: "text", value: e }
    }
    function PI() {
      return (e) => {
        m_(e, "element", (e, t, n) => {
          if ("element" === (null == n ? void 0 : n.type) && "pre" === n.tagName && "code" === e.tagName) {
            let t = 0
            ;(e.children = DI(e)),
              e.children.forEach((e) => {
                if ("element" === e.type && "span" === e.tagName) {
                  const n = e.children[e.children.length - 1]
                  ;(!TI(n) || (TI(n) && !NI(n))) && (e.children.push({ type: "text", value: "\n" }), t++)
                }
              }),
              (e.properties.style = [`--line-count: ${t};`, `--line-digits: ${t.toString().length};`])
          }
        })
      }
    }
    function DI(e, t = [], n) {
      const r = () => t[t.length - 1] ?? (t.push(RI()) && t[t.length - 1])
      return (
        e.children.forEach((a) => {
          if (TI(a) && NI(a)) {
            const o = a.value.split(/\n/)
            o.forEach((a, i) => {
              n ? r().children.push({ ...e, children: [CI(a)] }) : r().children.push(CI(a)),
                i !== o.length - 1 && t.push(RI())
            })
          } else AI(a) && a.children.some(NI) ? DI(a, t, !0) : r().children.push(a)
        }),
        t
      )
    }
    function RI(...e) {
      return { type: "element", tagName: "span", properties: { class: ["line"] }, children: e }
    }
    function NI(e) {
      return (TI(e) && /\r?\n/.test(e.value)) || (AI(e) && e.children.some(NI))
    }
    const $I = {
        parse: (e) => {
          const t = JSON.parse(e)
          if ("object" != typeof t) throw Error("Invalid JSON object")
          return t
        },
        parseSafe(e, t) {
          try {
            return $I.parse(e)
          } catch (e) {
            return "function" == typeof t ? t(e) : t
          }
        },
        stringify: (e) => JSON.stringify(e),
      },
      II = (e) => {
        if ("string" == typeof e)
          return ((e) => "string" == typeof e && !!$I.parseSafe(e, !1))(e) ? JSON.stringify(JSON.parse(e), null, 2) : e
        if ("object" == typeof e)
          try {
            return JSON.stringify(e, null, 2)
          } catch {
            return (function (e) {
              const t = new Set()
              return JSON.stringify(
                e,
                (e, n) => {
                  if ("object" == typeof n && null !== n) {
                    if (t.has(n)) return "[Circular]"
                    t.add(n)
                  }
                  return n
                },
                2,
              )
            })(e)
          }
        return e.toString()
      },
      MI = Object.assign({
        "./Add.svg": () => Promise.resolve().then(() => uZ),
        "./ArrowLeft.svg": () => Promise.resolve().then(() => gZ),
        "./ArrowRight.svg": () => Promise.resolve().then(() => wZ),
        "./Background.svg": () => Promise.resolve().then(() => EZ),
        "./Brackets.svg": () => Promise.resolve().then(() => DZ),
        "./Branch.svg": () => Promise.resolve().then(() => MZ),
        "./CallToAction.svg": () => Promise.resolve().then(() => UZ),
        "./Checkmark.svg": () => Promise.resolve().then(() => HZ),
        "./ChevronDown.svg": () => Promise.resolve().then(() => GZ),
        "./ChevronLeft.svg": () => Promise.resolve().then(() => nH),
        "./ChevronRight.svg": () => Promise.resolve().then(() => sH),
        "./ChevronUp.svg": () => Promise.resolve().then(() => pH),
        "./Clipboard.svg": () => Promise.resolve().then(() => bH),
        "./Close.svg": () => Promise.resolve().then(() => xH),
        "./CodeFolder.svg": () => Promise.resolve().then(() => TH),
        "./Collection.svg": () => Promise.resolve().then(() => RH),
        "./Cookie.svg": () => Promise.resolve().then(() => LH),
        "./DarkMode.svg": () => Promise.resolve().then(() => FH),
        "./Delete.svg": () => Promise.resolve().then(() => VH),
        "./Discord.svg": () => Promise.resolve().then(() => KH),
        "./DocsPage.svg": () => Promise.resolve().then(() => rV),
        "./Duplicate.svg": () => Promise.resolve().then(() => lV),
        "./Edit.svg": () => Promise.resolve().then(() => hV),
        "./Ellipses.svg": () => Promise.resolve().then(() => vV),
        "./Error.svg": () => Promise.resolve().then(() => kV),
        "./Example.svg": () => Promise.resolve().then(() => AV),
        "./ExternalLink.svg": () => Promise.resolve().then(() => NV),
        "./FilterList.svg": () => Promise.resolve().then(() => QV),
        "./Folder.svg": () => Promise.resolve().then(() => zV),
        "./GitHub.svg": () => Promise.resolve().then(() => WV),
        "./Google.svg": () => Promise.resolve().then(() => JV),
        "./Hide.svg": () => Promise.resolve().then(() => aW),
        "./History.svg": () => Promise.resolve().then(() => cW),
        "./House.svg": () => Promise.resolve().then(() => fW),
        "./Import.svg": () => Promise.resolve().then(() => yW),
        "./Info.svg": () => Promise.resolve().then(() => _W),
        "./Key.svg": () => Promise.resolve().then(() => CW),
        "./Leave.svg": () => Promise.resolve().then(() => $W),
        "./LightDarkModeToggle.svg": () => Promise.resolve().then(() => BW),
        "./LightMode.svg": () => Promise.resolve().then(() => qW),
        "./Link.svg": () => Promise.resolve().then(() => XW),
        "./Lock.svg": () => Promise.resolve().then(() => eX),
        "./Logo.svg": () => Promise.resolve().then(() => oX),
        "./LogoAPI.svg": () => Promise.resolve().then(() => dX),
        "./LogoClient.svg": () => Promise.resolve().then(() => mX),
        "./LogoMarket.svg": () => Promise.resolve().then(() => OX),
        "./LogoSwagger.svg": () => Promise.resolve().then(() => SX),
        "./Magic.svg": () => Promise.resolve().then(() => PX),
        "./Menu.svg": () => Promise.resolve().then(() => IX),
        "./Page.svg": () => Promise.resolve().then(() => jX),
        "./PaperAirplane.svg": () => Promise.resolve().then(() => ZX),
        "./Payment.svg": () => Promise.resolve().then(() => YX),
        "./Pencil.svg": () => Promise.resolve().then(() => tY),
        "./Play.svg": () => Promise.resolve().then(() => iY),
        "./Refresh.svg": () => Promise.resolve().then(() => uY),
        "./Search.svg": () => Promise.resolve().then(() => gY),
        "./Server.svg": () => Promise.resolve().then(() => wY),
        "./Show.svg": () => Promise.resolve().then(() => EY),
        "./Sort.svg": () => Promise.resolve().then(() => DY),
        "./Terminal.svg": () => Promise.resolve().then(() => MY),
        "./ThumbsDown.svg": () => Promise.resolve().then(() => UY),
        "./ThumbsUp.svg": () => Promise.resolve().then(() => HY),
        "./Trash.svg": () => Promise.resolve().then(() => GY),
        "./Unlock.svg": () => Promise.resolve().then(() => nG),
        "./Upload.svg": () => Promise.resolve().then(() => sG),
        "./UploadSimple.svg": () => Promise.resolve().then(() => pG),
        "./User.svg": () => Promise.resolve().then(() => bG),
        "./Workspace.svg": () => Promise.resolve().then(() => xG),
        "./programming-framework-angular.svg": () => Promise.resolve().then(() => TG),
        "./programming-framework-astro.svg": () => Promise.resolve().then(() => RG),
        "./programming-framework-laravel.svg": () => Promise.resolve().then(() => LG),
        "./programming-framework-nextdotjs.svg": () => Promise.resolve().then(() => FG),
        "./programming-framework-react.svg": () => Promise.resolve().then(() => VG),
        "./programming-framework-vuedotjs.svg": () => Promise.resolve().then(() => KG),
        "./programming-language-c.svg": () => Promise.resolve().then(() => rK),
        "./programming-language-clojure.svg": () => Promise.resolve().then(() => lK),
        "./programming-language-csharp.svg": () => Promise.resolve().then(() => hK),
        "./programming-language-css3.svg": () => Promise.resolve().then(() => vK),
        "./programming-language-go.svg": () => Promise.resolve().then(() => kK),
        "./programming-language-html5.svg": () => Promise.resolve().then(() => AK),
        "./programming-language-http.svg": () => Promise.resolve().then(() => NK),
        "./programming-language-java.svg": () => Promise.resolve().then(() => QK),
        "./programming-language-javascript.svg": () => Promise.resolve().then(() => zK),
        "./programming-language-json.svg": () => Promise.resolve().then(() => WK),
        "./programming-language-kotlin.svg": () => Promise.resolve().then(() => JK),
        "./programming-language-node.svg": () => Promise.resolve().then(() => aJ),
        "./programming-language-objc.svg": () => Promise.resolve().then(() => cJ),
        "./programming-language-ocaml.svg": () => Promise.resolve().then(() => fJ),
        "./programming-language-php.svg": () => Promise.resolve().then(() => yJ),
        "./programming-language-powershell.svg": () => Promise.resolve().then(() => _J),
        "./programming-language-python.svg": () => Promise.resolve().then(() => CJ),
        "./programming-language-r.svg": () => Promise.resolve().then(() => $J),
        "./programming-language-ruby.svg": () => Promise.resolve().then(() => BJ),
        "./programming-language-scala.svg": () => Promise.resolve().then(() => qJ),
        "./programming-language-shell.svg": () => Promise.resolve().then(() => XJ),
        "./programming-language-swift.svg": () => Promise.resolve().then(() => e0),
        "./programming-language-typescript.svg": () => Promise.resolve().then(() => o0),
        "./programming-script-code.svg": () => Promise.resolve().then(() => d0),
        "./programming-tool-git.svg": () => Promise.resolve().then(() => m0),
        "./programming-tool-tailwindcss.svg": () => Promise.resolve().then(() => O0),
      }),
      LI = (e) => {
        const t = `./${e}.svg`
        return MI[t]
          ? (function (e) {
              xe(e) && (e = { loader: e })
              const {
                loader: t,
                loadingComponent: n,
                errorComponent: r,
                delay: a = 200,
                timeout: o,
                suspensible: i = !0,
                onError: s,
              } = e
              let l,
                c = null,
                d = 0
              const u = () => {
                let e
                return (
                  c ||
                  (e = c =
                    t()
                      .catch((e) => {
                        if (((e = e instanceof Error ? e : new Error(String(e))), s))
                          return new Promise((t, n) => {
                            s(
                              e,
                              () => t((d++, (c = null), u())),
                              () => n(e),
                              d + 1,
                            )
                          })
                        throw e
                      })
                      .then((t) =>
                        e !== c && c
                          ? c
                          : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default), (l = t), t),
                      ))
                )
              }
              return Hr({
                name: "AsyncComponentWrapper",
                __asyncLoader: u,
                get __asyncResolved() {
                  return l
                },
                setup() {
                  const e = Ho
                  if (l) return () => Wr(l, e)
                  const t = (t) => {
                    ;(c = null), Vn(t, e, 13, !r)
                  }
                  if ((i && e.suspense) || ei)
                    return u()
                      .then((t) => () => Wr(t, e))
                      .catch((e) => (t(e), () => (r ? No(r, { error: e }) : null)))
                  const s = Dn(!1),
                    d = Dn(),
                    p = Dn(!!a)
                  return (
                    a &&
                      setTimeout(() => {
                        p.value = !1
                      }, a),
                    null != o &&
                      setTimeout(() => {
                        if (!s.value && !d.value) {
                          const e = new Error(`Async component timed out after ${o}ms.`)
                          t(e), (d.value = e)
                        }
                      }, o),
                    u()
                      .then(() => {
                        ;(s.value = !0),
                          e.parent && to(e.parent.vnode) && ((e.parent.effect.dirty = !0), ar(e.parent.update))
                      })
                      .catch((e) => {
                        t(e), (d.value = e)
                      }),
                    () =>
                      s.value && l
                        ? Wr(l, e)
                        : d.value && r
                          ? No(r, { error: d.value })
                          : n && !p.value
                            ? No(n)
                            : void 0
                  )
                },
              })
            })(MI[t])
          : (console.warn(`Could not find icon: ${e}`), null)
      },
      QI = Hr({
        __name: "ScalarIcon",
        props: { icon: {}, size: {}, thickness: {} },
        setup(e) {
          vi((e) => ({ "5933775d": r.value }))
          const t = e,
            n = tw({
              variants: {
                size: {
                  xs: "size-3",
                  sm: "size-3.5",
                  md: "size-4",
                  lg: "size-5",
                  xl: "size-6",
                  "2xl": "size-8",
                  "3xl": "size-10",
                  full: "size-full",
                },
              },
              defaultVariants: { size: "full" },
            }),
            r = ii(() => t.thickness ?? "2")
          return (e, t) => (
            xo(),
            To(Tr(In(LI)(e.icon)), { class: Ge(In(nw)("scalar-icon", In(n)({ size: e.size }))) }, null, 8, ["class"])
          )
        },
      }),
      BI = iw(QI, [["__scopeId", "data-v-43d05207"]]),
      jI = { class: "scalar-code-block" },
      UI = Ro("span", { class: "sr-only" }, "Copy content", -1),
      FI = ["innerHTML"],
      zI = Hr({
        __name: "ScalarCodeBlock",
        props: {
          content: {},
          lang: { default: "plaintext" },
          lineNumbers: { type: Boolean, default: !1 },
          hideCredentials: {},
        },
        setup(e) {
          const t = e,
            n = ii(() =>
              (function (e, t) {
                const n = (
                    "string" == typeof (null == t ? void 0 : t.maskCredentials)
                      ? [t.maskCredentials]
                      : ((null == t ? void 0 : t.maskCredentials) ?? [])
                  ).filter(
                    (e) =>
                      !(
                        e.length < 3 &&
                        (console.error(
                          `Codeblock credentials must be at least 3 characters to mask. Will not mask "${e}"`,
                        ),
                        1)
                      ),
                  ),
                  r = `language-${gw[t.lang] ?? t.lang}`
                var a
                const o = dI()
                  .use(EI, { fragment: !0 })
                  .use(
                    ((a = e),
                    () => (e) => {
                      m_(e, "element", (e) => {
                        "code" === e.tagName && e.children.push({ type: "text", value: a })
                      })
                    }),
                  )
                  .use(b_, { languages: t.languages })
                  .use((null == t ? void 0 : t.lineNumbers) ? PI : () => {})
                  .use(PP)
                  .processSync(`<pre><code class="${r}"></code></pre>`)
                  .toString()
                return n.length
                  ? o.replace(new RegExp(n.join("|"), "g"), (e) => `<span class="credentials">${e}</span>`)
                  : o
              })(II(t.content), {
                lang: t.lang.trim(),
                languages: bI,
                lineNumbers: t.lineNumbers,
                maskCredentials: t.hideCredentials,
              }).slice(5, -6),
            ),
            { copyToClipboard: r } = (() => {
              const { toast: e } = Vu()
              return {
                copyToClipboard: (t) => {
                  navigator.clipboard.writeText(t).then(() => {
                    e("Copied to the clipboard", "info")
                  })
                },
              }
            })(),
            a = ii(() => null !== t.content && "null" !== t.content)
          return (e, o) => (
            xo(),
            Eo("div", jI, [
              a.value
                ? (xo(),
                  Eo(
                    "button",
                    {
                      key: 0,
                      class: "copy-button",
                      type: "button",
                      onClick: o[0] || (o[0] = (e) => In(r)(In(II)(t.content))),
                    },
                    [UI, No(In(BI), { icon: "Clipboard", size: "md" })],
                  ))
                : Qo("", !0),
              Ro("pre", { class: "scalar-codeblock-pre", innerHTML: n.value }, null, 8, FI),
            ])
          )
        },
      }),
      qI = ["innerHTML"],
      ZI = Hr({
        __name: "ScalarMarkdown",
        props: { value: {}, withImages: { type: Boolean, default: !1 } },
        setup(e) {
          const t = e,
            n = ii(() =>
              (function (e, t) {
                const n = (null == t ? void 0 : t.removeTags) ?? [],
                  r = [...($C.tagNames ?? []), ...((null == t ? void 0 : t.allowTags) ?? [])].filter(
                    (e) => !n.includes(e),
                  )
                return dI()
                  .use(g$)
                  .use(BN)
                  .use(I$, { allowDangerousHtml: !0 })
                  .use(RC)
                  .use(FC, { ...$C, tagNames: r, attributes: { ...$C.attributes, abbr: ["title"] } })
                  .use(b_, { languages: bI, detect: !0 })
                  .use($_, { target: "_blank" })
                  .use(sS)
                  .use(PP)
                  .processSync(e)
                  .toString()
              })(t.value ?? "", { removeTags: t.withImages ? [] : ["img", "picture"] }),
            )
          return (
            Qr(async () => await new Promise((e) => setTimeout(e, 1))),
            (e, t) => (xo(), Eo("div", { class: "markdown", innerHTML: n.value }, null, 8, qI))
          )
        },
      }),
      HI = ["top", "right", "bottom", "left"],
      VI = Math.min,
      WI = Math.max,
      XI = Math.round,
      YI = Math.floor,
      GI = (e) => ({ x: e, y: e }),
      KI = { left: "right", right: "left", bottom: "top", top: "bottom" },
      JI = { start: "end", end: "start" }
    function eM(e, t, n) {
      return WI(e, VI(t, n))
    }
    function tM(e, t) {
      return "function" == typeof e ? e(t) : e
    }
    function nM(e) {
      return e.split("-")[0]
    }
    function rM(e) {
      return e.split("-")[1]
    }
    function aM(e) {
      return "x" === e ? "y" : "x"
    }
    function oM(e) {
      return "y" === e ? "height" : "width"
    }
    function iM(e) {
      return ["top", "bottom"].includes(nM(e)) ? "y" : "x"
    }
    function sM(e) {
      return aM(iM(e))
    }
    function lM(e) {
      return e.replace(/start|end/g, (e) => JI[e])
    }
    function cM(e) {
      return e.replace(/left|right|bottom|top/g, (e) => KI[e])
    }
    function dM(e) {
      return "number" != typeof e
        ? (function (e) {
            return { top: 0, right: 0, bottom: 0, left: 0, ...e }
          })(e)
        : { top: e, right: e, bottom: e, left: e }
    }
    function uM(e) {
      const { x: t, y: n, width: r, height: a } = e
      return { width: r, height: a, top: n, left: t, right: t + r, bottom: n + a, x: t, y: n }
    }
    function pM(e, t, n) {
      let { reference: r, floating: a } = e
      const o = iM(t),
        i = sM(t),
        s = oM(i),
        l = nM(t),
        c = "y" === o,
        d = r.x + r.width / 2 - a.width / 2,
        u = r.y + r.height / 2 - a.height / 2,
        p = r[s] / 2 - a[s] / 2
      let h
      switch (l) {
        case "top":
          h = { x: d, y: r.y - a.height }
          break
        case "bottom":
          h = { x: d, y: r.y + r.height }
          break
        case "right":
          h = { x: r.x + r.width, y: u }
          break
        case "left":
          h = { x: r.x - a.width, y: u }
          break
        default:
          h = { x: r.x, y: r.y }
      }
      switch (rM(t)) {
        case "start":
          h[i] -= p * (n && c ? -1 : 1)
          break
        case "end":
          h[i] += p * (n && c ? -1 : 1)
      }
      return h
    }
    async function hM(e, t) {
      var n
      void 0 === t && (t = {})
      const { x: r, y: a, platform: o, rects: i, elements: s, strategy: l } = e,
        {
          boundary: c = "clippingAncestors",
          rootBoundary: d = "viewport",
          elementContext: u = "floating",
          altBoundary: p = !1,
          padding: h = 0,
        } = tM(t, e),
        f = dM(h),
        m = s[p ? ("floating" === u ? "reference" : "floating") : u],
        g = uM(
          await o.getClippingRect({
            element:
              null == (n = await (null == o.isElement ? void 0 : o.isElement(m))) || n
                ? m
                : m.contextElement ||
                  (await (null == o.getDocumentElement ? void 0 : o.getDocumentElement(s.floating))),
            boundary: c,
            rootBoundary: d,
            strategy: l,
          }),
        ),
        b = "floating" === u ? { x: r, y: a, width: i.floating.width, height: i.floating.height } : i.reference,
        v = await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(s.floating)),
        y = ((await (null == o.isElement ? void 0 : o.isElement(v))) &&
          (await (null == o.getScale ? void 0 : o.getScale(v)))) || { x: 1, y: 1 },
        O = uM(
          o.convertOffsetParentRelativeRectToViewportRelativeRect
            ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
                elements: s,
                rect: b,
                offsetParent: v,
                strategy: l,
              })
            : b,
        )
      return {
        top: (g.top - O.top + f.top) / y.y,
        bottom: (O.bottom - g.bottom + f.bottom) / y.y,
        left: (g.left - O.left + f.left) / y.x,
        right: (O.right - g.right + f.right) / y.x,
      }
    }
    function fM(e, t) {
      return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width }
    }
    function mM(e) {
      return HI.some((t) => e[t] >= 0)
    }
    function gM(e) {
      return yM(e) ? (e.nodeName || "").toLowerCase() : "#document"
    }
    function bM(e) {
      var t
      return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
    }
    function vM(e) {
      var t
      return null == (t = (yM(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement
    }
    function yM(e) {
      return e instanceof Node || e instanceof bM(e).Node
    }
    function OM(e) {
      return e instanceof Element || e instanceof bM(e).Element
    }
    function wM(e) {
      return e instanceof HTMLElement || e instanceof bM(e).HTMLElement
    }
    function xM(e) {
      return "undefined" != typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof bM(e).ShadowRoot)
    }
    function kM(e) {
      const { overflow: t, overflowX: n, overflowY: r, display: a } = AM(e)
      return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(a)
    }
    function _M(e) {
      return ["table", "td", "th"].includes(gM(e))
    }
    function SM(e) {
      const t = EM(),
        n = AM(e)
      return (
        "none" !== n.transform ||
        "none" !== n.perspective ||
        (!!n.containerType && "normal" !== n.containerType) ||
        (!t && !!n.backdropFilter && "none" !== n.backdropFilter) ||
        (!t && !!n.filter && "none" !== n.filter) ||
        ["transform", "perspective", "filter"].some((e) => (n.willChange || "").includes(e)) ||
        ["paint", "layout", "strict", "content"].some((e) => (n.contain || "").includes(e))
      )
    }
    function EM() {
      return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none")
    }
    function TM(e) {
      return ["html", "body", "#document"].includes(gM(e))
    }
    function AM(e) {
      return bM(e).getComputedStyle(e)
    }
    function CM(e) {
      return OM(e)
        ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
        : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset }
    }
    function PM(e) {
      if ("html" === gM(e)) return e
      const t = e.assignedSlot || e.parentNode || (xM(e) && e.host) || vM(e)
      return xM(t) ? t.host : t
    }
    function DM(e) {
      const t = PM(e)
      return TM(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : wM(t) && kM(t) ? t : DM(t)
    }
    function RM(e, t, n) {
      var r
      void 0 === t && (t = []), void 0 === n && (n = !0)
      const a = DM(e),
        o = a === (null == (r = e.ownerDocument) ? void 0 : r.body),
        i = bM(a)
      return o
        ? t.concat(i, i.visualViewport || [], kM(a) ? a : [], i.frameElement && n ? RM(i.frameElement) : [])
        : t.concat(a, RM(a, [], n))
    }
    function NM(e) {
      const t = AM(e)
      let n = parseFloat(t.width) || 0,
        r = parseFloat(t.height) || 0
      const a = wM(e),
        o = a ? e.offsetWidth : n,
        i = a ? e.offsetHeight : r,
        s = XI(n) !== o || XI(r) !== i
      return s && ((n = o), (r = i)), { width: n, height: r, $: s }
    }
    function $M(e) {
      return OM(e) ? e : e.contextElement
    }
    function IM(e) {
      const t = $M(e)
      if (!wM(t)) return GI(1)
      const n = t.getBoundingClientRect(),
        { width: r, height: a, $: o } = NM(t)
      let i = (o ? XI(n.width) : n.width) / r,
        s = (o ? XI(n.height) : n.height) / a
      return (i && Number.isFinite(i)) || (i = 1), (s && Number.isFinite(s)) || (s = 1), { x: i, y: s }
    }
    const MM = GI(0)
    function LM(e) {
      const t = bM(e)
      return EM() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : MM
    }
    function QM(e, t, n, r) {
      void 0 === t && (t = !1), void 0 === n && (n = !1)
      const a = e.getBoundingClientRect(),
        o = $M(e)
      let i = GI(1)
      t && (r ? OM(r) && (i = IM(r)) : (i = IM(e)))
      const s = (function (e, t, n) {
        return void 0 === t && (t = !1), !(!n || (t && n !== bM(e))) && t
      })(o, n, r)
        ? LM(o)
        : GI(0)
      let l = (a.left + s.x) / i.x,
        c = (a.top + s.y) / i.y,
        d = a.width / i.x,
        u = a.height / i.y
      if (o) {
        const e = bM(o),
          t = r && OM(r) ? bM(r) : r
        let n = e,
          a = n.frameElement
        for (; a && r && t !== n; ) {
          const e = IM(a),
            t = a.getBoundingClientRect(),
            r = AM(a),
            o = t.left + (a.clientLeft + parseFloat(r.paddingLeft)) * e.x,
            i = t.top + (a.clientTop + parseFloat(r.paddingTop)) * e.y
          ;(l *= e.x), (c *= e.y), (d *= e.x), (u *= e.y), (l += o), (c += i), (n = bM(a)), (a = n.frameElement)
        }
      }
      return uM({ width: d, height: u, x: l, y: c })
    }
    const BM = [":popover-open", ":modal"]
    function jM(e) {
      return BM.some((t) => {
        try {
          return e.matches(t)
        } catch (e) {
          return !1
        }
      })
    }
    function UM(e) {
      return QM(vM(e)).left + CM(e).scrollLeft
    }
    function FM(e, t, n) {
      let r
      if ("viewport" === t)
        r = (function (e, t) {
          const n = bM(e),
            r = vM(e),
            a = n.visualViewport
          let o = r.clientWidth,
            i = r.clientHeight,
            s = 0,
            l = 0
          if (a) {
            ;(o = a.width), (i = a.height)
            const e = EM()
            ;(!e || (e && "fixed" === t)) && ((s = a.offsetLeft), (l = a.offsetTop))
          }
          return { width: o, height: i, x: s, y: l }
        })(e, n)
      else if ("document" === t)
        r = (function (e) {
          const t = vM(e),
            n = CM(e),
            r = e.ownerDocument.body,
            a = WI(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
            o = WI(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight)
          let i = -n.scrollLeft + UM(e)
          const s = -n.scrollTop
          return (
            "rtl" === AM(r).direction && (i += WI(t.clientWidth, r.clientWidth) - a),
            { width: a, height: o, x: i, y: s }
          )
        })(vM(e))
      else if (OM(t))
        r = (function (e, t) {
          const n = QM(e, !0, "fixed" === t),
            r = n.top + e.clientTop,
            a = n.left + e.clientLeft,
            o = wM(e) ? IM(e) : GI(1)
          return { width: e.clientWidth * o.x, height: e.clientHeight * o.y, x: a * o.x, y: r * o.y }
        })(t, n)
      else {
        const n = LM(e)
        r = { ...t, x: t.x - n.x, y: t.y - n.y }
      }
      return uM(r)
    }
    function zM(e, t) {
      const n = PM(e)
      return !(n === t || !OM(n) || TM(n)) && ("fixed" === AM(n).position || zM(n, t))
    }
    function qM(e, t, n) {
      const r = wM(t),
        a = vM(t),
        o = "fixed" === n,
        i = QM(e, !0, o, t)
      let s = { scrollLeft: 0, scrollTop: 0 }
      const l = GI(0)
      if (r || (!r && !o))
        if ((("body" !== gM(t) || kM(a)) && (s = CM(t)), r)) {
          const e = QM(t, !0, o, t)
          ;(l.x = e.x + t.clientLeft), (l.y = e.y + t.clientTop)
        } else a && (l.x = UM(a))
      return { x: i.left + s.scrollLeft - l.x, y: i.top + s.scrollTop - l.y, width: i.width, height: i.height }
    }
    function ZM(e) {
      return "static" === AM(e).position
    }
    function HM(e, t) {
      return wM(e) && "fixed" !== AM(e).position ? (t ? t(e) : e.offsetParent) : null
    }
    function VM(e, t) {
      const n = bM(e)
      if (jM(e)) return n
      if (!wM(e)) {
        let t = PM(e)
        for (; t && !TM(t); ) {
          if (OM(t) && !ZM(t)) return t
          t = PM(t)
        }
        return n
      }
      let r = HM(e, t)
      for (; r && _M(r) && ZM(r); ) r = HM(r, t)
      return r && TM(r) && ZM(r) && !SM(r)
        ? n
        : r ||
            (function (e) {
              let t = PM(e)
              for (; wM(t) && !TM(t); ) {
                if (SM(t)) return t
                t = PM(t)
              }
              return null
            })(e) ||
            n
    }
    const WM = {
      convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
        let { elements: t, rect: n, offsetParent: r, strategy: a } = e
        const o = "fixed" === a,
          i = vM(r),
          s = !!t && jM(t.floating)
        if (r === i || (s && o)) return n
        let l = { scrollLeft: 0, scrollTop: 0 },
          c = GI(1)
        const d = GI(0),
          u = wM(r)
        if ((u || (!u && !o)) && (("body" !== gM(r) || kM(i)) && (l = CM(r)), wM(r))) {
          const e = QM(r)
          ;(c = IM(r)), (d.x = e.x + r.clientLeft), (d.y = e.y + r.clientTop)
        }
        return {
          width: n.width * c.x,
          height: n.height * c.y,
          x: n.x * c.x - l.scrollLeft * c.x + d.x,
          y: n.y * c.y - l.scrollTop * c.y + d.y,
        }
      },
      getDocumentElement: vM,
      getClippingRect: function (e) {
        let { element: t, boundary: n, rootBoundary: r, strategy: a } = e
        const o = [
            ...("clippingAncestors" === n
              ? jM(t)
                ? []
                : (function (e, t) {
                    const n = t.get(e)
                    if (n) return n
                    let r = RM(e, [], !1).filter((e) => OM(e) && "body" !== gM(e)),
                      a = null
                    const o = "fixed" === AM(e).position
                    let i = o ? PM(e) : e
                    for (; OM(i) && !TM(i); ) {
                      const t = AM(i),
                        n = SM(i)
                      n || "fixed" !== t.position || (a = null),
                        (
                          o
                            ? !n && !a
                            : (!n && "static" === t.position && a && ["absolute", "fixed"].includes(a.position)) ||
                              (kM(i) && !n && zM(e, i))
                        )
                          ? (r = r.filter((e) => e !== i))
                          : (a = t),
                        (i = PM(i))
                    }
                    return t.set(e, r), r
                  })(t, this._c)
              : [].concat(n)),
            r,
          ],
          i = o[0],
          s = o.reduce(
            (e, n) => {
              const r = FM(t, n, a)
              return (
                (e.top = WI(r.top, e.top)),
                (e.right = VI(r.right, e.right)),
                (e.bottom = VI(r.bottom, e.bottom)),
                (e.left = WI(r.left, e.left)),
                e
              )
            },
            FM(t, i, a),
          )
        return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top }
      },
      getOffsetParent: VM,
      getElementRects: async function (e) {
        const t = this.getOffsetParent || VM,
          n = this.getDimensions,
          r = await n(e.floating)
        return {
          reference: qM(e.reference, await t(e.floating), e.strategy),
          floating: { x: 0, y: 0, width: r.width, height: r.height },
        }
      },
      getClientRects: function (e) {
        return Array.from(e.getClientRects())
      },
      getDimensions: function (e) {
        const { width: t, height: n } = NM(e)
        return { width: t, height: n }
      },
      getScale: IM,
      isElement: OM,
      isRTL: function (e) {
        return "rtl" === AM(e).direction
      },
    }
    function XM(e, t, n, r) {
      void 0 === r && (r = {})
      const {
          ancestorScroll: a = !0,
          ancestorResize: o = !0,
          elementResize: i = "function" == typeof ResizeObserver,
          layoutShift: s = "function" == typeof IntersectionObserver,
          animationFrame: l = !1,
        } = r,
        c = $M(e),
        d = a || o ? [...(c ? RM(c) : []), ...RM(t)] : []
      d.forEach((e) => {
        a && e.addEventListener("scroll", n, { passive: !0 }), o && e.addEventListener("resize", n)
      })
      const u =
        c && s
          ? (function (e, t) {
              let n,
                r = null
              const a = vM(e)
              function o() {
                var e
                clearTimeout(n), null == (e = r) || e.disconnect(), (r = null)
              }
              return (
                (function i(s, l) {
                  void 0 === s && (s = !1), void 0 === l && (l = 1), o()
                  const { left: c, top: d, width: u, height: p } = e.getBoundingClientRect()
                  if ((s || t(), !u || !p)) return
                  const h = {
                    rootMargin:
                      -YI(d) +
                      "px " +
                      -YI(a.clientWidth - (c + u)) +
                      "px " +
                      -YI(a.clientHeight - (d + p)) +
                      "px " +
                      -YI(c) +
                      "px",
                    threshold: WI(0, VI(1, l)) || 1,
                  }
                  let f = !0
                  function m(e) {
                    const t = e[0].intersectionRatio
                    if (t !== l) {
                      if (!f) return i()
                      t
                        ? i(!1, t)
                        : (n = setTimeout(() => {
                            i(!1, 1e-7)
                          }, 1e3))
                    }
                    f = !1
                  }
                  try {
                    r = new IntersectionObserver(m, { ...h, root: a.ownerDocument })
                  } catch (e) {
                    r = new IntersectionObserver(m, h)
                  }
                  r.observe(e)
                })(!0),
                o
              )
            })(c, n)
          : null
      let p,
        h = -1,
        f = null
      i &&
        ((f = new ResizeObserver((e) => {
          let [r] = e
          r &&
            r.target === c &&
            f &&
            (f.unobserve(t),
            cancelAnimationFrame(h),
            (h = requestAnimationFrame(() => {
              var e
              null == (e = f) || e.observe(t)
            }))),
            n()
        })),
        c && !l && f.observe(c),
        f.observe(t))
      let m = l ? QM(e) : null
      return (
        l &&
          (function t() {
            const r = QM(e)
            !m || (r.x === m.x && r.y === m.y && r.width === m.width && r.height === m.height) || n(),
              (m = r),
              (p = requestAnimationFrame(t))
          })(),
        n(),
        () => {
          var e
          d.forEach((e) => {
            a && e.removeEventListener("scroll", n), o && e.removeEventListener("resize", n)
          }),
            null == u || u(),
            null == (e = f) || e.disconnect(),
            (f = null),
            l && cancelAnimationFrame(p)
        }
      )
    }
    const YM = function (e) {
        return (
          void 0 === e && (e = 0),
          {
            name: "offset",
            options: e,
            async fn(t) {
              var n, r
              const { x: a, y: o, placement: i, middlewareData: s } = t,
                l = await (async function (e, t) {
                  const { placement: n, platform: r, elements: a } = e,
                    o = await (null == r.isRTL ? void 0 : r.isRTL(a.floating)),
                    i = nM(n),
                    s = rM(n),
                    l = "y" === iM(n),
                    c = ["left", "top"].includes(i) ? -1 : 1,
                    d = o && l ? -1 : 1,
                    u = tM(t, e)
                  let {
                    mainAxis: p,
                    crossAxis: h,
                    alignmentAxis: f,
                  } = "number" == typeof u
                    ? { mainAxis: u, crossAxis: 0, alignmentAxis: null }
                    : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...u }
                  return (
                    s && "number" == typeof f && (h = "end" === s ? -1 * f : f),
                    l ? { x: h * d, y: p * c } : { x: p * c, y: h * d }
                  )
                })(t, e)
              return i === (null == (n = s.offset) ? void 0 : n.placement) && null != (r = s.arrow) && r.alignmentOffset
                ? {}
                : { x: a + l.x, y: o + l.y, data: { ...l, placement: i } }
            },
          }
        )
      },
      GM = function (e) {
        return (
          void 0 === e && (e = {}),
          {
            name: "shift",
            options: e,
            async fn(t) {
              const { x: n, y: r, placement: a } = t,
                {
                  mainAxis: o = !0,
                  crossAxis: i = !1,
                  limiter: s = {
                    fn: (e) => {
                      let { x: t, y: n } = e
                      return { x: t, y: n }
                    },
                  },
                  ...l
                } = tM(e, t),
                c = { x: n, y: r },
                d = await hM(t, l),
                u = iM(nM(a)),
                p = aM(u)
              let h = c[p],
                f = c[u]
              if (o) {
                const e = "y" === p ? "bottom" : "right"
                h = eM(h + d["y" === p ? "top" : "left"], h, h - d[e])
              }
              if (i) {
                const e = "y" === u ? "bottom" : "right"
                f = eM(f + d["y" === u ? "top" : "left"], f, f - d[e])
              }
              const m = s.fn({ ...t, [p]: h, [u]: f })
              return { ...m, data: { x: m.x - n, y: m.y - r } }
            },
          }
        )
      },
      KM = function (e) {
        return (
          void 0 === e && (e = {}),
          {
            name: "flip",
            options: e,
            async fn(t) {
              var n, r
              const { placement: a, middlewareData: o, rects: i, initialPlacement: s, platform: l, elements: c } = t,
                {
                  mainAxis: d = !0,
                  crossAxis: u = !0,
                  fallbackPlacements: p,
                  fallbackStrategy: h = "bestFit",
                  fallbackAxisSideDirection: f = "none",
                  flipAlignment: m = !0,
                  ...g
                } = tM(e, t)
              if (null != (n = o.arrow) && n.alignmentOffset) return {}
              const b = nM(a),
                v = nM(s) === s,
                y = await (null == l.isRTL ? void 0 : l.isRTL(c.floating)),
                O =
                  p ||
                  (v || !m
                    ? [cM(s)]
                    : (function (e) {
                        const t = cM(e)
                        return [lM(e), t, lM(t)]
                      })(s))
              p ||
                "none" === f ||
                O.push(
                  ...(function (e, t, n, r) {
                    const a = rM(e)
                    let o = (function (e, t, n) {
                      const r = ["left", "right"],
                        a = ["right", "left"],
                        o = ["top", "bottom"],
                        i = ["bottom", "top"]
                      switch (e) {
                        case "top":
                        case "bottom":
                          return n ? (t ? a : r) : t ? r : a
                        case "left":
                        case "right":
                          return t ? o : i
                        default:
                          return []
                      }
                    })(nM(e), "start" === n, r)
                    return a && ((o = o.map((e) => e + "-" + a)), t && (o = o.concat(o.map(lM)))), o
                  })(s, m, f, y),
                )
              const w = [s, ...O],
                x = await hM(t, g),
                k = []
              let _ = (null == (r = o.flip) ? void 0 : r.overflows) || []
              if ((d && k.push(x[b]), u)) {
                const e = (function (e, t, n) {
                  void 0 === n && (n = !1)
                  const r = rM(e),
                    a = sM(e),
                    o = oM(a)
                  let i =
                    "x" === a ? (r === (n ? "end" : "start") ? "right" : "left") : "start" === r ? "bottom" : "top"
                  return t.reference[o] > t.floating[o] && (i = cM(i)), [i, cM(i)]
                })(a, i, y)
                k.push(x[e[0]], x[e[1]])
              }
              if (((_ = [..._, { placement: a, overflows: k }]), !k.every((e) => e <= 0))) {
                var S, E
                const e = ((null == (S = o.flip) ? void 0 : S.index) || 0) + 1,
                  t = w[e]
                if (t) return { data: { index: e, overflows: _ }, reset: { placement: t } }
                let n =
                  null == (E = _.filter((e) => e.overflows[0] <= 0).sort((e, t) => e.overflows[1] - t.overflows[1])[0])
                    ? void 0
                    : E.placement
                if (!n)
                  switch (h) {
                    case "bestFit": {
                      var T
                      const e =
                        null ==
                        (T = _.map((e) => [
                          e.placement,
                          e.overflows.filter((e) => e > 0).reduce((e, t) => e + t, 0),
                        ]).sort((e, t) => e[1] - t[1])[0])
                          ? void 0
                          : T[0]
                      e && (n = e)
                      break
                    }
                    case "initialPlacement":
                      n = s
                  }
                if (a !== n) return { reset: { placement: n } }
              }
              return {}
            },
          }
        )
      },
      JM = function (e) {
        return (
          void 0 === e && (e = {}),
          {
            name: "size",
            options: e,
            async fn(t) {
              const { placement: n, rects: r, platform: a, elements: o } = t,
                { apply: i = () => {}, ...s } = tM(e, t),
                l = await hM(t, s),
                c = nM(n),
                d = rM(n),
                u = "y" === iM(n),
                { width: p, height: h } = r.floating
              let f, m
              "top" === c || "bottom" === c
                ? ((f = c),
                  (m =
                    d === ((await (null == a.isRTL ? void 0 : a.isRTL(o.floating))) ? "start" : "end")
                      ? "left"
                      : "right"))
                : ((m = c), (f = "end" === d ? "top" : "bottom"))
              const g = h - l.top - l.bottom,
                b = p - l.left - l.right,
                v = VI(h - l[f], g),
                y = VI(p - l[m], b),
                O = !t.middlewareData.shift
              let w = v,
                x = y
              if ((u ? (x = d || O ? VI(y, b) : b) : (w = d || O ? VI(v, g) : g), O && !d)) {
                const e = WI(l.left, 0),
                  t = WI(l.right, 0),
                  n = WI(l.top, 0),
                  r = WI(l.bottom, 0)
                u
                  ? (x = p - 2 * (0 !== e || 0 !== t ? e + t : WI(l.left, l.right)))
                  : (w = h - 2 * (0 !== n || 0 !== r ? n + r : WI(l.top, l.bottom)))
              }
              await i({ ...t, availableWidth: x, availableHeight: w })
              const k = await a.getDimensions(o.floating)
              return p !== k.width || h !== k.height ? { reset: { rects: !0 } } : {}
            },
          }
        )
      },
      eL = function (e) {
        return (
          void 0 === e && (e = {}),
          {
            name: "hide",
            options: e,
            async fn(t) {
              const { rects: n } = t,
                { strategy: r = "referenceHidden", ...a } = tM(e, t)
              switch (r) {
                case "referenceHidden": {
                  const e = fM(await hM(t, { ...a, elementContext: "reference" }), n.reference)
                  return { data: { referenceHiddenOffsets: e, referenceHidden: mM(e) } }
                }
                case "escaped": {
                  const e = fM(await hM(t, { ...a, altBoundary: !0 }), n.floating)
                  return { data: { escapedOffsets: e, escaped: mM(e) } }
                }
                default:
                  return {}
              }
            },
          }
        )
      },
      tL = function (e) {
        return (
          void 0 === e && (e = {}),
          {
            options: e,
            fn(t) {
              const { x: n, y: r, placement: a, rects: o, middlewareData: i } = t,
                { offset: s = 0, mainAxis: l = !0, crossAxis: c = !0 } = tM(e, t),
                d = { x: n, y: r },
                u = iM(a),
                p = aM(u)
              let h = d[p],
                f = d[u]
              const m = tM(s, t),
                g = "number" == typeof m ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m }
              if (l) {
                const e = "y" === p ? "height" : "width",
                  t = o.reference[p] - o.floating[e] + g.mainAxis,
                  n = o.reference[p] + o.reference[e] - g.mainAxis
                h < t ? (h = t) : h > n && (h = n)
              }
              if (c) {
                var b, v
                const e = "y" === p ? "width" : "height",
                  t = ["top", "left"].includes(nM(a)),
                  n =
                    o.reference[u] -
                    o.floating[e] +
                    ((t && (null == (b = i.offset) ? void 0 : b[u])) || 0) +
                    (t ? 0 : g.crossAxis),
                  r =
                    o.reference[u] +
                    o.reference[e] +
                    (t ? 0 : (null == (v = i.offset) ? void 0 : v[u]) || 0) -
                    (t ? g.crossAxis : 0)
                f < n ? (f = n) : f > r && (f = r)
              }
              return { [p]: h, [u]: f }
            },
          }
        )
      }
    function nL(e) {
      if (
        (function (e) {
          return null != e && "object" == typeof e && "$el" in e
        })(e)
      ) {
        const t = e.$el
        return yM(t) && "#comment" === gM(t) ? null : t
      }
      return e
    }
    function rL(e) {
      return "undefined" == typeof window ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
    }
    function aL(e, t) {
      const n = rL(e)
      return Math.round(t * n) / n
    }
    function oL(e, t, n) {
      void 0 === n && (n = {})
      const r = n.whileElementsMounted,
        a = ii(() => {
          var e
          return null == (e = In(n.open)) || e
        }),
        o = ii(() => In(n.middleware)),
        i = ii(() => {
          var e
          return null != (e = In(n.placement)) ? e : "bottom"
        }),
        s = ii(() => {
          var e
          return null != (e = In(n.strategy)) ? e : "absolute"
        }),
        l = ii(() => {
          var e
          return null == (e = In(n.transform)) || e
        }),
        c = ii(() => nL(e.value)),
        d = ii(() => nL(t.value)),
        u = Dn(0),
        p = Dn(0),
        h = Dn(s.value),
        f = Dn(i.value),
        m = Rn({}),
        g = Dn(!1),
        b = ii(() => {
          const e = { position: h.value, left: "0", top: "0" }
          if (!d.value) return e
          const t = aL(d.value, u.value),
            n = aL(d.value, p.value)
          return l.value
            ? {
                ...e,
                transform: "translate(" + t + "px, " + n + "px)",
                ...(rL(d.value) >= 1.5 && { willChange: "transform" }),
              }
            : { position: h.value, left: t + "px", top: n + "px" }
        })
      let v
      function y() {
        null != c.value &&
          null != d.value &&
          ((e, t, n) => {
            const r = new Map(),
              a = { platform: WM, ...n },
              o = { ...a.platform, _c: r }
            return (async (e, t, n) => {
              const { placement: r = "bottom", strategy: a = "absolute", middleware: o = [], platform: i } = n,
                s = o.filter(Boolean),
                l = await (null == i.isRTL ? void 0 : i.isRTL(t))
              let c = await i.getElementRects({ reference: e, floating: t, strategy: a }),
                { x: d, y: u } = pM(c, r, l),
                p = r,
                h = {},
                f = 0
              for (let n = 0; n < s.length; n++) {
                const { name: o, fn: m } = s[n],
                  {
                    x: g,
                    y: b,
                    data: v,
                    reset: y,
                  } = await m({
                    x: d,
                    y: u,
                    initialPlacement: r,
                    placement: p,
                    strategy: a,
                    middlewareData: h,
                    rects: c,
                    platform: i,
                    elements: { reference: e, floating: t },
                  })
                ;(d = null != g ? g : d),
                  (u = null != b ? b : u),
                  (h = { ...h, [o]: { ...h[o], ...v } }),
                  y &&
                    f <= 50 &&
                    (f++,
                    "object" == typeof y &&
                      (y.placement && (p = y.placement),
                      y.rects &&
                        (c =
                          !0 === y.rects
                            ? await i.getElementRects({ reference: e, floating: t, strategy: a })
                            : y.rects),
                      ({ x: d, y: u } = pM(c, p, l))),
                    (n = -1))
              }
              return { x: d, y: u, placement: p, strategy: a, middlewareData: h }
            })(e, t, { ...a, platform: o })
          })(c.value, d.value, { middleware: o.value, placement: i.value, strategy: s.value }).then((e) => {
            ;(u.value = e.x),
              (p.value = e.y),
              (h.value = e.strategy),
              (f.value = e.placement),
              (m.value = e.middlewareData),
              (g.value = !0)
          })
      }
      function O() {
        "function" == typeof v && (v(), (v = void 0))
      }
      return (
        Ya([o, i, s], y, { flush: "sync" }),
        Ya(
          [c, d],
          function () {
            O(), void 0 !== r ? null == c.value || null == d.value || (v = r(c.value, d.value, y)) : y()
          },
          { flush: "sync" },
        ),
        Ya(
          a,
          function () {
            a.value || (g.value = !1)
          },
          { flush: "sync" },
        ),
        dt() && ut(O),
        {
          x: vn(u),
          y: vn(p),
          strategy: vn(h),
          placement: vn(f),
          middlewareData: vn(m),
          isPositioned: vn(g),
          floatingStyles: b,
          update: y,
        }
      )
    }
    const iL = { class: "scalar-app" },
      sL = Hr({
        inheritAttrs: !1,
        __name: "ScalarFloating",
        props: {
          placement: {},
          resize: { type: Boolean },
          middleware: {},
          isOpen: { type: Boolean },
          teleport: { type: [Boolean, String] },
        },
        setup(e) {
          const t = e,
            n = Dn(null),
            r = Dn(null),
            a = ii(() => {
              var e, t
              return ((null == (t = null == (e = r.value) ? void 0 : e.children) ? void 0 : t[0]) || r.value) ?? void 0
            }),
            o = (function (e, t = { enabled: Dn(!0) }) {
              const n = Dn(0),
                r = Dn(0),
                a = Dn()
              return (
                typeof ResizeObserver < "u" &&
                  (a.value = new ResizeObserver(([e]) => {
                    var t, a
                    e &&
                      ((n.value = (null == (t = e.borderBoxSize[0]) ? void 0 : t.inlineSize) ?? 0),
                      (r.value = (null == (a = e.borderBoxSize[0]) ? void 0 : a.blockSize) ?? 0))
                  })),
                Ya(
                  [() => Mn(t.enabled), () => Mn(e)],
                  ([e, t]) => {
                    !t || !a.value || (e ? a.value.observe(t) : a.value.disconnect())
                  },
                  { immediate: !0 },
                ),
                {
                  width: ii(() => (Mn(t.enabled) ? `${n.value}px` : void 0)),
                  height: ii(() => (Mn(t.enabled) ? `${r.value}px` : void 0)),
                }
              )
            })(a, { enabled: ii(() => t.resize) }),
            i = ii(() => ("y" === iM(t.placement || "bottom") ? o.width.value : void 0)),
            s = ii(() => ("x" === iM(t.placement || "bottom") ? o.height.value : void 0)),
            { floatingStyles: l, middlewareData: c } = oL(a, n, {
              placement: ii(() => t.placement),
              whileElementsMounted: XM,
              middleware: ii(() => [YM(5), KM(), GM(), ...(t.middleware ?? [])]),
            })
          return (e, t) => (
            xo(),
            Eo(
              go,
              null,
              [
                Ro(
                  "div",
                  { ref_key: "wrapperRef", ref: r, class: Ge({ contents: !!e.$slots.default }) },
                  [Xr(e.$slots, "default")],
                  2,
                ),
                e.isOpen
                  ? (xo(),
                    To(
                      fo,
                      { key: 0, disabled: !e.teleport, to: "string" == typeof e.teleport ? e.teleport : "body" },
                      [
                        Ro("div", iL, [
                          Ro(
                            "div",
                            { ref_key: "floatingRef", ref: n, class: "relative z-overlay", style: He(In(l)) },
                            [Xr(e.$slots, "floating", { data: In(c), height: s.value, width: i.value })],
                            4,
                          ),
                        ]),
                      ],
                      8,
                      ["disabled", "to"],
                    ))
                  : Qo("", !0),
              ],
              64,
            )
          )
        },
      }),
      lL = Ro("div", { class: "absolute inset-0 -z-1 rounded bg-b-1 shadow-lg brightness-lifted" }, null, -1),
      cL = Hr({
        inheritAttrs: !1,
        __name: "ScalarDropdown",
        props: {
          placement: {},
          resize: { type: Boolean },
          isOpen: { type: Boolean },
          teleport: { type: [Boolean, String] },
        },
        setup: (e) => (e, t) => (
          xo(),
          To(In(jy), null, {
            default: yr(({ open: t }) => [
              No(
                In(sL),
                {
                  isOpen: t ?? e.isOpen,
                  placement: e.placement ?? "bottom-start",
                  resize: e.resize,
                  teleport: e.teleport,
                },
                {
                  floating: yr(({ width: t }) => [
                    No(
                      In(Fy),
                      Fo({ class: "relative flex w-56 flex-col p-0.75", style: { width: t } }, e.$attrs),
                      { default: yr(() => [Xr(e.$slots, "items"), lL]), _: 2 },
                      1040,
                      ["style"],
                    ),
                  ]),
                  default: yr(() => [
                    No(In(Uy), { as: "template" }, { default: yr(() => [Xr(e.$slots, "default")]), _: 3 }),
                  ]),
                  _: 2,
                },
                1032,
                ["isOpen", "placement", "resize", "teleport"],
              ),
            ]),
            _: 3,
          })
        ),
      }),
      dL = { class: "-mx-0.75 my-0.75 h-px bg-border" },
      uL = iw({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", dL)
          },
        ],
      ]),
      pL = Hr({
        __name: "ScalarDropdownItem",
        props: { disabled: { type: Boolean } },
        emits: ["click"],
        setup(e) {
          const t = tw({
            base: [
              "min-w-0 items-center gap-1.5 rounded px-2.5 py-1.5 text-left",
              "truncate text-xs text-c-1",
              "cursor-pointer hover:bg-b-2 hover:text-c-1",
            ],
            variants: { disabled: { true: "pointer-events-none text-c-3" }, active: { true: "bg-b-2 text-c-1" } },
          })
          return (e, n) => (
            xo(),
            To(
              In(zy),
              { disabled: e.disabled },
              {
                default: yr(({ active: r }) => [
                  Ro(
                    "button",
                    {
                      class: Ge(["item", In(nw)("scalar-dropdown-item", In(t)({ active: r, disabled: e.disabled }))]),
                      type: "button",
                      onClick: n[0] || (n[0] = (t) => e.$emit("click", t)),
                    },
                    [Xr(e.$slots, "default")],
                    2,
                  ),
                ]),
                _: 3,
              },
              8,
              ["disabled"],
            )
          )
        },
      }),
      hL = ["ariaDisabled"],
      fL = { class: "sr-only" },
      mL = Hr({
        __name: "ScalarIconButton",
        props: {
          label: {},
          icon: {},
          disabled: { type: Boolean },
          variant: { default: "ghost" },
          size: { default: "md" },
          thickness: {},
        },
        setup(e) {
          const t = tw({
              base: "scalar-icon-button grid aspect-square cursor-pointer rounded",
              variants: {
                size: {
                  xxs: "size-3.5 p-0.5",
                  xs: "size-5 p-1",
                  sm: "size-6 p-1",
                  md: "size-10 p-3",
                  full: "h-full w-full",
                },
                disabled: { true: "cursor-not-allowed shadow-none" },
                variant: lw,
              },
            }),
            n = ii(() => {
              const { class: e, ...t } = ra()
              return { class: e || "", rest: t }
            })
          return (e, r) => (
            xo(),
            Eo(
              "button",
              Fo(n.value.rest, {
                ariaDisabled: e.disabled || void 0,
                class: In(nw)(In(t)({ size: e.size, variant: e.variant, disabled: e.disabled }), n.value.class),
                type: "button",
              }),
              [
                No(In(BI), { icon: e.icon, thickness: e.thickness }, null, 8, ["icon", "thickness"]),
                Ro("span", fL, at(e.label), 1),
              ],
              16,
              hL,
            )
          )
        },
      }),
      gL = { class: "inline-block min-w-0 flex-1 truncate text-c-1" },
      bL = Ro("div", { class: "absolute inset-0 -z-1 rounded bg-b-1 shadow-md brightness-lifted" }, null, -1),
      vL = Hr({
        inheritAttrs: !1,
        __name: "ScalarListbox",
        props: {
          multiple: { type: Boolean, default: !1 },
          options: {},
          modelValue: {},
          fullWidth: { type: Boolean },
          id: {},
          placement: {},
          resize: { type: Boolean },
          isOpen: { type: Boolean },
          teleport: { type: [Boolean, String] },
        },
        emits: ["update:modelValue"],
        setup(e) {
          const t = tw({
            base: [
              "group",
              "flex min-w-0 items-center gap-1.5 rounded px-2 py-1.5 text-left",
              "first-of-type:mt-0.75 last-of-type:mb-0.75",
              "truncate bg-transparent text-c-1",
              "cursor-pointer hover:bg-b-2",
            ],
            variants: {
              selected: { true: "text-c-1" },
              active: { true: "bg-b-2" },
              disabled: { true: "pointer-events-none opacity-50" },
            },
          })
          return (e, n) => (
            xo(),
            To(
              In(Ry),
              {
                as: "div",
                class: Ge([{ "w-full": e.fullWidth }, "text-xs"]),
                modelValue: e.modelValue,
                multiple: e.multiple,
                "onUpdate:modelValue": n[0] || (n[0] = (t) => e.$emit("update:modelValue", t)),
              },
              {
                default: yr(({ open: n }) => [
                  No(
                    In(sL),
                    {
                      isOpen: n ?? e.isOpen,
                      placement: e.placement ?? "bottom-start",
                      resize: e.resize,
                      teleport: e.teleport,
                    },
                    {
                      floating: yr(({ width: n }) => [
                        No(
                          In($y),
                          Fo(
                            { class: "relative flex w-40 flex-col rounded border p-0.75", style: { width: n } },
                            e.$attrs,
                          ),
                          {
                            default: yr(() => [
                              (xo(!0),
                              Eo(
                                go,
                                null,
                                qr(
                                  e.options,
                                  (e) => (
                                    xo(),
                                    To(
                                      In(Iy),
                                      { key: e.id, as: "template", disabled: e.disabled, value: e },
                                      {
                                        default: yr(({ active: n, selected: r }) => [
                                          Ro(
                                            "li",
                                            {
                                              class: Ge(
                                                In(nw)(In(t)({ active: n, selected: r, disabled: e.disabled })),
                                              ),
                                            },
                                            [
                                              Ro(
                                                "div",
                                                {
                                                  class: Ge([
                                                    "flex size-4 items-center justify-center rounded-full p-[3px] group-hover:shadow-border",
                                                    r ? "bg-blue text-b-1" : "text-transparent",
                                                  ]),
                                                },
                                                [
                                                  No(In(BI), {
                                                    class: "relative top-[0.5px] size-2.5",
                                                    icon: "Checkmark",
                                                    thickness: "2.5",
                                                  }),
                                                ],
                                                2,
                                              ),
                                              Ro("span", gL, at(e.label), 1),
                                            ],
                                            2,
                                          ),
                                        ]),
                                        _: 2,
                                      },
                                      1032,
                                      ["disabled", "value"],
                                    )
                                  ),
                                ),
                                128,
                              )),
                              bL,
                            ]),
                            _: 2,
                          },
                          1040,
                          ["style"],
                        ),
                      ]),
                      default: yr(() => [
                        No(
                          In(Ny),
                          { id: e.id, as: "template", class: "justify-start" },
                          { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                          8,
                          ["id"],
                        ),
                      ]),
                      _: 2,
                    },
                    1032,
                    ["isOpen", "placement", "resize", "teleport"],
                  ),
                ]),
                _: 3,
              },
              8,
              ["class", "modelValue", "multiple"],
            )
          )
        },
      }),
      yL = { class: "sr-only" },
      OL = ["value"],
      wL = Hr({
        inheritAttrs: !1,
        __name: "ScalarSearchInput",
        props: { loading: {}, modelValue: {} },
        emits: ["update:modelValue"],
        setup(e, { emit: t }) {
          const n = t
          function r(e) {
            n("update:modelValue", e.target.value)
          }
          const a = ii(() => {
            const { class: e, ...t } = ra()
            return { className: e || "", rest: t }
          })
          return (e, t) => (
            xo(),
            Eo(
              "label",
              Fo(a.value.rest, {
                class: In(nw)(
                  "flex rounded border bg-b-1 text-sm font-medium focus-within:border-c-1",
                  a.value.className,
                ),
              }),
              [
                Ro("span", yL, [Xr(e.$slots, "label", {}, () => [Mo("Enter search")])]),
                Ro(
                  "input",
                  {
                    autocapitalize: "off",
                    autocomplete: "off",
                    autocorrect: "off",
                    class: "flex-1 rounded border-none bg-transparent p-3 outline-none",
                    placeholder: "Search...",
                    spellcheck: "false",
                    type: "text",
                    value: e.modelValue,
                    onInput: r,
                  },
                  null,
                  40,
                  OL,
                ),
                e.loading && e.loading.isLoading
                  ? (xo(),
                    To(In(pw), { key: 0, class: "mr-3 self-center", loadingState: e.loading, size: "20px" }, null, 8, [
                      "loadingState",
                    ]))
                  : e.modelValue
                    ? (xo(),
                      To(In(mL), {
                        key: 1,
                        class: "p-2.5",
                        icon: "Close",
                        label: "Clear Search",
                        thickness: "1.5",
                        onClick: t[0] || (t[0] = (e) => n("update:modelValue", "")),
                      }))
                    : Qo("", !0),
              ],
              16,
            )
          )
        },
      }),
      xL = { class: "contents" },
      kL = { class: "flex h-fit items-center text-sm font-medium text-c-3 group-hover:text-c-1" },
      _L = Ro("span", null, "", -1),
      SL = { class: "flex min-w-0 flex-1 flex-col gap-0.75" },
      EL = { class: "flex items-center gap-1" },
      TL = { class: "flex-1 truncate text-sm font-medium" },
      AL = { key: 0, class: "text-xs text-c-2" },
      CL = { class: "truncate text-xs text-c-2" },
      PL = Hr({
        inheritAttrs: !1,
        __name: "ScalarSearchResultItem",
        props: { icon: {}, active: { type: Boolean } },
        setup(e) {
          const t = ii(() => {
            const { class: e, ...t } = ra()
            return { className: e || "", rest: t }
          })
          return (e, n) => (
            xo(),
            Eo("li", xL, [
              Ro(
                "a",
                Fo(t.value.rest, {
                  class: In(nw)(
                    "group flex cursor-pointer gap-2.5 rounded px-3 py-1.5 no-underline hover:bg-b-2",
                    { "bg-b-2": e.active },
                    t.value.className,
                  ),
                }),
                [
                  Ro("div", kL, [
                    Xr(e.$slots, "icon", {}, () => [
                      e.icon ? (xo(), To(In(BI), { key: 0, icon: e.icon, size: "sm" }, null, 8, ["icon"])) : Qo("", !0),
                    ]),
                    _L,
                  ]),
                  Ro("div", SL, [
                    Ro("div", EL, [
                      Ro("div", TL, [Xr(e.$slots, "default")]),
                      e.$slots.addon ? (xo(), Eo("div", AL, [Xr(e.$slots, "addon")])) : Qo("", !0),
                    ]),
                    Ro("div", CL, [Xr(e.$slots, "description")]),
                  ]),
                ],
                16,
              ),
            ])
          )
        },
      }),
      DL = Ro(
        "div",
        { class: "flex flex-col items-center gap-2 px-3 py-4" },
        [
          Ro("div", { class: "rotate-90 text-lg font-bold" }, ":("),
          Ro("div", { class: "text-sm font-medium text-c-2" }, "No results found"),
        ],
        -1,
      ),
      RL = Hr({
        inheritAttrs: !1,
        __name: "ScalarSearchResultList",
        props: { noResults: { type: Boolean } },
        setup(e) {
          const t = ii(() => {
            const { class: e, ...t } = ra()
            return { className: e || "", rest: t }
          })
          return (e, n) => (
            xo(),
            Eo(
              "ul",
              Fo(t.value.rest, { class: In(nw)("flex flex-col", t.value.className) }),
              [e.noResults ? Xr(e.$slots, "noResults", { key: 0 }, () => [DL]) : Qo("", !0), Xr(e.$slots, "default")],
              16,
            )
          )
        },
      })
    let NL = (e = 21) => {
      let t = "",
        n = crypto.getRandomValues(new Uint8Array(e))
      for (; e--; ) t += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[63 & n[e]]
      return t
    }
    function $L(e, t) {
      const n = Symbol("string" != typeof e || t ? t : `${e}Context`)
      return [
        (t) => {
          const r = xa(n, t)
          if (r || null === r) return r
          throw new Error(
            `Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`,
          )
        },
        (e) => (wa(n, e), e),
      ]
    }
    function IL(e, t, n) {
      const r = n.originalEvent.target,
        a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n })
      t && r.addEventListener(e, t, { once: !0 }), r.dispatchEvent(a)
    }
    function ML(e) {
      return !!dt() && (ut(e), !0)
    }
    function LL(e) {
      return "function" == typeof e ? e() : In(e)
    }
    const QL = typeof window < "u" && typeof document < "u"
    typeof WorkerGlobalScope < "u" && (globalThis, WorkerGlobalScope)
    const BL = Object.prototype.toString,
      jL = (e) => "[object Object]" === BL.call(e),
      UL = () => {}
    function FL(e, t, n = {}) {
      const { immediate: r = !0 } = n,
        a = Dn(!1)
      let o = null
      function i() {
        o && (clearTimeout(o), (o = null))
      }
      function s() {
        ;(a.value = !1), i()
      }
      function l(...n) {
        i(),
          (a.value = !0),
          (o = setTimeout(() => {
            ;(a.value = !1), (o = null), e(...n)
          }, LL(t)))
      }
      return r && ((a.value = !0), QL && l()), ML(s), { isPending: bn(a), start: l, stop: s }
    }
    function zL(e) {
      var t
      const n = LL(e)
      return null != (t = null == n ? void 0 : n.$el) ? t : n
    }
    const qL = QL ? window : void 0
    function ZL(...e) {
      let t, n, r, a
      if (("string" == typeof e[0] || Array.isArray(e[0]) ? (([n, r, a] = e), (t = qL)) : ([t, n, r, a] = e), !t))
        return UL
      Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r])
      const o = [],
        i = () => {
          o.forEach((e) => e()), (o.length = 0)
        },
        s = Ya(
          () => [zL(t), LL(a)],
          ([e, t]) => {
            if ((i(), !e)) return
            const a = jL(t) ? { ...t } : t
            o.push(
              ...n.flatMap((t) =>
                r.map((n) =>
                  ((e, t, n, r) => (e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r)))(e, t, n, a),
                ),
              ),
            )
          },
          { immediate: !0, flush: "post" },
        ),
        l = () => {
          s(), i()
        }
      return ML(l), l
    }
    function HL(e) {
      return e ? e.flatMap((e) => (e.type === go ? HL(e.children) : [e])) : []
    }
    const [VL, WL] = $L("ConfigProvider")
    function XL(e) {
      const t = Vo(),
        n = Object.keys((null == t ? void 0 : t.type.props) ?? {}).reduce((e, n) => {
          const r = (null == t ? void 0 : t.type.props[n]).default
          return void 0 !== r && (e[n] = r), e
        }, {}),
        r = zn(e)
      return ii(() => {
        const e = {},
          a = (null == t ? void 0 : t.vnode.props) ?? {}
        return (
          Object.keys(a).forEach((t) => {
            e[Ie(t)] = a[t]
          }),
          Object.keys({ ...n, ...e }).reduce((e, t) => (void 0 !== r.value[t] && (e[t] = r.value[t]), e), {})
        )
      })
    }
    function YL() {
      const e = Vo(),
        t = Dn(),
        n = ii(() => {
          var e, n
          return ["#text", "#comment"].includes(null == (e = t.value) ? void 0 : e.$el.nodeName)
            ? null == (n = t.value)
              ? void 0
              : n.$el.nextElementSibling
            : zL(t)
        }),
        r = Object.assign({}, e.exposed),
        a = {}
      for (const t in e.props) Object.defineProperty(a, t, { enumerable: !0, configurable: !0, get: () => e.props[t] })
      if (Object.keys(r).length > 0)
        for (const e in r) Object.defineProperty(a, e, { enumerable: !0, configurable: !0, get: () => r[e] })
      return (
        Object.defineProperty(a, "$el", { enumerable: !0, configurable: !0, get: () => e.vnode.el }),
        (e.exposed = a),
        {
          forwardRef: function (n) {
            ;(t.value = n),
              !(n instanceof Element) &&
                n &&
                (Object.defineProperty(a, "$el", { enumerable: !0, configurable: !0, get: () => n.$el }),
                (e.exposed = a))
          },
          currentRef: t,
          currentElement: n,
        }
      )
    }
    function GL(e, t) {
      const n = (function (e, t = 1e4) {
          return (
            (n = (n, r) => {
              let a,
                o = LL(e)
              return (
                ML(() => {
                  clearTimeout(a)
                }),
                {
                  get: () => (n(), o),
                  set(n) {
                    ;(o = n),
                      r(),
                      clearTimeout(a),
                      (a = setTimeout(() => {
                        ;(o = LL(e)), r()
                      }, LL(t)))
                  },
                }
              )
            }),
            new Bn(n)
          )
          var n
        })(!1, 300),
        r = Dn(null),
        a = (function () {
          const e = new Set(),
            t = (t) => {
              e.delete(t)
            }
          return {
            on: (n) => {
              e.add(n)
              const r = () => t(n)
              return ML(r), { off: r }
            },
            off: t,
            trigger: (...t) => Promise.all(Array.from(e).map((e) => e(...t))),
          }
        })()
      function o() {
        ;(r.value = null), (n.value = !1)
      }
      function i(e, t) {
        const a = e.currentTarget,
          o = { x: e.clientX, y: e.clientY },
          i = (function (e, t) {
            const n = Math.abs(t.top - e.y),
              r = Math.abs(t.bottom - e.y),
              a = Math.abs(t.right - e.x),
              o = Math.abs(t.left - e.x)
            switch (Math.min(n, r, a, o)) {
              case o:
                return "left"
              case a:
                return "right"
              case n:
                return "top"
              case r:
                return "bottom"
              default:
                throw new Error("unreachable")
            }
          })(o, a.getBoundingClientRect()),
          s = (function (e, t, n = 5) {
            const r = []
            switch (t) {
              case "top":
                r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n })
                break
              case "bottom":
                r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n })
                break
              case "left":
                r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n })
                break
              case "right":
                r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n })
            }
            return r
          })(o, i),
          l = (function (e) {
            const { top: t, right: n, bottom: r, left: a } = e
            return [
              { x: a, y: t },
              { x: n, y: t },
              { x: n, y: r },
              { x: a, y: r },
            ]
          })(t.getBoundingClientRect()),
          c = (function (e) {
            const t = e.slice()
            return (
              t.sort((e, t) => (e.x < t.x ? -1 : e.x > t.x ? 1 : e.y < t.y ? -1 : e.y > t.y ? 1 : 0)),
              (function (e) {
                if (e.length <= 1) return e.slice()
                const t = []
                for (let n = 0; n < e.length; n++) {
                  const r = e[n]
                  for (; t.length >= 2; ) {
                    const e = t[t.length - 1],
                      n = t[t.length - 2]
                    if (!((e.x - n.x) * (r.y - n.y) >= (e.y - n.y) * (r.x - n.x))) break
                    t.pop()
                  }
                  t.push(r)
                }
                t.pop()
                const n = []
                for (let t = e.length - 1; t >= 0; t--) {
                  const r = e[t]
                  for (; n.length >= 2; ) {
                    const e = n[n.length - 1],
                      t = n[n.length - 2]
                    if (!((e.x - t.x) * (r.y - t.y) >= (e.y - t.y) * (r.x - t.x))) break
                    n.pop()
                  }
                  n.push(r)
                }
                return (
                  n.pop(), 1 === t.length && 1 === n.length && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n)
                )
              })(t)
            )
          })([...s, ...l])
        ;(r.value = c), (n.value = !0)
      }
      return (
        Wa((n) => {
          if (e.value && t.value) {
            const r = (e) => i(e, t.value),
              a = (t) => i(t, e.value)
            e.value.addEventListener("pointerleave", r),
              t.value.addEventListener("pointerleave", a),
              n(() => {
                var n, o
                null == (n = e.value) || n.removeEventListener("pointerleave", r),
                  null == (o = t.value) || o.removeEventListener("pointerleave", a)
              })
          }
        }),
        Wa((n) => {
          if (r.value) {
            const i = (n) => {
              var i, s
              if (!r.value) return
              const l = n.target,
                c = { x: n.clientX, y: n.clientY },
                d =
                  (null == (i = e.value) ? void 0 : i.contains(l)) || (null == (s = t.value) ? void 0 : s.contains(l)),
                u = !(function (e, t) {
                  const { x: n, y: r } = e
                  let a = !1
                  for (let e = 0, o = t.length - 1; e < t.length; o = e++) {
                    const i = t[e].x,
                      s = t[e].y,
                      l = t[o].x,
                      c = t[o].y
                    s > r != c > r && n < ((l - i) * (r - s)) / (c - s) + i && (a = !a)
                  }
                  return a
                })(c, r.value)
              d ? o() : u && (o(), a.trigger())
            }
            document.addEventListener("pointermove", i), n(() => document.removeEventListener("pointermove", i))
          }
        }),
        { isPointerInTransit: n, onPointerExit: a.on }
      )
    }
    let KL = 0
    const JL = Hr({
        name: "PrimitiveSlot",
        inheritAttrs: !1,
        setup:
          (e, { attrs: t, slots: n }) =>
          () => {
            var e, r
            if (!n.default) return null
            const a = HL(n.default()),
              o = a.findIndex((e) => e.type !== vo)
            if (-1 === o) return a
            const i = a[o]
            null == (e = i.props) || delete e.ref
            const s = i.props ? Fo(t, i.props) : t
            t.class && null != (r = i.props) && r.class && delete i.props.class
            const l = Io(i, s)
            for (const e in s) e.startsWith("on") && (l.props || (l.props = {}), (l.props[e] = s[e]))
            return 1 === a.length ? l : ((a[o] = l), a)
          },
      }),
      eQ = Hr({
        name: "Primitive",
        inheritAttrs: !1,
        props: { asChild: { type: Boolean, default: !1 }, as: { type: [String, Object], default: "div" } },
        setup(e, { attrs: t, slots: n }) {
          const r = e.asChild ? "template" : e.as
          return "string" == typeof r && ["area", "img", "input"].includes(r)
            ? () => si(r, t)
            : "template" !== r
              ? () => si(e.as, t, { default: n.default })
              : () => si(JL, t, { default: n.default })
        },
      })
    function tQ(e) {
      return (e && getComputedStyle(e).animationName) || "none"
    }
    const nQ = Hr({
        name: "Presence",
        props: { present: { type: Boolean, required: !0 }, forceMount: { type: Boolean } },
        slots: {},
        setup(e, { slots: t, expose: n }) {
          var r
          const { present: a, forceMount: o } = jn(e),
            i = Dn(),
            { isPresent: s } = (function (e, t) {
              const n = Dn({}),
                r = Dn("none"),
                a = e.value ? "mounted" : "unmounted",
                { state: o, dispatch: i } = (function (e, t) {
                  const n = Dn(e)
                  return {
                    state: n,
                    dispatch: (e) => {
                      n.value = (function (e) {
                        return t[n.value][e] ?? n.value
                      })(e)
                    },
                  }
                })(a, {
                  mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
                  unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
                  unmounted: { MOUNT: "mounted" },
                }),
                s = (e) => {
                  var n
                  if (QL) {
                    const r = new CustomEvent(e, { bubbles: !1, cancelable: !1 })
                    null == (n = t.value) || n.dispatchEvent(r)
                  }
                }
              Ya(
                e,
                async (e, a) => {
                  var o
                  const l = a !== e
                  if ((await rr(), l)) {
                    const l = r.value,
                      c = tQ(t.value)
                    e
                      ? (i("MOUNT"), s("enter"), "none" === c && s("after-enter"))
                      : "none" === c || "none" === (null == (o = n.value) ? void 0 : o.display)
                        ? (i("UNMOUNT"), s("leave"), s("after-leave"))
                        : a && l !== c
                          ? (i("ANIMATION_OUT"), s("leave"))
                          : (i("UNMOUNT"), s("after-leave"))
                  }
                },
                { immediate: !0 },
              )
              const l = (e) => {
                  const n = tQ(t.value),
                    r = n.includes(e.animationName),
                    a = "mounted" === o.value ? "enter" : "leave"
                  e.target === t.value && r && (s(`after-${a}`), i("ANIMATION_END")),
                    e.target === t.value && "none" === n && i("ANIMATION_END")
                },
                c = (e) => {
                  e.target === t.value && (r.value = tQ(t.value))
                },
                d = Ya(
                  t,
                  (e, t) => {
                    e
                      ? ((n.value = getComputedStyle(e)),
                        e.addEventListener("animationstart", c),
                        e.addEventListener("animationcancel", l),
                        e.addEventListener("animationend", l))
                      : (i("ANIMATION_END"),
                        null == t || t.removeEventListener("animationstart", c),
                        null == t || t.removeEventListener("animationcancel", l),
                        null == t || t.removeEventListener("animationend", l))
                  },
                  { immediate: !0 },
                ),
                u = Ya(o, () => {
                  const e = tQ(t.value)
                  r.value = "mounted" === o.value ? e : "none"
                })
              return (
                Lr(() => {
                  d(), u()
                }),
                { isPresent: ii(() => ["mounted", "unmountSuspended"].includes(o.value)) }
              )
            })(a, i)
          n({ present: s })
          let l = t.default({ present: s })
          l = HL(l || [])
          const c = Vo()
          if (l && (null == l ? void 0 : l.length) > 1) {
            const e =
              null != (r = null == c ? void 0 : c.parent) && r.type.name ? `<${c.parent.type.name} />` : "component"
            throw new Error(
              [
                `Detected an invalid children for \`${e}\` for  \`Presence\` component.`,
                "",
                "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
                "You can apply a few solutions:",
                [
                  "Provide a single child element so that `presence` directive attach correctly.",
                  "Ensure the first child is an actual element instead of a raw text node or comment node.",
                ]
                  .map((e) => `  - ${e}`)
                  .join("\n"),
              ].join("\n"),
            )
          }
          return () =>
            o.value || a.value || s.value
              ? si(t.default({ present: s })[0], {
                  ref: (e) => {
                    const t = zL(e)
                    return (
                      typeof (null == t ? void 0 : t.hasAttribute) > "u" ||
                        (null != t && t.hasAttribute("data-radix-popper-content-wrapper")
                          ? (i.value = t.firstElementChild)
                          : (i.value = t)),
                      t
                    )
                  },
                })
              : null
        },
      }),
      rQ = Hr({
        __name: "Teleport",
        props: { to: { default: "body" }, disabled: { type: Boolean }, forceMount: { type: Boolean } },
        setup(e) {
          const t = (function () {
            const e = Dn(!1),
              t = Vo()
            return (
              t &&
                Nr(() => {
                  e.value = !0
                }, t),
              e
            )
          })()
          return (e, n) =>
            In(t) || e.forceMount
              ? (xo(),
                To(fo, { key: 0, to: e.to, disabled: e.disabled }, [Xr(e.$slots, "default")], 8, ["to", "disabled"]))
              : Qo("", !0)
        },
      })
    function aQ(e, t) {
      const n = t.closest("[data-dismissable-layer]"),
        r = "" === e.dataset.dismissableLayer ? e : e.querySelector("[data-dismissable-layer]"),
        a = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"))
      return !!((n && r === n) || a.indexOf(r) < a.indexOf(n))
    }
    const oQ = mn({ layersRoot: new Set(), layersWithOutsidePointerEventsDisabled: new Set(), branches: new Set() }),
      iQ = Hr({
        __name: "DismissableLayer",
        props: { disableOutsidePointerEvents: { type: Boolean, default: !1 }, asChild: { type: Boolean }, as: {} },
        emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            { forwardRef: a, currentElement: o } = YL(),
            i = ii(() => {
              var e
              return (null == (e = o.value) ? void 0 : e.ownerDocument) ?? globalThis.document
            }),
            s = ii(() => oQ.layersRoot),
            l = ii(() => (o.value ? Array.from(s.value).indexOf(o.value) : -1)),
            c = ii(() => oQ.layersWithOutsidePointerEventsDisabled.size > 0),
            d = ii(() => {
              const e = Array.from(s.value),
                [t] = [...oQ.layersWithOutsidePointerEventsDisabled].slice(-1),
                n = e.indexOf(t)
              return l.value >= n
            }),
            u = (function (e, t) {
              var n
              const r =
                  (null == (n = null == t ? void 0 : t.value) ? void 0 : n.ownerDocument) ??
                  (null == globalThis ? void 0 : globalThis.document),
                a = Dn(!1),
                o = Dn(() => {})
              return (
                Wa((n) => {
                  if (!QL) return
                  const i = async (n) => {
                      const i = n.target
                      if (null != t && t.value) {
                        if (aQ(t.value, i)) return void (a.value = !1)
                        if (n.target && !a.value) {
                          let t = function () {
                            IL("dismissableLayer.pointerDownOutside", e, a)
                          }
                          const a = { originalEvent: n }
                          "touch" === n.pointerType
                            ? (r.removeEventListener("click", o.value),
                              (o.value = t),
                              r.addEventListener("click", o.value, { once: !0 }))
                            : t()
                        } else r.removeEventListener("click", o.value)
                        a.value = !1
                      }
                    },
                    s = window.setTimeout(() => {
                      r.addEventListener("pointerdown", i)
                    }, 0)
                  n(() => {
                    window.clearTimeout(s),
                      r.removeEventListener("pointerdown", i),
                      r.removeEventListener("click", o.value)
                  })
                }),
                { onPointerDownCapture: () => (a.value = !0) }
              )
            })(async (e) => {
              const t = [...oQ.branches].some((t) => t.contains(e.target))
              !d.value ||
                t ||
                (r("pointerDownOutside", e), r("interactOutside", e), await rr(), e.defaultPrevented || r("dismiss"))
            }, o),
            p = (function (e, t) {
              var n
              const r =
                  (null == (n = null == t ? void 0 : t.value) ? void 0 : n.ownerDocument) ??
                  (null == globalThis ? void 0 : globalThis.document),
                a = Dn(!1)
              return (
                Wa((n) => {
                  if (!QL) return
                  const o = async (n) => {
                    null != t &&
                      t.value &&
                      (await rr(),
                      t.value &&
                        !aQ(t.value, n.target) &&
                        n.target &&
                        !a.value &&
                        IL("dismissableLayer.focusOutside", e, { originalEvent: n }))
                  }
                  r.addEventListener("focusin", o), n(() => r.removeEventListener("focusin", o))
                }),
                { onFocusCapture: () => (a.value = !0), onBlurCapture: () => (a.value = !1) }
              )
            })((e) => {
              ;[...oQ.branches].some((t) => t.contains(e.target)) ||
                (r("focusOutside", e), r("interactOutside", e), e.defaultPrevented || r("dismiss"))
            }, o)
          let h
          return (
            (function (...e) {
              let t,
                n,
                r = {}
              3 === e.length
                ? ((t = e[0]), (n = e[1]), (r = e[2]))
                : 2 === e.length
                  ? "object" == typeof e[1]
                    ? ((t = !0), (n = e[0]), (r = e[1]))
                    : ((t = e[0]), (n = e[1]))
                  : ((t = !0), (n = e[0]))
              const { target: a = qL, eventName: o = "keydown", passive: i = !1, dedupe: s = !1 } = r,
                l = (function (e) {
                  return "function" == typeof e
                    ? e
                    : "string" == typeof e
                      ? (t) => t.key === e
                      : Array.isArray(e)
                        ? (t) => e.includes(t.key)
                        : () => !0
                })(t)
              ZL(
                a,
                o,
                (e) => {
                  ;(e.repeat && LL(s)) || (l(e) && n(e))
                },
                i,
              )
            })("Escape", (e) => {
              l.value === s.value.size - 1 && (r("escapeKeyDown", e), e.defaultPrevented || r("dismiss"))
            }),
            Wa((e) => {
              o.value &&
                (n.disableOutsidePointerEvents &&
                  (0 === oQ.layersWithOutsidePointerEventsDisabled.size &&
                    ((h = i.value.body.style.pointerEvents), (i.value.body.style.pointerEvents = "none")),
                  oQ.layersWithOutsidePointerEventsDisabled.add(o.value)),
                s.value.add(o.value),
                e(() => {
                  n.disableOutsidePointerEvents &&
                    1 === oQ.layersWithOutsidePointerEventsDisabled.size &&
                    (i.value.body.style.pointerEvents = h)
                }))
            }),
            Wa((e) => {
              e(() => {
                o.value && (s.value.delete(o.value), oQ.layersWithOutsidePointerEventsDisabled.delete(o.value))
              })
            }),
            (e, t) => (
              xo(),
              To(
                In(eQ),
                {
                  ref: In(a),
                  "as-child": e.asChild,
                  as: e.as,
                  "data-dismissable-layer": "",
                  style: He({ pointerEvents: c.value ? (d.value ? "auto" : "none") : void 0 }),
                  onFocusCapture: In(p).onFocusCapture,
                  onBlurCapture: In(p).onBlurCapture,
                  onPointerdownCapture: In(u).onPointerDownCapture,
                },
                { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                8,
                ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"],
              )
            )
          )
        },
      })
    new ct(!0)
    const [sQ, lQ] = $L("PopperRoot"),
      cQ = Hr({
        __name: "PopperRoot",
        setup(e) {
          const t = Dn()
          return lQ({ anchor: t, onAnchorChange: (e) => (t.value = e) }), (e, t) => Xr(e.$slots, "default")
        },
      }),
      dQ = Hr({
        __name: "PopperAnchor",
        props: { element: {}, asChild: { type: Boolean }, as: {} },
        setup(e) {
          const t = e,
            { forwardRef: n, currentElement: r } = YL(),
            a = sQ()
          return (
            Ya(r, () => {
              a.onAnchorChange(t.element ?? r.value)
            }),
            (e, t) => (
              xo(),
              To(
                In(eQ),
                { ref: In(n), as: e.as, "as-child": e.asChild },
                { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                8,
                ["as", "as-child"],
              )
            )
          )
        },
      })
    function uQ(e) {
      return null !== e
    }
    function pQ(e) {
      return {
        name: "transformOrigin",
        options: e,
        fn(t) {
          var n, r, a
          const { placement: o, rects: i, middlewareData: s } = t,
            l = 0 !== (null == (n = s.arrow) ? void 0 : n.centerOffset),
            c = l ? 0 : e.arrowWidth,
            d = l ? 0 : e.arrowHeight,
            [u, p] = hQ(o),
            h = { start: "0%", center: "50%", end: "100%" }[p],
            f = ((null == (r = s.arrow) ? void 0 : r.x) ?? 0) + c / 2,
            m = ((null == (a = s.arrow) ? void 0 : a.y) ?? 0) + d / 2
          let g = "",
            b = ""
          return (
            "bottom" === u
              ? ((g = l ? h : `${f}px`), (b = -d + "px"))
              : "top" === u
                ? ((g = l ? h : `${f}px`), (b = `${i.floating.height + d}px`))
                : "right" === u
                  ? ((g = -d + "px"), (b = l ? h : `${m}px`))
                  : "left" === u && ((g = `${i.floating.width + d}px`), (b = l ? h : `${m}px`)),
            { data: { x: g, y: b } }
          )
        },
      }
    }
    function hQ(e) {
      const [t, n = "center"] = e.split("-")
      return [t, n]
    }
    const [fQ, mQ] = $L("PopperContent"),
      gQ = Hr({
        inheritAttrs: !1,
        __name: "PopperContent",
        props: (function (e, t) {
          const n = oa(e)
          for (const e in t) {
            if (e.startsWith("__skip")) continue
            let r = n[e]
            r
              ? ve(r) || xe(r)
                ? (r = n[e] = { type: r, default: t[e] })
                : (r.default = t[e])
              : null === r && (r = n[e] = { default: t[e] }),
              r && t[`__skip_${e}`] && (r.skipFactory = !0)
          }
          return n
        })(
          {
            side: {},
            sideOffset: {},
            align: {},
            alignOffset: {},
            avoidCollisions: { type: Boolean },
            collisionBoundary: {},
            collisionPadding: {},
            arrowPadding: {},
            sticky: {},
            hideWhenDetached: { type: Boolean },
            updatePositionStrategy: {},
            prioritizePosition: { type: Boolean },
            asChild: { type: Boolean },
            as: {},
          },
          {
            side: "bottom",
            sideOffset: 0,
            align: "center",
            alignOffset: 0,
            arrowPadding: 0,
            avoidCollisions: !0,
            collisionBoundary: () => [],
            collisionPadding: 0,
            sticky: "partial",
            hideWhenDetached: !1,
            updatePositionStrategy: "optimized",
            prioritizePosition: !1,
          },
        ),
        emits: ["placed"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = sQ(),
            { forwardRef: o, currentElement: i } = YL(),
            s = Dn(),
            l = Dn(),
            { width: c, height: d } = (function (e) {
              const t = Dn(),
                n = ii(() => {
                  var e
                  return (null == (e = t.value) ? void 0 : e.width) ?? 0
                }),
                r = ii(() => {
                  var e
                  return (null == (e = t.value) ? void 0 : e.height) ?? 0
                })
              return (
                Nr(() => {
                  const n = zL(e)
                  if (n) {
                    t.value = { width: n.offsetWidth, height: n.offsetHeight }
                    const e = new ResizeObserver((e) => {
                      if (!Array.isArray(e) || !e.length) return
                      const r = e[0]
                      let a, o
                      if ("borderBoxSize" in r) {
                        const e = r.borderBoxSize,
                          t = Array.isArray(e) ? e[0] : e
                        ;(a = t.inlineSize), (o = t.blockSize)
                      } else (a = n.offsetWidth), (o = n.offsetHeight)
                      t.value = { width: a, height: o }
                    })
                    return e.observe(n, { box: "border-box" }), () => e.unobserve(n)
                  }
                  t.value = void 0
                }),
                { width: n, height: r }
              )
            })(l),
            u = ii(() => n.side + ("center" !== n.align ? `-${n.align}` : "")),
            p = ii(() =>
              "number" == typeof n.collisionPadding
                ? n.collisionPadding
                : { top: 0, right: 0, bottom: 0, left: 0, ...n.collisionPadding },
            ),
            h = ii(() => (Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary])),
            f = ii(() => ({ padding: p.value, boundary: h.value.filter(uQ), altBoundary: h.value.length > 0 })),
            m = (function (e, t) {
              const n = Rn()
              return (
                Wa(
                  () => {
                    n.value = e()
                  },
                  { flush: "sync" },
                ),
                bn(n)
              )
            })(() => {
              return [
                YM({ mainAxis: n.sideOffset + d.value, alignmentAxis: n.alignOffset }),
                n.prioritizePosition && n.avoidCollisions && KM({ ...f.value }),
                n.avoidCollisions &&
                  GM({
                    mainAxis: !0,
                    crossAxis: !!n.prioritizePosition,
                    limiter: "partial" === n.sticky ? tL() : void 0,
                    ...f.value,
                  }),
                !n.prioritizePosition && n.avoidCollisions && KM({ ...f.value }),
                JM({
                  ...f.value,
                  apply: ({ elements: e, rects: t, availableWidth: n, availableHeight: r }) => {
                    const { width: a, height: o } = t.reference,
                      i = e.floating.style
                    Object.assign(e.floating.style, { maxWidth: `${n}px`, maxHeight: `${r}px` }),
                      i.setProperty("--radix-popper-available-width", `${n}px`),
                      i.setProperty("--radix-popper-available-height", `${r}px`),
                      i.setProperty("--radix-popper-anchor-width", `${a}px`),
                      i.setProperty("--radix-popper-anchor-height", `${o}px`)
                  },
                }),
                l.value &&
                  ((e = { element: l.value, padding: n.arrowPadding }),
                  {
                    name: "arrow",
                    options: e,
                    fn(t) {
                      const n = nL(In(e.element))
                      return null == n
                        ? {}
                        : ((e) => ({
                            name: "arrow",
                            options: e,
                            async fn(t) {
                              const {
                                  x: n,
                                  y: r,
                                  placement: a,
                                  rects: o,
                                  platform: i,
                                  elements: s,
                                  middlewareData: l,
                                } = t,
                                { element: c, padding: d = 0 } = tM(e, t) || {}
                              if (null == c) return {}
                              const u = dM(d),
                                p = { x: n, y: r },
                                h = sM(a),
                                f = oM(h),
                                m = await i.getDimensions(c),
                                g = "y" === h,
                                b = g ? "top" : "left",
                                v = g ? "bottom" : "right",
                                y = g ? "clientHeight" : "clientWidth",
                                O = o.reference[f] + o.reference[h] - p[h] - o.floating[f],
                                w = p[h] - o.reference[h],
                                x = await (null == i.getOffsetParent ? void 0 : i.getOffsetParent(c))
                              let k = x ? x[y] : 0
                              ;(k && (await (null == i.isElement ? void 0 : i.isElement(x)))) ||
                                (k = s.floating[y] || o.floating[f])
                              const _ = O / 2 - w / 2,
                                S = k / 2 - m[f] / 2 - 1,
                                E = VI(u[b], S),
                                T = VI(u[v], S),
                                A = E,
                                C = k - m[f] - T,
                                P = k / 2 - m[f] / 2 + _,
                                D = eM(A, P, C),
                                R =
                                  !l.arrow &&
                                  null != rM(a) &&
                                  P !== D &&
                                  o.reference[f] / 2 - (P < A ? E : T) - m[f] / 2 < 0,
                                N = R ? (P < A ? P - A : P - C) : 0
                              return {
                                [h]: p[h] + N,
                                data: { [h]: D, centerOffset: P - D - N, ...(R && { alignmentOffset: N }) },
                                reset: R,
                              }
                            },
                          }))({ element: n, padding: e.padding }).fn(t)
                    },
                  }),
                pQ({ arrowWidth: c.value, arrowHeight: d.value }),
                n.hideWhenDetached && eL({ strategy: "referenceHidden", ...f.value }),
              ]
              var e
            }),
            {
              floatingStyles: g,
              placement: b,
              isPositioned: v,
              middlewareData: y,
            } = oL(a.anchor, s, {
              strategy: "fixed",
              placement: u,
              whileElementsMounted: (...e) => XM(...e, { animationFrame: "always" === n.updatePositionStrategy }),
              middleware: m,
            }),
            O = ii(() => hQ(b.value)[0]),
            w = ii(() => hQ(b.value)[1])
          Wa(() => {
            v.value && r("placed")
          })
          const x = ii(() => {
              var e
              return 0 !== (null == (e = y.value.arrow) ? void 0 : e.centerOffset)
            }),
            k = Dn("")
          Wa(() => {
            i.value && (k.value = window.getComputedStyle(i.value).zIndex)
          })
          const _ = ii(() => {
              var e
              return (null == (e = y.value.arrow) ? void 0 : e.x) ?? 0
            }),
            S = ii(() => {
              var e
              return (null == (e = y.value.arrow) ? void 0 : e.y) ?? 0
            })
          return (
            mQ({ placedSide: O, onArrowChange: (e) => (l.value = e), arrowX: _, arrowY: S, shouldHideArrow: x }),
            (e, t) => {
              var r, a, i
              return (
                xo(),
                Eo(
                  "div",
                  {
                    ref_key: "floatingRef",
                    ref: s,
                    "data-radix-popper-content-wrapper": "",
                    style: He({
                      ...In(g),
                      transform: In(v) ? In(g).transform : "translate(0, -200%)",
                      minWidth: "max-content",
                      zIndex: k.value,
                      "--radix-popper-transform-origin": [
                        null == (r = In(y).transformOrigin) ? void 0 : r.x,
                        null == (a = In(y).transformOrigin) ? void 0 : a.y,
                      ].join(" "),
                      ...((null == (i = In(y).hide) ? void 0 : i.referenceHidden) && {
                        visibility: "hidden",
                        pointerEvents: "none",
                      }),
                    }),
                  },
                  [
                    No(
                      In(eQ),
                      Fo({ ref: In(o) }, e.$attrs, {
                        "as-child": n.asChild,
                        as: e.as,
                        "data-side": O.value,
                        "data-align": w.value,
                        style: { animation: In(v) ? void 0 : "none" },
                      }),
                      { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                      16,
                      ["as-child", "as", "data-side", "data-align", "style"],
                    ),
                  ],
                  4,
                )
              )
            }
          )
        },
      }),
      bQ = Hr({
        __name: "VisuallyHidden",
        props: { asChild: { type: Boolean }, as: { default: "span" } },
        setup: (e) => (
          YL(),
          (e, t) => (
            xo(),
            To(
              In(eQ),
              {
                as: e.as,
                "as-child": e.asChild,
                style: He({
                  position: "absolute",
                  border: 0,
                  width: "1px",
                  display: "inline-block",
                  height: "1px",
                  padding: 0,
                  margin: "-1px",
                  overflow: "hidden",
                  clip: "rect(0, 0, 0, 0)",
                  whiteSpace: "nowrap",
                  wordWrap: "normal",
                }),
              },
              { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
              8,
              ["as", "as-child", "style"],
            )
          )
        ),
      })
    "function" == typeof matchMedia && matchMedia("(pointer:coarse)").matches
    const vQ = "tooltip.open",
      [yQ, OQ] = $L("TooltipProvider"),
      wQ = Hr({
        __name: "TooltipProvider",
        props: {
          delayDuration: { default: 700 },
          skipDelayDuration: { default: 300 },
          disableHoverableContent: { type: Boolean, default: !1 },
          disableClosingTrigger: { type: Boolean },
          disabled: { type: Boolean },
          ignoreNonKeyboardFocus: { type: Boolean, default: !1 },
        },
        setup(e) {
          const t = e,
            {
              delayDuration: n,
              skipDelayDuration: r,
              disableHoverableContent: a,
              disableClosingTrigger: o,
              ignoreNonKeyboardFocus: i,
              disabled: s,
            } = jn(t)
          YL()
          const l = Dn(!0),
            c = Dn(!1),
            { start: d, stop: u } = FL(
              () => {
                l.value = !0
              },
              r,
              { immediate: !1 },
            )
          return (
            OQ({
              isOpenDelayed: l,
              delayDuration: n,
              onOpen() {
                u(), (l.value = !1)
              },
              onClose() {
                d()
              },
              isPointerInTransitRef: c,
              disableHoverableContent: a,
              disableClosingTrigger: o,
              disabled: s,
              ignoreNonKeyboardFocus: i,
            }),
            (e, t) => Xr(e.$slots, "default")
          )
        },
      }),
      [xQ, kQ] = $L("TooltipRoot"),
      _Q = Hr({
        __name: "TooltipRoot",
        props: {
          defaultOpen: { type: Boolean, default: !1 },
          open: { type: Boolean, default: void 0 },
          delayDuration: { default: void 0 },
          disableHoverableContent: { type: Boolean, default: void 0 },
          disableClosingTrigger: { type: Boolean, default: void 0 },
          disabled: { type: Boolean, default: void 0 },
          ignoreNonKeyboardFocus: { type: Boolean, default: void 0 },
        },
        emits: ["update:open"],
        setup(e, { emit: t }) {
          const n = e,
            r = t
          YL()
          const a = yQ(),
            o = ii(() => n.disableHoverableContent ?? a.disableHoverableContent.value),
            i = ii(() => n.disableClosingTrigger ?? a.disableClosingTrigger.value),
            s = ii(() => n.disabled ?? a.disabled.value),
            l = ii(() => n.delayDuration ?? a.delayDuration.value),
            c = ii(() => n.ignoreNonKeyboardFocus ?? a.ignoreNonKeyboardFocus.value),
            d = (function (e, t, n, r = {}) {
              var a, o, i
              const { clone: s = !1, passive: l = !1, eventName: c, deep: d = !1, defaultValue: u, shouldEmit: p } = r,
                h = Vo(),
                f =
                  n ||
                  (null == h ? void 0 : h.emit) ||
                  (null == (a = null == h ? void 0 : h.$emit) ? void 0 : a.bind(h)) ||
                  (null == (i = null == (o = null == h ? void 0 : h.proxy) ? void 0 : o.$emit)
                    ? void 0
                    : i.bind(null == h ? void 0 : h.proxy))
              let m = c
              m = m || `update:${t.toString()}`
              const g = (e) =>
                  s
                    ? "function" == typeof s
                      ? s(e)
                      : (function (e) {
                          return JSON.parse(JSON.stringify(e))
                        })(e)
                    : e,
                b = () => (((e) => typeof e < "u")(e[t]) ? g(e[t]) : u),
                v = (e) => {
                  p ? p(e) && f(m, e) : f(m, e)
                }
              if (l) {
                const n = Dn(b())
                let r = !1
                return (
                  Ya(
                    () => e[t],
                    (e) => {
                      r || ((r = !0), (n.value = g(e)), rr(() => (r = !1)))
                    },
                  ),
                  Ya(
                    n,
                    (n) => {
                      !r && (n !== e[t] || d) && v(n)
                    },
                    { deep: d },
                  ),
                  n
                )
              }
              return ii({
                get: () => b(),
                set(e) {
                  v(e)
                },
              })
            })(n, "open", r, { defaultValue: n.defaultOpen, passive: void 0 === n.open })
          Ya(d, (e) => {
            a.onClose && (e ? (a.onOpen(), document.dispatchEvent(new CustomEvent(vQ))) : a.onClose())
          })
          const u = Dn(!1),
            p = Dn(),
            h = ii(() => (d.value ? (u.value ? "delayed-open" : "instant-open") : "closed")),
            { start: f, stop: m } = FL(
              () => {
                ;(u.value = !0), (d.value = !0)
              },
              l,
              { immediate: !1 },
            )
          function g() {
            m(), (u.value = !1), (d.value = !0)
          }
          function b() {
            m(), (d.value = !1)
          }
          return (
            kQ({
              contentId: "",
              open: d,
              stateAttribute: h,
              trigger: p,
              onTriggerChange(e) {
                p.value = e
              },
              onTriggerEnter() {
                a.isOpenDelayed.value ? f() : g()
              },
              onTriggerLeave() {
                o.value ? b() : m()
              },
              onOpen: g,
              onClose: b,
              disableHoverableContent: o,
              disableClosingTrigger: i,
              disabled: s,
              ignoreNonKeyboardFocus: c,
            }),
            (e, t) => (xo(), To(In(cQ), null, { default: yr(() => [Xr(e.$slots, "default", { open: In(d) })]), _: 3 }))
          )
        },
      }),
      SQ = Hr({
        __name: "TooltipTrigger",
        props: { asChild: { type: Boolean }, as: { default: "button" } },
        setup(e) {
          const t = e,
            n = xQ(),
            r = yQ()
          n.contentId ||
            (n.contentId = (function (e, t = "radix") {
              const { useId: n } = VL({ useId: void 0 })
              return n && "function" == typeof n ? `${t}-${n()}` : `${t}-${++KL}`
            })(0, "radix-vue-tooltip-content"))
          const { forwardRef: a, currentElement: o } = YL(),
            i = Dn(!1),
            s = Dn(!1),
            l = ii(() =>
              n.disabled.value ? {} : { click: m, focus: h, pointermove: u, pointerleave: p, pointerdown: d, blur: f },
            )
          function c() {
            i.value = !1
          }
          function d() {
            ;(i.value = !0), document.addEventListener("pointerup", c, { once: !0 })
          }
          function u(e) {
            "touch" !== e.pointerType &&
              !s.value &&
              !r.isPointerInTransitRef.value &&
              (n.onTriggerEnter(), (s.value = !0))
          }
          function p() {
            n.onTriggerLeave(), (s.value = !1)
          }
          function h(e) {
            var t, r
            i.value ||
              (n.ignoreNonKeyboardFocus.value &&
                (null == (r = (t = e.target).matches) || !r.call(t, ":focus-visible"))) ||
              n.onOpen()
          }
          function f() {
            n.onClose()
          }
          function m() {
            n.disableClosingTrigger.value || n.onClose()
          }
          return (
            Nr(() => {
              n.onTriggerChange(o.value)
            }),
            (e, r) => (
              xo(),
              To(
                In(dQ),
                { "as-child": "" },
                {
                  default: yr(() => [
                    No(
                      In(eQ),
                      Fo(
                        {
                          ref: In(a),
                          "aria-describedby": In(n).open.value ? In(n).contentId : void 0,
                          "data-state": In(n).stateAttribute.value,
                          as: e.as,
                          "as-child": t.asChild,
                        },
                        Gr(l.value),
                      ),
                      { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                      16,
                      ["aria-describedby", "data-state", "as", "as-child"],
                    ),
                  ]),
                  _: 3,
                },
              )
            )
          )
        },
      }),
      EQ = Hr({
        __name: "TooltipContentImpl",
        props: {
          ariaLabel: {},
          asChild: { type: Boolean },
          as: {},
          side: { default: "top" },
          sideOffset: { default: 0 },
          align: { default: "center" },
          alignOffset: {},
          avoidCollisions: { type: Boolean, default: !0 },
          collisionBoundary: { default: () => [] },
          collisionPadding: { default: 0 },
          arrowPadding: { default: 0 },
          sticky: { default: "partial" },
          hideWhenDetached: { type: Boolean, default: !1 },
        },
        emits: ["escapeKeyDown", "pointerDownOutside"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = xQ(),
            { forwardRef: o } = YL(),
            i = na(),
            s = ii(() => {
              var e
              return null == (e = i.default) ? void 0 : e.call(i)
            }),
            l = ii(() => {
              var e
              if (n.ariaLabel) return n.ariaLabel
              let t = ""
              function r(e) {
                "string" == typeof e.children
                  ? (t += e.children)
                  : Array.isArray(e.children) && e.children.forEach((e) => r(e))
              }
              return null == (e = s.value) || e.forEach((e) => r(e)), t
            }),
            c = ii(() => {
              const { ariaLabel: e, ...t } = n
              return t
            })
          return (
            Nr(() => {
              ZL(window, "scroll", (e) => {
                const t = e.target
                null != t && t.contains(a.trigger.value) && a.onClose()
              }),
                ZL(window, vQ, a.onClose)
            }),
            (e, t) => (
              xo(),
              To(
                In(iQ),
                {
                  "as-child": "",
                  "disable-outside-pointer-events": !1,
                  onEscapeKeyDown: t[0] || (t[0] = (e) => r("escapeKeyDown", e)),
                  onPointerDownOutside:
                    t[1] ||
                    (t[1] = (e) => {
                      var t
                      In(a).disableClosingTrigger.value &&
                        null != (t = In(a).trigger.value) &&
                        t.contains(e.target) &&
                        e.preventDefault(),
                        r("pointerDownOutside", e)
                    }),
                  onFocusOutside: t[2] || (t[2] = Wi(() => {}, ["prevent"])),
                  onDismiss: t[3] || (t[3] = (e) => In(a).onClose()),
                },
                {
                  default: yr(() => [
                    No(
                      In(gQ),
                      Fo(
                        { ref: In(o), "data-state": In(a).stateAttribute.value },
                        { ...e.$attrs, ...c.value },
                        {
                          style: {
                            "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                            "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                            "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                            "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)",
                          },
                        },
                      ),
                      {
                        default: yr(() => [
                          Xr(e.$slots, "default"),
                          No(
                            In(bQ),
                            { id: In(a).contentId, role: "tooltip" },
                            { default: yr(() => [Mo(at(l.value), 1)]), _: 1 },
                            8,
                            ["id"],
                          ),
                        ]),
                        _: 3,
                      },
                      16,
                      ["data-state", "style"],
                    ),
                  ]),
                  _: 3,
                },
              )
            )
          )
        },
      }),
      TQ = Hr({
        __name: "TooltipContentHoverable",
        props: {
          ariaLabel: {},
          asChild: { type: Boolean },
          as: {},
          side: {},
          sideOffset: {},
          align: {},
          alignOffset: {},
          avoidCollisions: { type: Boolean },
          collisionBoundary: {},
          collisionPadding: {},
          arrowPadding: {},
          sticky: {},
          hideWhenDetached: { type: Boolean },
        },
        setup(e) {
          const t = XL(e),
            { forwardRef: n, currentElement: r } = YL(),
            { trigger: a, onClose: o } = xQ(),
            i = yQ(),
            { isPointerInTransit: s, onPointerExit: l } = GL(a, r)
          return (
            (i.isPointerInTransitRef = s),
            l(() => {
              o()
            }),
            (e, r) => (
              xo(), To(EQ, Fo({ ref: In(n) }, In(t)), { default: yr(() => [Xr(e.$slots, "default")]), _: 3 }, 16)
            )
          )
        },
      }),
      AQ = Hr({
        __name: "TooltipContent",
        props: {
          forceMount: { type: Boolean },
          ariaLabel: {},
          asChild: { type: Boolean },
          as: {},
          side: { default: "top" },
          sideOffset: {},
          align: {},
          alignOffset: {},
          avoidCollisions: { type: Boolean },
          collisionBoundary: {},
          collisionPadding: {},
          arrowPadding: {},
          sticky: {},
          hideWhenDetached: { type: Boolean },
        },
        emits: ["escapeKeyDown", "pointerDownOutside"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = xQ(),
            o = (function (e, t) {
              const n = XL(e),
                r = t
                  ? (function (e) {
                      const t = Vo(),
                        n = null == t ? void 0 : t.type.emits,
                        r = {}
                      return (
                        (null != n && n.length) ||
                          console.warn(
                            `No emitted event found. Please check component: ${null == t ? void 0 : t.type.__name}`,
                          ),
                        null == n ||
                          n.forEach((t) => {
                            r[Be(Ie(t))] = (...n) => e(t, ...n)
                          }),
                        r
                      )
                    })(t)
                  : {}
              return ii(() => ({ ...n.value, ...r }))
            })(n, r),
            { forwardRef: i } = YL()
          return (e, t) => (
            xo(),
            To(
              In(nQ),
              { present: e.forceMount || In(a).open.value },
              {
                default: yr(() => [
                  (xo(),
                  To(
                    Tr(In(a).disableHoverableContent.value ? EQ : TQ),
                    Fo({ ref: In(i) }, In(o)),
                    { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                    16,
                  )),
                ]),
                _: 3,
              },
              8,
              ["present"],
            )
          )
        },
      }),
      CQ = Hr({
        __name: "TooltipPortal",
        props: { to: {}, disabled: { type: Boolean }, forceMount: { type: Boolean } },
        setup(e) {
          const t = e
          return (e, n) => (xo(), To(In(rQ), Ke($o(t)), { default: yr(() => [Xr(e.$slots, "default")]), _: 3 }, 16))
        },
      }),
      PQ = Hr({
        __name: "ScalarTooltip",
        props: {
          click: {},
          delay: {},
          skipDelay: { default: 1e3 },
          align: { default: "center" },
          side: { default: "top" },
          sideOffset: {},
          class: {},
          triggerClass: {},
          resize: { type: Boolean },
        },
        emits: ["click"],
        setup(e) {
          const t = e
          return (e, n) => (
            xo(),
            To(
              In(wQ),
              { delayDuration: t.delay, skipDelayDuration: t.skipDelay },
              {
                default: yr(() => [
                  No(In(_Q), null, {
                    default: yr(() => [
                      No(
                        In(SQ),
                        {
                          class: Ge(["flex items-center justify-center", [t.resize ? "w-full" : "", t.triggerClass]]),
                          onClick: t.click,
                        },
                        { default: yr(() => [Xr(e.$slots, "trigger")]), _: 3 },
                        8,
                        ["class", "onClick"],
                      ),
                      No(
                        In(CQ),
                        { to: ".scalar-client" },
                        {
                          default: yr(() => [
                            No(
                              In(AQ),
                              {
                                align: t.align,
                                class: Ge(["scalar-app", t.class]),
                                side: t.side,
                                sideOffset: t.sideOffset,
                              },
                              { default: yr(() => [Xr(e.$slots, "content")]), _: 3 },
                              8,
                              ["align", "class", "side", "sideOffset"],
                            ),
                          ]),
                          _: 3,
                        },
                      ),
                    ]),
                    _: 3,
                  }),
                ]),
                _: 3,
              },
              8,
              ["delayDuration", "skipDelayDuration"],
            )
          )
        },
      }),
      DQ = () => {
        const e = document.getElementById("headlessui-portal-root")
        if (e) e.classList.add("scalar-app"), e.classList.add("scalar-client")
        else {
          const e = new MutationObserver((t) => {
            const n = t.find((e) => Array.from(e.addedNodes).find((e) => "headlessui-portal-root" === e.id))
            if (n) {
              const t = n.addedNodes[0]
              t.classList.add("scalar-app"), t.classList.add("scalar-client"), e.disconnect()
            }
          })
          e.observe(document.body, { childList: !0 })
        }
      },
      RQ = Symbol(),
      NQ = Symbol(),
      $Q = Mm(RQ),
      IQ = Mm(NQ),
      MQ = Hr({
        __name: "ApiClientModal",
        props: { proxyUrl: {}, spec: {} },
        setup(e) {
          const t = e,
            n = Dn(null),
            r = Dn(null),
            { authentication: a } = Zd(),
            { server: o } = au()
          return (
            Nr(async () => {
              if (!n.value) return
              const { createApiClientModal: e } = await Promise.resolve().then(() => U8),
                {
                  app: i,
                  open: s,
                  updateAuth: l,
                  updateServerUrl: c,
                  modalState: d,
                  updateSpec: u,
                } = await e(n.value, { spec: t.spec ?? {}, proxyUrl: t.proxyUrl })
              IQ.emit(d),
                $Q.on((e) => {
                  if (e.open) {
                    l(a)
                    const t = $d(o)
                    t && c(t), s(e.open)
                  }
                  e.updateSpec && u(e.updateSpec)
                }),
                Ya(
                  () => t.spec,
                  (e) => e && u(e),
                  { deep: !0 },
                ),
                (r.value = i)
            }),
            Mr(() => {
              var e
              return null == (e = r.value) ? void 0 : e.unmount()
            }),
            (e, t) => (xo(), Eo("div", { ref_key: "el", ref: n }, null, 512))
          )
        },
      }),
      LQ = ["title", "innerHTML"],
      QQ = (e, t) => {
        const n = e.__vccOpts || e
        for (const [e, r] of t) n[e] = r
        return n
      },
      BQ = QQ(
        Hr({
          __name: "ServerUrl",
          props: { server: {}, variables: {} },
          setup(e) {
            const t = e,
              n = ii(() => {
                var e
                return Rd(((null == (e = t.server) ? void 0 : e.url) ?? "").replace(/(<([^>]+)>)/gi, ""), (e) => {
                  var n
                  const r = (null == (n = t.variables) ? void 0 : n[e]) ?? ""
                  return `<span class="base-url-variable">${"" !== r ? r : `{${e}}`}</span>`
                })
              })
            return (e, t) =>
              e.server
                ? (xo(),
                  Eo("a", { key: 0, class: "base-url", title: e.server.description, innerHTML: n.value }, null, 8, LQ))
                : Qo("", !0)
          },
        }),
        [["__scopeId", "data-v-f5297e83"]],
      ),
      jQ = { class: "w-full" },
      UQ = { class: "custom-scroll" },
      FQ = QQ(
        Hr({
          __name: "ServerUrlSelect",
          props: { options: {}, value: {} },
          emits: ["change"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              a = ii(() => n.options.map((e, t) => ({ id: t.toString(), label: e.url ?? "" }))),
              o = ii({
                get: () => {
                  var e
                  return null == (e = a.value) ? void 0 : e.find((e) => e.id === n.value.toString())
                },
                set: (e) => r("change", (null == e ? void 0 : e.id) ?? ""),
              })
            return (e, t) => (
              xo(),
              Eo("div", jQ, [
                No(
                  In(vL),
                  {
                    modelValue: o.value,
                    "onUpdate:modelValue": t[0] || (t[0] = (e) => (o.value = e)),
                    options: a.value,
                    resize: "",
                  },
                  {
                    default: yr(() => [
                      No(
                        In(mw),
                        {
                          class: Ge(["url-select", { "pointer-events-none": a.value.length <= 1 }]),
                          fullWidth: "",
                          variant: "ghost",
                        },
                        {
                          default: yr(() => [
                            Ro("span", UQ, [Xr(e.$slots, "default", {}, void 0, !0)]),
                            a.value.length > 1
                              ? (xo(), To(In(BI), { key: 0, icon: "ChevronDown", size: "xs" }))
                              : Qo("", !0),
                          ]),
                          _: 3,
                        },
                        8,
                        ["class"],
                      ),
                    ]),
                    _: 3,
                  },
                  8,
                  ["modelValue", "options"],
                ),
              ])
            )
          },
        }),
        [["__scopeId", "data-v-eb9d4d8e"]],
      ),
      zQ = { class: "w-full" },
      qQ = Hr({
        __name: "ServerVariablesSelect",
        props: { enum: {}, value: {} },
        emits: ["change"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = ii(() => n.enum.map((e) => ({ id: e, label: e }))),
            o = ii({
              get: () => a.value.find((e) => e.id === n.value),
              set: (e) => r("change", (null == e ? void 0 : e.id) ?? ""),
            })
          return (e, t) => (
            xo(),
            Eo("div", zQ, [
              No(
                In(vL),
                { modelValue: o.value, "onUpdate:modelValue": t[0] || (t[0] = (e) => (o.value = e)), options: a.value },
                {
                  default: yr(() => [
                    No(
                      In(mw),
                      { class: "variable-select", fullWidth: "", variant: "ghost" },
                      {
                        default: yr(() => [
                          Ro("span", null, at(e.value), 1),
                          No(In(BI), { icon: "ChevronDown", size: "xs" }),
                        ]),
                        _: 1,
                      },
                    ),
                  ]),
                  _: 1,
                },
                8,
                ["modelValue", "options"],
              ),
            ])
          )
        },
      }),
      ZQ = QQ(qQ, [["__scopeId", "data-v-4b092d90"]]),
      HQ = QQ(
        Hr({
          __name: "ServerVariablesTextbox",
          props: { value: {} },
          emits: ["change"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              a = ii({ get: () => n.value, set: (e) => r("change", e) })
            return (e, t) =>
              Fr(
                (xo(),
                Eo(
                  "input",
                  {
                    "onUpdate:modelValue": t[0] || (t[0] = (e) => (a.value = e)),
                    autocomplete: "off",
                    class: "variable-textbox",
                    placeholder: "value",
                    spellcheck: "false",
                    type: "text",
                  },
                  null,
                  512,
                )),
                [[Bi, a.value]],
              )
          },
        }),
        [["__scopeId", "data-v-fbcac0a4"]],
      ),
      VQ = { key: 0, class: "variable-container" },
      WQ = ["for"],
      XQ = Hr({
        __name: "ServerVariablesForm",
        props: { variables: {}, values: {} },
        emits: ["update:variable"],
        setup(e, { emit: t }) {
          const n = e,
            r = t
          function a(e, t) {
            r("update:variable", e, t)
          }
          const o = (e) => {
            var t, r
            return (
              (null == (t = n.values) ? void 0 : t[e]) ??
              (null == (r = n.variables) ? void 0 : r[e].default) ??
              ""
            ).toString()
          }
          return (e, t) =>
            e.variables && Object.keys(e.variables ?? {}).length
              ? (xo(),
                Eo("div", VQ, [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(Object.keys(e.variables), (t) => {
                      var n, r, i, s
                      return (
                        xo(),
                        Eo("div", { key: t, class: "variable-container-item" }, [
                          Ro(
                            "label",
                            { class: "variable-label", for: `variable-${t}` },
                            [Ro("code", null, at(t), 1)],
                            8,
                            WQ,
                          ),
                          (null == (r = null == (n = e.variables) ? void 0 : n[t].enum) ? void 0 : r.length)
                            ? (xo(),
                              To(
                                ZQ,
                                {
                                  key: 0,
                                  enum:
                                    (null == (s = null == (i = e.variables[t]) ? void 0 : i.enum)
                                      ? void 0
                                      : s.map((e) => `${e}`)) ?? [],
                                  value: o(t),
                                  onChange: (e) => a(t, e),
                                },
                                null,
                                8,
                                ["enum", "value", "onChange"],
                              ))
                            : (xo(),
                              To(HQ, { key: 1, value: o(t), onChange: (e) => a(t, e) }, null, 8, [
                                "value",
                                "onChange",
                              ])),
                        ])
                      )
                    }),
                    128,
                  )),
                ]))
              : Qo("", !0)
        },
      }),
      YQ = QQ(XQ, [["__scopeId", "data-v-d5675216"]]),
      GQ = { key: 0 },
      KQ = ((e) => (br("data-v-1bd31bc3"), (e = e()), vr(), e))(() =>
        Ro("span", { class: "server-form-title" }, "Base URL", -1),
      ),
      JQ = { class: "server-form" },
      eB = { class: "server-form-container" },
      tB = { class: "server-item" },
      nB = { key: 0, muted: "" },
      rB = { class: "description" },
      aB = QQ(
        Hr({
          __name: "ServerForm",
          props: { selected: { default: 0 }, servers: {}, variables: {} },
          emits: ["update:selected", "update:variable"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              a = zn(Number(n.selected)),
              o = (e) => {
                const t = parseInt(e, 10)
                r("update:selected", t), (a.value = t)
              },
              i = ii(() => {
                var e
                return null == (e = n.servers) ? void 0 : e[a.value]
              })
            return (e, t) => {
              var n, r, s
              return (null == (n = e.servers) ? void 0 : n.length)
                ? (xo(),
                  Eo("div", GQ, [
                    KQ,
                    Ro("div", JQ, [
                      Ro("div", eB, [
                        Ro("div", tB, [
                          No(
                            FQ,
                            { options: e.servers, value: a.value, onChange: o },
                            {
                              default: yr(() => [
                                No(BQ, { server: i.value, variables: e.variables }, null, 8, ["server", "variables"]),
                              ]),
                              _: 1,
                            },
                            8,
                            ["options", "value"],
                          ),
                        ]),
                        No(
                          YQ,
                          {
                            values: e.variables,
                            variables: null == (r = i.value) ? void 0 : r.variables,
                            "onUpdate:variable": t[0] || (t[0] = (t, n) => e.$emit("update:variable", t, n)),
                          },
                          null,
                          8,
                          ["values", "variables"],
                        ),
                      ]),
                    ]),
                    (null == (s = i.value) ? void 0 : s.description)
                      ? (xo(),
                        Eo("div", nB, [
                          Ro("div", rB, [No(In(ZI), { value: i.value.description }, null, 8, ["value"])]),
                        ]))
                      : Qo("", !0),
                  ]))
                : Qo("", !0)
            }
          },
        }),
        [["__scopeId", "data-v-1bd31bc3"]],
      )
    const oB = Hr({
        __name: "BaseUrl",
        props: { specification: {}, defaultServerUrl: {}, servers: {} },
        setup(e) {
          const t = e,
            { server: n, setServer: r } = au(),
            a = Dn(0)
          function o(e, t) {
            return Object.fromEntries(Object.entries(e).filter(([e]) => e in (t.variables ?? {})))
          }
          function i(e, t) {
            r({ variables: { ...n.variables, [e]: t } })
          }
          return (
            Ya(a, () => r({ selectedServer: a.value }), { immediate: !0 }),
            Ya(
              () => t.specification,
              () => {
                var e
                const i = (function (e, t) {
                  var n
                  let r = []
                  return (
                    (r =
                      (null == e ? void 0 : e.servers) && (null == e ? void 0 : e.servers.length) > 0
                        ? e.servers
                        : (null == e ? void 0 : e.host)
                          ? [
                              {
                                url: `${(null == (n = e.schemes) ? void 0 : n[0]) ?? "http"}://${e.host}${(null == e ? void 0 : e.basePath) ?? ""}`,
                              },
                            ]
                          : [
                              {
                                url: (null == t ? void 0 : t.defaultServerUrl)
                                  ? null == t
                                    ? void 0
                                    : t.defaultServerUrl
                                  : "undefined" != typeof window
                                    ? window.location.origin
                                    : "/",
                              },
                            ]),
                    ((null == t ? void 0 : t.defaultServerUrl) || "undefined" != typeof window) &&
                      (r = r.map((e) =>
                        (function (e, t) {
                          var n
                          return (null == (n = e.url) ? void 0 : n.match(/^(?!(https?|file):\/\/|{).+/))
                            ? ((e.url = ps(
                                (null == t ? void 0 : t.defaultServerUrl)
                                  ? null == t
                                    ? void 0
                                    : t.defaultServerUrl
                                  : "undefined" != typeof window
                                    ? window.location.origin
                                    : "",
                                e.url,
                              )),
                              e)
                            : e
                        })(e, t),
                      )),
                    r.map((e) => {
                      const t = e.variables ?? {}
                      return (
                        ([...(e.url ?? "").matchAll(/(?:\{+)\s*(\w+)\s*(?:\}+)/g)].map((e) => e[1].trim()) || [])
                          .filter((e) => !t[e])
                          .forEach((t) => {
                            void 0 === e.variables && (e.variables = {}), (e.variables[t] = {})
                          }),
                        e
                      )
                    })
                  )
                })(void 0 === t.servers ? t.specification : bp({ servers: t.servers }), {
                  defaultServerUrl: t.defaultServerUrl,
                })
                var s
                r({
                  servers: i,
                  variables: {
                    ...((s = (null == (e = i[a.value]) ? void 0 : e.variables) ?? {}),
                    Object.fromEntries(
                      Object.entries(s ?? {}).map(([e, t]) => {
                        var n, r, a
                        return [
                          e,
                          (null == (n = t.default) ? void 0 : n.toString()) ??
                            (null == (a = null == (r = t.enum) ? void 0 : r[0]) ? void 0 : a.toString()) ??
                            "",
                        ]
                      }),
                    )),
                    ...o(n.variables, i[a.value]),
                  },
                })
              },
              { deep: !0, immediate: !0 },
            ),
            (e, t) => (
              xo(),
              To(
                aB,
                {
                  selected: a.value,
                  servers: In(n).servers,
                  variables: In(n).variables,
                  "onUpdate:selected":
                    t[0] ||
                    (t[0] = (e) => {
                      a.value = e
                    }),
                  "onUpdate:variable": i,
                },
                null,
                8,
                ["selected", "servers", "variables"],
              )
            )
          )
        },
      }),
      iB = { class: "card-form" },
      sB = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("form", iB, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-21a1cfbf"],
      ]),
      lB = QQ(
        Hr({
          __name: "CardFormButton",
          setup(e, { expose: t }) {
            const n = Dn()
            return (
              t({ el: n }),
              (e, t) => (
                xo(),
                Eo(
                  "button",
                  { ref_key: "el", ref: n, class: "card-form-button", type: "button" },
                  [Xr(e.$slots, "default", {}, void 0, !0)],
                  512,
                )
              )
            )
          },
        }),
        [["__scopeId", "data-v-502d153b"]],
      ),
      cB = { class: "card-form-group" },
      dB = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", cB, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-88abf5f7"],
      ]),
      uB = { class: "card-form-rows" },
      pB = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", uB, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-1611fc76"],
      ]),
      hB = { class: "card-form-input" },
      fB = ["for"],
      mB = ["id", "type"],
      gB = QQ(
        Hr({
          inheritAttrs: !1,
          __name: "CardFormTextInput",
          props: { id: {}, type: {} },
          setup(e) {
            const t = e,
              n = Dn(!0),
              r = ii(() => ("password" === t.type ? (n.value ? "password" : "text") : (t.type ?? "text")))
            return (e, t) => (
              xo(),
              Eo("div", hB, [
                Ro("label", { for: e.id }, [Xr(e.$slots, "default", {}, void 0, !0)], 8, fB),
                Ro(
                  "input",
                  Fo(e.$attrs, {
                    id: e.id,
                    autocomplete: "off",
                    "data-1p-ignore": "",
                    spellcheck: "false",
                    type: r.value,
                  }),
                  null,
                  16,
                  mB,
                ),
                "password" === e.type
                  ? (xo(),
                    To(
                      In(mL),
                      {
                        key: 0,
                        class: "password-mask",
                        icon: n.value ? "Show" : "Hide",
                        label: n.value ? "Show Password" : "Hide Password",
                        onClick: t[0] || (t[0] = (e) => (n.value = !n.value)),
                      },
                      null,
                      8,
                      ["icon", "label"],
                    ))
                  : Qo("", !0),
              ])
            )
          },
        }),
        [["__scopeId", "data-v-2c06084d"]],
      ),
      bB = { class: "scopes-label" },
      vB = ((e) => (br("data-v-0957134f"), (e = e()), vr(), e))(() => Ro("em", null, "/", -1)),
      yB = ["checked"],
      OB = { class: "dropdown-item-title" },
      wB = { class: "dropdown-item-description" },
      xB = Hr({
        __name: "SecuritySchemeScopes",
        props: { scopes: {}, selected: {} },
        emits: ["update:selected"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = Dn(),
            o = Dn(),
            { floatingStyles: i } = oL(a, o, {
              placement: "bottom-end",
              whileElementsMounted: XM,
              middleware: [YM(5), KM(), GM()],
            }),
            s = ii({ get: () => n.selected, set: (e) => r("update:selected", e) })
          return (e, t) =>
            Object.keys(e.scopes ?? {}).length
              ? (xo(),
                To(
                  In(Ry),
                  {
                    key: 0,
                    modelValue: s.value,
                    "onUpdate:modelValue": t[0] || (t[0] = (e) => (s.value = e)),
                    multiple: "",
                  },
                  {
                    default: yr(({ open: t }) => [
                      Ro(
                        "div",
                        { ref_key: "trigger", ref: a, class: Ge(["wrapper", { "wrapper-open": t }]) },
                        [
                          No(
                            In(Ny),
                            { as: lB },
                            {
                              default: yr(() => [
                                Ro("div", bB, [
                                  Mo(" Scopes " + at(s.value.length), 1),
                                  vB,
                                  Mo(at(Object.entries(e.scopes ?? {}).length) + " ", 1),
                                  No(In(BI), { icon: t ? "ChevronUp" : "ChevronDown", size: "sm" }, null, 8, ["icon"]),
                                ]),
                              ]),
                              _: 2,
                            },
                            1024,
                          ),
                        ],
                        2,
                      ),
                      (xo(),
                      To(fo, { to: "body" }, [
                        Ro(
                          "div",
                          { ref_key: "dropdown", ref: o, class: "floating", style: He(In(i)) },
                          [
                            No(
                              In($y),
                              { as: "dl", class: "dropdown" },
                              {
                                default: yr(() => [
                                  (xo(!0),
                                  Eo(
                                    go,
                                    null,
                                    qr(
                                      Object.entries(e.scopes ?? {}),
                                      ([e, t]) => (
                                        xo(),
                                        To(
                                          In(Iy),
                                          { key: e, as: "div", class: "dropdown-item", value: e },
                                          {
                                            default: yr(({ selected: n }) => [
                                              Ro(
                                                "input",
                                                {
                                                  checked: n,
                                                  class: "dropdown-item-check",
                                                  tabindex: "-1",
                                                  type: "checkbox",
                                                },
                                                null,
                                                8,
                                                yB,
                                              ),
                                              Ro("dt", OB, at(e), 1),
                                              Ro("dd", wB, at(t), 1),
                                            ]),
                                            _: 2,
                                          },
                                          1032,
                                          ["value"],
                                        )
                                      ),
                                    ),
                                    128,
                                  )),
                                ]),
                                _: 1,
                              },
                            ),
                          ],
                          4,
                        ),
                      ])),
                    ]),
                    _: 1,
                  },
                  8,
                  ["modelValue"],
                ))
              : Qo("", !0)
        },
      }),
      kB = QQ(xB, [["__scopeId", "data-v-0957134f"]]),
      _B = QQ(
        Hr({
          __name: "SecurityScheme",
          props: { value: {}, proxy: {} },
          setup(e) {
            const { toast: t } = Vu(),
              { server: n } = au(),
              { authentication: r, setAuthentication: a } = Zd(),
              o = (e) => {
                a({ apiKey: { ...r.apiKey, token: e.target.value } })
              },
              i = (e) => {
                a({ http: { ...r.http, basic: { ...r.http.basic, username: e.target.value } } })
              },
              s = (e) => {
                a({ http: { ...r.http, basic: { ...r.http.basic, password: e.target.value } } })
              },
              l = (e) => {
                a({ http: { ...r.http, bearer: { ...r.http.bearer, token: e.target.value } } })
              },
              c = (e) => {
                a({ oAuth2: { ...r.oAuth2, clientId: e.target.value } })
              },
              d = (e) => {
                a({ oAuth2: { ...r.oAuth2, username: e.target.value } })
              },
              u = (e) => {
                a({ oAuth2: { ...r.oAuth2, password: e.target.value } })
              },
              p = ii({ get: () => r.oAuth2.scopes, set: (e) => a({ oAuth2: { ...r.oAuth2, scopes: e } }) })
            return (e, h) => {
              var f
              return e.value && (null == (f = e.value) ? void 0 : f.type)
                ? (xo(),
                  To(
                    sB,
                    { key: 0 },
                    {
                      default: yr(() => [
                        "apiKey" === e.value.type
                          ? (xo(),
                            To(
                              gB,
                              {
                                key: 0,
                                id: `security-scheme-${e.value.name}`,
                                placeholder: "Token",
                                type: "password",
                                value: In(r).apiKey.token,
                                onInput: o,
                              },
                              {
                                default: yr(() => {
                                  var t, n, r
                                  return [
                                    e.value.in
                                      ? (xo(),
                                        Eo(
                                          go,
                                          { key: 0 },
                                          [
                                            Mo(
                                              at(
                                                (null == (n = null == (t = e.value.in) ? void 0 : t.charAt(0))
                                                  ? void 0
                                                  : n.toUpperCase()) + (null == (r = e.value.in) ? void 0 : r.slice(1)),
                                              ),
                                              1,
                                            ),
                                          ],
                                          64,
                                        ))
                                      : Qo("", !0),
                                    Mo(" API "),
                                  ]
                                }),
                                _: 1,
                              },
                              8,
                              ["id", "value"],
                            ))
                          : "http" === e.value.type || "basic" === e.value.type
                            ? (xo(),
                              Eo(
                                go,
                                { key: 1 },
                                [
                                  "basic" === e.value.type || "basic" === e.value.scheme
                                    ? (xo(),
                                      To(
                                        dB,
                                        { key: 0 },
                                        {
                                          default: yr(() => [
                                            No(
                                              gB,
                                              {
                                                id: "http.basic.username",
                                                placeholder: "Username",
                                                value: In(r).http.basic.username,
                                                onInput: i,
                                              },
                                              { default: yr(() => [Mo(" Username ")]), _: 1 },
                                              8,
                                              ["value"],
                                            ),
                                            No(
                                              gB,
                                              {
                                                id: "http.basic.password",
                                                placeholder: "Password",
                                                type: "password",
                                                value: In(r).http.basic.password,
                                                onInput: s,
                                              },
                                              { default: yr(() => [Mo(" Password ")]), _: 1 },
                                              8,
                                              ["value"],
                                            ),
                                          ]),
                                          _: 1,
                                        },
                                      ))
                                    : "http" === e.value.type && "bearer" === e.value.scheme
                                      ? (xo(),
                                        To(
                                          gB,
                                          {
                                            key: 1,
                                            id: "http.bearer.token",
                                            placeholder: "Token",
                                            type: "password",
                                            value: In(r).http.bearer.token,
                                            onInput: l,
                                          },
                                          { default: yr(() => [Mo(" Bearer Token ")]), _: 1 },
                                          8,
                                          ["value"],
                                        ))
                                      : Qo("", !0),
                                ],
                                64,
                              ))
                            : "oauth2" === e.value.type.toLowerCase() && e.value.flows
                              ? (xo(),
                                To(
                                  dB,
                                  { key: 2 },
                                  {
                                    default: yr(() => {
                                      var o, i
                                      return [
                                        e.value.flows.implicit
                                          ? (xo(),
                                            Eo(
                                              go,
                                              { key: 0 },
                                              [
                                                In(r).oAuth2.accessToken
                                                  ? (xo(),
                                                    Eo(
                                                      go,
                                                      { key: 0 },
                                                      [
                                                        No(
                                                          gB,
                                                          {
                                                            id: "oAuth2.accessToken",
                                                            placeholder: "xxxxx",
                                                            type: "password",
                                                            value: In(r).oAuth2.accessToken,
                                                          },
                                                          { default: yr(() => [Mo(" Access Token ")]), _: 1 },
                                                          8,
                                                          ["value"],
                                                        ),
                                                        No(
                                                          lB,
                                                          {
                                                            onClick:
                                                              h[0] ||
                                                              (h[0] = () =>
                                                                In(a)({
                                                                  oAuth2: {
                                                                    ...In(r).oAuth2,
                                                                    accessToken: "",
                                                                    state: "",
                                                                  },
                                                                })),
                                                          },
                                                          { default: yr(() => [Mo(" Reset ")]), _: 1 },
                                                        ),
                                                      ],
                                                      64,
                                                    ))
                                                  : Qo("", !0),
                                              ],
                                              64,
                                            ))
                                          : Qo("", !0),
                                        (null == (i = null == (o = e.value) ? void 0 : o.flows) ? void 0 : i.password)
                                          ? (xo(),
                                            To(
                                              pB,
                                              { key: 1 },
                                              {
                                                default: yr(() => [
                                                  No(dB, null, {
                                                    default: yr(() => [
                                                      No(
                                                        gB,
                                                        {
                                                          id: "oAuth2.username",
                                                          placeholder: "Username",
                                                          value: In(r).oAuth2.username,
                                                          onInput: d,
                                                        },
                                                        { default: yr(() => [Mo(" Username ")]), _: 1 },
                                                        8,
                                                        ["value"],
                                                      ),
                                                      No(
                                                        gB,
                                                        {
                                                          id: "oAuth2.password",
                                                          placeholder: "Password",
                                                          type: "password",
                                                          value: In(r).oAuth2.password,
                                                          onInput: u,
                                                        },
                                                        { default: yr(() => [Mo(" Password ")]), _: 1 },
                                                        8,
                                                        ["value"],
                                                      ),
                                                    ]),
                                                    _: 1,
                                                  }),
                                                  No(dB, null, {
                                                    default: yr(() => {
                                                      var o, i, s, l, d, u, f, m, g, b, v
                                                      return [
                                                        No(
                                                          gB,
                                                          {
                                                            id: "oAuth2.clientId",
                                                            placeholder: "12345",
                                                            type: "text",
                                                            value: In(r).oAuth2.clientId,
                                                            onInput: c,
                                                          },
                                                          { default: yr(() => [Mo(" Client ID ")]), _: 1 },
                                                          8,
                                                          ["value"],
                                                        ),
                                                        void 0 !== e.value &&
                                                        Object.entries(
                                                          (null ==
                                                          (s =
                                                            null == (i = null == (o = e.value) ? void 0 : o.flows)
                                                              ? void 0
                                                              : i.implicit)
                                                            ? void 0
                                                            : s.scopes) ??
                                                            (null ==
                                                            (u =
                                                              null == (d = null == (l = e.value) ? void 0 : l.flows)
                                                                ? void 0
                                                                : d.password)
                                                              ? void 0
                                                              : u.scopes) ??
                                                            {},
                                                        ).length > 0
                                                          ? (xo(),
                                                            To(
                                                              kB,
                                                              {
                                                                key: 0,
                                                                selected: p.value,
                                                                "onUpdate:selected":
                                                                  h[1] || (h[1] = (e) => (p.value = e)),
                                                                scopes:
                                                                  (null ==
                                                                  (g =
                                                                    null ==
                                                                    (m = null == (f = e.value) ? void 0 : f.flows)
                                                                      ? void 0
                                                                      : m.implicit)
                                                                    ? void 0
                                                                    : g.scopes) ??
                                                                  (null ==
                                                                  (v = null == (b = e.value) ? void 0 : b.flows)
                                                                    ? void 0
                                                                    : v.password.scopes),
                                                              },
                                                              null,
                                                              8,
                                                              ["selected", "scopes"],
                                                            ))
                                                          : Qo("", !0),
                                                        Ro(
                                                          "button",
                                                          {
                                                            class: "cardform-auth-button",
                                                            type: "button",
                                                            onClick:
                                                              h[2] ||
                                                              (h[2] = () => {
                                                                var o, i
                                                                return (function (e, n) {
                                                                  if ("string" != typeof e)
                                                                    return void console.log("tokenUrl is not a string")
                                                                  const o =
                                                                      (null == n ? void 0 : n.baseUrl) &&
                                                                      !e.startsWith("http")
                                                                        ? ps(null == n ? void 0 : n.baseUrl, e)
                                                                        : e,
                                                                    i = new URL(o)
                                                                  i.searchParams.set("grant_type", "password"),
                                                                    i.searchParams.set("username", r.oAuth2.username),
                                                                    i.searchParams.set("password", r.oAuth2.password),
                                                                    i.searchParams.set("client_id", r.oAuth2.clientId),
                                                                    i.searchParams.set(
                                                                      "scope",
                                                                      r.oAuth2.scopes.join(" "),
                                                                    ),
                                                                    fetch(
                                                                      (null == n ? void 0 : n.proxy)
                                                                        ? gs(null == n ? void 0 : n.proxy, i.toString())
                                                                        : i.toString(),
                                                                      {
                                                                        method: "POST",
                                                                        headers: {
                                                                          "Content-Type":
                                                                            "application/x-www-form-urlencoded",
                                                                        },
                                                                      },
                                                                    )
                                                                      .then((e) => {
                                                                        if (!e.ok)
                                                                          throw new Error(
                                                                            "Failed to get an access token. Please check your credentials.",
                                                                          )
                                                                        return e.json()
                                                                      })
                                                                      .then((e) => {
                                                                        a({
                                                                          oAuth2: {
                                                                            ...r.oAuth2,
                                                                            accessToken: e.access_token,
                                                                          },
                                                                        })
                                                                      })
                                                                      .catch((e) => {
                                                                        t(
                                                                          "Couldnt retrieve the password grant token",
                                                                          "warn",
                                                                          {
                                                                            description:
                                                                              "Open your browser console to get more information.",
                                                                          },
                                                                        ),
                                                                          console.error("[authorizeWithPassword]", e)
                                                                      })
                                                                })(
                                                                  null ==
                                                                    (i =
                                                                      null == (o = e.value.flows) ? void 0 : o.password)
                                                                    ? void 0
                                                                    : i.tokenUrl,
                                                                  { baseUrl: In($d)(In(n)), proxy: e.proxy },
                                                                )
                                                              }),
                                                          },
                                                          " Authorize ",
                                                        ),
                                                      ]
                                                    }),
                                                    _: 1,
                                                  }),
                                                ]),
                                                _: 1,
                                              },
                                            ))
                                          : (xo(),
                                            To(
                                              pB,
                                              { key: 2 },
                                              {
                                                default: yr(() => [
                                                  No(dB, null, {
                                                    default: yr(() => {
                                                      var t, n
                                                      return [
                                                        No(
                                                          gB,
                                                          {
                                                            id: "oAuth2.clientId",
                                                            placeholder: "12345",
                                                            type: "text",
                                                            value: In(r).oAuth2.clientId,
                                                            onInput: c,
                                                          },
                                                          { default: yr(() => [Mo(" Client ID ")]), _: 1 },
                                                          8,
                                                          ["value"],
                                                        ),
                                                        void 0 !== e.value &&
                                                        Object.entries(
                                                          (null == (t = e.value.flows.implicit) ? void 0 : t.scopes) ??
                                                            e.value.flows.password.scopes,
                                                        ).length > 0
                                                          ? (xo(),
                                                            To(
                                                              kB,
                                                              {
                                                                key: 0,
                                                                selected: p.value,
                                                                "onUpdate:selected":
                                                                  h[3] || (h[3] = (e) => (p.value = e)),
                                                                scopes:
                                                                  (null == (n = e.value.flows.implicit)
                                                                    ? void 0
                                                                    : n.scopes) ?? e.value.flows.password.scopes,
                                                              },
                                                              null,
                                                              8,
                                                              ["selected", "scopes"],
                                                            ))
                                                          : Qo("", !0),
                                                        Ro(
                                                          "button",
                                                          {
                                                            class: "cardform-auth-button",
                                                            type: "button",
                                                            onClick:
                                                              h[4] ||
                                                              (h[4] = () => {
                                                                var t, n, o, i
                                                                return ((e) => {
                                                                  const t = window.open(
                                                                    e,
                                                                    "openAuth2Window",
                                                                    "left=100,top=100,width=800,height=600",
                                                                  )
                                                                  if (t) {
                                                                    const e = setInterval(function () {
                                                                      var n
                                                                      try {
                                                                        const o = new URLSearchParams(
                                                                          t.location.href,
                                                                        ).get("access_token")
                                                                        if (t.closed || o) {
                                                                          clearInterval(e)
                                                                          const i =
                                                                            null ==
                                                                            (n = t.location.href.match(/state=([^&]*)/))
                                                                              ? void 0
                                                                              : n[1]
                                                                          o &&
                                                                            r.oAuth2.state === i &&
                                                                            a({
                                                                              oAuth2: { ...r.oAuth2, accessToken: o },
                                                                            }),
                                                                            t.close()
                                                                        }
                                                                      } catch {}
                                                                    }, 200)
                                                                  }
                                                                })(
                                                                  (function (e) {
                                                                    const t = r.oAuth2.scopes.join(" "),
                                                                      n = (Math.random() + 1).toString(36).substring(7),
                                                                      o = new URL(e.authorizationUrl)
                                                                    return (
                                                                      a({ oAuth2: { ...r.oAuth2, state: n } }),
                                                                      o.searchParams.set("response_type", "token"),
                                                                      o.searchParams.set(
                                                                        "client_id",
                                                                        r.oAuth2.clientId,
                                                                      ),
                                                                      o.searchParams.set(
                                                                        "redirect_uri",
                                                                        window.location.href,
                                                                      ),
                                                                      o.searchParams.set("scope", t),
                                                                      o.searchParams.set("state", n),
                                                                      o.toString()
                                                                    )
                                                                  })(
                                                                    (null ==
                                                                    (n = null == (t = e.value) ? void 0 : t.flows)
                                                                      ? void 0
                                                                      : n.implicit) ??
                                                                      (null ==
                                                                      (i = null == (o = e.value) ? void 0 : o.flows)
                                                                        ? void 0
                                                                        : i.password),
                                                                  ),
                                                                )
                                                              }),
                                                          },
                                                          " Authorize ",
                                                        ),
                                                      ]
                                                    }),
                                                    _: 1,
                                                  }),
                                                ]),
                                                _: 1,
                                              },
                                            )),
                                      ]
                                    }),
                                    _: 1,
                                  },
                                ))
                              : Qo("", !0),
                      ]),
                      _: 1,
                    },
                  ))
                : Qo("", !0)
            }
          },
        }),
        [["__scopeId", "data-v-3bdd11a8"]],
      ),
      SB = { key: 0, class: "security-scheme-label" },
      EB = { key: 1, class: "security-scheme-selector" },
      TB = { class: "security-scheme-label" },
      AB = ["value"],
      CB = ((e) => (br("data-v-d4d9bca1"), (e = e()), vr(), e))(() => Ro("option", { value: "" }, "None", -1)),
      PB = ["value"],
      DB = QQ(
        Hr({
          __name: "SecuritySchemeSelector",
          props: { value: {} },
          emits: ["input"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              { authentication: a, setAuthentication: o } = Zd(),
              i = (e) => {
                s(e.target.value)
              }
            Nr(() => {
              a.preferredSecurityScheme || s(Object.keys(n.value ?? {})[0] ?? null)
            })
            const s = (e) => {
              o({ preferredSecurityScheme: e }), r("input", e)
            }
            Qr(() => s(Object.keys(n.value ?? {})[0] ?? null))
            const l = (e, t) => `${c(e)} (${t})`,
              c = (e) => {
                var t, n
                return ((e) => !(null == e ? void 0 : e.type))(e)
                  ? "No Authentication"
                  : ((e) => "apikey" === e.type.toLowerCase())(e)
                    ? "API Key"
                    : ((e) =>
                          ("http" === e.type && "basic" === e.scheme.toLowerCase()) ||
                          "basic" === e.type.toLowerCase())(e)
                      ? "Basic Authentication"
                      : ((e) => "http" === e.type && "bearer" === e.scheme.toLowerCase())(e)
                        ? "Bearer Authentication"
                        : ((e) => "oauth2" === e.type.toLowerCase())(e)
                          ? (null == (t = e.flows) ? void 0 : t.implicit)
                            ? "OAuth 2.0 Implicit"
                            : (null == (n = e.flows) ? void 0 : n.password)
                              ? "OAuth 2.0 Password"
                              : "OAuth 2.0"
                          : `${e.type} (not yet supported)`
              },
              d = ii(() => Object.keys(n.value ?? {}))
            return (e, t) => {
              var n, r
              return 1 === d.value.length
                ? (xo(), Eo("div", SB, at(l(null == (n = e.value) ? void 0 : n[d.value[0]], d.value[0])), 1))
                : d.value.length > 1
                  ? (xo(),
                    Eo("div", EB, [
                      Ro(
                        "span",
                        TB,
                        at(
                          In(a).preferredSecurityScheme
                            ? l(
                                null == (r = e.value) ? void 0 : r[In(a).preferredSecurityScheme],
                                In(a).preferredSecurityScheme,
                              )
                            : "None",
                        ),
                        1,
                      ),
                      No(In(BI), { icon: "ChevronDown" }),
                      Ro(
                        "select",
                        {
                          value: In(a).preferredSecurityScheme,
                          onClick: t[0] || (t[0] = Wi(() => {}, ["prevent"])),
                          onInput: i,
                        },
                        [
                          CB,
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(d.value, (t) => {
                              var n
                              return (
                                xo(),
                                Eo(
                                  "option",
                                  { key: t, value: t ?? null },
                                  at(l(null == (n = e.value) ? void 0 : n[t], t)),
                                  9,
                                  PB,
                                )
                              )
                            }),
                            128,
                          )),
                        ],
                        40,
                        AB,
                      ),
                    ]))
                  : Qo("", !0)
            }
          },
        }),
        [["__scopeId", "data-v-d4d9bca1"]],
      ),
      RB = { key: 0 },
      NB = { class: "authentication-header" },
      $B = { class: "selector" },
      IB = { key: 0, class: "authentication-content" },
      MB = QQ(
        Hr({
          __name: "Authentication",
          props: { parsedSpec: {}, proxy: {} },
          setup(e) {
            const t = e,
              { authentication: n, setAuthentication: r } = Zd(),
              a = ii(() => {
                var e, r, a
                if (!n.preferredSecurityScheme) return !1
                const o =
                  null ==
                  (a = null == (r = null == (e = t.parsedSpec) ? void 0 : e.components) ? void 0 : r.securitySchemes)
                    ? void 0
                    : a[n.preferredSecurityScheme]
                return !!o && "type" in o && !!o.type
              })
            return (
              Ya(
                () => {
                  var e, n
                  return null == (n = null == (e = t.parsedSpec) ? void 0 : e.components) ? void 0 : n.securitySchemes
                },
                () => {
                  var e, n
                  r({
                    securitySchemes:
                      null == (n = null == (e = t.parsedSpec) ? void 0 : e.components) ? void 0 : n.securitySchemes,
                  })
                },
                { deep: !0, immediate: !0 },
              ),
              Qr(async () => {
                const e = Va()
                await ym(1), (e.payload.data["useGlobalStore-authentication"] = n)
              }),
              (e, t) => {
                var r, o, i, s, l
                return In(zf)(e.parsedSpec)
                  ? (xo(),
                    Eo("div", RB, [
                      Ro("div", NB, [
                        Ro("div", $B, [
                          No(
                            DB,
                            {
                              value:
                                null == (o = null == (r = e.parsedSpec) ? void 0 : r.components)
                                  ? void 0
                                  : o.securitySchemes,
                            },
                            null,
                            8,
                            ["value"],
                          ),
                        ]),
                      ]),
                      a.value
                        ? (xo(),
                          Eo("div", IB, [
                            In(n).preferredSecurityScheme
                              ? (xo(),
                                To(
                                  _B,
                                  {
                                    key: 0,
                                    proxy: e.proxy,
                                    value:
                                      null ==
                                      (l =
                                        null == (s = null == (i = e.parsedSpec) ? void 0 : i.components)
                                          ? void 0
                                          : s.securitySchemes)
                                        ? void 0
                                        : l[In(n).preferredSecurityScheme],
                                  },
                                  null,
                                  8,
                                  ["proxy", "value"],
                                ))
                              : Qo("", !0),
                          ]))
                        : Qo("", !0),
                    ]))
                  : Qo("", !0)
              }
            )
          },
        }),
        [["__scopeId", "data-v-9052a928"]],
      ),
      LB = ["onClick"],
      QB = ["value"],
      BB = ["label"],
      jB = ["value"],
      UB = { class: "client-libraries-icon__more" },
      FB = {
        key: 1,
        class: "client-libraries-icon",
        height: "50",
        viewBox: "0 0 50 50",
        width: "50",
        xmlns: "http://www.w3.org/2000/svg",
      },
      zB = [
        ((e) => (br("data-v-ab6bf947"), (e = e()), vr(), e))(() =>
          Ro(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            [
              Ro("path", {
                d: "M10.71 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M21.13 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M31.55 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0",
              }),
            ],
            -1,
          ),
        ),
      ],
      qB = { key: 0 },
      ZB = QQ(
        Hr({
          __name: "ClientSelector",
          setup(e) {
            const { httpClient: t, setHttpClient: n, availableTargets: r, getClientTitle: a, getTargetTitle: o } = Rb(),
              i = Dn(),
              s = [
                { targetKey: "shell", clientKey: "curl" },
                { targetKey: "ruby", clientKey: "native" },
                { targetKey: "node", clientKey: "undici" },
                { targetKey: "php", clientKey: "guzzle" },
                { targetKey: "python", clientKey: "python3" },
              ].filter((e) =>
                r.value.find((t) => t.key === e.targetKey && t.clients.find((t) => t.key === e.clientKey)),
              ),
              l = (e) => `programming-language-${e}`,
              c = (e) => s.some((t) => t.targetKey === e.targetKey && t.clientKey === e.clientKey)
            return (e, d) => (
              xo(),
              Eo(
                "div",
                { ref_key: "containerRef", ref: i, class: "client-libraries-content" },
                [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(In(s), (e) => {
                      return (
                        xo(),
                        Eo(
                          "div",
                          {
                            key: e.clientKey,
                            class: Ge([
                              "client-libraries rendered-code-sdks",
                              {
                                "client-libraries__active":
                                  ((r = e), r.targetKey === t.targetKey && r.clientKey === t.clientKey),
                              },
                            ]),
                            onClick: () => In(n)(e),
                          },
                          [
                            Ro(
                              "div",
                              { class: Ge(`client-libraries-icon__${e.targetKey}`) },
                              [No(In(BI), { class: "client-libraries-icon", icon: l(e.targetKey) }, null, 8, ["icon"])],
                              2,
                            ),
                            Ro("span", null, at(In(o)(e)), 1),
                          ],
                          10,
                          LB,
                        )
                      )
                      var r
                    }),
                    128,
                  )),
                  Ro(
                    "div",
                    {
                      class: Ge([
                        "client-libraries client-libraries__select",
                        { "client-libraries__active": In(t) && !c(In(t)) },
                      ]),
                    },
                    [
                      Ro(
                        "select",
                        {
                          class: "language-select",
                          value: JSON.stringify(In(t)),
                          onInput: d[0] || (d[0] = (e) => In(n)(JSON.parse(e.target.value))),
                        },
                        [
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(
                              In(r),
                              (e) => (
                                xo(),
                                Eo(
                                  "optgroup",
                                  { key: e.key, label: e.title },
                                  [
                                    (xo(!0),
                                    Eo(
                                      go,
                                      null,
                                      qr(
                                        e.clients,
                                        (t) => (
                                          xo(),
                                          Eo(
                                            "option",
                                            {
                                              key: t.key,
                                              value: JSON.stringify({ targetKey: e.key, clientKey: t.key }),
                                            },
                                            at(In(a)({ targetKey: e.key, clientKey: t.key })),
                                            9,
                                            jB,
                                          )
                                        ),
                                      ),
                                      128,
                                    )),
                                  ],
                                  8,
                                  BB,
                                )
                              ),
                            ),
                            128,
                          )),
                        ],
                        40,
                        QB,
                      ),
                      Ro("div", UB, [
                        In(t) && !c(In(t))
                          ? (xo(),
                            Eo(
                              "div",
                              { key: 0, class: Ge(`client-libraries-icon__${In(t).targetKey}`) },
                              [
                                No(In(BI), { class: "client-libraries-icon", icon: l(In(t).targetKey) }, null, 8, [
                                  "icon",
                                ]),
                              ],
                              2,
                            ))
                          : (xo(), Eo("svg", FB, zB)),
                      ]),
                      In(r).length ? (xo(), Eo("span", qB, "More")) : Qo("", !0),
                    ],
                    2,
                  ),
                ],
                512,
              )
            )
          },
        }),
        [["__scopeId", "data-v-ab6bf947"]],
      ),
      HB = ((e) => (br("data-v-301043da"), (e = e()), vr(), e))(() =>
        Ro("div", { class: "client-libraries-heading" }, "Client Libraries", -1),
      ),
      VB = { class: "selected-client card-footer", muted: "" },
      WB = QQ(
        Hr({
          __name: "ClientLibraries",
          setup(e) {
            const { availableTargets: t, httpTargetTitle: n, httpClientTitle: r } = Rb()
            return (e, a) => (
              xo(),
              Eo("div", null, [
                In(t).length
                  ? (xo(),
                    Eo(
                      go,
                      { key: 0 },
                      [HB, Ro("div", null, [No(ZB)]), Ro("div", VB, at(In(r)) + " " + at(In(n)), 1)],
                      64,
                    ))
                  : Qo("", !0),
              ])
            )
          },
        }),
        [["__scopeId", "data-v-301043da"]],
      ),
      XB = { class: "badge" },
      YB = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", XB, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-190574ac"],
      ]),
      GB = Hr({
        __name: "IntersectionObserver",
        props: { id: {}, is: {} },
        emits: ["intersecting"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = Dn(),
            o = (e) => {
              const t = e.offsetHeight
              return `${t / 2}px 0px ${t / 2}px 0px`
            }
          return (
            Nr(() => {
              if (a.value) {
                const t = {
                  rootMargin: o(a.value),
                  threshold: ((e = a.value), e.offsetHeight < window.innerHeight ? 0.8 : 0.5),
                }
                !(function (e, t, n = {}) {
                  const { root: r, rootMargin: a = "0px", threshold: o = 0.1, window: i = Dm, immediate: s = !0 } = n,
                    l = Nm(() => i && "IntersectionObserver" in i),
                    c = ii(() => {
                      const t = wm(e)
                      return (Array.isArray(t) ? t : [t]).map(Pm).filter(km)
                    })
                  let d = Em
                  const u = Dn(s),
                    p = l.value
                      ? Ya(
                          () => [c.value, Pm(r), u.value],
                          ([e, n]) => {
                            if ((d(), !u.value)) return
                            if (!e.length) return
                            const r = new IntersectionObserver(t, { root: Pm(n), rootMargin: a, threshold: o })
                            e.forEach((e) => e && r.observe(e)),
                              (d = () => {
                                r.disconnect(), (d = Em)
                              })
                          },
                          { immediate: s, flush: "post" },
                        )
                      : Em
                  Om(() => {
                    d(), p(), (u.value = !1)
                  })
                })(
                  a,
                  ([{ isIntersecting: e }]) => {
                    e && n.id && r("intersecting")
                  },
                  t,
                )
              }
              var e
            }),
            (e, t) => (
              xo(),
              To(
                Tr(e.is ?? "div"),
                { id: e.id, ref_key: "intersectionObserverRef", ref: a },
                { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
                8,
                ["id"],
              )
            )
          )
        },
      }),
      KB = QQ(
        Hr({
          __name: "Section",
          props: { id: {}, label: {} },
          setup(e) {
            const t = e,
              { getSectionId: n, hash: r, isIntersectionEnabled: a, pathRouting: o } = fp(),
              { setCollapsedSidebarItem: i } = sg()
            function s() {
              var e, s
              if (!t.label || !a.value) return
              const l = new URL(window.location.href),
                c = t.id ?? ""
              o.value ? (l.pathname = qf(o.value.basePath, c)) : (l.hash = c),
                (r.value = c),
                window.history.replaceState({}, "", l),
                ((null == (e = t.id) ? void 0 : e.startsWith("model")) ||
                  (null == (s = t.id) ? void 0 : s.startsWith("webhook"))) &&
                  i(n(t.id), !0)
            }
            return (e, t) => (
              xo(),
              To(
                GB,
                { is: "section", id: e.id, class: "section", onIntersecting: s },
                { default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]), _: 3 },
                8,
                ["id"],
              )
            )
          },
        }),
        [["__scopeId", "data-v-7bdc2dab"]],
      ),
      JB = { class: "section-accordion-button-content" },
      ej = { key: 0, class: "section-accordion-button-actions" },
      tj = { key: 0, class: "section-accordion-description" },
      nj = { class: "section-accordion-content-card" },
      rj = QQ(
        Hr({
          __name: "SectionAccordion",
          props: { id: {}, transparent: { type: Boolean } },
          setup(e) {
            const t = Dn(),
              n = (function (e, t = {}) {
                const { delayEnter: n = 0, delayLeave: r = 0, window: a = Dm } = t,
                  o = Dn(!1)
                let i
                const s = (e) => {
                  const t = e ? n : r
                  i && (clearTimeout(i), (i = void 0)), t ? (i = setTimeout(() => (o.value = e), t)) : (o.value = e)
                }
                return a
                  ? (Rm(e, "mouseenter", () => s(!0), { passive: !0 }),
                    Rm(e, "mouseleave", () => s(!1), { passive: !0 }),
                    o)
                  : o
              })(t)
            return (e, r) => (
              xo(),
              To(
                GB,
                { id: e.id, class: "section-wrapper" },
                {
                  default: yr(() => [
                    No(
                      In(Oy),
                      {
                        as: "section",
                        class: Ge(["section-accordion", { "section-accordion-transparent": e.transparent }]),
                      },
                      {
                        default: yr(({ open: r }) => [
                          No(
                            In(wy),
                            { ref_key: "button", ref: t, class: "section-accordion-button" },
                            {
                              default: yr(() => [
                                Ro("div", JB, [Xr(e.$slots, "title", {}, void 0, !0)]),
                                e.$slots.actions
                                  ? (xo(), Eo("div", ej, [Xr(e.$slots, "actions", { active: In(n) || r }, void 0, !0)]))
                                  : Qo("", !0),
                                No(
                                  In(BI),
                                  { class: "section-accordion-chevron", icon: r ? "ChevronDown" : "ChevronRight" },
                                  null,
                                  8,
                                  ["icon"],
                                ),
                              ]),
                              _: 2,
                            },
                            1536,
                          ),
                          No(
                            In(xy),
                            { class: "section-accordion-content" },
                            {
                              default: yr(() => [
                                e.$slots.description
                                  ? (xo(), Eo("div", tj, [Xr(e.$slots, "description", {}, void 0, !0)]))
                                  : Qo("", !0),
                                Ro("div", nj, [Xr(e.$slots, "default", {}, void 0, !0)]),
                              ]),
                              _: 3,
                            },
                          ),
                        ]),
                        _: 3,
                      },
                      8,
                      ["class"],
                    ),
                  ]),
                  _: 3,
                },
                8,
                ["id"],
              )
            )
          },
        }),
        [["__scopeId", "data-v-07cabcb0"]],
      ),
      aj = { class: "section-column" },
      oj = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", aj, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-d64e7382"],
      ]),
      ij = { class: "section-columns" },
      sj = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", ij, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-8b9602bf"],
      ]),
      lj = { class: "section-container" },
      cj = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", lj, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-34b26958"],
      ]),
      dj = { class: "section-accordion-wrapper" },
      uj = { class: "section-accordion-title" },
      pj = QQ(
        Hr({
          __name: "SectionContainerAccordion",
          setup: (e) => (e, t) => (
            xo(),
            Eo("div", dj, [
              No(
                In(Oy),
                { as: "div", class: "section-accordion", defaultOpen: "" },
                {
                  default: yr(({ open: t }) => [
                    No(
                      In(wy),
                      { class: "section-accordion-button" },
                      {
                        default: yr(() => [
                          No(
                            In(BI),
                            { class: "section-accordion-chevron", icon: t ? "ChevronDown" : "ChevronRight" },
                            null,
                            8,
                            ["icon"],
                          ),
                          Ro("div", uj, [Xr(e.$slots, "title", {}, void 0, !0)]),
                        ]),
                        _: 2,
                      },
                      1024,
                    ),
                    No(
                      In(xy),
                      { class: "section-accordion-content" },
                      { default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]), _: 3 },
                    ),
                  ]),
                  _: 3,
                },
              ),
            ])
          ),
        }),
        [["__scopeId", "data-v-2049975e"]],
      ),
      hj = QQ(
        Hr({
          __name: "LoadingSkeleton",
          props: { lines: { default: 1 } },
          setup: (e) => (e, t) => (
            xo(!0),
            Eo(
              go,
              null,
              qr(
                [...Array(e.lines).keys()],
                (t) => (xo(), Eo("div", { key: t, class: Ge(["loading", { "single-line": 1 === e.lines }]) }, null, 2)),
              ),
              128,
            )
          ),
        }),
        [["__scopeId", "data-v-c90b2c46"]],
      ),
      fj = { class: "section-content" },
      mj = QQ(
        Hr({
          __name: "SectionContent",
          props: { loading: { type: Boolean, default: !1 } },
          setup: (e) => (e, t) => (
            xo(),
            Eo("div", fj, [
              e.loading ? (xo(), To(hj, { key: 1, lines: 8 })) : Xr(e.$slots, "default", { key: 0 }, void 0, !0),
            ])
          ),
        }),
        [["__scopeId", "data-v-9735459e"]],
      ),
      gj = QQ(
        Hr({
          __name: "SectionHeader",
          props: {
            loading: { type: Boolean, default: !1 },
            tight: { type: Boolean, default: !1 },
            level: { default: 1 },
          },
          setup: (e) => (e, t) =>
            e.loading
              ? (xo(), To(hj, { key: 0 }))
              : (xo(),
                To(
                  Tr(`h${e.level}`),
                  { key: 1, class: Ge(["section-header", { tight: e.tight }]) },
                  { default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]), _: 3 },
                  8,
                  ["class"],
                )),
        }),
        [["__scopeId", "data-v-3bd1b9f0"]],
      ),
      bj = { key: 0, class: "introduction-description" },
      vj = QQ(
        Hr({
          __name: "Description",
          props: { value: {} },
          setup(e) {
            const t = e,
              n = `components-Content-Introduction-Description-sections${hs(t.value)}`,
              r = Cm(async () => {
                if (!t.value) return []
                const e = await Bf(t.value),
                  n = jf(e)
                return await Promise.all(
                  (function (e, t = 1) {
                    const n = new RegExp(`^(?=#{${t}} )`, "m")
                    return e
                      .split(n)
                      .map((e) => e.trim())
                      .filter(Boolean)
                  })(t.value, n).map(async (e) => ({ heading: (await Bf(e))[0], content: e })),
                )
              }, Nd[n] ?? []),
              { getHeadingId: a, hash: o, isIntersectionEnabled: i, pathRouting: s } = fp()
            return (
              Qr(async () => {
                const e = Va()
                await ym(1), (e.payload.data[n] = r.value)
              }),
              (e, t) =>
                e.value
                  ? (xo(),
                    Eo("div", bj, [
                      (xo(!0),
                      Eo(
                        go,
                        null,
                        qr(
                          In(r),
                          (e, t) => (
                            xo(),
                            Eo(
                              go,
                              { key: t },
                              [
                                e.heading
                                  ? (xo(),
                                    To(
                                      GB,
                                      {
                                        key: 0,
                                        id: In(a)(e.heading),
                                        class: "introduction-description-heading",
                                        onIntersecting: () =>
                                          (function (e = "") {
                                            if (!i.value) return
                                            const t = new URL(window.location.href)
                                            s.value ? (t.pathname = qf(s.value.basePath, e)) : (t.hash = e),
                                              (o.value = e),
                                              window.history.replaceState({}, "", t)
                                          })(In(a)(e.heading)),
                                      },
                                      {
                                        default: yr(() => [
                                          No(In(ZI), { value: e.content, withImages: "" }, null, 8, ["value"]),
                                        ]),
                                        _: 2,
                                      },
                                      1032,
                                      ["id", "onIntersecting"],
                                    ))
                                  : (xo(),
                                    To(In(ZI), { key: 1, value: e.content, withImages: "" }, null, 8, ["value"])),
                              ],
                              64,
                            )
                          ),
                        ),
                        128,
                      )),
                    ]))
                  : Qo("", !0)
            )
          },
        }),
        [["__scopeId", "data-v-61b651b9"]],
      ),
      yj = { class: "download" },
      Oj = { class: "download-cta" },
      wj = QQ(
        Hr({
          __name: "DownloadSpec",
          props: { specTitle: {} },
          setup(e) {
            const t = e,
              n = xa(bm),
              r = () => {
                Bm.emit({ id: "", specTitle: t.specTitle })
              }
            return (e, t) => {
              var a
              return (
                xo(),
                Eo("div", yj, [
                  Ro("div", Oj, [
                    (null == (a = In(n)) ? void 0 : a())
                      ? Qo("", !0)
                      : (xo(),
                        Eo(
                          "button",
                          { key: 0, class: "download-button", type: "button", onClick: r },
                          " Download OpenAPI Spec ",
                        )),
                  ]),
                ])
              )
            }
          },
        }),
        [["__scopeId", "data-v-810904a4"]],
      ),
      xj = { class: "badges" },
      kj = { class: "sticky-cards" },
      _j = QQ(
        Hr({
          __name: "Introduction",
          props: { info: {}, parsedSpec: {} },
          setup(e) {
            const t = e,
              n = new tp(),
              r = ii(() => t.parsedSpec.openapi ?? t.parsedSpec.swagger ?? ""),
              a = ii(() => n.slug(t.info.title ?? ""))
            return (e, t) => (
              xo(),
              To(In(cj), null, {
                default: yr(() => [
                  No(
                    In(KB),
                    { class: "introduction-section" },
                    {
                      default: yr(() => [
                        No(
                          In(mj),
                          { loading: !e.info.description && !e.info.title },
                          {
                            default: yr(() => [
                              No(In(sj), null, {
                                default: yr(() => [
                                  No(In(oj), null, {
                                    default: yr(() => [
                                      Ro("div", xj, [
                                        e.info.version
                                          ? (xo(),
                                            To(
                                              In(YB),
                                              { key: 0 },
                                              { default: yr(() => [Mo(at(e.info.version), 1)]), _: 1 },
                                            ))
                                          : Qo("", !0),
                                        r.value
                                          ? (xo(),
                                            To(
                                              In(YB),
                                              { key: 1 },
                                              { default: yr(() => [Mo(" OAS " + at(r.value), 1)]), _: 1 },
                                            ))
                                          : Qo("", !0),
                                      ]),
                                      No(
                                        In(gj),
                                        { level: 1, loading: !e.info.title, tight: "" },
                                        { default: yr(() => [Mo(at(e.info.title), 1)]), _: 1 },
                                        8,
                                        ["loading"],
                                      ),
                                      No(wj, { specTitle: a.value }, null, 8, ["specTitle"]),
                                      No(vj, { value: e.info.description }, null, 8, ["value"]),
                                    ]),
                                    _: 1,
                                  }),
                                  e.$slots.aside
                                    ? (xo(),
                                      To(
                                        In(oj),
                                        { key: 0 },
                                        {
                                          default: yr(() => [Ro("div", kj, [Xr(e.$slots, "aside", {}, void 0, !0)])]),
                                          _: 3,
                                        },
                                      ))
                                    : Qo("", !0),
                                ]),
                                _: 3,
                              }),
                            ]),
                            _: 3,
                          },
                          8,
                          ["loading"],
                        ),
                        Xr(e.$slots, "after", {}, void 0, !0),
                      ]),
                      _: 3,
                    },
                  ),
                ]),
                _: 3,
              })
            )
          },
        }),
        [["__scopeId", "data-v-83f73a98"]],
      ),
      Sj = Mm(Symbol()),
      Ej = Hr({
        __name: "Lazy",
        props: { id: {}, isLazy: { type: Boolean, default: !0 }, lazyTimeout: { default: 0 } },
        setup(e) {
          const t = e,
            n = Dn(!t.isLazy)
          return (
            t.isLazy
              ? ((e = () => {}) => {
                  "undefined" == typeof window ||
                    ("requestIdleCallback" in window
                      ? setTimeout(() => window.requestIdleCallback(e), t.lazyTimeout)
                      : setTimeout(() => rr(e), t.lazyTimeout ?? 300))
                })(() => {
                  ;(n.value = !0), t.id && rr(() => Sj.emit({ id: t.id }))
                })
              : t.id && rr(() => Sj.emit({ id: t.id })),
            (e, t) => (n.value ? Xr(e.$slots, "default", { key: 0 }) : Qo("", !0))
          )
        },
      }),
      Tj = { key: 0, class: "screenreader-only" },
      Aj = QQ(
        Hr({
          __name: "ScreenReader",
          props: { if: { type: Boolean, default: !0 } },
          setup: (e) => (e, t) =>
            e.$props.if
              ? (xo(), Eo("span", Tj, [Xr(e.$slots, "default", {}, void 0, !0)]))
              : Xr(e.$slots, "default", { key: 1 }, void 0, !0),
        }),
        [["__scopeId", "data-v-681ebf2c"]],
      ),
      Cj = { class: "label" },
      Pj = { class: "anchor" },
      Dj = ((e) => (br("data-v-d9801d4e"), (e = e()), vr(), e))(() => Ro("span", null, "", -1)),
      Rj = QQ(
        Hr({
          __name: "Anchor",
          props: { id: {} },
          setup(e) {
            const { copyToClipboard: t } = Xu()
            return (e, n) => (
              xo(),
              Eo("span", Cj, [
                Xr(e.$slots, "default", {}, void 0, !0),
                Ro("span", Pj, [
                  Dj,
                  Ro(
                    "button",
                    {
                      class: "anchor-copy",
                      type: "button",
                      onClick:
                        n[0] ||
                        (n[0] = Wi(
                          (n) =>
                            In(t)(
                              ((e) => {
                                const t = new URL(window.location.href)
                                return (t.hash = e), t.toString()
                              })(e.id),
                            ),
                          ["stop"],
                        )),
                    },
                    [
                      Mo(" # "),
                      No(Aj, null, {
                        default: yr(() => [Mo('Copy link to "'), Xr(e.$slots, "default", {}, void 0, !0), Mo('"')]),
                        _: 3,
                      }),
                    ],
                  ),
                ]),
              ])
            )
          },
        }),
        [["__scopeId", "data-v-d9801d4e"]],
      ),
      Nj = ["value"],
      $j = ["label"],
      Ij = ["value"],
      Mj = ["value"],
      Lj = Hr({
        __name: "TextSelect",
        props: { modelValue: {}, options: {} },
        emits: ["update:modelValue"],
        setup: (e) => (e, t) => (
          xo(),
          Eo(
            "div",
            { class: Ge(["text-select", 1 === e.options.length ? "text-select--single-option" : ""]) },
            [
              Ro("span", null, [Xr(e.$slots, "default")]),
              Ro(
                "select",
                { value: e.modelValue, onInput: t[0] || (t[0] = (t) => e.$emit("update:modelValue", t.target.value)) },
                [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(
                      e.options,
                      (e) => (
                        xo(),
                        Eo(
                          go,
                          { key: e.value },
                          [
                            e.options
                              ? (xo(),
                                Eo(
                                  "optgroup",
                                  { key: 0, label: e.label },
                                  [
                                    (xo(!0),
                                    Eo(
                                      go,
                                      null,
                                      qr(
                                        e.options,
                                        (e) => (
                                          xo(), Eo("option", { key: e.value, value: e.value }, at(e.label), 9, Ij)
                                        ),
                                      ),
                                      128,
                                    )),
                                  ],
                                  8,
                                  $j,
                                ))
                              : (xo(), Eo("option", { key: e.value, value: e.value }, at(e.label), 9, Mj)),
                          ],
                          64,
                        )
                      ),
                    ),
                    128,
                  )),
                ],
                40,
                Nj,
              ),
            ],
            2,
          )
        ),
      }),
      Qj = QQ(
        Hr({
          __name: "ExamplePicker",
          props: { examples: {} },
          emits: ["update:modelValue"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              a = Dn(Object.keys(n.examples)[0])
            function o(e) {
              if (!e) return "Select an example"
              const t = n.examples[e]
              return (null == t ? void 0 : t.summary) ?? e
            }
            return (
              Ya(
                () => n.examples,
                () => {
                  var e
                  ;(e = Object.keys(n.examples)[0]) && (a.value = e)
                },
                { immediate: !0 },
              ),
              Ya(
                a,
                () => {
                  a.value && r("update:modelValue", a.value)
                },
                { immediate: !0 },
              ),
              (e, t) => (
                xo(),
                To(
                  Lj,
                  {
                    modelValue: a.value,
                    "onUpdate:modelValue": t[0] || (t[0] = (e) => (a.value = e)),
                    class: "example-selector",
                    options: Object.keys(e.examples).map((e) => ({ label: o(e), value: e })),
                  },
                  { default: yr(() => [Mo(at(o(a.value)), 1)]), _: 1 },
                  8,
                  ["modelValue", "options"],
                )
              )
            )
          },
        }),
        [["__scopeId", "data-v-090632a2"]],
      )
    function Bj(e) {
      return e.reduce((e, t) => ((e[t.name] = t.value), e), {})
    }
    function jj(e) {
      return /\s|-/.test(e)
    }
    function Uj(e, t = 0) {
      let n = [],
        r = " ".repeat(t),
        a = " ".repeat(t + 2)
      for (const [r, o] of Object.entries(e)) {
        let e = jj(r) ? `'${r}'` : r
        if (Array.isArray(o)) {
          const r = o
            .map((e) => ("string" == typeof e ? `'${e}'` : e && "object" == typeof e ? Uj(e, t + 2) : e))
            .join(`, ${a}`)
          n.push(`${a}${e}: [${r}]`)
        } else if (o && "object" == typeof o) n.push(`${a}${e}: ${Uj(o, t + 2)}`)
        else if ("string" == typeof o) {
          let t = `${o}`
          if (o.startsWith("JSON.stringify")) {
            const e = o.split("\n")
            e.length > 1 && (t = e.map((e, t) => (0 === t ? e : `${a}${e}`)).join("\n"))
          } else t = `'${o}'`
          n.push(`${a}${e}: ${t}`)
        } else n.push(`${a}${e}: ${o}`)
      }
      return `{\n${n.join(",\n")}\n${r}}`
    }
    function Fj(e) {
      var t, n
      const r = { method: "GET", ...e }
      r.method = r.method.toUpperCase()
      const a = { method: "GET" === r.method ? void 0 : r.method },
        o = new URLSearchParams(r.queryString ? Bj(r.queryString) : void 0),
        i = o.size ? `?${o.toString()}` : ""
      null != (t = r.headers) &&
        t.length &&
        ((a.headers = {}),
        r.headers.forEach((e) => {
          a.headers[e.name] = e.value
        })),
        null != (n = r.cookies) &&
          n.length &&
          ((a.headers = a.headers || {}),
          r.cookies.forEach((e) => {
            a.headers["Set-Cookie"] = a.headers["Set-Cookie"]
              ? `${a.headers["Set-Cookie"]}; ${e.name}=${e.value}`
              : `${e.name}=${e.value}`
          })),
        Object.keys(a).forEach((e) => {
          void 0 === a[e] && delete a[e]
        }),
        r.postData &&
          ((a.body = r.postData.text),
          "application/json" === r.postData.mimeType && (a.body = `JSON.stringify(${Uj(JSON.parse(a.body))})`))
      const s = Object.keys(a).length ? `, ${Uj(a)}` : ""
      return {
        target: "node",
        client: "undici",
        code: `import { request } from 'undici'\n\nconst { statusCode, body } = await request('${r.url}${i}'${s})`,
      }
    }
    function zj(e) {
      var t, n
      const r = { method: "GET", ...e }
      r.method = r.method.toUpperCase()
      const a = { method: "GET" === r.method ? void 0 : r.method },
        o = new URLSearchParams(r.queryString ? Bj(r.queryString) : void 0),
        i = o.size ? `?${o.toString()}` : ""
      null != (t = r.headers) &&
        t.length &&
        ((a.headers = {}),
        r.headers.forEach((e) => {
          a.headers[e.name] = e.value
        })),
        null != (n = r.cookies) &&
          n.length &&
          ((a.headers = a.headers || {}),
          r.cookies.forEach((e) => {
            a.headers["Set-Cookie"] = a.headers["Set-Cookie"]
              ? `${a.headers["Set-Cookie"]}; ${e.name}=${e.value}`
              : `${e.name}=${e.value}`
          })),
        Object.keys(a).forEach((e) => {
          void 0 === a[e] && delete a[e]
        }),
        r.postData &&
          ((a.body = r.postData.text),
          "application/json" === r.postData.mimeType && (a.body = `JSON.stringify(${Uj(JSON.parse(a.body))})`))
      const s = Object.keys(a).length ? `, ${Uj(a)}` : ""
      return { target: "node", client: "fetch", code: `fetch('${r.url}${i}'${s})` }
    }
    function qj(e) {
      var t, n
      const r = { method: "GET", ...e }
      r.method = r.method.toUpperCase()
      const a = { method: "GET" === r.method ? void 0 : r.method },
        o = new URLSearchParams(r.queryString ? Bj(r.queryString) : void 0),
        i = o.size ? `?${o.toString()}` : ""
      null != (t = r.headers) &&
        t.length &&
        ((a.headers = {}),
        r.headers.forEach((e) => {
          a.headers[e.name] = e.value
        })),
        null != (n = r.cookies) &&
          n.length &&
          ((a.headers = a.headers || {}),
          r.cookies.forEach((e) => {
            a.headers["Set-Cookie"] = a.headers["Set-Cookie"]
              ? `${a.headers["Set-Cookie"]}; ${e.name}=${e.value}`
              : `${e.name}=${e.value}`
          })),
        Object.keys(a).forEach((e) => {
          void 0 === a[e] && delete a[e]
        }),
        r.postData &&
          ((a.body = r.postData.text),
          "application/json" === r.postData.mimeType && (a.body = `JSON.stringify(${Uj(JSON.parse(a.body))})`))
      const s = Object.keys(a).length ? `, ${Uj(a)}` : ""
      return { target: "js", client: "fetch", code: `fetch('${r.url}${i}'${s})` }
    }
    function Zj(e) {
      var t, n
      const r = { method: "GET", ...e }
      r.method = r.method.toUpperCase()
      const a = { method: "GET" === r.method ? void 0 : r.method },
        o = new URLSearchParams(r.queryString ? Bj(r.queryString) : void 0)
      o.size &&
        ((a.query = {}),
        o.forEach((e, t) => {
          a.query[t] = e
        })),
        null != (t = r.headers) &&
          t.length &&
          ((a.headers = {}),
          r.headers.forEach((e) => {
            a.headers[e.name] = e.value
          })),
        null != (n = r.cookies) &&
          n.length &&
          ((a.headers = a.headers || {}),
          r.cookies.forEach((e) => {
            a.headers["Set-Cookie"] = a.headers["Set-Cookie"]
              ? `${a.headers["Set-Cookie"]}; ${e.name}=${e.value}`
              : `${e.name}=${e.value}`
          })),
        Object.keys(a).forEach((e) => {
          void 0 === a[e] && delete a[e]
        }),
        r.postData &&
          ((a.body = r.postData.text), "application/json" === r.postData.mimeType && (a.body = JSON.parse(a.body)))
      const i = Object.keys(a).length ? `, ${Uj(a)}` : ""
      return { target: "js", client: "ofetch", code: `ofetch('${r.url}'${i})` }
    }
    function Hj(e) {
      var t, n
      const r = { method: "GET", ...e }
      r.method = r.method.toUpperCase()
      const a = { method: "GET" === r.method ? void 0 : r.method },
        o = new URLSearchParams(r.queryString ? Bj(r.queryString) : void 0)
      o.size &&
        ((a.query = {}),
        o.forEach((e, t) => {
          a.query[t] = e
        })),
        null != (t = r.headers) &&
          t.length &&
          ((a.headers = {}),
          r.headers.forEach((e) => {
            a.headers[e.name] = e.value
          })),
        null != (n = r.cookies) &&
          n.length &&
          ((a.headers = a.headers || {}),
          r.cookies.forEach((e) => {
            a.headers["Set-Cookie"] = a.headers["Set-Cookie"]
              ? `${a.headers["Set-Cookie"]}; ${e.name}=${e.value}`
              : `${e.name}=${e.value}`
          })),
        Object.keys(a).forEach((e) => {
          void 0 === a[e] && delete a[e]
        }),
        r.postData &&
          ((a.body = r.postData.text), "application/json" === r.postData.mimeType && (a.body = JSON.parse(a.body)))
      const i = Object.keys(a).length ? `, ${Uj(a)}` : ""
      return { target: "node", client: "ofetch", code: `ofetch('${r.url}'${i})` }
    }
    function Vj() {
      const e = [Fj, zj, qj, Zj, Hj]
      return {
        get(e, t, n) {
          const r = this.findPlugin(e, t)
          if (r) return r(n)
        },
        print(e, t, n) {
          var r
          return null == (r = this.get(e, t, n)) ? void 0 : r.code
        },
        targets: () => e.map((e) => e().target).filter((e, t, n) => n.indexOf(e) === t),
        clients: () => e.map((e) => e().client),
        plugins: () =>
          e.map((e) => {
            const t = e()
            return { target: t.target, client: t.client }
          }),
        findPlugin: (t, n) =>
          e.find((e) => {
            const r = e()
            return r.target === t && r.client === n
          }),
        hasPlugin(e, t) {
          return !!this.findPlugin(e, t)
        },
      }
    }
    const Wj = { class: "scalar-card" },
      Xj = QQ({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", Wj, [Xr(e.$slots, "default", {}, void 0, !0)])
          },
        ],
        ["__scopeId", "data-v-dcabb131"],
      ]),
      Yj = QQ(
        Hr({
          __name: "CardContent",
          props: {
            muted: { type: Boolean },
            contrast: { type: Boolean },
            frameless: { type: Boolean },
            transparent: { type: Boolean },
            borderless: { type: Boolean },
          },
          setup: (e) => (e, t) => (
            xo(),
            Eo(
              "div",
              {
                class: Ge([
                  "scalar-card-content",
                  {
                    "scalar-card--muted": e.muted,
                    "scalar-card--contrast": e.contrast,
                    "scalar-card--frameless": e.frameless,
                    "scalar-card--transparent": e.transparent,
                    "scalar-card--borderless": e.borderless,
                  },
                ]),
              },
              [Xr(e.$slots, "default", {}, void 0, !0)],
              2,
            )
          ),
        }),
        [["__scopeId", "data-v-1c1d215c"]],
      ),
      Gj = { class: "scalar-card-header-slots" },
      Kj = { class: "scalar-card-header-slot scalar-card-header-title" },
      Jj = { class: "scalar-card-header-slot scalar-card-header-actions" },
      eU = QQ(
        Hr({
          __name: "CardHeader",
          props: {
            muted: { type: Boolean },
            contrast: { type: Boolean },
            frameless: { type: Boolean },
            transparent: { type: Boolean },
            borderless: { type: Boolean },
          },
          setup(e) {
            const t = e
            return (e, n) => (
              xo(),
              To(
                Yj,
                Fo(t, { class: "scalar-card-header" }),
                {
                  default: yr(() => [
                    Ro("div", Gj, [
                      Ro("div", Kj, [Xr(e.$slots, "default", {}, void 0, !0)]),
                      Ro("div", Jj, [Xr(e.$slots, "actions", {}, void 0, !0)]),
                    ]),
                  ]),
                  _: 3,
                },
                16,
              )
            )
          },
        }),
        [["__scopeId", "data-v-ef7873bc"]],
      ),
      tU = QQ(
        Hr({
          __name: "CardFooter",
          props: {
            muted: { type: Boolean },
            contrast: { type: Boolean },
            frameless: { type: Boolean },
            transparent: { type: Boolean },
            borderless: { type: Boolean },
          },
          setup(e) {
            const t = e
            return (e, n) => (
              xo(), To(Yj, Ke($o(t)), { default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]), _: 3 }, 16)
            )
          },
        }),
        [["__scopeId", "data-v-918ab8d6"]],
      ),
      nU = QQ(
        Hr({
          __name: "CardTabHeader",
          emits: ["change"],
          setup(e, { emit: t }) {
            const n = t,
              r = (e) => {
                n("change", e)
              }
            return (e, t) => (
              xo(),
              To(
                eU,
                { class: "scalar-card-header scalar-card-header-tabs" },
                {
                  actions: yr(() => [Xr(e.$slots, "actions", {}, void 0, !0)]),
                  default: yr(() => [
                    No(
                      In(Ky),
                      { onChange: r },
                      {
                        default: yr(() => [
                          No(
                            In(Jy),
                            { class: "tab-list custom-scroll" },
                            { default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]), _: 3 },
                          ),
                        ]),
                        _: 3,
                      },
                    ),
                  ]),
                  _: 3,
                },
              )
            )
          },
        }),
        [["__scopeId", "data-v-03fdb072"]],
      ),
      rU = QQ(
        Hr({
          __name: "CardTab",
          setup: (e) => (e, t) => (
            xo(),
            To(
              In(eO),
              { as: "template" },
              {
                default: yr(({ selected: t }) => [
                  Ro(
                    "button",
                    { class: Ge({ tab: !0, "tab-selected": t }), type: "button" },
                    [Ro("span", null, [Xr(e.$slots, "default", {}, void 0, !0)])],
                    2,
                  ),
                ]),
                _: 3,
              },
            )
          ),
        }),
        [["__scopeId", "data-v-f373ecc2"]],
      ),
      aU = ["GET", "POST", "PUT", "HEAD", "DELETE", "PATCH", "OPTIONS", "CONNECT", "TRACE"],
      oU = {
        POST: "var(--scalar-color-green)",
        DELETE: "var(--scalar-color-red)",
        PATCH: "var(--scalar-color-yellow)",
        GET: "var(--scalar-color-blue)",
        PUT: "var(--scalar-color-orange)",
        OPTIONS: "var(--scalar-color-purple)",
        HEAD: "var(--scalar-color-2)",
        CONNECT: "var(--scalar-color-2)",
        TRACE: "var(--scalar-color-2)",
      },
      iU = {
        POST: "POST",
        DELETE: "DEL",
        PATCH: "PATCH",
        GET: "GET",
        PUT: "PUT",
        OPTIONS: "OPTS",
        HEAD: "HEAD",
        CONNECT: "CONN",
        TRACE: "TRACE",
      }
    function sU(e) {
      return aU.includes(e)
    }
    const lU = Hr({
        __name: "HttpMethod",
        props: { as: {}, property: {}, short: { type: Boolean }, method: {} },
        setup(e) {
          const t = e,
            n = ii(() => t.method.trim().toUpperCase()),
            r = ii(() => (sU(n.value) ? iU[n.value] : n.value.slice(0, 4))),
            a = ii(() => (sU(n.value) ? oU[n.value] : "var(--scalar-color-ghost)"))
          return (e, t) => (
            xo(),
            To(
              Tr(e.as ?? "span"),
              { style: He({ [e.property || "color"]: a.value }) },
              {
                default: yr(() => [
                  Xr(e.$slots, "default", Ke($o({ normalized: n.value, abbreviated: r.value, color: a.value })), () => [
                    Mo(at(e.short ? r.value : n.value), 1),
                  ]),
                ]),
                _: 3,
              },
              8,
              ["style"],
            )
          )
        },
      }),
      cU = { class: "request-header" },
      dU = { class: "code-snippet" },
      uU = { key: 0, class: "request-card-footer-addon" },
      pU = Hr({
        __name: "ExampleRequest",
        props: { customExamples: {}, operation: {} },
        setup(e) {
          var t
          const n = e,
            r = `components-Content-Operation-Example-Request${hs(n.operation.path + n.operation.httpVerb + n.operation.operationId)}`,
            a = Dn(),
            { httpClient: o, setHttpClient: i, availableTargets: s, httpTargetTitle: l, httpClientTitle: c } = Rb(),
            { server: d } = au(),
            { authentication: u } = Zd(),
            p = Dn(
              (null == (t = n.customExamples) ? void 0 : t.length)
                ? { targetKey: "customExamples", clientKey: 0 }
                : { targetKey: o.targetKey, clientKey: o.clientKey },
            )
          Ya(o, () => {
            p.value = { targetKey: o.targetKey, clientKey: o.clientKey }
          })
          const h = ii(() => {
              var e, t, r, a
              return (
                Object.keys(
                  (null ==
                  (a =
                    null ==
                    (r =
                      null == (t = null == (e = n.operation.information) ? void 0 : e.requestBody) ? void 0 : t.content)
                      ? void 0
                      : r["application/json"])
                    ? void 0
                    : a.examples) ?? {},
                ).length > 1
              )
            }),
            f = xa(gm)
          async function m() {
            var e, t, r
            if ("customExamples" === p.value.targetKey)
              return (
                (null == (t = null == (e = n.customExamples) ? void 0 : e[p.value.clientKey]) ? void 0 : t.source) ?? ""
              )
            const i = Qf(
                { url: $d(d) },
                kp(n.operation, { replaceVariables: !0 }, a.value),
                cs(u, (null == (r = n.operation.information) ? void 0 : r.security) ?? (null == f ? void 0 : f())),
              ),
              s = "undici" === o.clientKey || "fetch" === o.clientKey || "ofetch" === o.clientKey ? o.clientKey : null,
              l = o.targetKey.replace("javascript", "js")
            if (s && Vj().hasPlugin(l, s) && ("node" === l || "js" === l)) return Vj().print(l, s, i) ?? ""
            try {
              const e = new gb(i)
              return await e.convert(o.targetKey, o.clientKey)
            } catch (e) {
              return console.error("[ExampleRequest]", e), ""
            }
          }
          const g = Cm(async () => {
            try {
              return await m()
            } catch (e) {
              return console.error("[generateSnippet]", e), ""
            }
          }, Nd[r] ?? "")
          Qr(async () => {
            Va().payload.data[r] = await m()
          }),
            ii(() =>
              _p({
                serverState: d,
                authenticationState: u,
                operation: n.operation,
                globalSecurity: null == f ? void 0 : f(),
              }),
            )
          const b = ii(() => {
              var e, t, r
              const a =
                "customExamples" === (null == (e = p.value) ? void 0 : e.targetKey)
                  ? ((null == (r = null == (t = n.customExamples) ? void 0 : t[p.value.clientKey]) ? void 0 : r.lang) ??
                    "plaintext")
                  : o.targetKey
              return "shell" === a && g.value.includes("curl") ? "curl" : "Objective-C" === a ? "objc" : a
            }),
            v = ii(() => {
              var e
              const t = s.value.map((e) => ({
                value: e.key,
                label: e.title,
                options: e.clients.map((t) => ({
                  value: JSON.stringify({ targetKey: e.key, clientKey: t.key }),
                  label: t.title,
                })),
              }))
              return (
                (null == (e = n.customExamples) ? void 0 : e.length) &&
                  t.unshift({
                    value: "customExamples",
                    label: "Examples",
                    options: n.customExamples.map((e, t) => ({
                      value: JSON.stringify({ targetKey: "customExamples", clientKey: t }),
                      label: e.label ?? e.lang ?? `Example #${t + 1}`,
                    })),
                  }),
                t
              )
            })
          function y(e) {
            const t = JSON.parse(e)
            "customExamples" === t.targetKey ? (p.value = t) : i(t)
          }
          return (e, t) => (
            xo(),
            To(
              In(Xj),
              { class: "dark-mode" },
              {
                default: yr(() => [
                  No(
                    In(eU),
                    { muted: "" },
                    {
                      actions: yr(() => [
                        No(
                          Lj,
                          {
                            class: "request-client-picker",
                            modelValue: JSON.stringify(p.value),
                            options: v.value,
                            "onUpdate:modelValue": y,
                          },
                          {
                            default: yr(() => {
                              var e
                              return [
                                "customExamples" === p.value.targetKey
                                  ? (xo(),
                                    Eo(
                                      go,
                                      { key: 0 },
                                      [
                                        Mo(
                                          at(
                                            (null == (e = n.customExamples) ? void 0 : e[p.value.clientKey].label) ??
                                              "Example",
                                          ),
                                          1,
                                        ),
                                      ],
                                      64,
                                    ))
                                  : (xo(), Eo(go, { key: 1 }, [Mo(at(In(l)) + " " + at(In(c)), 1)], 64)),
                              ]
                            }),
                            _: 1,
                          },
                          8,
                          ["modelValue", "options"],
                        ),
                      ]),
                      default: yr(() => [
                        Ro("div", cU, [
                          No(In(lU), { as: "span", class: "request-method", method: e.operation.httpVerb }, null, 8, [
                            "method",
                          ]),
                          Xr(e.$slots, "header", {}, void 0, !0),
                        ]),
                      ]),
                      _: 3,
                    },
                  ),
                  No(
                    In(Yj),
                    { borderless: "", class: "request-editor-section custom-scroll", frameless: "" },
                    {
                      default: yr(() => [
                        Ro("div", dU, [
                          No(
                            In(zI),
                            { content: In(g), hideCredentials: In(us)(In(u)), lang: b.value, lineNumbers: "" },
                            null,
                            8,
                            ["content", "hideCredentials", "lang"],
                          ),
                        ]),
                      ]),
                      _: 1,
                    },
                  ),
                  h.value || e.$slots.footer
                    ? (xo(),
                      To(
                        In(tU),
                        { key: 0, class: "request-card-footer", contrast: "" },
                        {
                          default: yr(() => {
                            var n, r, o, i
                            return [
                              h.value
                                ? (xo(),
                                  Eo("div", uU, [
                                    No(
                                      Qj,
                                      {
                                        class: "request-example-selector",
                                        examples:
                                          (null ==
                                          (i =
                                            null ==
                                            (o =
                                              null ==
                                              (r = null == (n = e.operation.information) ? void 0 : n.requestBody)
                                                ? void 0
                                                : r.content)
                                              ? void 0
                                              : o["application/json"])
                                            ? void 0
                                            : i.examples) ?? [],
                                        "onUpdate:modelValue": t[0] || (t[0] = (e) => (a.value = e)),
                                      },
                                      null,
                                      8,
                                      ["examples"],
                                    ),
                                  ]))
                                : Qo("", !0),
                              Xr(e.$slots, "footer", {}, void 0, !0),
                            ]
                          }),
                          _: 3,
                        },
                      ))
                    : Qo("", !0),
                ]),
                _: 3,
              },
            )
          )
        },
      }),
      hU = QQ(pU, [["__scopeId", "data-v-eedd3e3e"]]),
      fU = { key: 0, class: "schema-type" },
      mU = ["title"],
      gU = QQ(
        Hr({
          __name: "SchemaHeading",
          props: { value: {}, name: {} },
          setup: (e) => (e, t) => {
            var n, r, a, o, i, s
            return "object" == typeof e.value
              ? (xo(),
                Eo("span", fU, [
                  Ro(
                    "span",
                    {
                      class: "schema-type-icon",
                      title:
                        "string" == typeof e.value.type
                          ? e.value.type
                          : Array.isArray(e.value.type)
                            ? e.value.type.join(" | ")
                            : "unkown type",
                    },
                    [
                      "object" === e.value.type ? (xo(), Eo(go, { key: 0 }, [Mo(" {} ")], 64)) : Qo("", !0),
                      "array" === e.value.type ? (xo(), Eo(go, { key: 1 }, [Mo(" [] ")], 64)) : Qo("", !0),
                      e.value.enum ? (xo(), Eo(go, { key: 2 }, [Mo(" enum ")], 64)) : Qo("", !0),
                    ],
                    8,
                    mU,
                  ),
                  (null == (r = null == (n = e.value) ? void 0 : n.xml) ? void 0 : r.name) &&
                  "##default" !== (null == (o = null == (a = e.value) ? void 0 : a.xml) ? void 0 : o.name)
                    ? (xo(),
                      Eo(
                        go,
                        { key: 0 },
                        [
                          Mo(
                            " <" + at(null == (s = null == (i = e.value) ? void 0 : i.xml) ? void 0 : s.name) + " /> ",
                            1,
                          ),
                        ],
                        64,
                      ))
                    : e.name
                      ? (xo(), Eo(go, { key: 1 }, [Mo(at(e.name), 1)], 64))
                      : (xo(), Eo(go, { key: 2 }, [Mo(at(e.value.type), 1)], 64)),
                ]))
              : Qo("", !0)
          },
        }),
        [["__scopeId", "data-v-c0a69ad0"]],
      ),
      bU = { key: 0, class: "property-detail-prefix" },
      vU = { key: 1, class: "property-detail-value" },
      yU = { key: 2, class: "property-detail-value" },
      OU = QQ(
        Hr({
          __name: "SchemaPropertyDetail",
          props: { truncate: { type: Boolean }, code: { type: Boolean } },
          setup: (e) => (e, t) => (
            xo(),
            Eo(
              "span",
              { class: Ge(["property-detail", { "property-detail-truncate": e.truncate }]) },
              [
                e.$slots.prefix
                  ? (xo(), Eo("div", bU, [Xr(e.$slots, "prefix", {}, void 0, !0), Mo(" ")]))
                  : Qo("", !0),
                e.code
                  ? (xo(), Eo("code", vU, [Xr(e.$slots, "default", {}, void 0, !0)]))
                  : (xo(), Eo("span", yU, [Xr(e.$slots, "default", {}, void 0, !0)])),
              ],
              2,
            )
          ),
        }),
        [["__scopeId", "data-v-16d94ef5"]],
      ),
      wU = { class: "property-heading" },
      xU = { key: 0, class: "property-name" },
      kU = { key: 1, class: "property-additional" },
      _U = { key: 2, class: "property-deprecated" },
      SU = { key: 3, class: "property-required" },
      EU = { key: 4, class: "property-const" },
      TU = { key: 5, class: "property-details" },
      AU = { key: 6, class: "property-write-only" },
      CU = { key: 7, class: "property-read-only" },
      PU = Hr({
        __name: "SchemaPropertyHeading",
        props: {
          value: {},
          enum: { type: Boolean },
          required: { type: Boolean, default: !1 },
          additional: { type: Boolean },
        },
        setup(e) {
          const t = ["oneOf", "anyOf", "allOf", "not"]
          return (e, n) => {
            var r, a, o, i, s, l, c
            return (
              xo(),
              Eo("div", wU, [
                e.$slots.name ? (xo(), Eo("div", xU, [Xr(e.$slots, "name", {}, void 0, !0)])) : Qo("", !0),
                e.additional
                  ? (xo(),
                    Eo("div", kU, [
                      (null == (r = e.value) ? void 0 : r["x-additionalPropertiesName"])
                        ? (xo(), Eo(go, { key: 0 }, [Mo(at(e.value["x-additionalPropertiesName"]), 1)], 64))
                        : (xo(), Eo(go, { key: 1 }, [Mo(" additional properties ")], 64)),
                    ]))
                  : Qo("", !0),
                (null == (a = e.value) ? void 0 : a.deprecated)
                  ? (xo(), Eo("div", _U, [No(In(YB), null, { default: yr(() => [Mo("deprecated")]), _: 1 })]))
                  : Qo("", !0),
                e.required ? (xo(), Eo("div", SU, " required ")) : Qo("", !0),
                (null == (o = e.value) ? void 0 : o.const) ||
                ((null == (i = e.value) ? void 0 : i.enum) && 1 === e.value.enum.length)
                  ? (xo(),
                    Eo("div", EU, [
                      No(
                        OU,
                        { truncate: "" },
                        {
                          prefix: yr(() => [Mo("const:")]),
                          default: yr(() => [Mo(" " + at(e.value.const ?? e.value.enum[0]), 1)]),
                          _: 1,
                        },
                      ),
                    ]))
                  : (null == (s = e.value) ? void 0 : s.type)
                    ? (xo(),
                      Eo("div", TU, [
                        e.additional
                          ? (xo(),
                            To(
                              OU,
                              { key: 0 },
                              { prefix: yr(() => [Mo("key:")]), default: yr(() => [Mo(" string ")]), _: 1 },
                            ))
                          : Qo("", !0),
                        No(
                          OU,
                          null,
                          Zr(
                            {
                              default: yr(() => {
                                var t, n, r
                                return [
                                  (null == (n = null == (t = e.value) ? void 0 : t.items) ? void 0 : n.type)
                                    ? (xo(),
                                      Eo(
                                        go,
                                        { key: 0 },
                                        [Mo(at(e.value.type) + " " + at(e.value.items.type) + "[] ", 1)],
                                        64,
                                      ))
                                    : (xo(),
                                      Eo(
                                        go,
                                        { key: 1 },
                                        [
                                          Mo(
                                            at(Array.isArray(e.value.type) ? e.value.type.join(" | ") : e.value.type) +
                                              " " +
                                              at((null == (r = e.value) ? void 0 : r.nullable) ? " | nullable" : ""),
                                            1,
                                          ),
                                        ],
                                        64,
                                      )),
                                  e.value.minItems || e.value.maxItems
                                    ? (xo(),
                                      Eo(
                                        go,
                                        { key: 2 },
                                        [Mo(at(e.value.minItems) + "" + at(e.value.maxItems), 1)],
                                        64,
                                      ))
                                    : Qo("", !0),
                                ]
                              }),
                              _: 2,
                            },
                            [e.additional ? { name: "prefix", fn: yr(() => [Mo("value:")]), key: "0" } : void 0],
                          ),
                          1024,
                        ),
                        e.value.minLength
                          ? (xo(),
                            To(
                              OU,
                              { key: 1 },
                              {
                                prefix: yr(() => [Mo("min:")]),
                                default: yr(() => [Mo(" " + at(e.value.minLength), 1)]),
                                _: 1,
                              },
                            ))
                          : Qo("", !0),
                        e.value.maxLength
                          ? (xo(),
                            To(
                              OU,
                              { key: 2 },
                              {
                                prefix: yr(() => [Mo("max:")]),
                                default: yr(() => [Mo(" " + at(e.value.maxLength), 1)]),
                                _: 1,
                              },
                            ))
                          : Qo("", !0),
                        e.value.uniqueItems
                          ? (xo(), To(OU, { key: 3 }, { default: yr(() => [Mo(" unique! ")]), _: 1 }))
                          : Qo("", !0),
                        e.value.format
                          ? (xo(), To(OU, { key: 4 }, { default: yr(() => [Mo(at(e.value.format), 1)]), _: 1 }))
                          : Qo("", !0),
                        void 0 !== e.value.minimum && e.value.exclusiveMinimum
                          ? (xo(),
                            To(
                              OU,
                              { key: 5 },
                              {
                                prefix: yr(() => [Mo("greater than:")]),
                                default: yr(() => [Mo(" " + at(e.value.minimum), 1)]),
                                _: 1,
                              },
                            ))
                          : Qo("", !0),
                        void 0 === e.value.minimum || e.value.exclusiveMinimum
                          ? Qo("", !0)
                          : (xo(),
                            To(
                              OU,
                              { key: 6 },
                              {
                                prefix: yr(() => [Mo("min:")]),
                                default: yr(() => [Mo(" " + at(e.value.minimum), 1)]),
                                _: 1,
                              },
                            )),
                        void 0 !== e.value.maximum && e.value.exclusiveMaximum
                          ? (xo(),
                            To(
                              OU,
                              { key: 7 },
                              {
                                prefix: yr(() => [Mo("less than:")]),
                                default: yr(() => [Mo(" " + at(e.value.maximum), 1)]),
                                _: 1,
                              },
                            ))
                          : Qo("", !0),
                        void 0 === e.value.maximum || e.value.exclusiveMaximum
                          ? Qo("", !0)
                          : (xo(),
                            To(
                              OU,
                              { key: 8 },
                              {
                                prefix: yr(() => [Mo("max:")]),
                                default: yr(() => [Mo(" " + at(e.value.maximum), 1)]),
                                _: 1,
                              },
                            )),
                        e.value.pattern
                          ? (xo(),
                            To(
                              OU,
                              { key: 9, code: "", truncate: "" },
                              { default: yr(() => [Mo(at(e.value.pattern), 1)]), _: 1 },
                            ))
                          : Qo("", !0),
                        e.$props.enum
                          ? (xo(), To(OU, { key: 10 }, { default: yr(() => [Mo("enum")]), _: 1 }))
                          : Qo("", !0),
                        e.value.default
                          ? (xo(),
                            To(
                              OU,
                              { key: 11, truncate: "" },
                              {
                                prefix: yr(() => [Mo("default:")]),
                                default: yr(() => {
                                  return [
                                    Mo(
                                      " " +
                                        at(
                                          ((t = e.value),
                                          Array.isArray(null == t ? void 0 : t.default) && 1 === t.default.length
                                            ? t.default[0]
                                            : null == t
                                              ? void 0
                                              : t.default),
                                        ),
                                      1,
                                    ),
                                  ]
                                  var t
                                }),
                                _: 1,
                              },
                            ))
                          : Qo("", !0),
                      ]))
                    : Qo("", !0),
                (null == (l = e.value) ? void 0 : l.writeOnly)
                  ? (xo(), Eo("div", AU, " write-only "))
                  : (null == (c = e.value) ? void 0 : c.readOnly)
                    ? (xo(), Eo("div", CU, " read-only "))
                    : Qo("", !0),
                (xo(!0),
                Eo(
                  go,
                  null,
                  qr(
                    t.filter((t) => {
                      var n, r, a
                      return (
                        (null == (n = e.value) ? void 0 : n[t]) ||
                        (null == (a = null == (r = e.value) ? void 0 : r.items) ? void 0 : a[t])
                      )
                    }),
                    (e) => (xo(), To(In(YB), { key: e }, { default: yr(() => [Mo(at(e), 1)]), _: 2 }, 1024)),
                  ),
                  128,
                )),
              ])
            )
          }
        },
      }),
      DU = QQ(PU, [["__scopeId", "data-v-38a47495"]]),
      RU = { key: 0, class: "property-description" },
      NU = { key: 1, class: "property-description" },
      $U = { key: 2, class: "property-example custom-scroll" },
      IU = ((e) => (br("data-v-fb06e93b"), (e = e()), vr(), e))(() =>
        Ro("span", { class: "property-example-label" }, "Example", -1),
      ),
      MU = { class: "property-example-value" },
      LU = { key: 3, class: "property-enum" },
      QU = { key: 0, class: "property-list" },
      BU = { class: "property-heading" },
      jU = { class: "property-name" },
      UU = { class: "property-description" },
      FU = { key: 1, class: "property-enum-values" },
      zU = { key: 4, class: "children" },
      qU = { key: 0, class: "children" },
      ZU = { key: 0, class: "property-rule" },
      HU = { key: 1, class: "property-rule" },
      VU = QQ(
        Hr({
          __name: "SchemaProperty",
          props: {
            value: {},
            level: { default: 0 },
            name: {},
            required: { type: Boolean, default: !1 },
            compact: { type: Boolean, default: !1 },
            description: {},
            additional: { type: Boolean },
          },
          setup(e) {
            const t = {
                integer: {
                  _default: "Integer numbers.",
                  int32: "Signed 32-bit integers (commonly used integer type).",
                  int64: "Signed 64-bit integers (long type).",
                },
                string: {
                  date: "full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21",
                  "date-time":
                    "the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z",
                  password: "a hint to UIs to mask the input",
                  byte: "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
                  binary: "binary data, used to describe files",
                },
              },
              n = function (e, t) {
                return (null == t ? void 0 : t.properties) || (null == t ? void 0 : t.additionalProperties)
                  ? null
                  : e || (null == t ? void 0 : t.description) || null
              },
              r = function (e) {
                return e && t[e.type] ? t[e.type][e.format || "_default"] : null
              },
              a = function (e) {
                var t
                return (
                  (null == e ? void 0 : e.enum) || (null == (t = null == e ? void 0 : e.items) ? void 0 : t.enum) || []
                )
              },
              o = ["oneOf", "anyOf", "allOf", "not"]
            return (e, t) => {
              var i, s, l, c, d, u, p, h, f, m, g
              return (
                xo(),
                Eo(
                  "div",
                  {
                    class: Ge([
                      "property",
                      [
                        `property--level-${e.level}`,
                        {
                          "property--compact": e.compact,
                          "property--deprecated": null == (i = e.value) ? void 0 : i.deprecated,
                        },
                      ],
                    ]),
                  },
                  [
                    No(
                      DU,
                      { additional: e.additional, enum: a(e.value).length > 1, required: e.required, value: e.value },
                      Zr({ _: 2 }, [e.name ? { name: "name", fn: yr(() => [Mo(at(e.name), 1)]), key: "0" } : void 0]),
                      1032,
                      ["additional", "enum", "required", "value"],
                    ),
                    n(e.description, e.value)
                      ? (xo(), Eo("div", RU, [No(In(ZI), { value: n(e.description, e.value) }, null, 8, ["value"])]))
                      : r(e.value)
                        ? (xo(), Eo("div", NU, [No(In(ZI), { value: r(e.value) || "" }, null, 8, ["value"])]))
                        : Qo("", !0),
                    (null == (s = e.value) ? void 0 : s.example) ||
                    (null == (c = null == (l = e.value) ? void 0 : l.items) ? void 0 : c.example)
                      ? (xo(),
                        Eo("div", $U, [
                          IU,
                          Ro("code", MU, at(e.value.example || (null == (d = e.value) ? void 0 : d.items.example)), 1),
                        ]))
                      : Qo("", !0),
                    (null == (u = a(e.value)) ? void 0 : u.length) > 1
                      ? (xo(),
                        Eo("div", LU, [
                          (null == (p = e.value) ? void 0 : p["x-enumDescriptions"])
                            ? (xo(),
                              Eo("div", QU, [
                                (xo(!0),
                                Eo(
                                  go,
                                  null,
                                  qr(
                                    a(e.value),
                                    (t) => (
                                      xo(),
                                      Eo("div", { key: t, class: "property" }, [
                                        Ro("div", BU, [Ro("div", jU, at(t), 1)]),
                                        Ro("div", UU, [
                                          No(In(ZI), { value: e.value["x-enumDescriptions"][t] }, null, 8, ["value"]),
                                        ]),
                                      ])
                                    ),
                                  ),
                                  128,
                                )),
                              ]))
                            : (xo(),
                              Eo("ul", FU, [
                                (xo(!0),
                                Eo(
                                  go,
                                  null,
                                  qr(
                                    a(e.value),
                                    (e) => (xo(), Eo("li", { key: e, class: "property-enum-value" }, at(e), 1)),
                                  ),
                                  128,
                                )),
                              ])),
                        ]))
                      : Qo("", !0),
                    "object" === (null == (h = e.value) ? void 0 : h.type) &&
                    ((null == (f = e.value) ? void 0 : f.properties) ||
                      (null == (m = e.value) ? void 0 : m.additionalProperties))
                      ? (xo(),
                        Eo("div", zU, [
                          No(GU, { compact: e.compact, level: e.level + 1, value: e.value }, null, 8, [
                            "compact",
                            "level",
                            "value",
                          ]),
                        ]))
                      : Qo("", !0),
                    (null == (g = e.value) ? void 0 : g.items)
                      ? (xo(),
                        Eo(
                          go,
                          { key: 5 },
                          [
                            ["object"].includes(e.value.items.type)
                              ? (xo(),
                                Eo("div", qU, [
                                  No(GU, { compact: e.compact, level: e.level + 1, value: e.value.items }, null, 8, [
                                    "compact",
                                    "level",
                                    "value",
                                  ]),
                                ]))
                              : Qo("", !0),
                          ],
                          64,
                        ))
                      : Qo("", !0),
                    (xo(),
                    Eo(
                      go,
                      null,
                      qr(o, (t) => {
                        var n, r, a
                        return (
                          xo(),
                          Eo(
                            go,
                            { key: t },
                            [
                              (null == (n = e.value) ? void 0 : n[t])
                                ? (xo(),
                                  Eo("div", ZU, [
                                    (xo(!0),
                                    Eo(
                                      go,
                                      null,
                                      qr(
                                        e.value[t],
                                        (t, n) => (
                                          xo(),
                                          To(
                                            GU,
                                            { key: n, compact: e.compact, level: e.level + 1, value: t },
                                            null,
                                            8,
                                            ["compact", "level", "value"],
                                          )
                                        ),
                                      ),
                                      128,
                                    )),
                                  ]))
                                : Qo("", !0),
                              (null == (a = null == (r = e.value) ? void 0 : r.items) ? void 0 : a[t]) && e.level < 3
                                ? (xo(),
                                  Eo("div", HU, [
                                    (xo(!0),
                                    Eo(
                                      go,
                                      null,
                                      qr(
                                        e.value.items[t],
                                        (t, n) => (
                                          xo(),
                                          To(
                                            GU,
                                            { key: n, compact: e.compact, level: e.level + 1, value: t },
                                            null,
                                            8,
                                            ["compact", "level", "value"],
                                          )
                                        ),
                                      ),
                                      128,
                                    )),
                                  ]))
                                : Qo("", !0),
                            ],
                            64,
                          )
                        )
                      }),
                      64,
                    )),
                  ],
                  2,
                )
              )
            }
          },
        }),
        [["__scopeId", "data-v-fb06e93b"]],
      ),
      WU = { key: 0, class: "schema-card-description" },
      XU = [
        ((e) => (br("data-v-25443e6c"), (e = e()), vr(), e))(() =>
          Ro(
            "polygon",
            { "fill-rule": "nonzero", points: "14 8 8 8 8 14 6 14 6 8 0 8 0 6 6 6 6 0 8 0 8 6 14 6" },
            null,
            -1,
          ),
        ),
      ],
      YU = Hr({
        __name: "Schema",
        props: {
          value: {},
          level: { default: 0 },
          name: {},
          compact: { type: Boolean },
          noncollapsible: { type: Boolean },
        },
        setup(e) {
          const t = e,
            n = ii(() => !t.noncollapsible && 0 !== t.level),
            r = (e) => t.noncollapsible && e.stopPropagation()
          return (e, t) =>
            "object" == typeof e.value && Object.keys(e.value).length
              ? (xo(),
                To(
                  In(Oy),
                  { key: 0, defaultOpen: e.noncollapsible },
                  {
                    default: yr(({ open: t }) => {
                      var a
                      return [
                        Ro(
                          "div",
                          {
                            class: Ge([
                              "schema-card",
                              [
                                `schema-card--level-${e.level}`,
                                { "schema-card--compact": e.compact, "schema-card--open": t },
                              ],
                            ]),
                          },
                          [
                            (null == (a = e.value) ? void 0 : a.description) && "string" == typeof e.value.description
                              ? (xo(), Eo("div", WU, [No(In(ZI), { value: e.value.description }, null, 8, ["value"])]))
                              : Qo("", !0),
                            Ro(
                              "div",
                              { class: Ge(["schema-properties", { "schema-properties-open": t }]) },
                              [
                                Fr(
                                  No(
                                    In(wy),
                                    {
                                      as: e.noncollapsible ? "div" : "button",
                                      class: Ge(["schema-card-title", { "schema-card-title--compact": e.compact }]),
                                      style: He({
                                        top: `calc(var(--refs-header-height) +  calc(var(--schema-title-height) * ${e.level}))`,
                                      }),
                                      onClickCapture: r,
                                    },
                                    {
                                      default: yr(() => {
                                        var r, a, o
                                        return [
                                          e.compact
                                            ? (xo(),
                                              Eo(
                                                go,
                                                { key: 0 },
                                                [
                                                  n.value
                                                    ? (xo(),
                                                      Eo(
                                                        "svg",
                                                        {
                                                          key: 0,
                                                          class: Ge([
                                                            "schema-card-title-icon",
                                                            { "schema-card-title-icon--open": t },
                                                          ]),
                                                          fill: "currentColor",
                                                          height: "14",
                                                          viewBox: "0 0 14 14",
                                                          width: "14",
                                                          xmlns: "http://www.w3.org/2000/svg",
                                                        },
                                                        XU,
                                                        2,
                                                      ))
                                                    : Qo("", !0),
                                                  t
                                                    ? (xo(),
                                                      Eo(
                                                        go,
                                                        { key: 1 },
                                                        [
                                                          Mo(
                                                            " Hide " +
                                                              at(
                                                                (null == (r = e.value) ? void 0 : r.title) ??
                                                                  "Child Attributes",
                                                              ),
                                                            1,
                                                          ),
                                                        ],
                                                        64,
                                                      ))
                                                    : (xo(),
                                                      Eo(
                                                        go,
                                                        { key: 2 },
                                                        [
                                                          Mo(
                                                            " Show " +
                                                              at(
                                                                (null == (a = e.value) ? void 0 : a.title) ??
                                                                  "Child Attributes",
                                                              ),
                                                            1,
                                                          ),
                                                        ],
                                                        64,
                                                      )),
                                                ],
                                                64,
                                              ))
                                            : (xo(),
                                              Eo(
                                                go,
                                                { key: 1 },
                                                [
                                                  n.value
                                                    ? (xo(),
                                                      To(
                                                        In(BI),
                                                        {
                                                          key: 0,
                                                          class: Ge([
                                                            "schema-card-title-icon",
                                                            { "schema-card-title-icon--open": t },
                                                          ]),
                                                          icon: "ChevronRight",
                                                          size: "md",
                                                        },
                                                        null,
                                                        8,
                                                        ["class"],
                                                      ))
                                                    : Qo("", !0),
                                                  No(
                                                    gU,
                                                    {
                                                      name: (null == (o = e.value) ? void 0 : o.title) ?? e.name,
                                                      value: e.value,
                                                    },
                                                    null,
                                                    8,
                                                    ["name", "value"],
                                                  ),
                                                ],
                                                64,
                                              )),
                                        ]
                                      }),
                                      _: 2,
                                    },
                                    1032,
                                    ["as", "class", "style"],
                                  ),
                                  [[mi, !(e.noncollapsible && e.compact)]],
                                ),
                                No(
                                  In(xy),
                                  { static: e.noncollapsible },
                                  {
                                    default: yr(() => {
                                      var t
                                      return [
                                        e.value.properties || e.value.additionalProperties
                                          ? (xo(),
                                            Eo(
                                              go,
                                              { key: 0 },
                                              [
                                                e.value.properties
                                                  ? (xo(!0),
                                                    Eo(
                                                      go,
                                                      { key: 0 },
                                                      qr(
                                                        Object.keys(null == (t = e.value) ? void 0 : t.properties),
                                                        (t) => {
                                                          var n, r, a, o
                                                          return (
                                                            xo(),
                                                            To(
                                                              VU,
                                                              {
                                                                key: t,
                                                                compact: e.compact,
                                                                level: e.level,
                                                                name: t,
                                                                required:
                                                                  (null == (n = e.value.required)
                                                                    ? void 0
                                                                    : n.includes(t)) ||
                                                                  !0 ===
                                                                    (null ==
                                                                    (a =
                                                                      null == (r = e.value.properties) ? void 0 : r[t])
                                                                      ? void 0
                                                                      : a.required),
                                                                value: null == (o = e.value.properties) ? void 0 : o[t],
                                                              },
                                                              null,
                                                              8,
                                                              ["compact", "level", "name", "required", "value"],
                                                            )
                                                          )
                                                        },
                                                      ),
                                                      128,
                                                    ))
                                                  : Qo("", !0),
                                                e.value.additionalProperties
                                                  ? (xo(),
                                                    Eo(
                                                      go,
                                                      { key: 1 },
                                                      [
                                                        !0 !== e.value.additionalProperties &&
                                                        0 !== Object.keys(e.value.additionalProperties).length &&
                                                        e.value.additionalProperties.type
                                                          ? (xo(),
                                                            To(
                                                              VU,
                                                              {
                                                                key: 1,
                                                                additional: "",
                                                                compact: e.compact,
                                                                level: e.level,
                                                                noncollapsible: "",
                                                                value: e.value.additionalProperties,
                                                              },
                                                              null,
                                                              8,
                                                              ["compact", "level", "value"],
                                                            ))
                                                          : (xo(),
                                                            To(
                                                              VU,
                                                              {
                                                                key: 0,
                                                                additional: "",
                                                                compact: e.compact,
                                                                level: e.level,
                                                                noncollapsible: "",
                                                                value: {
                                                                  type: "any",
                                                                  ...("object" == typeof e.value.additionalProperties
                                                                    ? e.value.additionalProperties
                                                                    : {}),
                                                                },
                                                              },
                                                              null,
                                                              8,
                                                              ["compact", "level", "value"],
                                                            )),
                                                      ],
                                                      64,
                                                    ))
                                                  : Qo("", !0),
                                              ],
                                              64,
                                            ))
                                          : (xo(),
                                            To(
                                              VU,
                                              {
                                                key: 1,
                                                compact: e.compact,
                                                level: e.level,
                                                name: e.value.name,
                                                value: e.value,
                                              },
                                              null,
                                              8,
                                              ["compact", "level", "name", "value"],
                                            )),
                                      ]
                                    }),
                                    _: 1,
                                  },
                                  8,
                                  ["static"],
                                ),
                              ],
                              2,
                            ),
                          ],
                          2,
                        ),
                      ]
                    }),
                    _: 1,
                  },
                  8,
                  ["defaultOpen"],
                ))
              : Qo("", !0)
        },
      }),
      GU = QQ(YU, [["__scopeId", "data-v-25443e6c"]]),
      KU = { class: "parameter-item" },
      JU = { class: "parameter-item-container" },
      eF = QQ(
        Hr({
          __name: "ParameterItem",
          props: { parameter: {}, showChildren: { type: Boolean, default: !1 } },
          setup: (e) => (e, t) => (
            xo(),
            Eo("li", KU, [
              Ro("div", JU, [
                No(
                  In(VU),
                  {
                    compact: "",
                    description: e.parameter.description,
                    level: 0,
                    name: e.parameter.name,
                    noncollapsible: e.showChildren,
                    required: e.parameter.required,
                    value: e.parameter.schema,
                  },
                  null,
                  8,
                  ["description", "name", "noncollapsible", "required", "value"],
                ),
              ]),
            ])
          ),
        }),
        [["__scopeId", "data-v-f70ee55c"]],
      ),
      tF = { key: 0, class: "parameters" },
      nF = { class: "parameters-title" },
      rF = { class: "parameter-list" },
      aF = QQ(
        Hr({
          __name: "Parameters",
          props: { parameters: {}, showChildren: { type: Boolean, default: !1 } },
          setup: (e) => (e, t) => {
            var n
            return (null == (n = e.parameters) ? void 0 : n.length)
              ? (xo(),
                Eo("div", tF, [
                  Ro("div", nF, [Xr(e.$slots, "title", {}, void 0, !0)]),
                  Ro("ul", rF, [
                    (xo(!0),
                    Eo(
                      go,
                      null,
                      qr(
                        e.parameters,
                        (t) => (
                          xo(),
                          To(eF, { key: t.name, parameter: t, showChildren: e.showChildren }, null, 8, [
                            "parameter",
                            "showChildren",
                          ])
                        ),
                      ),
                      128,
                    )),
                  ]),
                ]))
              : Qo("", !0)
          },
        }),
        [["__scopeId", "data-v-45fca787"]],
      ),
      oF = { key: 0 },
      iF = { class: "request-body-title" },
      sF = ["value"],
      lF = { key: 0, class: "request-body-description" },
      cF = { key: 0, class: "request-body-schema" },
      dF = QQ(
        Hr({
          __name: "RequestBody",
          props: { requestBody: {} },
          setup(e) {
            var t
            const n = e,
              r = ii(() => {
                var e
                return (null == (e = n.requestBody) ? void 0 : e.content) ? Object.keys(n.requestBody.content) : []
              }),
              a = Dn("application/json")
            return (
              (null == (t = n.requestBody) ? void 0 : t.content) && r.value.length > 0 && (a.value = r.value[0]),
              (e, t) => {
                var o, i, s, l
                return (null == n ? void 0 : n.requestBody)
                  ? (xo(),
                    Eo("div", oF, [
                      Ro("div", iF, [
                        Xr(e.$slots, "title", {}, void 0, !0),
                        Ro(
                          "div",
                          {
                            class: Ge([
                              "request-body-title-select",
                              { "request-body-title-no-select": r.value.length <= 1 },
                            ]),
                          },
                          [
                            Ro("span", null, at(a.value), 1),
                            (null == n ? void 0 : n.requestBody) && r.value.length > 1
                              ? Fr(
                                  (xo(),
                                  Eo(
                                    "select",
                                    { key: 0, "onUpdate:modelValue": t[0] || (t[0] = (e) => (a.value = e)) },
                                    [
                                      (xo(!0),
                                      Eo(
                                        go,
                                        null,
                                        qr(
                                          null == (o = n.requestBody) ? void 0 : o.content,
                                          (e, t) => (xo(), Eo("option", { key: t, value: t }, at(t), 9, sF)),
                                        ),
                                        128,
                                      )),
                                    ],
                                    512,
                                  )),
                                  [[Fi, a.value]],
                                )
                              : Qo("", !0),
                          ],
                          2,
                        ),
                        (null == n ? void 0 : n.requestBody.description)
                          ? (xo(),
                            Eo("div", lF, [No(In(ZI), { value: n.requestBody.description }, null, 8, ["value"])]))
                          : Qo("", !0),
                      ]),
                      (null == (i = null == n ? void 0 : n.requestBody.content) ? void 0 : i[a.value])
                        ? (xo(),
                          Eo("div", cF, [
                            No(
                              In(GU),
                              {
                                compact: "",
                                noncollapsible: "",
                                value:
                                  null ==
                                  (l = null == (s = null == n ? void 0 : n.requestBody.content) ? void 0 : s[a.value])
                                    ? void 0
                                    : l.schema,
                              },
                              null,
                              8,
                              ["value"],
                            ),
                          ]))
                        : Qo("", !0),
                    ]))
                  : Qo("", !0)
              }
            )
          },
        }),
        [["__scopeId", "data-v-23ed11af"]],
      ),
      uF = { class: "endpoint-details" },
      pF = { class: "endpoint-description" },
      hF = Hr({
        __name: "EndpointDetails",
        props: { operation: {} },
        setup(e) {
          const t = e,
            { parameterMap: n } = mp(t),
            { responses: r } = Um(t.operation)
          return (e, t) => {
            var a, o
            return (
              xo(),
              Eo("div", uF, [
                Ro("div", pF, [No(In(ZI), { value: e.operation.description, withImages: "" }, null, 8, ["value"])]),
                No(aF, { parameters: In(n).path }, { title: yr(() => [Mo("Path Parameters")]), _: 1 }, 8, [
                  "parameters",
                ]),
                No(aF, { parameters: In(n).query }, { title: yr(() => [Mo("Query Parameters")]), _: 1 }, 8, [
                  "parameters",
                ]),
                No(aF, { parameters: In(n).header }, { title: yr(() => [Mo("Headers")]), _: 1 }, 8, ["parameters"]),
                No(
                  aF,
                  { parameters: In(n).body, showChildren: "" },
                  { title: yr(() => [Mo("Body Parameters")]), _: 1 },
                  8,
                  ["parameters"],
                ),
                No(aF, { parameters: In(n).formData }, { title: yr(() => [Mo("Form Data")]), _: 1 }, 8, ["parameters"]),
                (null == (a = e.operation.information) ? void 0 : a.requestBody)
                  ? (xo(),
                    To(
                      dF,
                      { key: 0, requestBody: null == (o = e.operation.information) ? void 0 : o.requestBody },
                      { title: yr(() => [Mo("Body")]), _: 1 },
                      8,
                      ["requestBody"],
                    ))
                  : Qo("", !0),
                No(aF, { parameters: In(r) }, { title: yr(() => [Mo("Responses")]), _: 1 }, 8, ["parameters"]),
              ])
            )
          }
        },
      }),
      fF = { key: 0 },
      mF = Hr({
        __name: "EndpointPath",
        props: { path: {}, deprecated: { type: Boolean } },
        setup(e) {
          const t = e,
            n = (e) => e.startsWith("{") && e.endsWith("}"),
            r = ii(() => t.path.split(/({[^}]+})/))
          return (e, t) => (
            xo(),
            Eo(
              "span",
              { class: Ge(["endpoint-path", { deprecated: e.deprecated }]) },
              [
                (xo(!0),
                Eo(
                  go,
                  null,
                  qr(
                    r.value,
                    (e, t) => (
                      xo(),
                      Eo(
                        go,
                        { key: t },
                        [n(e) ? (xo(), Eo("em", fF, at(e), 1)) : (xo(), Eo(go, { key: 1 }, [Mo(at(e), 1)], 64))],
                        64,
                      )
                    ),
                  ),
                  128,
                )),
              ],
              2,
            )
          )
        },
      }),
      gF = QQ(mF, [["__scopeId", "data-v-a4eadd9b"]]),
      bF = { key: 0, class: "rule" },
      vF = { class: "rule-title" },
      yF = { class: "rule-items" },
      OF = { key: 2, class: "empty-state" },
      wF = QQ(
        Hr({
          __name: "ExampleResponse",
          props: { response: {} },
          setup(e) {
            const t = ["oneOf", "anyOf", "not"],
              n = (e) => e.reduce((e, t) => ({ ...e, ...t }), {})
            return (e, r) => {
              var a, o, i, s, l, c, d, u, p
              return (null == (a = e.response) ? void 0 : a.example)
                ? (xo(),
                  To(
                    In(zI),
                    { key: 0, content: In(Dd)(null == (o = e.response) ? void 0 : o.example), lang: "json" },
                    null,
                    8,
                    ["content"],
                  ))
                : (null == (i = e.response) ? void 0 : i.schema)
                  ? (xo(),
                    Eo(
                      go,
                      { key: 1 },
                      [
                        (xo(),
                        Eo(
                          go,
                          null,
                          qr(t, (t) => {
                            var n, r, a, o, i, s
                            return (
                              xo(),
                              Eo(
                                go,
                                { key: t },
                                [
                                  (null == (n = e.response) ? void 0 : n.schema[t]) &&
                                  ((null == (r = e.response) ? void 0 : r.schema[t].length) > 1 || "not" === t)
                                    ? (xo(),
                                      Eo("div", bF, [
                                        Ro("div", vF, at(t), 1),
                                        Ro("ol", yF, [
                                          (xo(!0),
                                          Eo(
                                            go,
                                            null,
                                            qr(
                                              null == (a = e.response) ? void 0 : a.schema[t],
                                              (e, t) => (
                                                xo(),
                                                Eo("li", { key: t, class: "rule-item" }, [
                                                  No(
                                                    In(zI),
                                                    {
                                                      content: In(yp)(e, { emptyString: "", mode: "read" }),
                                                      lang: "json",
                                                    },
                                                    null,
                                                    8,
                                                    ["content"],
                                                  ),
                                                ])
                                              ),
                                            ),
                                            128,
                                          )),
                                        ]),
                                      ]))
                                    : (null == (o = e.response) ? void 0 : o.schema[t]) &&
                                        1 === (null == (i = e.response) ? void 0 : i.schema[t].length)
                                      ? (xo(),
                                        To(
                                          In(zI),
                                          {
                                            key: 1,
                                            content: In(yp)(null == (s = e.response) ? void 0 : s.schema[t][0], {
                                              emptyString: "",
                                              mode: "read",
                                            }),
                                            lang: "json",
                                          },
                                          null,
                                          8,
                                          ["content"],
                                        ))
                                      : Qo("", !0),
                                ],
                                64,
                              )
                            )
                          }),
                          64,
                        )),
                        (null == (s = e.response) ? void 0 : s.schema.allOf)
                          ? (xo(),
                            To(
                              In(zI),
                              {
                                key: 0,
                                content: n(
                                  null == (l = e.response)
                                    ? void 0
                                    : l.schema.allOf.map((e) => In(yp)(e, { emptyString: "", mode: "read" })),
                                ),
                                lang: "json",
                              },
                              null,
                              8,
                              ["content"],
                            ))
                          : (null == (d = null == (c = e.response) ? void 0 : c.schema.items) ? void 0 : d.allOf)
                            ? (xo(),
                              To(
                                In(zI),
                                {
                                  key: 1,
                                  content: n(
                                    null == (u = e.response)
                                      ? void 0
                                      : u.schema.items.allOf.map((e) => In(yp)(e, { emptyString: "", mode: "read" })),
                                  ),
                                  lang: "json",
                                },
                                null,
                                8,
                                ["content"],
                              ))
                            : (xo(),
                              To(
                                In(zI),
                                {
                                  key: 2,
                                  content: In(Dd)(
                                    In(yp)(null == (p = e.response) ? void 0 : p.schema, {
                                      emptyString: "",
                                      mode: "read",
                                    }),
                                  ),
                                  lang: "json",
                                },
                                null,
                                8,
                                ["content"],
                              )),
                      ],
                      64,
                    ))
                  : (xo(), Eo("div", OF, " No Body "))
            }
          },
        }),
        [["__scopeId", "data-v-9fd95437"]],
      ),
      xF = { key: 1, class: "scalar-card-checkbox" },
      kF = ((e) => (br("data-v-778ab953"), (e = e()), vr(), e))(() =>
        Ro("span", { class: "scalar-card-checkbox-checkmark" }, null, -1),
      ),
      _F = { class: "scalar-card-container custom-scroll" },
      SF = { key: 1, class: "response-description" },
      EF = QQ(
        Hr({
          __name: "PathResponses",
          props: { operation: {} },
          setup(e) {
            const t = e,
              { copyToClipboard: n } = Xu(),
              r = Dn(),
              a = ii(() => {
                var e, n
                return Object.keys(
                  (null == (n = null == (e = null == t ? void 0 : t.operation) ? void 0 : e.information)
                    ? void 0
                    : n.responses) ?? {},
                ).sort()
              }),
              o = ii(() => !!l.value.examples),
              i = Dn(0),
              s = ii(() => {
                var e, n
                const r = a.value[i.value]
                return null == (n = null == (e = t.operation.information) ? void 0 : e.responses) ? void 0 : n[r]
              }),
              l = ii(() => {
                var e
                const t = Cd(null == (e = s.value) ? void 0 : e.content)
                return (null == t ? void 0 : t["application/json"]) ?? (null == t ? void 0 : t["text/plain"]) ?? s.value
              }),
              c = () => {
                if (o.value) {
                  if (Array.isArray(l.value.examples)) return l.value.examples[0]
                  {
                    const e = Object.keys(l.value.examples)[0]
                    return l.value.examples[e]
                  }
                }
                return l.value.example
              },
              d = ii(() => ({
                ...l.value,
                example: o.value && r.value ? (l.value.examples[r.value].value ?? l.value.examples[r.value]) : c(),
              })),
              u = (e) => {
                ;(i.value = e), (r.value = void 0)
              },
              p = Dn(!1)
            return (e, t) =>
              a.value.length
                ? (xo(),
                  To(
                    In(Xj),
                    { key: 0 },
                    {
                      default: yr(() => {
                        var e
                        return [
                          No(
                            In(nU),
                            { muted: "", x: "as", onChange: u },
                            {
                              actions: yr(() => {
                                var e, r
                                return [
                                  (null == (e = l.value) ? void 0 : e.example)
                                    ? (xo(),
                                      Eo(
                                        "button",
                                        {
                                          key: 0,
                                          class: "code-copy",
                                          type: "button",
                                          onClick:
                                            t[0] ||
                                            (t[0] = () => {
                                              var e
                                              return In(n)(null == (e = l.value) ? void 0 : e.example)
                                            }),
                                        },
                                        [No(In(BI), { icon: "Clipboard", width: "12px", x: "asd" })],
                                      ))
                                    : Qo("", !0),
                                  (null == (r = l.value) ? void 0 : r.schema)
                                    ? (xo(),
                                      Eo("label", xF, [
                                        Mo(" Show Schema "),
                                        Fr(
                                          Ro(
                                            "input",
                                            {
                                              "onUpdate:modelValue": t[1] || (t[1] = (e) => (p.value = e)),
                                              class: "scalar-card-checkbox-input",
                                              type: "checkbox",
                                            },
                                            null,
                                            512,
                                          ),
                                          [[ji, p.value]],
                                        ),
                                        kF,
                                      ]))
                                    : Qo("", !0),
                                ]
                              }),
                              default: yr(() => [
                                (xo(!0),
                                Eo(
                                  go,
                                  null,
                                  qr(
                                    a.value,
                                    (e) => (
                                      xo(), To(In(rU), { key: e }, { default: yr(() => [Mo(at(e), 1)]), _: 2 }, 1024)
                                    ),
                                  ),
                                  128,
                                )),
                              ]),
                              _: 1,
                            },
                          ),
                          Ro("div", _F, [
                            No(
                              In(Yj),
                              { muted: "" },
                              {
                                default: yr(() => {
                                  var e
                                  return [
                                    (null == (e = l.value) ? void 0 : e.schema)
                                      ? (xo(),
                                        Eo(
                                          go,
                                          { key: 0 },
                                          [
                                            p.value && d.value
                                              ? (xo(),
                                                To(In(zI), { key: 0, content: d.value, lang: "json" }, null, 8, [
                                                  "content",
                                                ]))
                                              : (xo(), To(wF, { key: 1, response: d.value }, null, 8, ["response"])),
                                          ],
                                          64,
                                        ))
                                      : (xo(), To(wF, { key: 1, response: d.value }, null, 8, ["response"])),
                                  ]
                                }),
                                _: 1,
                              },
                            ),
                          ]),
                          (null == (e = s.value) ? void 0 : e.description) || o.value
                            ? (xo(),
                              To(
                                In(tU),
                                { key: 0, class: "response-card-footer", muted: "" },
                                {
                                  default: yr(() => {
                                    var e, n
                                    return [
                                      o.value
                                        ? (xo(),
                                          To(
                                            In(Qj),
                                            {
                                              key: 0,
                                              class: "response-example-selector",
                                              examples: null == (e = l.value) ? void 0 : e.examples,
                                              "onUpdate:modelValue": t[2] || (t[2] = (e) => (r.value = e)),
                                            },
                                            null,
                                            8,
                                            ["examples"],
                                          ))
                                        : (null == (n = s.value) ? void 0 : n.description)
                                          ? (xo(),
                                            Eo("div", SF, [
                                              No(In(ZI), { class: "markdown", value: s.value.description }, null, 8, [
                                                "value",
                                              ]),
                                            ]))
                                          : Qo("", !0),
                                    ]
                                  }),
                                  _: 1,
                                },
                              ))
                            : Qo("", !0),
                        ]
                      }),
                      _: 1,
                    },
                  ))
                : Qo("", !0)
          },
        }),
        [["__scopeId", "data-v-778ab953"]],
      ),
      TF = ["method"],
      AF = ((e) => (br("data-v-8620cd40"), (e = e()), vr(), e))(() => Ro("span", null, "Test Request", -1)),
      CF = QQ(
        Hr({
          __name: "TestRequestButton",
          props: { operation: {} },
          setup: (e) => (e, t) => (
            xo(),
            Eo(
              "button",
              {
                class: "show-api-client-button",
                method: e.operation.httpVerb,
                type: "button",
                onClick:
                  t[0] ||
                  (t[0] = Wi(
                    (t) => In($Q).emit({ open: { path: e.operation.path, method: e.operation.httpVerb } }),
                    ["stop"],
                  )),
              },
              [No(In(BI), { icon: "Play", size: "sm" }), AF],
              8,
              TF,
            )
          ),
        }),
        [["__scopeId", "data-v-8620cd40"]],
      ),
      PF = { class: "examples" },
      DF = QQ(
        Hr({
          __name: "Operation",
          props: { id: {}, operation: {} },
          setup(e) {
            const t = e,
              { availableTargets: n } = Rb(),
              r = ii(() => {
                var e
                const n = ["x-custom-examples", "x-codeSamples", "x-code-samples"]
                for (const r of n)
                  if (null == (e = t.operation.information) ? void 0 : e[r]) return t.operation.information[r]
                return null
              })
            return (e, t) => (
              xo(),
              To(
                In(KB),
                { id: e.id, label: e.operation.name },
                {
                  default: yr(() => [
                    No(In(mj), null, {
                      default: yr(() => [
                        No(In(sj), null, {
                          default: yr(() => [
                            No(In(oj), null, {
                              default: yr(() => {
                                var t, n
                                return [
                                  (null == (t = e.operation.information) ? void 0 : t.deprecated)
                                    ? (xo(), To(In(YB), { key: 0 }, { default: yr(() => [Mo(" Deprecated ")]), _: 1 }))
                                    : Qo("", !0),
                                  Ro(
                                    "div",
                                    {
                                      class: Ge(
                                        (null == (n = e.operation.information) ? void 0 : n.deprecated)
                                          ? "deprecated"
                                          : "",
                                      ),
                                    },
                                    [
                                      No(
                                        In(gj),
                                        { level: 3 },
                                        {
                                          default: yr(() => [
                                            No(
                                              In(Rj),
                                              { id: e.id ?? "" },
                                              { default: yr(() => [Mo(at(e.operation.name), 1)]), _: 1 },
                                              8,
                                              ["id"],
                                            ),
                                          ]),
                                          _: 1,
                                        },
                                      ),
                                    ],
                                    2,
                                  ),
                                  No(hF, { operation: e.operation }, null, 8, ["operation"]),
                                ]
                              }),
                              _: 1,
                            }),
                            No(In(oj), null, {
                              default: yr(() => [
                                Ro("div", PF, [
                                  In(n).length
                                    ? (xo(),
                                      To(
                                        In(hU),
                                        { key: 0, customExamples: r.value, operation: e.operation },
                                        {
                                          header: yr(() => {
                                            var t
                                            return [
                                              No(
                                                gF,
                                                {
                                                  class: "example-path",
                                                  deprecated:
                                                    null == (t = e.operation.information) ? void 0 : t.deprecated,
                                                  path: e.operation.path,
                                                },
                                                null,
                                                8,
                                                ["deprecated", "path"],
                                              ),
                                            ]
                                          }),
                                          footer: yr(() => [
                                            No(CF, { operation: e.operation }, null, 8, ["operation"]),
                                          ]),
                                          _: 1,
                                        },
                                        8,
                                        ["customExamples", "operation"],
                                      ))
                                    : Qo("", !0),
                                  No(In(EF), { operation: e.operation, style: { "margin-top": "12px" } }, null, 8, [
                                    "operation",
                                  ]),
                                ]),
                              ]),
                              _: 1,
                            }),
                          ]),
                          _: 1,
                        }),
                      ]),
                      _: 1,
                    }),
                  ]),
                  _: 1,
                },
                8,
                ["id", "label"],
              )
            )
          },
        }),
        [["__scopeId", "data-v-e99da259"]],
      ),
      RF = { class: "endpoint-details-card" },
      NF = QQ(
        Hr({
          __name: "EndpointDetailsCard",
          props: { operation: {} },
          setup(e) {
            const t = e,
              { parameterMap: n } = mp(t),
              { responses: r } = Um(t.operation)
            return (e, t) => {
              var a
              return (
                xo(),
                Eo("div", RF, [
                  No(
                    aF,
                    { class: "endpoint-details-card-item", parameters: In(n).path },
                    { title: yr(() => [Mo("Path Parameters")]), _: 1 },
                    8,
                    ["parameters"],
                  ),
                  No(
                    aF,
                    { class: "endpoint-details-card-item", parameters: In(n).query },
                    { title: yr(() => [Mo("Query Parameters")]), _: 1 },
                    8,
                    ["parameters"],
                  ),
                  No(
                    aF,
                    { class: "endpoint-details-card-item", parameters: In(n).header },
                    { title: yr(() => [Mo("Headers")]), _: 1 },
                    8,
                    ["parameters"],
                  ),
                  No(
                    dF,
                    {
                      class: "endpoint-details-card-item",
                      requestBody: null == (a = e.operation.information) ? void 0 : a.requestBody,
                    },
                    { title: yr(() => [Mo("Body")]), _: 1 },
                    8,
                    ["requestBody"],
                  ),
                  No(
                    aF,
                    { class: "endpoint-details-card-item", parameters: In(r) },
                    { title: yr(() => [Mo("Responses")]), _: 1 },
                    8,
                    ["parameters"],
                  ),
                ])
              )
            }
          },
        }),
        [["__scopeId", "data-v-f94bee14"]],
      ),
      $F = { class: "endpoint-header" },
      IF = { class: "endpoint-details" },
      MF = { class: "endpoint-label" },
      LF = { class: "endpoint-label-path" },
      QF = { class: "endpoint-label-name" },
      BF = { class: "endpoint-content" },
      jF = QQ(
        Hr({
          __name: "OperationAccordion",
          props: { id: {}, operation: {} },
          setup(e) {
            const { copyToClipboard: t } = Xu()
            return (e, n) => (
              xo(),
              To(
                In(rj),
                { id: e.id, class: "reference-endpoint", transparent: "" },
                Zr(
                  {
                    title: yr(() => [
                      Ro("h3", $F, [
                        Ro("div", IF, [
                          No(In(lU), { class: "endpoint-type", method: e.operation.httpVerb, short: "" }, null, 8, [
                            "method",
                          ]),
                          No(
                            In(Rj),
                            { id: e.id ?? "", class: "endpoint-anchor" },
                            {
                              default: yr(() => {
                                var t
                                return [
                                  Ro("div", MF, [
                                    Ro("div", LF, [
                                      No(
                                        gF,
                                        {
                                          deprecated: null == (t = e.operation.information) ? void 0 : t.deprecated,
                                          path: e.operation.path,
                                        },
                                        null,
                                        8,
                                        ["deprecated", "path"],
                                      ),
                                    ]),
                                    Ro("div", QF, at(e.operation.name), 1),
                                  ]),
                                ]
                              }),
                              _: 1,
                            },
                            8,
                            ["id"],
                          ),
                        ]),
                      ]),
                    ]),
                    actions: yr(({ active: r }) => [
                      r
                        ? (xo(), To(CF, { key: 0, operation: e.operation }, null, 8, ["operation"]))
                        : (xo(), To(In(BI), { key: 1, class: "endpoint-try-hint", icon: "Play", thickness: "1.75px" })),
                      No(In(mL), {
                        class: "endpoint-copy",
                        icon: "Clipboard",
                        label: "Copy endpoint URL",
                        size: "xs",
                        variant: "ghost",
                        onClick: n[0] || (n[0] = Wi((n) => In(t)(e.operation.path), ["stop"])),
                      }),
                    ]),
                    default: yr(() => [
                      Ro("div", BF, [
                        No(NF, { operation: e.operation }, null, 8, ["operation"]),
                        No(In(EF), { operation: e.operation }, null, 8, ["operation"]),
                        No(In(hU), { operation: e.operation }, null, 8, ["operation"]),
                      ]),
                    ]),
                    _: 2,
                  },
                  [
                    e.operation.description
                      ? {
                          name: "description",
                          fn: yr(() => [
                            No(In(ZI), { value: e.operation.description, withImages: "" }, null, 8, ["value"]),
                          ]),
                          key: "0",
                        }
                      : void 0,
                  ],
                ),
                1032,
                ["id"],
              )
            )
          },
        }),
        [["__scopeId", "data-v-28101aa3"]],
      ),
      UF = QQ(
        Hr({
          __name: "ShowMoreButton",
          props: { id: {} },
          setup(e) {
            const { setCollapsedSidebarItem: t } = sg()
            return (e, n) => (
              xo(),
              Eo("button", { class: "show-more", type: "button", onClick: n[0] || (n[0] = (n) => In(t)(e.id, !0)) }, [
                Mo(" Show More "),
                No(In(BI), { class: "show-more-icon", icon: "ChevronDown" }),
              ])
            )
          },
        }),
        [["__scopeId", "data-v-481def22"]],
      ),
      FF = { class: "endpoints" },
      zF = ["onClick"],
      qF = QQ(
        Hr({
          __name: "Endpoints",
          props: { id: {}, tag: {} },
          emits: ["observeAndNavigate"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              { getOperationId: a, getTagId: o } = fp(),
              { setCollapsedSidebarItem: i } = sg()
            return (e, t) => (
              xo(),
              To(
                In(KB),
                { id: e.id, label: e.tag.name.toUpperCase() },
                {
                  default: yr(() => [
                    No(In(mj), null, {
                      default: yr(() => [
                        No(In(sj), null, {
                          default: yr(() => [
                            No(In(oj), null, {
                              default: yr(() => [
                                No(
                                  In(gj),
                                  { level: 2 },
                                  {
                                    default: yr(() => [
                                      No(
                                        In(Rj),
                                        { id: In(o)(e.tag) },
                                        { default: yr(() => [Mo(at(e.tag["x-displayName"] ?? e.tag.name), 1)]), _: 1 },
                                        8,
                                        ["id"],
                                      ),
                                    ]),
                                    _: 1,
                                  },
                                ),
                                No(In(ZI), { value: e.tag.description, withImages: "" }, null, 8, ["value"]),
                              ]),
                              _: 1,
                            }),
                            No(In(oj), null, {
                              default: yr(() => {
                                var t
                                return [
                                  (null == (t = e.tag.operations) ? void 0 : t.length) > 0
                                    ? (xo(),
                                      To(
                                        In(Xj),
                                        { key: 0, class: "scalar-card-sticky" },
                                        {
                                          default: yr(() => [
                                            No(In(eU), { muted: "" }, { default: yr(() => [Mo("Endpoints")]), _: 1 }),
                                            No(
                                              In(Yj),
                                              { class: "custom-scroll", muted: "" },
                                              {
                                                default: yr(() => [
                                                  Ro("div", FF, [
                                                    (xo(!0),
                                                    Eo(
                                                      go,
                                                      null,
                                                      qr(
                                                        e.tag.operations,
                                                        (t) => (
                                                          xo(),
                                                          Eo(
                                                            "a",
                                                            {
                                                              key: In(a)(t, e.tag),
                                                              class: "endpoint",
                                                              onClick: (e) =>
                                                                (async function (e) {
                                                                  var t
                                                                  ;(t = a(e, n.tag)),
                                                                    r("observeAndNavigate", t),
                                                                    i(o(n.tag), !0)
                                                                })(t),
                                                            },
                                                            [
                                                              No(In(lU), { method: t.httpVerb }, null, 8, ["method"]),
                                                              Ro("span", null, at(t.path), 1),
                                                            ],
                                                            8,
                                                            zF,
                                                          )
                                                        ),
                                                      ),
                                                      128,
                                                    )),
                                                  ]),
                                                ]),
                                                _: 1,
                                              },
                                            ),
                                          ]),
                                          _: 1,
                                        },
                                      ))
                                    : Qo("", !0),
                                ]
                              }),
                              _: 1,
                            }),
                          ]),
                          _: 1,
                        }),
                      ]),
                      _: 1,
                    }),
                  ]),
                  _: 1,
                },
                8,
                ["id", "label"],
              )
            )
          },
        }),
        [["__scopeId", "data-v-f0ef5b24"]],
      ),
      ZF = QQ(
        Hr({
          __name: "Tag",
          props: { id: {}, tag: {}, spec: {} },
          setup(e) {
            const t = e,
              n = Dn(null),
              { collapsedSidebarItems: r } = sg(),
              { getTagId: a } = fp(),
              o = ii(() => {
                var e, n, r
                return (
                  1 !== (null == (e = t.spec.tags) ? void 0 : e.length) ||
                  "default" !== (null == (n = t.tag) ? void 0 : n.name) ||
                  "" !== (null == (r = t.tag) ? void 0 : r.description)
                )
              }),
              i = (e) => {
                window.location.href = `#${e}`
              },
              s = (e) => {
                document.getElementById(e)
                  ? i(e)
                  : ((e) => {
                      ;((e, t) => {
                        !(function (e, t, n = {}) {
                          const { window: r = Dm, ...a } = n
                          let o
                          const i = Nm(() => r && "MutationObserver" in r),
                            s = () => {
                              o && (o.disconnect(), (o = void 0))
                            },
                            l = ii(() => {
                              const t = wm(e),
                                n = (Array.isArray(t) ? t : [t]).map(Pm).filter(km)
                              return new Set(n)
                            }),
                            c = Ya(
                              () => l.value,
                              (e) => {
                                s(),
                                  i.value &&
                                    e.size &&
                                    ((o = new MutationObserver(t)), e.forEach((e) => o.observe(e, a)))
                              },
                              { immediate: !0, flush: "post" },
                            )
                          Om(() => {
                            s(), c()
                          })
                        })(e, t, { childList: !0, subtree: !0 })
                      })(n, (t, n) => {
                        t.forEach((t) => {
                          Array.from(t.addedNodes).some((t) => t instanceof HTMLElement && t.id === e) &&
                            (i(e), n.disconnect())
                        })
                      })
                    })(e)
              }
            return (e, t) => (
              xo(),
              To(
                In(cj),
                { ref_key: "sectionContainerRef", ref: n, class: "tag-section-container" },
                {
                  default: yr(() => {
                    var t
                    return [
                      o.value
                        ? (xo(),
                          To(qF, { key: 0, id: e.id, tag: e.tag, onObserveAndNavigate: s }, null, 8, ["id", "tag"]))
                        : Qo("", !0),
                      !In(r)[In(a)(e.tag)] && (null == (t = e.tag.operations) ? void 0 : t.length) > 1
                        ? (xo(), To(UF, { key: 1, id: e.id ?? "" }, null, 8, ["id"]))
                        : Xr(e.$slots, "default", { key: 2 }, void 0, !0),
                    ]
                  }),
                  _: 3,
                },
                512,
              )
            )
          },
        }),
        [["__scopeId", "data-v-e7d35918"]],
      ),
      HF = QQ(
        Hr({
          __name: "TagAccordion",
          props: { tag: {}, spec: {} },
          setup(e) {
            const { getTagId: t } = fp()
            return (e, n) => (
              xo(),
              To(
                In(pj),
                { class: "tag-section" },
                {
                  title: yr(() => [
                    No(
                      In(gj),
                      { class: "tag-name", level: 2 },
                      {
                        default: yr(() => [
                          No(In(Rj), { id: In(t)(e.tag) }, { default: yr(() => [Mo(at(e.tag.name), 1)]), _: 1 }, 8, [
                            "id",
                          ]),
                        ]),
                        _: 1,
                      },
                    ),
                    No(In(ZI), { class: "tag-description", value: e.tag.description, withImages: "" }, null, 8, [
                      "value",
                    ]),
                  ]),
                  default: yr(() => [Xr(e.$slots, "default", {}, void 0, !0)]),
                  _: 3,
                },
              )
            )
          },
        }),
        [["__scopeId", "data-v-2a212e36"]],
      ),
      VF = Hr({
        __name: "Loading",
        props: { layout: { default: "default" }, parsedSpec: {} },
        setup(e) {
          const t = e,
            n = Dn(!1),
            r = Dn([]),
            a = Dn([]),
            { getModelId: o, getSectionId: i, getTagId: s, hash: l, isIntersectionEnabled: c } = fp(),
            d = Dn("accordion" !== t.layout && l.value)
          Ya(
            () => {
              var e
              return null == (e = t.parsedSpec.tags) ? void 0 : e.length
            },
            (e) => {
              var o, d
              if (!l.value || "number" != typeof e || !t.parsedSpec.tags) return
              const u = i()
              if (u.startsWith("tag")) {
                let e = 0
                const a = (null == (o = t.parsedSpec.tags) ? void 0 : o.findIndex((e) => s(e) === u)) ?? 0,
                  i = l.value.match(/tag\/([^/]+)\/([^/]+)\/(.+)/)
                if (4 === (null == i ? void 0 : i.length)) {
                  const n = i[2],
                    r = "/" + i[3]
                  e =
                    null == (d = t.parsedSpec.tags[a])
                      ? void 0
                      : d.operations.findIndex(({ httpVerb: e, path: t }) => n === e && r === t)
                }
                const c = t.parsedSpec.tags[a]
                if (!c) return
                "default" !== c.name && (n.value = u !== l.value && u.startsWith("tag")),
                  r.value.push({ ...c, lazyOperations: c.operations.slice(e, e + 2) })
              } else if (l.value.startsWith("model")) {
                const e = Object.keys(Uf(t.parsedSpec) ?? {}),
                  [, n] = l.value.toLowerCase().split("/"),
                  r = "models" === l.value ? 0 : e.findIndex((e) => e.toLowerCase() === n)
                if (-1 === r) return
                a.value = e.slice(r, r + 3)
              } else "undefined" != typeof window && vm(l.value), setTimeout(() => (c.value = !0), 1e3)
            },
            { immediate: !0 },
          )
          const u = Sj.on(({ id: e }) => {
            const t = l.value
            t &&
              e === t &&
              (u(),
              setTimeout(() => {
                "undefined" != typeof window && vm(t), (d.value = !1), setTimeout(() => (c.value = !0), 1e3)
              }, 300))
          })
          return (
            Nr(() => {
              l.value || setTimeout(() => (c.value = !0), 1e3)
            }),
            (e, t) =>
              Fr(
                (xo(),
                Eo(
                  "div",
                  {
                    class: Ge([
                      "references-loading",
                      { "references-loading-hidden-tag": n.value, "references-loading-top-spacer": r.value.length },
                    ]),
                  },
                  [
                    (xo(!0),
                    Eo(
                      go,
                      null,
                      qr(
                        r.value,
                        (t, n) => (
                          xo(),
                          Eo(
                            go,
                            { key: t.name + n },
                            [
                              t.operations && t.operations.length > 0
                                ? (xo(),
                                  To(
                                    In(ZF),
                                    { key: 0, spec: e.parsedSpec, tag: t },
                                    {
                                      default: yr(() => [
                                        (xo(!0),
                                        Eo(
                                          go,
                                          null,
                                          qr(
                                            t.lazyOperations,
                                            (e) => (
                                              xo(),
                                              To(
                                                In(DF),
                                                { key: `${e.httpVerb}-${e.operationId}`, operation: e, tag: t },
                                                null,
                                                8,
                                                ["operation", "tag"],
                                              )
                                            ),
                                          ),
                                          128,
                                        )),
                                      ]),
                                      _: 2,
                                    },
                                    1032,
                                    ["spec", "tag"],
                                  ))
                                : Qo("", !0),
                            ],
                            64,
                          )
                        ),
                      ),
                      128,
                    )),
                    a.value.length
                      ? (xo(),
                        To(
                          In(cj),
                          { key: 0 },
                          {
                            default: yr(() => [
                              (xo(!0),
                              Eo(
                                go,
                                null,
                                qr(
                                  a.value,
                                  (t) => (
                                    xo(),
                                    To(
                                      In(KB),
                                      { key: t, label: t },
                                      {
                                        default: yr(() => {
                                          var n
                                          return [
                                            (null == (n = In(Uf)(e.parsedSpec)) ? void 0 : n[t])
                                              ? (xo(),
                                                To(
                                                  In(mj),
                                                  { key: 0 },
                                                  {
                                                    default: yr(() => {
                                                      var n
                                                      return [
                                                        No(
                                                          In(gj),
                                                          { level: 2 },
                                                          {
                                                            default: yr(() => [
                                                              No(
                                                                In(Rj),
                                                                { id: In(o)(t) },
                                                                {
                                                                  default: yr(() => {
                                                                    var n
                                                                    return [
                                                                      Mo(
                                                                        at(
                                                                          (null == (n = In(Uf)(e.parsedSpec))
                                                                            ? void 0
                                                                            : n[t]
                                                                          ).title ?? t,
                                                                        ),
                                                                        1,
                                                                      ),
                                                                    ]
                                                                  }),
                                                                  _: 2,
                                                                },
                                                                1032,
                                                                ["id"],
                                                              ),
                                                            ]),
                                                            _: 2,
                                                          },
                                                          1024,
                                                        ),
                                                        No(
                                                          In(GU),
                                                          {
                                                            name: t,
                                                            noncollapsible: "",
                                                            value: null == (n = In(Uf)(e.parsedSpec)) ? void 0 : n[t],
                                                          },
                                                          null,
                                                          8,
                                                          ["name", "value"],
                                                        ),
                                                      ]
                                                    }),
                                                    _: 2,
                                                  },
                                                  1024,
                                                ))
                                              : Qo("", !0),
                                          ]
                                        }),
                                        _: 2,
                                      },
                                      1032,
                                      ["label"],
                                    )
                                  ),
                                ),
                                128,
                              )),
                            ]),
                            _: 1,
                          },
                        ))
                      : Qo("", !0),
                  ],
                  2,
                )),
                [[mi, d.value]],
              )
          )
        },
      }),
      WF = ((e) => (br("data-v-f19478dd"), (e = e()), vr(), e))(() => Ro("div", { id: "models" }, null, -1)),
      XF = QQ(
        Hr({
          __name: "Models",
          props: { schemas: {} },
          setup(e) {
            const t = e,
              { collapsedSidebarItems: n } = sg(),
              { getModelId: r } = fp(),
              a = ii(() => Object.keys(t.schemas ?? {}).length <= 3 || n[r()]),
              o = ii(() => {
                const e = Object.keys(t.schemas ?? {})
                return a.value ? e : e.slice(0, 3)
              })
            return (e, t) =>
              e.schemas
                ? (xo(),
                  To(
                    In(cj),
                    { key: 0 },
                    {
                      default: yr(() => [
                        No(In(Ej), { id: "models", isLazy: !1 }, { default: yr(() => [WF]), _: 1 }),
                        (xo(!0),
                        Eo(
                          go,
                          null,
                          qr(
                            o.value,
                            (t, n) => (
                              xo(),
                              To(
                                In(Ej),
                                { id: In(r)(t), key: t, isLazy: "" },
                                {
                                  default: yr(() => [
                                    No(
                                      In(KB),
                                      { id: In(r)(t), label: t },
                                      {
                                        default: yr(() => [
                                          e.schemas[t]
                                            ? (xo(),
                                              To(
                                                In(mj),
                                                { key: 0 },
                                                {
                                                  default: yr(() => [
                                                    No(
                                                      In(gj),
                                                      { level: 2 },
                                                      {
                                                        default: yr(() => [
                                                          No(
                                                            In(Rj),
                                                            { id: In(r)(t) },
                                                            {
                                                              default: yr(() => [Mo(at(e.schemas[t].title ?? t), 1)]),
                                                              _: 2,
                                                            },
                                                            1032,
                                                            ["id"],
                                                          ),
                                                        ]),
                                                        _: 2,
                                                      },
                                                      1024,
                                                    ),
                                                    No(
                                                      In(GU),
                                                      { name: t, noncollapsible: "", value: e.schemas[t] },
                                                      null,
                                                      8,
                                                      ["name", "value"],
                                                    ),
                                                    a.value || n !== o.value.length - 1
                                                      ? Qo("", !0)
                                                      : (xo(),
                                                        To(
                                                          UF,
                                                          { key: 0, id: In(r)(), class: "something-special" },
                                                          null,
                                                          8,
                                                          ["id"],
                                                        )),
                                                  ]),
                                                  _: 2,
                                                },
                                                1024,
                                              ))
                                            : Qo("", !0),
                                        ]),
                                        _: 2,
                                      },
                                      1032,
                                      ["id", "label"],
                                    ),
                                  ]),
                                  _: 2,
                                },
                                1032,
                                ["id"],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                      _: 1,
                    },
                  ))
                : Qo("", !0)
          },
        }),
        [["__scopeId", "data-v-f19478dd"]],
      ),
      YF = { key: 0, class: "properties" },
      GF = { key: 1 },
      KF = QQ(
        Hr({
          __name: "ModelsAccordion",
          props: { schemas: {} },
          setup(e) {
            const t = e,
              n = ii(() => (t.schemas ? Object.entries(t.schemas).map(([e, t]) => ({ name: e, schema: t })) : [])),
              { getModelId: r } = fp()
            return (e, a) =>
              t.schemas
                ? (xo(),
                  To(
                    In(pj),
                    { key: 0, class: "reference-models" },
                    {
                      title: yr(() => [No(In(gj), { level: 2 }, { default: yr(() => [Mo("Models")]), _: 1 })]),
                      default: yr(() => [
                        (xo(!0),
                        Eo(
                          go,
                          null,
                          qr(
                            n.value,
                            ({ name: e, schema: t }) => (
                              xo(),
                              To(
                                In(rj),
                                { id: In(r)(e), key: e, label: e },
                                {
                                  title: yr(() => [
                                    No(
                                      In(Rj),
                                      { id: In(r)(e), class: "reference-models-anchor" },
                                      {
                                        default: yr(() => [
                                          No(In(gU), { class: "reference-models-label", name: e, value: t }, null, 8, [
                                            "name",
                                            "value",
                                          ]),
                                        ]),
                                        _: 2,
                                      },
                                      1032,
                                      ["id"],
                                    ),
                                  ]),
                                  default: yr(() => [
                                    (null == t ? void 0 : t.properties)
                                      ? (xo(),
                                        Eo("div", YF, [
                                          (xo(!0),
                                          Eo(
                                            go,
                                            null,
                                            qr(Object.entries(t.properties), ([e, n]) => {
                                              var r, a, o
                                              return (
                                                xo(),
                                                To(
                                                  In(VU),
                                                  {
                                                    key: e,
                                                    name: e,
                                                    required:
                                                      (null == (r = t.required) ? void 0 : r.includes(e)) ||
                                                      !0 ===
                                                        (null == (o = null == (a = t.properties) ? void 0 : a[e])
                                                          ? void 0
                                                          : o.required),
                                                    value: n,
                                                  },
                                                  null,
                                                  8,
                                                  ["name", "required", "value"],
                                                )
                                              )
                                            }),
                                            128,
                                          )),
                                        ]))
                                      : (xo(), Eo("div", GF, [No(In(VU), { value: t }, null, 8, ["value"])])),
                                  ]),
                                  _: 2,
                                },
                                1032,
                                ["id", "label"],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                      _: 1,
                    },
                  ))
                : Qo("", !0)
          },
        }),
        [["__scopeId", "data-v-304ad700"]],
      ),
      JF = Hr({
        __name: "Webhook",
        props: { webhook: {} },
        setup(e) {
          const t = e,
            { responses: n } = Um(t.webhook)
          return (e, t) => {
            var r
            return e.webhook
              ? (xo(),
                Eo(
                  go,
                  { key: 0 },
                  [
                    No(
                      dF,
                      { requestBody: null == (r = e.webhook.information) ? void 0 : r.requestBody },
                      { title: yr(() => [Mo("Payload")]), _: 1 },
                      8,
                      ["requestBody"],
                    ),
                    No(aF, { parameters: In(n) }, { title: yr(() => [Mo("Responses")]), _: 1 }, 8, ["parameters"]),
                  ],
                  64,
                ))
              : Qo("", !0)
          }
        },
      }),
      ez = Hr({
        __name: "Webhooks",
        props: { webhooks: {} },
        setup(e) {
          const t = e,
            n = ii(() => Object.keys(t.webhooks ?? {})),
            { getWebhookId: r } = fp()
          return (e, t) =>
            n.value.length
              ? (xo(),
                To(
                  In(cj),
                  { key: 0 },
                  {
                    default: yr(() => [
                      (xo(!0),
                      Eo(
                        go,
                        null,
                        qr(n.value, (t) => {
                          var n
                          return (
                            xo(),
                            Eo(
                              go,
                              { key: t },
                              [
                                (xo(!0),
                                Eo(
                                  go,
                                  null,
                                  qr(
                                    Object.keys(null == (n = e.webhooks) ? void 0 : n[t]),
                                    (n) => (
                                      xo(),
                                      To(
                                        In(KB),
                                        { id: In(r)(t, n), key: n, label: t },
                                        {
                                          default: yr(() => {
                                            var a
                                            return [
                                              (null == (a = e.webhooks) ? void 0 : a[t])
                                                ? (xo(),
                                                  To(
                                                    In(mj),
                                                    { key: 0 },
                                                    {
                                                      default: yr(() => {
                                                        var a, o
                                                        return [
                                                          No(
                                                            In(gj),
                                                            { level: 2 },
                                                            {
                                                              default: yr(() => [
                                                                No(
                                                                  In(Rj),
                                                                  { id: In(r)(t, n) },
                                                                  {
                                                                    default: yr(() => {
                                                                      var r
                                                                      return [
                                                                        Mo(
                                                                          at(
                                                                            null == (r = e.webhooks[t][n])
                                                                              ? void 0
                                                                              : r.name,
                                                                          ),
                                                                          1,
                                                                        ),
                                                                      ]
                                                                    }),
                                                                    _: 2,
                                                                  },
                                                                  1032,
                                                                  ["id"],
                                                                ),
                                                              ]),
                                                              _: 2,
                                                            },
                                                            1024,
                                                          ),
                                                          (null == (a = e.webhooks[t][n]) ? void 0 : a.description)
                                                            ? (xo(),
                                                              To(
                                                                In(ZI),
                                                                {
                                                                  key: 0,
                                                                  value:
                                                                    null == (o = e.webhooks[t][n])
                                                                      ? void 0
                                                                      : o.description,
                                                                  withImages: "",
                                                                },
                                                                null,
                                                                8,
                                                                ["value"],
                                                              ))
                                                            : Qo("", !0),
                                                          No(JF, { webhook: e.webhooks[t][n] }, null, 8, ["webhook"]),
                                                        ]
                                                      }),
                                                      _: 2,
                                                    },
                                                    1024,
                                                  ))
                                                : Qo("", !0),
                                            ]
                                          }),
                                          _: 2,
                                        },
                                        1032,
                                        ["id", "label"],
                                      )
                                    ),
                                  ),
                                  128,
                                )),
                              ],
                              64,
                            )
                          )
                        }),
                        128,
                      )),
                    ]),
                    _: 1,
                  },
                ))
              : Qo("", !0)
        },
      }),
      tz = Lo(
        '<div class="section-flare" data-v-0b17f72e><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div><div class="section-flare-item" data-v-0b17f72e></div></div>',
        1,
      ),
      nz = { class: "narrow-references-container" },
      rz = QQ(
        Hr({
          __name: "Content",
          props: { parsedSpec: {}, layout: {}, baseServerURL: {}, servers: {}, proxy: {} },
          setup(e) {
            const t = e,
              { getOperationId: n, getTagId: r, hash: a } = fp(),
              { hideModels: o, collapsedSidebarItems: i } = sg(),
              s = ii(() => ("accordion" === t.layout ? HF : ZF)),
              l = ii(() => ("accordion" === t.layout ? jF : DF)),
              c = ii(() => ("accordion" === t.layout ? "after" : "aside")),
              d = "accordion" !== t.layout && !a.value.startsWith("model")
            return (e, a) => {
              var u, p, h, f
              return (
                xo(),
                Eo(
                  go,
                  null,
                  [
                    tz,
                    Ro("div", nz, [
                      Xr(e.$slots, "start", {}, void 0, !0),
                      No(In(VF), { layout: e.layout, parsedSpec: e.parsedSpec }, null, 8, ["layout", "parsedSpec"]),
                      (null == (p = null == (u = e.parsedSpec) ? void 0 : u.info) ? void 0 : p.title) ||
                      (null == (f = null == (h = e.parsedSpec) ? void 0 : h.info) ? void 0 : f.description)
                        ? (xo(),
                          To(
                            In(_j),
                            { key: 0, info: e.parsedSpec.info, parsedSpec: e.parsedSpec },
                            {
                              [c.value]: yr(() => [
                                Ro(
                                  "div",
                                  {
                                    class: Ge([
                                      "introduction-card",
                                      { "introduction-card-row": "accordion" === e.layout },
                                    ]),
                                  },
                                  [
                                    No(
                                      In(oB),
                                      {
                                        defaultServerUrl: e.baseServerURL,
                                        servers: t.servers,
                                        specification: e.parsedSpec,
                                      },
                                      null,
                                      8,
                                      ["defaultServerUrl", "servers", "specification"],
                                    ),
                                    No(In(MB), { parsedSpec: e.parsedSpec, proxy: e.proxy }, null, 8, [
                                      "parsedSpec",
                                      "proxy",
                                    ]),
                                    No(In(WB)),
                                  ],
                                  2,
                                ),
                              ]),
                              _: 2,
                            },
                            1032,
                            ["info", "parsedSpec"],
                          ))
                        : Xr(e.$slots, "empty-state", { key: 1 }, void 0, !0),
                      (xo(!0),
                      Eo(
                        go,
                        null,
                        qr(
                          e.parsedSpec.tags,
                          (t) => (
                            xo(),
                            To(
                              In(Ej),
                              { id: In(r)(t), key: In(r)(t), isLazy: In(d) && !In(i)[In(r)(t)] },
                              {
                                default: yr(() => [
                                  (xo(),
                                  To(
                                    Tr(s.value),
                                    { id: In(r)(t), spec: e.parsedSpec, tag: t },
                                    {
                                      default: yr(() => [
                                        (xo(!0),
                                        Eo(
                                          go,
                                          null,
                                          qr(
                                            t.operations,
                                            (e, r) => (
                                              xo(),
                                              To(
                                                In(Ej),
                                                {
                                                  id: In(n)(e, t),
                                                  key: `${e.httpVerb}-${e.operationId}`,
                                                  isLazy: r > 0,
                                                },
                                                {
                                                  default: yr(() => [
                                                    (xo(),
                                                    To(
                                                      Tr(l.value),
                                                      { id: In(n)(e, t), operation: e, tag: t },
                                                      null,
                                                      8,
                                                      ["id", "operation", "tag"],
                                                    )),
                                                  ]),
                                                  _: 2,
                                                },
                                                1032,
                                                ["id", "isLazy"],
                                              )
                                            ),
                                          ),
                                          128,
                                        )),
                                      ]),
                                      _: 2,
                                    },
                                    1032,
                                    ["id", "spec", "tag"],
                                  )),
                                ]),
                                _: 2,
                              },
                              1032,
                              ["id", "isLazy"],
                            )
                          ),
                        ),
                        128,
                      )),
                      e.parsedSpec.webhooks
                        ? (xo(), To(In(ez), { key: 2, webhooks: e.parsedSpec.webhooks }, null, 8, ["webhooks"]))
                        : Qo("", !0),
                      In(Ff)(e.parsedSpec) && !In(o)
                        ? (xo(),
                          Eo(
                            go,
                            { key: 3 },
                            [
                              "accordion" === e.layout
                                ? (xo(), To(In(KF), { key: 0, schemas: In(Uf)(e.parsedSpec) }, null, 8, ["schemas"]))
                                : (xo(), To(In(XF), { key: 1, schemas: In(Uf)(e.parsedSpec) }, null, 8, ["schemas"])),
                            ],
                            64,
                          ))
                        : Qo("", !0),
                      Xr(e.$slots, "end", {}, void 0, !0),
                    ]),
                  ],
                  64,
                )
              )
            }
          },
        }),
        [["__scopeId", "data-v-0b17f72e"]],
      ),
      az = { class: "start custom-scroll" },
      oz = { class: "start-copy" },
      iz = Lo(
        '<div class="start-logo" data-v-391b4e37><svg height="36" viewBox="0 0 36 36" width="36" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><path d="M18 0a18 18 0 1 1 0 36 18 18 0 0 1 0-36Zm11.2 6.5c-3.3-3.3-11.1-1-17.4 5.3-6.2 6.3-8.6 14-5.3 17.4 3.3 3.3 11 .9 17.3-5.4 6.3-6.2 8.7-14 5.4-17.3ZM17.6 12a6.3 6.3 0 1 1 0 12.7 6.3 6.3 0 0 1 0-12.7Z" fill="currentColor" fill-rule="evenodd" data-v-391b4e37></path></svg></div><h1 class="start-h1" data-v-391b4e37>Swagger Editor</h1><p class="start-p" data-v-391b4e37> Welcome to the Scalar API References + Swagger Editor, a Free &amp; Open-Source tool that takes your Swagger/OAS file and generates Beautiful API references. </p>',
        3,
      ),
      sz = { class: "start-cta" },
      lz = { class: "start-row" },
      cz = Lo(
        '<div class="start-section start-section-integrations" data-v-391b4e37><div class="start-h2" data-v-391b4e37>INTEGRATIONS</div><a class="start-item" href="https://github.com/scalar/scalar/tree/main/packages/fastify-api-reference#readme" target="_blank" data-v-391b4e37><svg fill="currentColor" height="16" viewBox="0 0 19 16" width="19" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><path d="m18.2 3.1.8-2V.9l-4.7 1.3C15.2 1 15 0 15 0s-2.5 1.6-4.3 1.5c-2 0-3.6.8-4 1-1.8 1.2-2.5 3.3-3.2 3.8L0 8.9 2.3 8l-2 2.5c.2.3 1.2 1.6 2.1 1.3l.4-.1 1.6.5-.7-1 .2-.2.9.3-.1-.8.9.3-.1-.8.3-.1 1-3.5 3.7-2.6-.3.7A4 4 0 0 1 8 7l-.6.2c-.5.5-.7.7-.8 2.5a2 2 0 0 1 1 0c1.6.4 2.2 2.3 1.7 2.9l-.7.6H8v.6h-.7v.5l-.2.2c-.7 0-1.4-.6-1.4-.6 0 .5.4 1.3.4 1.3s1.7 1.1 2.7.7c1-.4.7-2.3 2.8-3.2l3.3-.9.8-2.2-1.7.5v-2l2.5-.6.9-2.2-3.4.9v-2l4.2-1.1Z" fill="currentColor" fill-rule="nonzero" data-v-391b4e37></path></svg><span data-v-391b4e37>Fastify</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#from-a-cdn" target="_blank" data-v-391b4e37><svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g data-v-391b4e37><path d="M22.5 1.5h-21A1.5 1.5 0 0 0 0 3v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 6V3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3A1.25 1.25 0 1 1 4.5 5.75 1.25 1.25 0 0 1 3.25 4.5ZM8.5 5.75A1.25 1.25 0 1 1 9.75 4.5 1.25 1.25 0 0 1 8.5 5.75Z" fill="currentColor" data-v-391b4e37></path><path d="M22.5 9h-21A1.5 1.5 0 0 0 0 10.5v3A1.5 1.5 0 0 0 1.5 15h21a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 22.5 9ZM3.25 12a1.25 1.25 0 1 1 1.25 1.25A1.25 1.25 0 0 1 3.25 12Zm5.25 1.25A1.25 1.25 0 1 1 9.75 12a1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-391b4e37></path><path d="M22.5 16.5h-21A1.5 1.5 0 0 0 0 18v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 21v-3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3a1.25 1.25 0 1 1 1.25 1.25 1.25 1.25 0 0 1-1.25-1.25Zm5.25 1.25a1.25 1.25 0 1 1 1.25-1.25 1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-391b4e37></path></g></svg><span data-v-391b4e37>CDN</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-vuejs" target="_blank" data-v-391b4e37><svg height="170" viewBox="0 0 196.3 170" width="196.3" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g fill="currentColor" fill-rule="nonzero" data-v-391b4e37><polygon points="39.23 0 0 0 2.9450761 5.1010782 98.16 170.02 196.32 0 157.06 0 98.16 102.01 42.175701 5.0991171" data-v-391b4e37></polygon><polygon points="75.5 2.009956e-14 0 2.009956e-14 2.94 5.1 78.44871 5.1 98.16 39.26 117.87937 5.1 193.38 5.1 196.325 0 120.82 7.8065636e-15 114.97322 2.009956e-14 98.16 29.037153 81.35 2.009956e-14" data-v-391b4e37></polygon></g></svg><span data-v-391b4e37>Vue</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-react" target="_blank" data-v-391b4e37><svg height="23.3" viewBox="0 0 22 23.3" width="22" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g fill="none" fill-rule="evenodd" data-v-391b4e37><circle cx="11" cy="11.6" fill="currentColor" fill-rule="nonzero" r="2" data-v-391b4e37></circle><g stroke="currentColor" data-v-391b4e37><ellipse cx="11" cy="11.6" rx="11" ry="4.2" data-v-391b4e37></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(60 11 11.6)" data-v-391b4e37></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(120 11 11.6)" data-v-391b4e37></ellipse></g></g></svg><span data-v-391b4e37>React</span></a></div>',
        1,
      ),
      dz = { class: "start-section start-section-colors" },
      uz = ((e) => (br("data-v-391b4e37"), (e = e()), vr(), e))(() => Ro("p", { class: "start-h2" }, "THEMING", -1)),
      pz = ["onClick"],
      hz = Lo(
        '<p class="start-h1" data-v-391b4e37>Features</p><ul class="start-ul" data-v-391b4e37><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Customize</p> Bring your typography &amp; color palettes, or use our themes! </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Testing</p> A deeply integrated Rest API Client (Also Free &amp; Open-Source) </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Search</p> Fully integrated Search (Using fuse.js) </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Hosting</p> Free subdomain hosting on https://apidocumentation.com </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>OpenAPI &amp; Swagger</p> Support for OpenAPI 3.1, OpenAPI 3.0, and Swagger 2.0 </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Code Samples</p> Code samples to show off your API in most popular languages </li></ul>',
        2,
      ),
      fz = QQ(
        Hr({
          __name: "GettingStarted",
          props: { theme: {} },
          emits: ["changeTheme", "loadSwaggerFile", "linkSwaggerFile", "updateContent"],
          setup(e, { emit: t }) {
            const n = t,
              r = [
                "default",
                "alternate",
                "moon",
                "purple",
                "solarized",
                "bluePlanet",
                "saturn",
                "kepler",
                "mars",
                "deepSpace",
              ]
            async function a() {
              const e = await fetch("https://cdn.jsdelivr.net/npm/@scalar/galaxy/dist/latest.yaml")
              n("updateContent", await e.text())
            }
            return (e, t) => (
              xo(),
              Eo("div", az, [
                Ro("div", oz, [
                  iz,
                  Ro("div", sz, [
                    No(In(mw), { fullWidth: "", onClick: a }, { default: yr(() => [Mo(" Show Example ")]), _: 1 }),
                    No(
                      In(mw),
                      {
                        fullWidth: "",
                        variant: "outlined",
                        onClick: t[0] || (t[0] = (t) => e.$emit("loadSwaggerFile")),
                      },
                      { default: yr(() => [Mo(" Upload File ")]), _: 1 },
                    ),
                  ]),
                ]),
                Ro("div", lz, [
                  cz,
                  Ro("div", dz, [
                    uz,
                    (xo(),
                    Eo(
                      go,
                      null,
                      qr(r, (t) =>
                        Ro(
                          "div",
                          {
                            key: t,
                            class: Ge(["start-item", { "start-item-active": t === e.theme }]),
                            onClick: (n) => e.$emit("changeTheme", { id: t, label: In(lu)[t] }),
                          },
                          at(In(lu)[t]),
                          11,
                          pz,
                        ),
                      ),
                      64,
                    )),
                  ]),
                ]),
                hz,
              ])
            )
          },
        }),
        [["__scopeId", "data-v-391b4e37"]],
      ),
      mz = QQ(
        Hr({
          __name: "SidebarHttpBadge",
          props: { active: { type: Boolean }, method: {} },
          setup: (e) => (e, t) => (
            xo(),
            To(
              In(lU),
              {
                class: Ge(["sidebar-heading-type", { "sidebar-heading-type-active": e.active }]),
                method: e.method,
                property: "--method-color",
                short: "",
              },
              null,
              8,
              ["class", "method"],
            )
          ),
        }),
        [["__scopeId", "data-v-f51e2805"]],
      ),
      gz = ["id"],
      bz = { key: 0, class: "sidebar-heading-chevron" },
      vz = ["href"],
      yz = { class: "sidebar-heading-link-title" },
      Oz = { key: 1, class: "sidebar-heading-link-method" },
      wz = { key: 1, class: "action-menu" },
      xz = QQ(
        Hr({
          __name: "SidebarElement",
          props: {
            id: {},
            item: {},
            isActive: { type: Boolean },
            hasChildren: { type: Boolean },
            open: { type: Boolean },
          },
          emits: ["toggleOpen"],
          setup(e, { emit: t }) {
            const n = e,
              r = t,
              { hash: a, isIntersectionEnabled: o, pathRouting: i } = fp(),
              s = async () => {
                var e, t
                n.hasChildren && r("toggleOpen"),
                  null == (t = null == (e = n.item) ? void 0 : e.select) || t.call(e),
                  n.open && ((o.value = !1), await ym(100), (o.value = !0))
              },
              l = () => {
                if (i.value) return qf(i.value.basePath, n.item.id)
                if ("undefined" != typeof window) {
                  const e = new URL(window.location.href)
                  return (e.hash = n.item.id), `${e.pathname}${e.search}${e.hash}`
                }
                return `#${n.item.id}`
              },
              c = async (e) => {
                var t, s
                if (i.value) {
                  e.preventDefault(),
                    n.hasChildren && r("toggleOpen"),
                    null == (s = null == (t = n.item) ? void 0 : t.select) || s.call(t),
                    r("toggleOpen"),
                    (o.value = !1),
                    (a.value = n.item.id)
                  const l = new URL(window.location.href)
                  ;(l.pathname = qf(i.value.basePath, n.item.id)),
                    window.history.pushState({}, "", l),
                    vm(n.item.id),
                    await ym(100),
                    (o.value = !0)
                }
              }
            return (e, t) => {
              var n, r
              return (
                xo(),
                Eo(
                  "li",
                  { id: e.id, class: "sidebar-group-item" },
                  [
                    Ro(
                      "div",
                      {
                        class: Ge([
                          "sidebar-heading",
                          {
                            "sidebar-group-item__folder": e.hasChildren,
                            active_page: e.isActive,
                            deprecated: e.item.deprecated ?? !1,
                          },
                        ]),
                        onClick: s,
                      },
                      [
                        e.hasChildren
                          ? (xo(),
                            Eo("p", bz, [
                              No(
                                In(mL),
                                {
                                  class: "toggle-nested-icon",
                                  icon: e.open ? "ChevronDown" : "ChevronRight",
                                  label: "Toggle group",
                                  size: "xs",
                                  onClick: Wi(s, ["stop"]),
                                },
                                null,
                                8,
                                ["icon"],
                              ),
                              Mo("  "),
                            ]))
                          : Qo("", !0),
                        Ro(
                          "a",
                          { class: "sidebar-heading-link", href: l(), onClick: c },
                          [
                            (null == (r = null == (n = e.item) ? void 0 : n.icon) ? void 0 : r.src)
                              ? (xo(),
                                To(In(BI), { key: 0, class: "sidebar-icon", icon: e.item.icon.src }, null, 8, ["icon"]))
                              : Qo("", !0),
                            Ro("p", yz, at(e.item.title), 1),
                            e.item.httpVerb && !e.hasChildren
                              ? (xo(),
                                Eo("p", Oz, [
                                  Mo("  "),
                                  No(mz, { active: e.isActive, method: e.item.httpVerb }, null, 8, [
                                    "active",
                                    "method",
                                  ]),
                                ]))
                              : Qo("", !0),
                          ],
                          8,
                          vz,
                        ),
                      ],
                      2,
                    ),
                    e.open ? Xr(e.$slots, "default", { key: 0 }, void 0, !0) : Qo("", !0),
                    e.$slots["action-menu"]
                      ? (xo(), Eo("div", wz, [Xr(e.$slots, "action-menu", {}, void 0, !0)]))
                      : Qo("", !0),
                  ],
                  8,
                  gz,
                )
              )
            }
          },
        }),
        [["__scopeId", "data-v-8f97b414"]],
      ),
      kz = QQ(
        Hr({
          __name: "SidebarGroup",
          props: { level: {} },
          setup: (e) => (e, t) => (
            xo(),
            Eo(
              "ul",
              { class: "sidebar-group sidebar-indent-nested", style: He({ "--scalar-sidebar-level": e.level }) },
              [Xr(e.$slots, "default", {}, void 0, !0)],
              4,
            )
          ),
        }),
        [["__scopeId", "data-v-39c84840"]],
      ),
      _z = { class: "sidebar" },
      Sz = { class: "sidebar-group-title" },
      Ez = QQ(
        Hr({
          __name: "Sidebar",
          props: { parsedSpec: {}, tagsSorter: { type: [String, Function] } },
          setup(e) {
            const t = e,
              { hash: n, isIntersectionEnabled: r } = fp(),
              {
                items: a,
                toggleCollapsedSidebarItem: o,
                collapsedSidebarItems: i,
              } = sg({ parsedSpec: t.parsedSpec, tagsSorter: t.tagsSorter }),
              s = Dn(null),
              l = Dn(!0)
            Ya(n, (e) => {
              r.value && !l.value && "undefined" != typeof window && c(e)
            })
            const c = (e) => {
              var t, n, r, a
              const o = document.getElementById(`sidebar-${e}`)
              if (!o || !s.value) return
              let i = -160
              "heading" === o.getAttribute("data-sidebar-type")
                ? (i +=
                    o.offsetTop +
                    (null == (t = o.getElementsByClassName("sidebar-heading")) ? void 0 : t[0]).offsetHeight)
                : (i +=
                    o.offsetTop +
                    ((null == (n = o.parentElement) ? void 0 : n.offsetTop) ?? 0) +
                    ((null == (a = null == (r = o.parentElement) ? void 0 : r.parentElement) ? void 0 : a.offsetTop) ??
                      0)),
                s.value.scrollTo({ top: i, behavior: "smooth" })
            }
            return (
              Nr(() => {
                setTimeout(() => c(n.value), 500), (l.value = !1)
              }),
              (e, t) => (
                xo(),
                Eo("div", _z, [
                  Xr(e.$slots, "sidebar-start", {}, void 0, !0),
                  Ro(
                    "div",
                    {
                      ref_key: "scrollerEl",
                      ref: s,
                      class: "sidebar-pages custom-scroll custom-scroll-self-contain-overflow",
                    },
                    [
                      No(
                        kz,
                        { level: 0 },
                        {
                          default: yr(() => [
                            (xo(!0),
                            Eo(
                              go,
                              null,
                              qr(
                                In(a).entries,
                                (e) => (
                                  xo(),
                                  Eo(
                                    go,
                                    { key: e.id },
                                    [
                                      e.isGroup
                                        ? (xo(),
                                          Eo(
                                            go,
                                            { key: 0 },
                                            [
                                              Ro("li", Sz, at(e.displayTitle ?? e.title), 1),
                                              (xo(!0),
                                              Eo(
                                                go,
                                                null,
                                                qr(
                                                  e.children,
                                                  (t) => (
                                                    xo(),
                                                    To(
                                                      xz,
                                                      {
                                                        key: t.id,
                                                        id: `sidebar-${t.id}`,
                                                        "data-sidebar-type": "heading",
                                                        hasChildren: t.children && t.children.length > 0,
                                                        isActive: In(n) === t.id,
                                                        item: {
                                                          id: t.id,
                                                          title: t.displayTitle ?? t.title,
                                                          select: t.select,
                                                          httpVerb: t.httpVerb,
                                                          deprecated: t.deprecated ?? !1,
                                                        },
                                                        open: In(i)[t.id] ?? !1,
                                                        onToggleOpen: async () => {
                                                          ;(l.value = !0),
                                                            In(o)(t.id),
                                                            await In(ym)(100),
                                                            (l.value = !1)
                                                        },
                                                      },
                                                      {
                                                        default: yr(() => {
                                                          var r
                                                          return [
                                                            t.children &&
                                                            (null == (r = t.children) ? void 0 : r.length) > 0
                                                              ? (xo(),
                                                                To(
                                                                  kz,
                                                                  { key: 0, level: 1 },
                                                                  {
                                                                    default: yr(() => [
                                                                      (xo(!0),
                                                                      Eo(
                                                                        go,
                                                                        null,
                                                                        qr(
                                                                          t.children,
                                                                          (t) => (
                                                                            xo(),
                                                                            Eo(
                                                                              go,
                                                                              { key: t.id },
                                                                              [
                                                                                e.show
                                                                                  ? (xo(),
                                                                                    To(
                                                                                      xz,
                                                                                      {
                                                                                        key: 0,
                                                                                        id: `sidebar-${t.id}`,
                                                                                        isActive: In(n) === t.id,
                                                                                        item: {
                                                                                          id: t.id,
                                                                                          title:
                                                                                            t.displayTitle ?? t.title,
                                                                                          select: t.select,
                                                                                          httpVerb: t.httpVerb,
                                                                                          deprecated:
                                                                                            t.deprecated ?? !1,
                                                                                        },
                                                                                      },
                                                                                      null,
                                                                                      8,
                                                                                      ["id", "isActive", "item"],
                                                                                    ))
                                                                                  : Qo("", !0),
                                                                              ],
                                                                              64,
                                                                            )
                                                                          ),
                                                                        ),
                                                                        128,
                                                                      )),
                                                                    ]),
                                                                    _: 2,
                                                                  },
                                                                  1024,
                                                                ))
                                                              : Qo("", !0),
                                                          ]
                                                        }),
                                                        _: 2,
                                                      },
                                                      1032,
                                                      ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"],
                                                    )
                                                  ),
                                                ),
                                                128,
                                              )),
                                            ],
                                            64,
                                          ))
                                        : (xo(),
                                          Eo(
                                            go,
                                            { key: 1 },
                                            [
                                              e.show
                                                ? (xo(),
                                                  To(
                                                    xz,
                                                    {
                                                      key: 0,
                                                      id: `sidebar-${e.id}`,
                                                      "data-sidebar-type": "heading",
                                                      hasChildren: e.children && e.children.length > 0,
                                                      isActive: In(n) === e.id,
                                                      item: {
                                                        id: e.id,
                                                        title: e.displayTitle ?? e.title,
                                                        select: e.select,
                                                        httpVerb: e.httpVerb,
                                                        deprecated: e.deprecated ?? !1,
                                                      },
                                                      open: In(i)[e.id] ?? !1,
                                                      onToggleOpen: async () => {
                                                        ;(l.value = !0), In(o)(e.id), await In(ym)(100), (l.value = !1)
                                                      },
                                                    },
                                                    {
                                                      default: yr(() => {
                                                        var t
                                                        return [
                                                          e.children &&
                                                          (null == (t = e.children) ? void 0 : t.length) > 0
                                                            ? (xo(),
                                                              To(
                                                                kz,
                                                                { key: 0, level: 1 },
                                                                {
                                                                  default: yr(() => [
                                                                    (xo(!0),
                                                                    Eo(
                                                                      go,
                                                                      null,
                                                                      qr(
                                                                        e.children,
                                                                        (t) => (
                                                                          xo(),
                                                                          Eo(
                                                                            go,
                                                                            { key: t.id },
                                                                            [
                                                                              e.show
                                                                                ? (xo(),
                                                                                  To(
                                                                                    xz,
                                                                                    {
                                                                                      key: 0,
                                                                                      id: `sidebar-${t.id}`,
                                                                                      isActive: In(n) === t.id,
                                                                                      item: {
                                                                                        id: t.id,
                                                                                        title:
                                                                                          t.displayTitle ?? t.title,
                                                                                        select: t.select,
                                                                                        httpVerb: t.httpVerb,
                                                                                        deprecated: t.deprecated ?? !1,
                                                                                      },
                                                                                    },
                                                                                    null,
                                                                                    8,
                                                                                    ["id", "isActive", "item"],
                                                                                  ))
                                                                                : Qo("", !0),
                                                                            ],
                                                                            64,
                                                                          )
                                                                        ),
                                                                      ),
                                                                      128,
                                                                    )),
                                                                  ]),
                                                                  _: 2,
                                                                },
                                                                1024,
                                                              ))
                                                            : Qo("", !0),
                                                        ]
                                                      }),
                                                      _: 2,
                                                    },
                                                    1032,
                                                    ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"],
                                                  ))
                                                : Qo("", !0),
                                            ],
                                            64,
                                          )),
                                    ],
                                    64,
                                  )
                                ),
                              ),
                              128,
                            )),
                          ]),
                          _: 1,
                        },
                      ),
                    ],
                    512,
                  ),
                  Xr(e.$slots, "sidebar-end", {}, void 0, !0),
                ])
              )
            )
          },
        }),
        [["__scopeId", "data-v-14598096"]],
      ),
      Tz = ["innerHTML"],
      Az = { class: "references-header" },
      Cz = { key: 0, class: "references-navigation t-doc__sidebar" },
      Pz = { class: "references-navigation-list" },
      Dz = { class: "references-editor" },
      Rz = { class: "references-editor-textarea" },
      Nz = { class: "references-rendered" },
      $z = { key: 0, class: "references-footer" },
      Iz = Hr({
        inheritAttrs: !1,
        __name: "ApiReferenceLayout",
        props: { configuration: {}, parsedSpec: {}, rawSpec: {} },
        emits: ["changeTheme", "updateContent", "loadSwaggerFile", "linkSwaggerFile", "toggleDarkMode"],
        setup(e) {
          const t = e,
            { initializeToasts: n, toast: r } = Vu()
          n((e) => r(e))
          const a = $m("(min-width: 1150px)"),
            o = Dn("100dvh"),
            i = Dn(null)
          !(function (e, t, n = {}) {
            const { window: r = Dm, ...a } = n
            let o
            const i = Nm(() => r && "ResizeObserver" in r),
              s = () => {
                o && (o.disconnect(), (o = void 0))
              },
              l = Ya(
                ii(() => (Array.isArray(e) ? e.map((e) => Pm(e)) : [Pm(e)])),
                (e) => {
                  if ((s(), i.value && r)) {
                    o = new ResizeObserver(t)
                    for (const t of e) t && o.observe(t, a)
                  }
                },
                { immediate: !0, flush: "post" },
              )
            Om(() => {
              s(), l()
            })
          })(i, (e) => {
            o.value = e[0].contentRect.height + "px"
          })
          const s = Dn(0)
          Nr(() => {
            var e, t, n
            const r =
                null == (t = null == (e = i.value) ? void 0 : e.parentElement) ? void 0 : t.getBoundingClientRect(),
              a = null == (n = i.value) ? void 0 : n.getBoundingClientRect()
            if (r && a) {
              const e = a.top - r.top
              s.value = e < 2 ? 0 : e
            }
          })
          const {
              breadcrumb: l,
              collapsedSidebarItems: c,
              isSidebarOpen: d,
              setCollapsedSidebarItem: u,
              hideModels: p,
              defaultOpenAllTags: h,
              setParsedSpec: f,
            } = sg(),
            {
              getPathRoutingId: m,
              getSectionId: g,
              getTagId: b,
              hash: v,
              isIntersectionEnabled: y,
              pathRouting: O,
              updateHash: w,
            } = fp()
          ;(O.value = t.configuration.pathRouting), Rr(() => w())
          const x = async (e) => {
            var t
            ;(y.value = !1), w(), e ? vm(e) : null == (t = i.value) || t.scrollTo(0, 0), await ym(100), (y.value = !0)
          }
          Rr(() => DQ()),
            Nr(() => {
              Bm.on(({ specTitle: e }) => {
                !(function (e, t) {
                  const n = xd(e),
                    r = n ? new Blob([e], { type: "application/json" }) : new Blob([e], { type: "application/x-yaml" }),
                    a = URL.createObjectURL(r),
                    o = n ? ".json" : ".yaml",
                    i = t ? t + o : "spec" + o,
                    s = document.createElement("a")
                  ;(s.href = a),
                    (s.download = i),
                    s.dispatchEvent(new MouseEvent("click", { bubbles: !0, cancelable: !0, view: window })),
                    setTimeout(() => {
                      window.URL.revokeObjectURL(a), s.remove()
                    }, 100)
                })(t.rawSpec, e)
              }),
                (window.onhashchange = () => x(decodeURIComponent(window.location.hash.replace(/^#/, "")))),
                (window.onpopstate = () => O.value && x(m(window.location.pathname)))
            })
          const k = ii(() => a.value || !t.configuration.isEditable),
            _ = Tm((e) => {
              if ((e.target.scrollTop ?? 0) < 50) {
                const e = t.configuration.pathRouting ? t.configuration.pathRouting.basePath : window.location.pathname
                window.history.replaceState({}, "", e + window.location.search), (v.value = "")
              }
            }),
            S = ii(() => ({ breadcrumb: l.value, spec: t.parsedSpec }))
          var E
          Ya(() => t.parsedSpec, f, { deep: !0 }),
            Qr(() => {
              var e, n
              const r = Va()
              if (
                r &&
                (r.payload || (r.payload = { data: {} }),
                (e = r.payload).data || (e.data = {}),
                t.configuration.pathRouting)
              ) {
                const e = m(r.url)
                ;(v.value = e), (r.payload.data.hash = e)
                for (const e in c) Object.hasOwn(c, e) && delete c[e]
                if (e) u(g(e), !0)
                else {
                  const e = null == (n = t.parsedSpec.tags) ? void 0 : n[0]
                  e && u(b(e), !0)
                }
                r.payload.data["useSidebarContent-collapsedSidebarItems"] = c
              }
            }),
            wa(Ib, () => {
              var e
              const t = Vo(),
                n = "scalar-instance-id"
              if (!t) return n
              let r = t.uid
              return (
                "undefined" == typeof window
                  ? (t.attrs || (t.attrs = {}), (t.attrs[n] = r))
                  : (null == (e = t.vnode.el) ? void 0 : e.getAttribute) && (r = t.vnode.el.getAttribute(n)),
                `${n}-${r}`
              )
            }),
            wa(gm, () => t.parsedSpec.security),
            wa(bm, () => t.configuration.hideDownloadButton),
            (p.value = t.configuration.hideModels ?? !1),
            (h.value = t.configuration.defaultOpenAllTags ?? !1),
            (E = t.configuration),
            Ya(
              () => E,
              () => {
                var e
                E.proxy === Gu
                  ? (console.warn(`[DEPRECATED] Warning: configuration.proxy points to our old proxy (${Gu}).`),
                    console.warn(
                      `[DEPRECATED] We are overwriting the value and use the new proxy URL (${Ku}) instead.`,
                    ),
                    (E.proxy = Ku),
                    console.warn(
                      `[DEPRECATED] Action Required: You should manually update your configuration to use the new URL (${Ku}). Read more: https://github.com/scalar/scalar`,
                    ))
                  : (null == (e = E.proxy) ? void 0 : e.length) &&
                    E.proxy !== Ku &&
                    "http://localhost:5051" !== E.proxy &&
                    (console.warn(
                      `[DEPRECATED] Warning: configuration.proxy points to a custom proxy (${null == E ? void 0 : E.proxy}).`,
                    ),
                    console.warn(
                      "[DEPRECATED] Action Required: You need to use our new proxy (written in Go). Read more: https://github.com/scalar/scalar/tree/main/examples/proxy-server",
                    ))
              },
              { immediate: !0 },
            )
          const T = ii(
            () =>
              `<style>\n  ${((e, t) => {
                const { variables: n = !0, fonts: r = !0, layer: a = "scalar-theme" } = t ?? {},
                  o = [
                    du(e),
                    n
                      ? ":root {\n  --scalar-border-width: 1px;\n  --scalar-radius: 3px;\n  --scalar-radius-lg: 6px;\n  --scalar-radius-xl: 8px;\n\n  /* TYPOGRAPHY ------------------------------------ */\n  --scalar-font: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n    Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n  --scalar-font-code: 'JetBrains Mono', ui-monospace, Menlo, Monaco,\n    'Cascadia Mono', 'Segoe UI Mono', 'Roboto Mono', 'Oxygen Mono',\n    'Ubuntu Monospace', 'Source Code Pro', 'Fira Mono', 'Droid Sans Mono',\n    'Courier New', monospace;\n\n  /** Font sizes for rendered text content (editor styles or static content) */\n  --scalar-heading-1: 40px; /* Editor Page heading */\n  --scalar-page-description: 24px;\n  --scalar-heading-2: 24px; /* Editor section headings */\n  --scalar-heading-3: 20px;\n  --scalar-heading-4: 16px;\n  --scalar-heading-5: 16px;\n  --scalar-heading-6: 16px;\n\n  --scalar-paragraph: 16px;\n  --scalar-small: 14px;\n  --scalar-mini: 13px;\n  --scalar-micro: 12px;\n  --scalar-bold: 600;\n  --scalar-semibold: 500;\n  --scalar-regular: 400;\n\n  /* Font sizes for interactive applications (not rendered text content) */\n  --scalar-font-size-1: 24px;\n  --scalar-font-size-2: 16px;\n  --scalar-font-size-3: 14px;\n  --scalar-font-size-4: 13px;\n  --scalar-font-size-5: 12px;\n  --scalar-font-size-6: 12px;\n  --scalar-font-size-7: 10px;\n\n  --scalar-line-height-1: 32px;\n  --scalar-line-height-2: 24px;\n  --scalar-line-height-3: 20px;\n  --scalar-line-height-4: 18px;\n  --scalar-line-height-5: 16px;\n\n  --scalar-font-medium: 500;\n  --scalar-font-bold: 700;\n\n  --scalar-text-decoration: none;\n  --scalar-text-decoration-hover: underline;\n}\n.dark-mode {\n  color-scheme: dark;\n  --scalar-scrollbar-color: rgba(255, 255, 255, 0.18);\n  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.36);\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);\n  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,\n    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);\n\n  --scalar-sidebar-indent-border: transparent;\n  --scalar-sidebar-indent-border-hover: transparent;\n  --scalar-sidebar-indent-border-active: transparent;\n}\n.light-mode {\n  color-scheme: light;\n  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);\n  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,\n    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;\n\n  --scalar-sidebar-indent-border: transparent;\n  --scalar-sidebar-indent-border-hover: transparent;\n  --scalar-sidebar-indent-border-active: transparent;\n}\n/* On some browsers, the light color scheme takes precedence when the light mode is active */\n.light-mode .dark-mode {\n  color-scheme: dark !important;\n}\n@media (max-width: 460px) {\n  :root {\n    --scalar-font-size-1: 22px;\n    --scalar-font-size-2: 14px;\n    --scalar-font-size-3: 12px;\n  }\n}\n\n@media (max-width: 720px) {\n  :root {\n    --scalar-heading-1: 24px;\n    --scalar-page-description: 20px;\n  }\n}\n"
                      : "",
                    r
                      ? "/* Inter (--scalar-font) */\n/* cyrillic-ext */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-cyrillic-ext.woff2) format('woff2');\n  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F,\n    U+FE2E-FE2F;\n}\n/* cyrillic */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-cyrillic.woff2) format('woff2');\n  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n}\n/* greek-ext */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-greek-ext.woff2) format('woff2');\n  unicode-range: U+1F00-1FFF;\n}\n/* greek */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-greek.woff2) format('woff2');\n  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1,\n    U+03A3-03FF;\n}\n/* vietnamese */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-vietnamese.woff2) format('woff2');\n  unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1,\n    U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329,\n    U+1EA0-1EF9, U+20AB;\n}\n/* latin-ext */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-latin-ext.woff2) format('woff2');\n  unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF,\n    U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 100 900;\n  font-display: swap;\n  src: url(https://fonts.scalar.com/inter-latin.woff2) format('woff2');\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,\n    U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191,\n    U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n}\n/* JetBrains Mono (--scalar-font-code) */\n/* cyrillic-ext */\n@font-face {\n  font-family: 'JetBrains Mono';\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.scalar.com/mono-cyrillic-ext.woff2) format('woff2');\n  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F,\n    U+FE2E-FE2F;\n}\n/* cyrillic */\n@font-face {\n  font-family: 'JetBrains Mono';\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.scalar.com/mono-cyrillic.woff2) format('woff2');\n  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n}\n/* greek */\n@font-face {\n  font-family: 'JetBrains Mono';\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.scalar.com/mono-greek.woff2) format('woff2');\n  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1,\n    U+03A3-03FF;\n}\n/* vietnamese */\n@font-face {\n  font-family: 'JetBrains Mono';\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.scalar.com/mono-vietnamese.woff2) format('woff2');\n  unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1,\n    U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329,\n    U+1EA0-1EF9, U+20AB;\n}\n/* latin-ext */\n@font-face {\n  font-family: 'JetBrains Mono';\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.scalar.com/mono-latin-ext.woff2) format('woff2');\n  unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF,\n    U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n  font-family: 'JetBrains Mono';\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.scalar.com/mono-latin.woff2) format('woff2');\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA,\n    U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191,\n    U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n}\n"
                      : "",
                  ].join("")
                return a ? `@layer ${a} {\n${o}}` : o
              })(t.configuration.theme, { fonts: t.configuration.withDefaultFonts })}</style>`,
          )
          return (e, t) => {
            var n
            return (
              xo(),
              Eo(
                go,
                null,
                [
                  Ro("div", { innerHTML: T.value }, null, 8, Tz),
                  Ro(
                    "div",
                    {
                      ref_key: "documentEl",
                      ref: i,
                      class: Ge([
                        "scalar-app scalar-api-reference references-layout",
                        [
                          {
                            "references-editable": e.configuration.isEditable,
                            "references-sidebar": e.configuration.showSidebar,
                            "references-sidebar-mobile-open": In(d),
                            "references-classic": "classic" === e.configuration.layout,
                          },
                          e.$attrs.class,
                        ],
                      ]),
                      style: He({ "--scalar-y-offset": `var(--scalar-custom-header-height, ${s.value}px)` }),
                      onScrollPassive: t[4] || (t[4] = (...e) => In(_) && In(_)(...e)),
                    },
                    [
                      Ro("div", Az, [Xr(e.$slots, "header", Ke($o(S.value)), void 0, !0)]),
                      e.configuration.showSidebar
                        ? (xo(),
                          Eo("aside", Cz, [
                            Ro("div", Pz, [
                              No(
                                In(Ez),
                                { parsedSpec: e.parsedSpec, tagsSorter: e.configuration.tagsSorter },
                                {
                                  "sidebar-start": yr(() => [
                                    Xr(e.$slots, "sidebar-start", Ke($o(S.value)), void 0, !0),
                                  ]),
                                  "sidebar-end": yr(() => [Xr(e.$slots, "sidebar-end", Ke($o(S.value)), void 0, !0)]),
                                  _: 3,
                                },
                                8,
                                ["parsedSpec", "tagsSorter"],
                              ),
                            ]),
                          ]))
                        : Qo("", !0),
                      Fr(Ro("div", Dz, [Ro("div", Rz, [Xr(e.$slots, "editor", Ke($o(S.value)), void 0, !0)])], 512), [
                        [mi, e.configuration.isEditable],
                      ]),
                      k.value
                        ? (xo(),
                          Eo(
                            go,
                            { key: 1 },
                            [
                              Ro("div", Nz, [
                                No(
                                  In(rz),
                                  {
                                    baseServerURL: e.configuration.baseServerURL,
                                    layout: "classic" === e.configuration.layout ? "accordion" : "default",
                                    parsedSpec: e.parsedSpec,
                                    proxy: e.configuration.proxy,
                                    servers: e.configuration.servers,
                                  },
                                  Zr(
                                    {
                                      start: yr(() => [Xr(e.$slots, "content-start", Ke($o(S.value)), void 0, !0)]),
                                      end: yr(() => [Xr(e.$slots, "content-end", Ke($o(S.value)), void 0, !0)]),
                                      _: 2,
                                    },
                                    [
                                      (null == (n = e.configuration) ? void 0 : n.isEditable)
                                        ? {
                                            name: "empty-state",
                                            fn: yr(() => {
                                              var n
                                              return [
                                                No(
                                                  fz,
                                                  {
                                                    theme:
                                                      (null == (n = e.configuration) ? void 0 : n.theme) || "default",
                                                    onChangeTheme: t[0] || (t[0] = (t) => e.$emit("changeTheme", t)),
                                                    onLinkSwaggerFile:
                                                      t[1] || (t[1] = (t) => e.$emit("linkSwaggerFile")),
                                                    onLoadSwaggerFile:
                                                      t[2] || (t[2] = (t) => e.$emit("loadSwaggerFile")),
                                                    onUpdateContent:
                                                      t[3] || (t[3] = (t) => e.$emit("updateContent", t)),
                                                  },
                                                  null,
                                                  8,
                                                  ["theme"],
                                                ),
                                              ]
                                            }),
                                            key: "0",
                                          }
                                        : void 0,
                                    ],
                                  ),
                                  1032,
                                  ["baseServerURL", "layout", "parsedSpec", "proxy", "servers"],
                                ),
                              ]),
                              e.$slots.footer
                                ? (xo(), Eo("div", $z, [Xr(e.$slots, "footer", Ke($o(S.value)), void 0, !0)]))
                                : Qo("", !0),
                            ],
                            64,
                          ))
                        : Qo("", !0),
                      No(MQ, { proxyUrl: e.configuration.proxy, spec: e.configuration.spec }, null, 8, [
                        "proxyUrl",
                        "spec",
                      ]),
                    ],
                    38,
                  ),
                  No(In(Wu)),
                ],
                64,
              )
            )
          }
        },
      }),
      Mz = QQ(Iz, [["__scopeId", "data-v-4e8b0896"]]),
      Lz = { class: "references-classic-header-container" },
      Qz = { class: "references-classic-header" },
      Bz = QQ({}, [
        [
          "render",
          function (e, t) {
            return (
              xo(),
              Eo("div", Lz, [
                Ro("div", Qz, [
                  Xr(e.$slots, "default", {}, void 0, !0),
                  Xr(e.$slots, "dark-mode-toggle", {}, void 0, !0),
                ]),
              ])
            )
          },
        ],
        ["__scopeId", "data-v-a860f78f"],
      ]),
      jz = { class: "darklight-reference" },
      Uz = { key: 0 },
      Fz = { key: 1 },
      zz = ((e) => (br("data-v-c2022750"), (e = e()), vr(), e))(() =>
        Ro(
          "a",
          { class: "darklight-reference-promo", href: "https://www.scalar.com", target: "_blank" },
          " Powered by scalar.com ",
          -1,
        ),
      ),
      qz = QQ(
        Hr({
          __name: "DarkModeToggle",
          props: { isDarkMode: { type: Boolean } },
          emits: ["toggleDarkMode"],
          setup: (e) => (e, t) => (
            xo(),
            Eo("div", jz, [
              Ro(
                "button",
                { class: "darklight", type: "button", onClick: t[0] || (t[0] = (t) => e.$emit("toggleDarkMode")) },
                [
                  No(In(BI), { icon: "LightDarkModeToggle", size: "md" }),
                  e.isDarkMode ? (xo(), Eo("span", Uz, "Light Mode")) : (xo(), Eo("span", Fz, "Dark Mode")),
                ],
              ),
              zz,
            ])
          ),
        }),
        [["__scopeId", "data-v-c2022750"]],
      ),
      Zz = QQ(
        Hr({
          __name: "DarkModeIconToggle",
          props: { isDarkMode: { type: Boolean } },
          emits: ["toggleDarkMode"],
          setup: (e) => (e, t) => (
            xo(),
            Eo(
              "button",
              { class: "darklight", type: "button", onClick: t[0] || (t[0] = (t) => e.$emit("toggleDarkMode")) },
              [
                No(In(BI), { icon: e.isDarkMode ? "DarkMode" : "LightMode" }, null, 8, ["icon"]),
                No(Aj, null, {
                  default: yr(() => [Mo(" Switch to " + at(e.isDarkMode ? "Light" : "Dark") + " Mode ", 1)]),
                  _: 1,
                }),
              ],
            )
          ),
        }),
        [["__scopeId", "data-v-8f61ca56"]],
      )
    function Hz() {
      return typeof navigator < "u" && /Mac/.test(navigator.platform)
    }
    function Vz(e) {
      return Array.isArray ? Array.isArray(e) : "[object Array]" === Jz(e)
    }
    function Wz(e) {
      return "string" == typeof e
    }
    function Xz(e) {
      return "number" == typeof e
    }
    function Yz(e) {
      return "object" == typeof e
    }
    function Gz(e) {
      return null != e
    }
    function Kz(e) {
      return !e.trim().length
    }
    function Jz(e) {
      return null == e ? (void 0 === e ? "[object Undefined]" : "[object Null]") : Object.prototype.toString.call(e)
    }
    const eq = (e) => `Missing ${e} property in key`,
      tq = (e) => `Property 'weight' in key '${e}' must be a positive integer`,
      nq = Object.prototype.hasOwnProperty
    class rq {
      constructor(e) {
        ;(this._keys = []), (this._keyMap = {})
        let t = 0
        e.forEach((e) => {
          let n = aq(e)
          this._keys.push(n), (this._keyMap[n.id] = n), (t += n.weight)
        }),
          this._keys.forEach((e) => {
            e.weight /= t
          })
      }
      get(e) {
        return this._keyMap[e]
      }
      keys() {
        return this._keys
      }
      toJSON() {
        return JSON.stringify(this._keys)
      }
    }
    function aq(e) {
      let t = null,
        n = null,
        r = null,
        a = 1,
        o = null
      if (Wz(e) || Vz(e)) (r = e), (t = oq(e)), (n = iq(e))
      else {
        if (!nq.call(e, "name")) throw new Error(eq("name"))
        const i = e.name
        if (((r = i), nq.call(e, "weight") && ((a = e.weight), a <= 0))) throw new Error(tq(i))
        ;(t = oq(i)), (n = iq(i)), (o = e.getFn)
      }
      return { path: t, id: n, weight: a, src: r, getFn: o }
    }
    function oq(e) {
      return Vz(e) ? e : e.split(".")
    }
    function iq(e) {
      return Vz(e) ? e.join(".") : e
    }
    const sq = {
      useExtendedSearch: !1,
      getFn: function (e, t) {
        let n = [],
          r = !1
        const a = (e, t, o) => {
          if (Gz(e))
            if (t[o]) {
              const i = e[t[o]]
              if (!Gz(i)) return
              if (
                o === t.length - 1 &&
                (Wz(i) ||
                  Xz(i) ||
                  (function (e) {
                    return (
                      !0 === e ||
                      !1 === e ||
                      ((function (e) {
                        return Yz(e) && null !== e
                      })(e) &&
                        "[object Boolean]" == Jz(e))
                    )
                  })(i))
              )
                n.push(
                  (function (e) {
                    return null == e
                      ? ""
                      : (function (e) {
                          if ("string" == typeof e) return e
                          let t = e + ""
                          return "0" == t && 1 / e == -1 / 0 ? "-0" : t
                        })(e)
                  })(i),
                )
              else if (Vz(i)) {
                r = !0
                for (let e = 0, n = i.length; e < n; e += 1) a(i[e], t, o + 1)
              } else t.length && a(i, t, o + 1)
            } else n.push(e)
        }
        return a(e, Wz(t) ? t.split(".") : t, 0), r ? n : n[0]
      },
      ignoreLocation: !1,
      ignoreFieldNorm: !1,
      fieldNormWeight: 1,
    }
    var lq = {
      isCaseSensitive: !1,
      includeScore: !1,
      keys: [],
      shouldSort: !0,
      sortFn: (e, t) => (e.score === t.score ? (e.idx < t.idx ? -1 : 1) : e.score < t.score ? -1 : 1),
      includeMatches: !1,
      findAllMatches: !1,
      minMatchCharLength: 1,
      location: 0,
      threshold: 0.6,
      distance: 100,
      ...sq,
    }
    const cq = /[^ ]+/g
    class dq {
      constructor({ getFn: e = lq.getFn, fieldNormWeight: t = lq.fieldNormWeight } = {}) {
        ;(this.norm = (function (e = 1, t = 3) {
          const n = new Map(),
            r = Math.pow(10, t)
          return {
            get(t) {
              const a = t.match(cq).length
              if (n.has(a)) return n.get(a)
              const o = 1 / Math.pow(a, 0.5 * e),
                i = parseFloat(Math.round(o * r) / r)
              return n.set(a, i), i
            },
            clear() {
              n.clear()
            },
          }
        })(t, 3)),
          (this.getFn = e),
          (this.isCreated = !1),
          this.setIndexRecords()
      }
      setSources(e = []) {
        this.docs = e
      }
      setIndexRecords(e = []) {
        this.records = e
      }
      setKeys(e = []) {
        ;(this.keys = e),
          (this._keysMap = {}),
          e.forEach((e, t) => {
            this._keysMap[e.id] = t
          })
      }
      create() {
        !this.isCreated &&
          this.docs.length &&
          ((this.isCreated = !0),
          Wz(this.docs[0])
            ? this.docs.forEach((e, t) => {
                this._addString(e, t)
              })
            : this.docs.forEach((e, t) => {
                this._addObject(e, t)
              }),
          this.norm.clear())
      }
      add(e) {
        const t = this.size()
        Wz(e) ? this._addString(e, t) : this._addObject(e, t)
      }
      removeAt(e) {
        this.records.splice(e, 1)
        for (let t = e, n = this.size(); t < n; t += 1) this.records[t].i -= 1
      }
      getValueForItemAtKeyId(e, t) {
        return e[this._keysMap[t]]
      }
      size() {
        return this.records.length
      }
      _addString(e, t) {
        if (!Gz(e) || Kz(e)) return
        let n = { v: e, i: t, n: this.norm.get(e) }
        this.records.push(n)
      }
      _addObject(e, t) {
        let n = { i: t, $: {} }
        this.keys.forEach((t, r) => {
          let a = t.getFn ? t.getFn(e) : this.getFn(e, t.path)
          if (Gz(a))
            if (Vz(a)) {
              let e = []
              const t = [{ nestedArrIndex: -1, value: a }]
              for (; t.length; ) {
                const { nestedArrIndex: n, value: r } = t.pop()
                if (Gz(r))
                  if (Wz(r) && !Kz(r)) {
                    let t = { v: r, i: n, n: this.norm.get(r) }
                    e.push(t)
                  } else
                    Vz(r) &&
                      r.forEach((e, n) => {
                        t.push({ nestedArrIndex: n, value: e })
                      })
              }
              n.$[r] = e
            } else if (Wz(a) && !Kz(a)) {
              let e = { v: a, n: this.norm.get(a) }
              n.$[r] = e
            }
        }),
          this.records.push(n)
      }
      toJSON() {
        return { keys: this.keys, records: this.records }
      }
    }
    function uq(e, t, { getFn: n = lq.getFn, fieldNormWeight: r = lq.fieldNormWeight } = {}) {
      const a = new dq({ getFn: n, fieldNormWeight: r })
      return a.setKeys(e.map(aq)), a.setSources(t), a.create(), a
    }
    function pq(
      e,
      {
        errors: t = 0,
        currentLocation: n = 0,
        expectedLocation: r = 0,
        distance: a = lq.distance,
        ignoreLocation: o = lq.ignoreLocation,
      } = {},
    ) {
      const i = t / e.length
      if (o) return i
      const s = Math.abs(r - n)
      return a ? i + s / a : s ? 1 : i
    }
    const hq = 32
    function fq(e) {
      let t = {}
      for (let n = 0, r = e.length; n < r; n += 1) {
        const a = e.charAt(n)
        t[a] = (t[a] || 0) | (1 << (r - n - 1))
      }
      return t
    }
    class mq {
      constructor(
        e,
        {
          location: t = lq.location,
          threshold: n = lq.threshold,
          distance: r = lq.distance,
          includeMatches: a = lq.includeMatches,
          findAllMatches: o = lq.findAllMatches,
          minMatchCharLength: i = lq.minMatchCharLength,
          isCaseSensitive: s = lq.isCaseSensitive,
          ignoreLocation: l = lq.ignoreLocation,
        } = {},
      ) {
        if (
          ((this.options = {
            location: t,
            threshold: n,
            distance: r,
            includeMatches: a,
            findAllMatches: o,
            minMatchCharLength: i,
            isCaseSensitive: s,
            ignoreLocation: l,
          }),
          (this.pattern = s ? e : e.toLowerCase()),
          (this.chunks = []),
          !this.pattern.length)
        )
          return
        const c = (e, t) => {
            this.chunks.push({ pattern: e, alphabet: fq(e), startIndex: t })
          },
          d = this.pattern.length
        if (d > hq) {
          let e = 0
          const t = d % hq,
            n = d - t
          for (; e < n; ) c(this.pattern.substr(e, hq), e), (e += hq)
          if (t) {
            const e = d - hq
            c(this.pattern.substr(e), e)
          }
        } else c(this.pattern, 0)
      }
      searchIn(e) {
        const { isCaseSensitive: t, includeMatches: n } = this.options
        if ((t || (e = e.toLowerCase()), this.pattern === e)) {
          let t = { isMatch: !0, score: 0 }
          return n && (t.indices = [[0, e.length - 1]]), t
        }
        const {
          location: r,
          distance: a,
          threshold: o,
          findAllMatches: i,
          minMatchCharLength: s,
          ignoreLocation: l,
        } = this.options
        let c = [],
          d = 0,
          u = !1
        this.chunks.forEach(({ pattern: t, alphabet: p, startIndex: h }) => {
          const {
            isMatch: f,
            score: m,
            indices: g,
          } = (function (
            e,
            t,
            n,
            {
              location: r = lq.location,
              distance: a = lq.distance,
              threshold: o = lq.threshold,
              findAllMatches: i = lq.findAllMatches,
              minMatchCharLength: s = lq.minMatchCharLength,
              includeMatches: l = lq.includeMatches,
              ignoreLocation: c = lq.ignoreLocation,
            } = {},
          ) {
            if (t.length > hq) throw new Error("Pattern length exceeds max of 32.")
            const d = t.length,
              u = e.length,
              p = Math.max(0, Math.min(r, u))
            let h = o,
              f = p
            const m = s > 1 || l,
              g = m ? Array(u) : []
            let b
            for (; (b = e.indexOf(t, f)) > -1; ) {
              let e = pq(t, { currentLocation: b, expectedLocation: p, distance: a, ignoreLocation: c })
              if (((h = Math.min(e, h)), (f = b + d), m)) {
                let e = 0
                for (; e < d; ) (g[b + e] = 1), (e += 1)
              }
            }
            f = -1
            let v = [],
              y = 1,
              O = d + u
            const w = 1 << (d - 1)
            for (let r = 0; r < d; r += 1) {
              let o = 0,
                s = O
              for (; o < s; )
                pq(t, { errors: r, currentLocation: p + s, expectedLocation: p, distance: a, ignoreLocation: c }) <= h
                  ? (o = s)
                  : (O = s),
                  (s = Math.floor((O - o) / 2 + o))
              O = s
              let l = Math.max(1, p - s + 1),
                b = i ? u : Math.min(p + s, u) + d,
                x = Array(b + 2)
              x[b + 1] = (1 << r) - 1
              for (let o = b; o >= l; o -= 1) {
                let i = o - 1,
                  s = n[e.charAt(i)]
                if (
                  (m && (g[i] = +!!s),
                  (x[o] = ((x[o + 1] << 1) | 1) & s),
                  r && (x[o] |= ((v[o + 1] | v[o]) << 1) | 1 | v[o + 1]),
                  x[o] & w &&
                    ((y = pq(t, {
                      errors: r,
                      currentLocation: i,
                      expectedLocation: p,
                      distance: a,
                      ignoreLocation: c,
                    })),
                    y <= h))
                ) {
                  if (((h = y), (f = i), f <= p)) break
                  l = Math.max(1, 2 * p - f)
                }
              }
              if (pq(t, { errors: r + 1, currentLocation: p, expectedLocation: p, distance: a, ignoreLocation: c }) > h)
                break
              v = x
            }
            const x = { isMatch: f >= 0, score: Math.max(0.001, y) }
            if (m) {
              const e = (function (e = [], t = lq.minMatchCharLength) {
                let n = [],
                  r = -1,
                  a = -1,
                  o = 0
                for (let i = e.length; o < i; o += 1) {
                  let i = e[o]
                  i && -1 === r ? (r = o) : i || -1 === r || ((a = o - 1), a - r + 1 >= t && n.push([r, a]), (r = -1))
                }
                return e[o - 1] && o - r >= t && n.push([r, o - 1]), n
              })(g, s)
              e.length ? l && (x.indices = e) : (x.isMatch = !1)
            }
            return x
          })(e, t, p, {
            location: r + h,
            distance: a,
            threshold: o,
            findAllMatches: i,
            minMatchCharLength: s,
            includeMatches: n,
            ignoreLocation: l,
          })
          f && (u = !0), (d += m), f && g && (c = [...c, ...g])
        })
        let p = { isMatch: u, score: u ? d / this.chunks.length : 1 }
        return u && n && (p.indices = c), p
      }
    }
    class gq {
      constructor(e) {
        this.pattern = e
      }
      static isMultiMatch(e) {
        return bq(e, this.multiRegex)
      }
      static isSingleMatch(e) {
        return bq(e, this.singleRegex)
      }
      search() {}
    }
    function bq(e, t) {
      const n = e.match(t)
      return n ? n[1] : null
    }
    class vq extends gq {
      constructor(
        e,
        {
          location: t = lq.location,
          threshold: n = lq.threshold,
          distance: r = lq.distance,
          includeMatches: a = lq.includeMatches,
          findAllMatches: o = lq.findAllMatches,
          minMatchCharLength: i = lq.minMatchCharLength,
          isCaseSensitive: s = lq.isCaseSensitive,
          ignoreLocation: l = lq.ignoreLocation,
        } = {},
      ) {
        super(e),
          (this._bitapSearch = new mq(e, {
            location: t,
            threshold: n,
            distance: r,
            includeMatches: a,
            findAllMatches: o,
            minMatchCharLength: i,
            isCaseSensitive: s,
            ignoreLocation: l,
          }))
      }
      static get type() {
        return "fuzzy"
      }
      static get multiRegex() {
        return /^"(.*)"$/
      }
      static get singleRegex() {
        return /^(.*)$/
      }
      search(e) {
        return this._bitapSearch.searchIn(e)
      }
    }
    class yq extends gq {
      constructor(e) {
        super(e)
      }
      static get type() {
        return "include"
      }
      static get multiRegex() {
        return /^'"(.*)"$/
      }
      static get singleRegex() {
        return /^'(.*)$/
      }
      search(e) {
        let t,
          n = 0
        const r = [],
          a = this.pattern.length
        for (; (t = e.indexOf(this.pattern, n)) > -1; ) (n = t + a), r.push([t, n - 1])
        const o = !!r.length
        return { isMatch: o, score: o ? 0 : 1, indices: r }
      }
    }
    const Oq = [
        class extends gq {
          constructor(e) {
            super(e)
          }
          static get type() {
            return "exact"
          }
          static get multiRegex() {
            return /^="(.*)"$/
          }
          static get singleRegex() {
            return /^=(.*)$/
          }
          search(e) {
            const t = e === this.pattern
            return { isMatch: t, score: t ? 0 : 1, indices: [0, this.pattern.length - 1] }
          }
        },
        yq,
        class extends gq {
          constructor(e) {
            super(e)
          }
          static get type() {
            return "prefix-exact"
          }
          static get multiRegex() {
            return /^\^"(.*)"$/
          }
          static get singleRegex() {
            return /^\^(.*)$/
          }
          search(e) {
            const t = e.startsWith(this.pattern)
            return { isMatch: t, score: t ? 0 : 1, indices: [0, this.pattern.length - 1] }
          }
        },
        class extends gq {
          constructor(e) {
            super(e)
          }
          static get type() {
            return "inverse-prefix-exact"
          }
          static get multiRegex() {
            return /^!\^"(.*)"$/
          }
          static get singleRegex() {
            return /^!\^(.*)$/
          }
          search(e) {
            const t = !e.startsWith(this.pattern)
            return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] }
          }
        },
        class extends gq {
          constructor(e) {
            super(e)
          }
          static get type() {
            return "inverse-suffix-exact"
          }
          static get multiRegex() {
            return /^!"(.*)"\$$/
          }
          static get singleRegex() {
            return /^!(.*)\$$/
          }
          search(e) {
            const t = !e.endsWith(this.pattern)
            return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] }
          }
        },
        class extends gq {
          constructor(e) {
            super(e)
          }
          static get type() {
            return "suffix-exact"
          }
          static get multiRegex() {
            return /^"(.*)"\$$/
          }
          static get singleRegex() {
            return /^(.*)\$$/
          }
          search(e) {
            const t = e.endsWith(this.pattern)
            return { isMatch: t, score: t ? 0 : 1, indices: [e.length - this.pattern.length, e.length - 1] }
          }
        },
        class extends gq {
          constructor(e) {
            super(e)
          }
          static get type() {
            return "inverse-exact"
          }
          static get multiRegex() {
            return /^!"(.*)"$/
          }
          static get singleRegex() {
            return /^!(.*)$/
          }
          search(e) {
            const t = -1 === e.indexOf(this.pattern)
            return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] }
          }
        },
        vq,
      ],
      wq = Oq.length,
      xq = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
      kq = new Set([vq.type, yq.type])
    const _q = []
    function Sq(e, t) {
      for (let n = 0, r = _q.length; n < r; n += 1) {
        let r = _q[n]
        if (r.condition(e, t)) return new r(e, t)
      }
      return new mq(e, t)
    }
    const Eq = "$and",
      Tq = "$path",
      Aq = (e) => !(!e[Eq] && !e.$or),
      Cq = (e) => ({ [Eq]: Object.keys(e).map((t) => ({ [t]: e[t] })) })
    function Pq(e, t, { auto: n = !0 } = {}) {
      const r = (e) => {
        let a = Object.keys(e)
        const o = ((e) => !!e[Tq])(e)
        if (!o && a.length > 1 && !Aq(e)) return r(Cq(e))
        if (((e) => !Vz(e) && Yz(e) && !Aq(e))(e)) {
          const r = o ? e[Tq] : a[0],
            i = o ? e.$val : e[r]
          if (!Wz(i)) throw new Error(((e) => `Invalid value for key ${e}`)(r))
          const s = { keyId: iq(r), pattern: i }
          return n && (s.searcher = Sq(i, t)), s
        }
        let i = { children: [], operator: a[0] }
        return (
          a.forEach((t) => {
            const n = e[t]
            Vz(n) &&
              n.forEach((e) => {
                i.children.push(r(e))
              })
          }),
          i
        )
      }
      return Aq(e) || (e = Cq(e)), r(e)
    }
    function Dq(e, t) {
      const n = e.matches
      ;(t.matches = []),
        Gz(n) &&
          n.forEach((e) => {
            if (!Gz(e.indices) || !e.indices.length) return
            const { indices: n, value: r } = e
            let a = { indices: n, value: r }
            e.key && (a.key = e.key.src), e.idx > -1 && (a.refIndex = e.idx), t.matches.push(a)
          })
    }
    function Rq(e, t) {
      t.score = e.score
    }
    class Nq {
      constructor(e, t = {}, n) {
        ;(this.options = { ...lq, ...t }),
          this.options.useExtendedSearch,
          (this._keyStore = new rq(this.options.keys)),
          this.setCollection(e, n)
      }
      setCollection(e, t) {
        if (((this._docs = e), t && !(t instanceof dq))) throw new Error("Incorrect 'index' type")
        this._myIndex =
          t ||
          uq(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight,
          })
      }
      add(e) {
        Gz(e) && (this._docs.push(e), this._myIndex.add(e))
      }
      remove(e = () => !1) {
        const t = []
        for (let n = 0, r = this._docs.length; n < r; n += 1) {
          const a = this._docs[n]
          e(a, n) && (this.removeAt(n), (n -= 1), (r -= 1), t.push(a))
        }
        return t
      }
      removeAt(e) {
        this._docs.splice(e, 1), this._myIndex.removeAt(e)
      }
      getIndex() {
        return this._myIndex
      }
      search(e, { limit: t = -1 } = {}) {
        const { includeMatches: n, includeScore: r, shouldSort: a, sortFn: o, ignoreFieldNorm: i } = this.options
        let s = Wz(e)
          ? Wz(this._docs[0])
            ? this._searchStringList(e)
            : this._searchObjectList(e)
          : this._searchLogical(e)
        return (
          (function (e, { ignoreFieldNorm: t = lq.ignoreFieldNorm }) {
            e.forEach((e) => {
              let n = 1
              e.matches.forEach(({ key: e, norm: r, score: a }) => {
                const o = e ? e.weight : null
                n *= Math.pow(0 === a && o ? Number.EPSILON : a, (o || 1) * (t ? 1 : r))
              }),
                (e.score = n)
            })
          })(s, { ignoreFieldNorm: i }),
          a && s.sort(o),
          Xz(t) && t > -1 && (s = s.slice(0, t)),
          (function (e, t, { includeMatches: n = lq.includeMatches, includeScore: r = lq.includeScore } = {}) {
            const a = []
            return (
              n && a.push(Dq),
              r && a.push(Rq),
              e.map((e) => {
                const { idx: n } = e,
                  r = { item: t[n], refIndex: n }
                return (
                  a.length &&
                    a.forEach((t) => {
                      t(e, r)
                    }),
                  r
                )
              })
            )
          })(s, this._docs, { includeMatches: n, includeScore: r })
        )
      }
      _searchStringList(e) {
        const t = Sq(e, this.options),
          { records: n } = this._myIndex,
          r = []
        return (
          n.forEach(({ v: e, i: n, n: a }) => {
            if (!Gz(e)) return
            const { isMatch: o, score: i, indices: s } = t.searchIn(e)
            o && r.push({ item: e, idx: n, matches: [{ score: i, value: e, norm: a, indices: s }] })
          }),
          r
        )
      }
      _searchLogical(e) {
        const t = Pq(e, this.options),
          n = (e, t, r) => {
            if (!e.children) {
              const { keyId: n, searcher: a } = e,
                o = this._findMatches({
                  key: this._keyStore.get(n),
                  value: this._myIndex.getValueForItemAtKeyId(t, n),
                  searcher: a,
                })
              return o && o.length ? [{ idx: r, item: t, matches: o }] : []
            }
            const a = []
            for (let o = 0, i = e.children.length; o < i; o += 1) {
              const i = e.children[o],
                s = n(i, t, r)
              if (s.length) a.push(...s)
              else if (e.operator === Eq) return []
            }
            return a
          },
          r = this._myIndex.records,
          a = {},
          o = []
        return (
          r.forEach(({ $: e, i: r }) => {
            if (Gz(e)) {
              let i = n(t, e, r)
              i.length &&
                (a[r] || ((a[r] = { idx: r, item: e, matches: [] }), o.push(a[r])),
                i.forEach(({ matches: e }) => {
                  a[r].matches.push(...e)
                }))
            }
          }),
          o
        )
      }
      _searchObjectList(e) {
        const t = Sq(e, this.options),
          { keys: n, records: r } = this._myIndex,
          a = []
        return (
          r.forEach(({ $: e, i: r }) => {
            if (!Gz(e)) return
            let o = []
            n.forEach((n, r) => {
              o.push(...this._findMatches({ key: n, value: e[r], searcher: t }))
            }),
              o.length && a.push({ idx: r, item: e, matches: o })
          }),
          a
        )
      }
      _findMatches({ key: e, value: t, searcher: n }) {
        if (!Gz(t)) return []
        let r = []
        if (Vz(t))
          t.forEach(({ v: t, i: a, n: o }) => {
            if (!Gz(t)) return
            const { isMatch: i, score: s, indices: l } = n.searchIn(t)
            i && r.push({ score: s, key: e, value: t, idx: a, norm: o, indices: l })
          })
        else {
          const { v: a, n: o } = t,
            { isMatch: i, score: s, indices: l } = n.searchIn(a)
          i && r.push({ score: s, key: e, value: a, norm: o, indices: l })
        }
        return r
      }
    }
    ;(Nq.version = "7.0.0"),
      (Nq.createIndex = uq),
      (Nq.parseIndex = function (e, { getFn: t = lq.getFn, fieldNormWeight: n = lq.fieldNormWeight } = {}) {
        const { keys: r, records: a } = e,
          o = new dq({ getFn: t, fieldNormWeight: n })
        return o.setKeys(r), o.setIndexRecords(a), o
      }),
      (Nq.config = lq),
      (Nq.parseQuery = Pq),
      (function (...e) {
        _q.push(...e)
      })(
        class {
          constructor(
            e,
            {
              isCaseSensitive: t = lq.isCaseSensitive,
              includeMatches: n = lq.includeMatches,
              minMatchCharLength: r = lq.minMatchCharLength,
              ignoreLocation: a = lq.ignoreLocation,
              findAllMatches: o = lq.findAllMatches,
              location: i = lq.location,
              threshold: s = lq.threshold,
              distance: l = lq.distance,
            } = {},
          ) {
            ;(this.query = null),
              (this.options = {
                isCaseSensitive: t,
                includeMatches: n,
                minMatchCharLength: r,
                findAllMatches: o,
                ignoreLocation: a,
                location: i,
                threshold: s,
                distance: l,
              }),
              (this.pattern = t ? e : e.toLowerCase()),
              (this.query = (function (e, t = {}) {
                return e.split("|").map((e) => {
                  let n = e
                      .trim()
                      .split(xq)
                      .filter((e) => e && !!e.trim()),
                    r = []
                  for (let e = 0, a = n.length; e < a; e += 1) {
                    const a = n[e]
                    let o = !1,
                      i = -1
                    for (; !o && ++i < wq; ) {
                      const e = Oq[i]
                      let n = e.isMultiMatch(a)
                      n && (r.push(new e(n, t)), (o = !0))
                    }
                    if (!o)
                      for (i = -1; ++i < wq; ) {
                        const e = Oq[i]
                        let n = e.isSingleMatch(a)
                        if (n) {
                          r.push(new e(n, t))
                          break
                        }
                      }
                  }
                  return r
                })
              })(this.pattern, this.options))
          }
          static condition(e, t) {
            return t.useExtendedSearch
          }
          searchIn(e) {
            const t = this.query
            if (!t) return { isMatch: !1, score: 1 }
            const { includeMatches: n, isCaseSensitive: r } = this.options
            e = r ? e : e.toLowerCase()
            let a = 0,
              o = [],
              i = 0
            for (let r = 0, s = t.length; r < s; r += 1) {
              const s = t[r]
              ;(o.length = 0), (a = 0)
              for (let t = 0, r = s.length; t < r; t += 1) {
                const r = s[t],
                  { isMatch: l, indices: c, score: d } = r.search(e)
                if (!l) {
                  ;(i = 0), (a = 0), (o.length = 0)
                  break
                }
                if (((a += 1), (i += d), n)) {
                  const e = r.constructor.type
                  kq.has(e) ? (o = [...o, ...c]) : o.push(c)
                }
              }
              if (a) {
                let e = { isMatch: !0, score: i / a }
                return n && (e.indices = o), e
              }
            }
            return { isMatch: !1, score: 1 }
          }
        },
      )
    const $q = ((e) => (br("data-v-241cc7e9"), (e = e()), vr(), e))(() =>
        Ro("div", { class: "ref-search-meta" }, [Ro("span", null, " Navigate"), Ro("span", null, " Select")], -1),
      ),
      Iq = QQ(
        Hr({
          __name: "SearchModal",
          props: { parsedSpec: {}, modalState: {} },
          setup(e) {
            const t = e,
              n = zn(t, "parsedSpec"),
              r = { heading: "DocsPage", model: "Brackets", req: "Terminal", tag: "CodeFolder", webhook: "Terminal" },
              a = Qm(),
              o = Dn([]),
              i = Dn([]),
              s = Dn(0),
              l = Dn(""),
              c = Dn(null),
              d = new Nq(o.value, { keys: ["title", "description", "body"] }),
              u = () => {
                ;(s.value = 0), (i.value = d.search(l.value))
              },
              p = ii(() => O.value[s.value]),
              { getHeadingId: h, getWebhookId: f, getModelId: m, getOperationId: g, getTagId: b } = fp()
            Ya(
              () => t.modalState.open,
              (e) => {
                e && ((l.value = ""), (s.value = 0), (i.value = []))
              },
            )
            const { setCollapsedSidebarItem: v, hideModels: y } = sg()
            Ya(
              n.value,
              async () => {
                var e, n, r, a, i
                if (
                  ((o.value = []),
                  !(null == (n = null == (e = t.parsedSpec) ? void 0 : e.tags) ? void 0 : n.length) &&
                    !(null == (r = t.parsedSpec) ? void 0 : r.webhooks))
                )
                  return void d.setCollection([])
                const s = [],
                  l = Bf((null == (a = t.parsedSpec.info) ? void 0 : a.description) ?? "")
                l.length &&
                  (l.forEach((e) => {
                    s.push({
                      type: "heading",
                      title: `Info > ${e.value}`,
                      description: "",
                      href: `#${h(e)}`,
                      tag: e.slug,
                      body: "",
                    })
                  }),
                  (o.value = o.value.concat(s))),
                  null == (i = t.parsedSpec.tags) ||
                    i.forEach((e) => {
                      const t = {
                        title: e["x-displayName"] ?? e.name,
                        href: `#${b(e)}`,
                        description: e.description,
                        type: "tag",
                        tag: e.name,
                        body: "",
                      }
                      o.value.push(t),
                        e.operations &&
                          e.operations.forEach((t) => {
                            const { parameterMap: n } = mp({ operation: t }),
                              r =
                                (function (e) {
                                  var t, n, r
                                  try {
                                    const a =
                                      null ==
                                      (r =
                                        null ==
                                        (n = null == (t = null == e ? void 0 : e.information) ? void 0 : t.requestBody)
                                          ? void 0
                                          : n.content)
                                        ? void 0
                                        : r["application/json"]
                                    if (!a) throw new Error("Body not found")
                                    return (function (e) {
                                      var t
                                      const n = ["Body"],
                                        r = null == (t = null == e ? void 0 : e.schema) ? void 0 : t.properties
                                      return (
                                        r &&
                                          Object.keys(r).forEach((t) => {
                                            if (!e.schema) return
                                            n.push(
                                              (function (e, t) {
                                                let n = e
                                                return (
                                                  (n +=
                                                    t.required && t.required.includes(e) ? " REQUIRED " : " optional "),
                                                  t.properties[e] &&
                                                    ((n += t.properties[e].type),
                                                    t.properties[e].description &&
                                                      (n += " " + t.properties[e].description)),
                                                  n
                                                )
                                              })(t, e.schema),
                                            )
                                            const a = r[t]
                                            "object" === a.type &&
                                              a.properties &&
                                              a.properties &&
                                              Object.keys(a.properties).forEach((e) => {
                                                var t, r
                                                n.push(
                                                  `${e} ${null == (r = null == (t = a.properties) ? void 0 : t[e]) ? void 0 : r.type}`,
                                                )
                                              })
                                          }),
                                        n
                                      )
                                    })(a)
                                  } catch (e) {
                                    return !1
                                  }
                                })(t) || n.value
                            let a = null
                            "boolean" != typeof r && (a = r)
                            const i = {
                              type: "req",
                              title: t.name ?? t.path,
                              href: `#${g(t, e)}`,
                              operationId: t.operationId,
                              description: t.description ?? "",
                              httpVerb: t.httpVerb,
                              path: t.path,
                              tag: e.name,
                              operation: t,
                            }
                            a && (i.body = a), o.value.push(i)
                          })
                    })
                const c = t.parsedSpec.webhooks,
                  u = []
                c &&
                  Object.keys(c).forEach((e) => {
                    Object.keys(c[e]).forEach((t) => {
                      var n
                      u.push({
                        type: "webhook",
                        title: `Webhook: ${null == (n = c[e][t]) ? void 0 : n.name}`,
                        href: `#${f(e, t)}`,
                        description: e,
                        httpVerb: t,
                        tag: e,
                        body: "",
                      })
                    }),
                      (o.value = o.value.concat(u))
                  })
                const p = y.value ? {} : Uf(t.parsedSpec),
                  v = []
                p &&
                  (Object.keys(p).forEach((e) => {
                    v.push({
                      type: "model",
                      title: "Model",
                      href: `#${m(e)}`,
                      description: p[e].title ?? e,
                      tag: e,
                      body: "",
                    })
                  }),
                  (o.value = o.value.concat(v))),
                  d.setCollection(o.value)
              },
              { immediate: !0 },
            ),
              Am(a.enter, () => {
                t.modalState.open &&
                  window &&
                  (x(p.value), (window.location.hash = p.value.item.href), t.modalState.hide())
              }),
              Am(a.ArrowDown, () => {
                var e
                t.modalState.open &&
                  window &&
                  (s.value < O.value.length - 1 ? s.value++ : (s.value = 0),
                  null == (e = document.getElementById(p.value.item.href)) ||
                    e.scrollIntoView({ behavior: "smooth", block: "center" }))
              }),
              Am(a.ArrowUp, () => {
                var e
                t.modalState.open &&
                  window &&
                  (s.value > 0 ? s.value-- : (s.value = O.value.length - 1),
                  null == (e = document.getElementById(p.value.item.href)) ||
                    e.scrollIntoView({ behavior: "smooth", block: "center" }))
              })
            const O = ii(() => (0 === l.value.length ? o.value.map((e) => ({ item: e })) : i.value)),
              w = /#(tag\/[^/]*)/,
              x = (e) => {
                let n = "models"
                const r = e.item.href.match(w)
                ;(null == r ? void 0 : r.length) && r.length > 1 && (n = r[1]), v(n, !0), t.modalState.hide()
              }
            function k(e) {
              const t = new URL(window.location.href)
              return (t.hash = e), t.toString()
            }
            return (e, t) => (
              xo(),
              To(
                In(sw),
                { state: e.modalState, variant: "search" },
                {
                  default: yr(() => [
                    Ro(
                      "div",
                      { ref_key: "searchModalRef", ref: c, class: "ref-search-container" },
                      [
                        No(
                          In(wL),
                          {
                            modelValue: l.value,
                            "onUpdate:modelValue": t[0] || (t[0] = (e) => (l.value = e)),
                            onInput: u,
                          },
                          null,
                          8,
                          ["modelValue"],
                        ),
                      ],
                      512,
                    ),
                    No(
                      In(RL),
                      { class: "ref-search-results custom-scroll", noResults: !O.value.length },
                      {
                        query: yr(() => [Mo(at(l.value), 1)]),
                        default: yr(() => [
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(
                              O.value,
                              (e, t) => (
                                xo(),
                                To(
                                  In(PL),
                                  {
                                    id: e.item.href,
                                    key: e.refIndex,
                                    active: s.value === t,
                                    href: k(e.item.href),
                                    icon: r[e.item.type],
                                    onClick: (t) => x(e),
                                    onFocus: (e) => (s.value = t),
                                  },
                                  Zr({ default: yr(() => [Mo(at(e.item.title) + " ", 1)]), _: 2 }, [
                                    (e.item.httpVerb || e.item.path) && e.item.path !== e.item.title
                                      ? { name: "description", fn: yr(() => [Mo(at(e.item.path), 1)]), key: "0" }
                                      : e.item.description
                                        ? {
                                            name: "description",
                                            fn: yr(() => [Mo(at(e.item.description), 1)]),
                                            key: "1",
                                          }
                                        : void 0,
                                    "req" === e.item.type
                                      ? {
                                          name: "addon",
                                          fn: yr(() => [
                                            No(mz, { method: e.item.httpVerb ?? "get" }, null, 8, ["method"]),
                                          ]),
                                          key: "2",
                                        }
                                      : void 0,
                                  ]),
                                  1032,
                                  ["id", "active", "href", "icon", "onClick", "onFocus"],
                                )
                              ),
                            ),
                            128,
                          )),
                        ]),
                        _: 1,
                      },
                      8,
                      ["noResults"],
                    ),
                    $q,
                  ]),
                  _: 1,
                },
                8,
                ["state"],
              )
            )
          },
        }),
        [["__scopeId", "data-v-241cc7e9"]],
      ),
      Mq = { class: "sidebar-search-input" },
      Lq = ((e) => (br("data-v-45e2b1ac"), (e = e()), vr(), e))(() =>
        Ro("span", { class: "sidebar-search-placeholder" }, "Search", -1),
      ),
      Qq = { class: "sidebar-search-shortcut" },
      Bq = { class: "sidebar-search-key" },
      jq = Hr({
        __name: "SearchButton",
        props: { spec: {}, searchHotKey: { default: "k" } },
        setup(e) {
          const t = e,
            n = aw(),
            r = Dn(null),
            a = Qm({
              passive: !1,
              onEventFired(e) {
                !Hz() && e.ctrlKey && e.key === t.searchHotKey && (e.preventDefault(), e.stopPropagation())
              },
            })
          return (
            Nr(() => {
              IQ.on((e) => {
                r.value = e
              })
            }),
            Am(a[`${Hz() ? "meta" : "control"}_${t.searchHotKey}`], () => {
              var e
              ;(null == (e = r.value) ? void 0 : e.open) || (n.open ? n.hide() : n.show())
            }),
            (e, t) => (
              xo(),
              Eo(
                go,
                null,
                [
                  Ro(
                    "button",
                    {
                      class: Ge(["sidebar-search", e.$attrs.class]),
                      type: "button",
                      onClick: t[0] || (t[0] = (...e) => In(n).show && In(n).show(...e)),
                    },
                    [
                      No(In(BI), { class: "search-icon", icon: "Search", size: "sm", thickness: "2.5" }),
                      Ro("div", Mq, [
                        Lq,
                        Ro("span", Qq, [Ro("span", Bq, at(In(Hz)() ? "" : "") + at(e.searchHotKey), 1)]),
                      ]),
                    ],
                    2,
                  ),
                  No(Iq, { modalState: In(n), parsedSpec: e.spec }, null, 8, ["modalState", "parsedSpec"]),
                ],
                64,
              )
            )
          )
        },
      }),
      Uq = QQ(jq, [["__scopeId", "data-v-45e2b1ac"]]),
      Fq = Hr({
        __name: "ClassicLayout",
        props: { configuration: {}, parsedSpec: {}, rawSpec: {}, isDark: { type: Boolean } },
        emits: ["toggleDarkMode", "updateContent"],
        setup(e) {
          const t = e,
            n = na(),
            r = ii(() => ({ ...t.configuration, showSidebar: !1 }))
          return (e, t) => (
            xo(),
            To(
              Mz,
              {
                configuration: r.value,
                parsedSpec: e.parsedSpec,
                rawSpec: e.rawSpec,
                onUpdateContent: t[1] || (t[1] = (t) => e.$emit("updateContent", t)),
              },
              Zr(
                {
                  "content-start": yr(({ spec: n }) => [
                    No(
                      Bz,
                      null,
                      {
                        "dark-mode-toggle": yr(() => [
                          No(
                            In(Zz),
                            {
                              isDarkMode: e.isDark,
                              onToggleDarkMode: t[0] || (t[0] = (t) => e.$emit("toggleDarkMode")),
                            },
                            null,
                            8,
                            ["isDarkMode"],
                          ),
                        ]),
                        default: yr(() => [
                          No(Uq, { class: "t-doc__sidebar", searchHotKey: r.value.searchHotKey, spec: n }, null, 8, [
                            "searchHotKey",
                            "spec",
                          ]),
                        ]),
                        _: 2,
                      },
                      1024,
                    ),
                  ]),
                  _: 2,
                },
                [qr(n, (t, n) => ({ name: n, fn: yr((t) => [Xr(e.$slots, n, Ke($o(t || {})))]) }))],
              ),
              1032,
              ["configuration", "parsedSpec", "rawSpec"],
            )
          )
        },
      }),
      zq = { class: "references-mobile-header t-doc__header" },
      qq = { class: "references-mobile-breadcrumbs" },
      Zq = { class: "references-mobile-header-actions" },
      Hq = QQ(
        Hr({
          __name: "MobileHeader",
          props: { open: { type: Boolean } },
          emits: ["update:open"],
          setup(e) {
            const { breadcrumb: t } = sg()
            return (e, n) => (
              xo(),
              Eo("div", zq, [
                No(
                  In(mL),
                  {
                    icon: e.open ? "Close" : "Menu",
                    label: e.open ? "Close Menu" : "Open Menu",
                    size: "md",
                    onClick: n[0] || (n[0] = (t) => e.$emit("update:open", !e.open)),
                  },
                  null,
                  8,
                  ["icon", "label"],
                ),
                Ro("span", qq, at(In(t)), 1),
                Ro("div", Zq, [Xr(e.$slots, "actions", {}, void 0, !0)]),
              ])
            )
          },
        }),
        [["__scopeId", "data-v-b5fb4b8b"]],
      ),
      Vq = { class: "scalar-api-references-standalone-search" },
      Wq = Hr({
        __name: "ModernLayout",
        props: { configuration: {}, parsedSpec: {}, rawSpec: {}, isDark: { type: Boolean } },
        emits: ["toggleDarkMode", "updateContent"],
        setup(e) {
          const t = e,
            n = na(),
            r = $m("(max-width: 1000px)"),
            { isSidebarOpen: a } = sg()
          Ya(r, (e, t) => {
            e && !t && (a.value = !1)
          })
          const { hash: o } = fp()
          return (
            Ya(o, (e, t) => {
              e && e !== t && (a.value = !1)
            }),
            (e, r) => (
              xo(),
              To(
                Mz,
                {
                  class: Ge({ "scalar-api-references-standalone-mobile": e.configuration.showSidebar }),
                  configuration: e.configuration,
                  parsedSpec: e.parsedSpec,
                  rawSpec: e.rawSpec,
                  onUpdateContent: r[2] || (r[2] = (t) => e.$emit("updateContent", t)),
                },
                Zr(
                  {
                    header: yr(() => [
                      t.configuration.showSidebar
                        ? (xo(),
                          To(
                            Hq,
                            {
                              key: 0,
                              open: In(a),
                              "onUpdate:open": r[0] || (r[0] = (e) => (Pn(a) ? (a.value = e) : null)),
                            },
                            null,
                            8,
                            ["open"],
                          ))
                        : Qo("", !0),
                    ]),
                    "sidebar-start": yr(({ spec: e }) => {
                      var n
                      return [
                        Ro("div", Vq, [
                          No(
                            Uq,
                            { searchHotKey: null == (n = t.configuration) ? void 0 : n.searchHotKey, spec: e },
                            null,
                            8,
                            ["searchHotKey", "spec"],
                          ),
                        ]),
                      ]
                    }),
                    "sidebar-end": yr(() => [
                      No(
                        In(qz),
                        { isDarkMode: e.isDark, onToggleDarkMode: r[1] || (r[1] = (t) => e.$emit("toggleDarkMode")) },
                        null,
                        8,
                        ["isDarkMode"],
                      ),
                    ]),
                    _: 2,
                  },
                  [qr(n, (t, n) => ({ name: n, fn: yr((t) => [Xr(e.$slots, n, Ke($o(t || {})), void 0, !0)]) }))],
                ),
                1032,
                ["class", "configuration", "parsedSpec", "rawSpec"],
              )
            )
          )
        },
      }),
      Xq = QQ(Wq, [["__scopeId", "data-v-273f5da8"]]),
      Yq = Hr({
        __name: "Layouts",
        props: { configuration: {}, parsedSpec: {}, rawSpec: {}, isDark: { type: Boolean } },
        emits: ["toggleDarkMode", "updateContent"],
        setup(e) {
          const t = e,
            n = na(),
            r = { modern: Xq, classic: Fq }
          return (e, a) => (
            xo(),
            To(
              Tr(r[e.configuration.layout ?? "modern"] ?? Xq),
              Fo(t, {
                onToggleDarkMode: a[0] || (a[0] = (t) => e.$emit("toggleDarkMode")),
                onUpdateContent: a[1] || (a[1] = (t) => e.$emit("updateContent", t)),
              }),
              Zr({ _: 2 }, [qr(n, (t, n) => ({ name: n, fn: yr((t) => [Xr(e.$slots, n, Ke($o(t || {})))]) }))]),
              1040,
            )
          )
        },
      }),
      Gq = Hr({
        __name: "ApiReference",
        props: { configuration: {} },
        emits: ["updateContent"],
        setup(e) {
          var t, n
          const r = e,
            { toggleDarkMode: a, isDark: o } = (function (e) {
              var t
              return (
                (Yu.value =
                  ("undefined" == typeof window
                    ? null
                    : JSON.parse((null == (t = window.localStorage) ? void 0 : t.getItem("isDark")) || "null")) ??
                  e ??
                  (() => {
                    var e, t
                    const n =
                      "undefined" != typeof window
                        ? null == (e = window.localStorage)
                          ? void 0
                          : e.getItem("isDark")
                        : null
                    return "string" == typeof n
                      ? !!JSON.parse(n)
                      : !(
                          "undefined" == typeof window ||
                          !(null == (t = null == window ? void 0 : window.matchMedia("(prefers-color-scheme: dark)"))
                            ? void 0
                            : t.matches)
                        )
                  })()),
                Ya(
                  Yu,
                  (e) => {
                    "undefined" != typeof document &&
                      (document.body.classList.toggle("dark-mode", e), document.body.classList.toggle("light-mode", !e))
                  },
                  { immediate: !0 },
                ),
                {
                  isDark: Yu,
                  toggleDarkMode: () => {
                    var e
                    ;(Yu.value = !Yu.value),
                      "undefined" != typeof window &&
                        (null == (e = null == window ? void 0 : window.localStorage) ||
                          e.setItem("isDark", JSON.stringify(Yu.value)))
                  },
                  setDarkMode: function (e) {
                    var t
                    ;(Yu.value = e),
                      "undefined" != typeof window &&
                        (null == (t = null == window ? void 0 : window.localStorage) ||
                          t.setItem("isDark", JSON.stringify(Yu.value)))
                  },
                }
              )
            })(null == (t = r.configuration) ? void 0 : t.darkMode)
          Ya(
            () => {
              var e
              return null == (e = r.configuration) ? void 0 : e.darkMode
            },
            (e) => {
              e !== o.value && a()
            },
          )
          const i = ii(() => {
            var e, t
            if (null == (e = r.configuration) ? void 0 : e.customCss)
              return (function (e) {
                return su.some((t) => e.includes(t))
                  ? (console.warn(
                      "DEPRECATION WARNING: It looks like you're using legacy CSS variables in your custom CSS string. Please migrate them to use the updated prefixes. See https://github.com/scalar/scalar#theme-prefix-changes",
                    ),
                    iu.reduce((e, [t, n]) => e.replaceAll(t, n), e))
                  : e
              })(null == (t = r.configuration) ? void 0 : t.customCss)
          })
          Ya(i, () => console.log(i.value))
          const s = ii(() => {
            var e
            return {
              spec: { content: void 0, url: void 0, ...(null == (e = r.configuration) ? void 0 : e.spec) },
              proxy: void 0,
              theme: "default",
              showSidebar: !0,
              isEditable: !1,
              ...r.configuration,
              customCss: i.value,
            }
          })
          function l(e, t) {
            Ya(
              () => {
                var t
                return null == (t = s.value) ? void 0 : t[e]
              },
              (e) => {
                void 0 !== e && t(e)
              },
              { immediate: !0 },
            )
          }
          ;(null == (n = s.value) ? void 0 : n.metaData) &&
            (function (e, t) {
              const { title: n, titleTemplate: r, ...a } = e
              ss(
                { title: n, titleTemplate: r, _flatMeta: a },
                {
                  transform(e) {
                    const t = $({ ...e._flatMeta })
                    return delete e._flatMeta, { ...e, meta: t }
                  },
                },
              )
            })(s.value.metaData)
          const { setAuthentication: c } = Zd()
          l("authentication", c)
          const { setExcludedClients: d, setDefaultHttpClient: u } = Rb()
          l("defaultHttpClient", u), l("hiddenClients", d)
          const { parsedSpec: p, rawSpec: h } = jm({
            proxy: zn(() => s.value.proxy || ""),
            specConfig: zn(() => s.value.spec || {}),
          })
          return (e, t) => {
            var n
            return (
              xo(),
              Eo(
                go,
                null,
                [
                  (null == (n = s.value) ? void 0 : n.customCss)
                    ? (xo(), To(Tr("style"), { key: 0 }, { default: yr(() => [Mo(at(s.value.customCss), 1)]), _: 1 }))
                    : Qo("", !0),
                  No(
                    In(Yq),
                    {
                      configuration: s.value,
                      isDark: In(o),
                      parsedSpec: In(p),
                      rawSpec: In(h),
                      onToggleDarkMode: t[0] || (t[0] = () => In(a)()),
                      onUpdateContent: t[1] || (t[1] = (t) => e.$emit("updateContent", t)),
                    },
                    {
                      footer: yr(() => [Xr(e.$slots, "footer")]),
                      "content-end": yr(() => [Xr(e.$slots, "footer")]),
                      _: 3,
                    },
                    8,
                    ["configuration", "isDark", "parsedSpec", "rawSpec"],
                  ),
                ],
                64,
              )
            )
          }
        },
      }),
      Kq = document.getElementById("api-reference"),
      Jq = document.querySelector("[data-spec]"),
      eZ = document.querySelector("[data-spec-url]"),
      tZ = document.querySelector("#api-reference[data-configuration]"),
      nZ = () => {
        if (tZ) {
          const e = tZ.getAttribute("data-configuration")
          if (e) return JSON.parse(e.split("&quot;").join('"'))
        }
        return {}
      },
      rZ = () => {
        var e, t, n
        if (null == (e = nZ().spec) ? void 0 : e.url) return null == (t = nZ().spec) ? void 0 : t.url
        if (Kq) {
          const e = null == (n = Kq.getAttribute("data-url")) ? void 0 : n.trim()
          if (e) return e
        }
        if (eZ) {
          console.warn(
            '[@scalar/api-reference] The [data-spec-url] HTML API is deprecated. Use the new <script id="api-reference" data-url="/scalar.json" /> API instead.',
          )
          const e = eZ.getAttribute("data-spec-url")
          if (e) return e
        }
      },
      aZ = () => {
        var e, t
        if (Kq) {
          const t = null == (e = Kq.innerHTML) ? void 0 : e.trim()
          if (t) return t
        }
        if (Jq) {
          console.warn(
            '[@scalar/api-reference] The [data-spec] HTML API is deprecated. Use the new <script id="api-reference" type="application/json">{"openapi":"3.1.0","info":{"title":"Example"},"paths":{}}</script> API instead.',
          )
          const e = null == (t = Jq.getAttribute("data-spec")) ? void 0 : t.trim()
          if (e) return e
        }
      },
      oZ = () => {
        if (Kq) {
          const e = Kq.getAttribute("data-proxy-url")
          if (e) return e.trim()
        }
      },
      iZ = mn({})
    if (eZ || Jq || Kq) {
      const n = aZ() ? { content: aZ() } : { url: rZ() }
      Object.assign(iZ, { configuration: { ...nZ(), spec: { ...n }, proxy: oZ() } }),
        nZ().darkMode
          ? null == (e = document.body) || e.classList.add("dark-mode")
          : null == (t = document.body) || t.classList.add("light-mode")
      const r = (() => {
          var e
          let t = null
          return (
            Kq
              ? ((t = document.createElement("div")),
                null == (e = null == Kq ? void 0 : Kq.parentNode) || e.insertBefore(t, Kq))
              : (t = Jq || eZ || document.body),
            t
          )
        })(),
        a = () => {
          const e = Ji(() => si(Gq, iZ)),
            t = as()
          return e.use(t), r ? e.mount(r) : console.error("Could not find a mount point for API References"), e
        }
      let o = a()
      document.addEventListener(
        "scalar:reload-references",
        () => {
          r && !document.body.contains(r) && document.body.appendChild(r), o.unmount(), (o = a())
        },
        !1,
      ),
        document.addEventListener(
          "scalar:update-references-config",
          (e) => {
            "detail" in e && Object.assign(iZ, e.detail)
          },
          !1,
        )
    } else
      console.error(
        'Couldnt find a [data-spec], [data-spec-url] or <script id="api-reference" /> element. Try adding it like this: %c<div data-spec-url="https://cdn.jsdelivr.net/npm/@scalar/galaxy/dist/latest.yaml" />',
        "font-family: monospace;",
      )
    const sZ = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      lZ = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M2 12h20M12 2v20",
          },
          null,
          -1,
        ),
      ]
    function cZ(e, t) {
      return xo(), Eo("svg", sZ, [...lZ])
    }
    const dZ = { render: cZ },
      uZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: dZ, render: cZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      pZ = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      hZ = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M22 12H2m9.3-9.3L2 12l9.3 9.3",
          },
          null,
          -1,
        ),
      ]
    function fZ(e, t) {
      return xo(), Eo("svg", pZ, [...hZ])
    }
    const mZ = { render: fZ },
      gZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: mZ, render: fZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      bZ = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      vZ = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M2 12h20m-9.3 9.3L22 12l-9.3-9.3",
          },
          null,
          -1,
        ),
      ]
    function yZ(e, t) {
      return xo(), Eo("svg", bZ, [...vZ])
    }
    const OZ = { render: yZ },
      wZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: OZ, render: yZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      xZ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      kZ = [
        Ro(
          "path",
          {
            d: "M24 22.21 19.82 2a2.51 2.51 0 0 0-2.45-2H1.5A1.5 1.5 0 0 0 0 1.79l2.46 11.84a.24.24 0 0 1 0 .12L.06 22a1 1 0 0 0 1.94.56l1.07-3.69a.24.24 0 0 1 .25-.18.23.23 0 0 1 .23.2L4.18 22a2.51 2.51 0 0 0 2.45 2H22.5a1.5 1.5 0 0 0 1.5-1.79M3.72 4a.39.39 0 0 1 .4-.49h12.27A.63.63 0 0 1 17 4l3.29 16a.39.39 0 0 1-.4.49H7.61A.63.63 0 0 1 7 20Z",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M9 17h8a.51.51 0 0 0 .46-.71L15 10.79a.5.5 0 0 0-.89 0l-1.61 2.8a.22.22 0 0 1-.15.12.24.24 0 0 1-.2 0l-.83-.56a.51.51 0 0 0-.7.14l-2 3A.5.5 0 0 0 9 17m1-6.5A1.5 1.5 0 1 0 8.5 9a1.5 1.5 0 0 0 1.5 1.5",
          },
          null,
          -1,
        ),
      ]
    function _Z(e, t) {
      return xo(), Eo("svg", xZ, [...kZ])
    }
    const SZ = { render: _Z },
      EZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: SZ, render: _Z }, Symbol.toStringTag, { value: "Module" }),
      ),
      TZ = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      AZ = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M8 3H7a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5c0 1.1.9 2 2 2h1m8 0h1a2 2 0 0 0 2-2v-5c0-1.1.9-2 2-2a2 2 0 0 1-2-2V5a2 2 0 0 0-2-2h-1",
          },
          null,
          -1,
        ),
      ]
    function CZ(e, t) {
      return xo(), Eo("svg", TZ, [...AZ])
    }
    const PZ = { render: CZ },
      DZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: PZ, render: CZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      RZ = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      NZ = [
        Ro("path", { d: "M16.4 6.8v5.6H7.6m0-5.6v10.4" }, null, -1),
        Ro("circle", { cx: "7.6", cy: "4.4", r: "2.4" }, null, -1),
        Ro("circle", { cx: "7.6", cy: "19.6", r: "2.4" }, null, -1),
        Ro("circle", { cx: "16.4", cy: "4.4", r: "2.4" }, null, -1),
      ]
    function $Z(e, t) {
      return xo(), Eo("svg", RZ, [...NZ])
    }
    const IZ = { render: $Z },
      MZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: IZ, render: $Z }, Symbol.toStringTag, { value: "Module" }),
      ),
      LZ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 14 14" },
      QZ = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M12.639.099a.993.993 0 0 1 1.31.933v10.063a.994.994 0 0 1-1.31.933l-.005-.001-11.585-4.04A1.49 1.49 0 0 1 .051 6.63v-1.1a1.49 1.49 0 0 1 .998-1.4zm-10.61 10.67v-1.13l6.199 2.163a3.186 3.186 0 0 1-6.199-1.034Z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function BZ(e, t) {
      return xo(), Eo("svg", LZ, [...QZ])
    }
    const jZ = { render: BZ },
      UZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: jZ, render: BZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      FZ = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      zZ = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M21.4 4.6 10.6 19.4l-8-6.4",
          },
          null,
          -1,
        ),
      ]
    function qZ(e, t) {
      return xo(), Eo("svg", FZ, [...zZ])
    }
    const ZZ = { render: qZ },
      HZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: ZZ, render: qZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      VZ = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      WZ = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "m4.5 8.25 7.5 7.5 7.5-7.5",
          },
          null,
          -1,
        ),
      ]
    function XZ(e, t) {
      return xo(), Eo("svg", VZ, [...WZ])
    }
    const YZ = { render: XZ },
      GZ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: YZ, render: XZ }, Symbol.toStringTag, { value: "Module" }),
      ),
      KZ = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      JZ = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M15.75 19.5 8.25 12l7.5-7.5",
          },
          null,
          -1,
        ),
      ]
    function eH(e, t) {
      return xo(), Eo("svg", KZ, [...JZ])
    }
    const tH = { render: eH },
      nH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: tH, render: eH }, Symbol.toStringTag, { value: "Module" }),
      ),
      rH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      aH = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "m8.25 19.5 7.5-7.5-7.5-7.5",
          },
          null,
          -1,
        ),
      ]
    function oH(e, t) {
      return xo(), Eo("svg", rH, [...aH])
    }
    const iH = { render: oH },
      sH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: iH, render: oH }, Symbol.toStringTag, { value: "Module" }),
      ),
      lH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      cH = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M19.5 15.75 12 8.25l-7.5 7.5",
          },
          null,
          -1,
        ),
      ]
    function dH(e, t) {
      return xo(), Eo("svg", lH, [...cH])
    }
    const uH = { render: dH },
      pH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: uH, render: dH }, Symbol.toStringTag, { value: "Module" }),
      ),
      hH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      fH = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2m-6 4h10a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2",
          },
          null,
          -1,
        ),
      ]
    function mH(e, t) {
      return xo(), Eo("svg", hH, [...fH])
    }
    const gH = { render: mH },
      bH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: gH, render: mH }, Symbol.toStringTag, { value: "Module" }),
      ),
      vH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      yH = [
        Ro(
          "path",
          { stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", d: "M18 6 6 18M6 6l12 12" },
          null,
          -1,
        ),
      ]
    function OH(e, t) {
      return xo(), Eo("svg", vH, [...yH])
    }
    const wH = { render: OH },
      xH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: wH, render: OH }, Symbol.toStringTag, { value: "Module" }),
      ),
      kH = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      _H = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M21.75 9V6a1.5 1.5 0 0 0-1.5-1.5h-12V3a1.5 1.5 0 0 0-1.5-1.5h-4.5A1.5 1.5 0 0 0 .75 3v17.8a1.7 1.7 0 0 0 3.336.438l2.352-11.154A1.5 1.5 0 0 1 7.879 9za1.5 1.5 0 0 1 1.45 1.886l-2.2 10.5a1.5 1.5 0 0 1-1.45 1.114H2.447",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "m12 13.5-2.25 2.25L12 18m4.5-4.5 2.25 2.25L16.5 18",
          },
          null,
          -1,
        ),
      ]
    function SH(e, t) {
      return xo(), Eo("svg", kH, [..._H])
    }
    const EH = { render: SH },
      TH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: EH, render: SH }, Symbol.toStringTag, { value: "Module" }),
      ),
      AH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      CH = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M20.86 16.6c0 .32-.16.64-.47.72l-6.3 2.83a.93.93 0 0 1-.8-.08c-.23-.16-.38-.4-.38-.63V4.56c0-.24.15-.55.39-.63.24-.16.47-.16.79-.08l6.3 2.83c.31.16.47.4.47.71v9.22zM10.7 19.52a.77.77 0 0 1-.7-.08.72.72 0 0 1-.32-.63V5.35c0-.24.15-.56.4-.63.23-.16.46-.16.78-.08M7.43 18.73a.77.77 0 0 1-.7-.08.72.72 0 0 1-.32-.63V6.05c0-.23.16-.55.4-.63.23-.15.47-.15.78-.07m-3.43 12.6a.77.77 0 0 1-.7-.08.72.72 0 0 1-.32-.63V6.84c0-.23.16-.55.4-.63.23-.16.47-.16.78-.08",
          },
          null,
          -1,
        ),
      ]
    function PH(e, t) {
      return xo(), Eo("svg", AH, [...CH])
    }
    const DH = { render: PH },
      RH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: DH, render: PH }, Symbol.toStringTag, { value: "Module" }),
      ),
      NH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      $H = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M15.739 8.061c-2.02.404-4.041-1.01-4.445-3.03-.202-1.01 0-2.223.606-3.031C6.445 2 2 6.445 2 11.9s4.445 9.9 9.9 9.9 9.9-4.445 9.9-9.9v-.808c-1.616 1.212-4.04.808-5.253-.808-.606-.606-.808-1.415-.808-2.223",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            fill: "currentColor",
            d: "M8.667 15.133a1.212 1.212 0 1 0 0-2.425 1.212 1.212 0 0 0 0 2.425m4.243 1.212a1.212 1.212 0 1 0 0-2.424 1.212 1.212 0 0 0 0 2.424M9.88 9.88a1.212 1.212 0 1 0 0-2.425 1.212 1.212 0 0 0 0 2.425",
          },
          null,
          -1,
        ),
      ]
    function IH(e, t) {
      return xo(), Eo("svg", NH, [...$H])
    }
    const MH = { render: IH },
      LH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: MH, render: IH }, Symbol.toStringTag, { value: "Module" }),
      ),
      QH = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 10 10" },
      BH = [
        Ro(
          "path",
          {
            d: "M9.557 7.243a.46.46 0 0 0-.457-.252C9.023 7 8.951 7 8.877 7A4 4 0 0 1 5.546.781a.5.5 0 0 0 .018-.525A.48.48 0 0 0 5.1 0a5 5 0 1 0 4.439 7.767.5.5 0 0 0 .018-.524",
          },
          null,
          -1,
        ),
      ]
    function jH(e, t) {
      return xo(), Eo("svg", QH, [...BH])
    }
    const UH = { render: jH },
      FH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: UH, render: jH }, Symbol.toStringTag, { value: "Module" }),
      ),
      zH = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 14 14" },
      qH = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M5.763 2.013a1.75 1.75 0 0 1 2.914.737H5.323a1.75 1.75 0 0 1 .44-.737m-1.974.737a3.25 3.25 0 0 1 6.422 0H13a.75.75 0 0 1 0 1.5h-1v8.25a1.5 1.5 0 0 1-1.5 1.5h-7A1.5 1.5 0 0 1 2 12.5V4.25H1a.75.75 0 1 1 0-1.5zM5 5.876c.345 0 .625.28.625.625v4.002a.625.625 0 0 1-1.25 0V6.501c0-.345.28-.625.625-.625m4.625.625a.625.625 0 0 0-1.25 0v4.002a.625.625 0 0 0 1.25 0z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function ZH(e, t) {
      return xo(), Eo("svg", zH, [...qH])
    }
    const HH = { render: ZH },
      VH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: HH, render: ZH }, Symbol.toStringTag, { value: "Module" }),
      ),
      WH = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      XH = [
        Ro(
          "path",
          {
            d: "M20.317 4.37a19.8 19.8 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.3 18.3 0 0 0-5.487 0 13 13 0 0 0-.617-1.25.08.08 0 0 0-.079-.037A19.7 19.7 0 0 0 3.677 4.37a.1.1 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.08.08 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.08.08 0 0 0 .084-.028 14 14 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13 13 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10 10 0 0 0 .372-.292.07.07 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.07.07 0 0 1 .078.01q.181.149.373.292a.077.077 0 0 1-.006.127 12.3 12.3 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.08.08 0 0 0 .084.028 19.8 19.8 0 0 0 6.002-3.03.08.08 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.06.06 0 0 0-.031-.03M8.02 15.33c-1.182 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418m7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418",
          },
          null,
          -1,
        ),
      ]
    function YH(e, t) {
      return xo(), Eo("svg", WH, [...XH])
    }
    const GH = { render: YH },
      KH = Object.freeze(
        Object.defineProperty({ __proto__: null, default: GH, render: YH }, Symbol.toStringTag, { value: "Module" }),
      ),
      JH = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      eV = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M5.4 22.2h13c1.1 0 2-.9 2-2V3.6c0-1.1-.9-2-2-2h-9l-6 6v12.6c0 1.1.9 2 2 2",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M3.6 7.6h4c1.1 0 2-.9 2-2v-4zm9.4 0h4m-10 5h10M7 17.4h10",
          },
          null,
          -1,
        ),
      ]
    function tV(e, t) {
      return xo(), Eo("svg", JH, [...eV])
    }
    const nV = { render: tV },
      rV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: nV, render: tV }, Symbol.toStringTag, { value: "Module" }),
      ),
      aV = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      oV = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M7.42 16.58H3.25a.83.83 0 0 1-.83-.83V3.25a.83.83 0 0 1 .83-.83h12.5a.83.83 0 0 1 .83.83v4.17",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M8.25 7.42h12.5s.83 0 .83.83v12.5s0 .83-.83.83H8.25s-.83 0-.83-.83V8.25s0-.83.83-.83",
          },
          null,
          -1,
        ),
      ]
    function iV(e, t) {
      return xo(), Eo("svg", aV, [...oV])
    }
    const sV = { render: iV },
      lV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: sV, render: iV }, Symbol.toStringTag, { value: "Module" }),
      ),
      cV = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      dV = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M12 6.58H4.08a1.67 1.67 0 0 0-1.66 1.67v11.67a1.67 1.67 0 0 0 1.66 1.66h11.67a1.67 1.67 0 0 0 1.67-1.66V12m-4.53 1.82-3.16.45.45-3.16 8.13-8.13a1.92 1.92 0 1 1 2.71 2.7z",
          },
          null,
          -1,
        ),
      ]
    function uV(e, t) {
      return xo(), Eo("svg", cV, [...dV])
    }
    const pV = { render: uV },
      hV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: pV, render: uV }, Symbol.toStringTag, { value: "Module" }),
      ),
      fV = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      mV = [
        Ro(
          "path",
          {
            d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2",
          },
          null,
          -1,
        ),
      ]
    function gV(e, t) {
      return xo(), Eo("svg", fV, [...mV])
    }
    const bV = { render: gV },
      vV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: bV, render: gV }, Symbol.toStringTag, { value: "Module" }),
      ),
      yV = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      OV = [
        Ro(
          "path",
          {
            d: "M12 0a12.24 12.24 0 0 0-8.53 3.65A11.85 11.85 0 0 0 0 12.21 11.78 11.78 0 0 0 11.8 24h.2a12.11 12.11 0 0 0 12-12.21A11.77 11.77 0 0 0 12 0m-1.5 16.54A1.48 1.48 0 0 1 12 15a1.53 1.53 0 0 1 1.52 1.47A1.47 1.47 0 0 1 12.05 18a1.53 1.53 0 0 1-1.55-1.46m.5-4v-6a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0",
          },
          null,
          -1,
        ),
      ]
    function wV(e, t) {
      return xo(), Eo("svg", yV, [...OV])
    }
    const xV = { render: wV },
      kV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: xV, render: wV }, Symbol.toStringTag, { value: "Module" }),
      ),
      _V = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      SV = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "m18.59 15.3 2.9-2.91a1.32 1.32 0 0 0 0-1.87l-1.85-1.85a3.3 3.3 0 1 1-4.31-4.31L13.48 2.5a1.32 1.32 0 0 0-1.87 0l-2.9 2.91a3.3 3.3 0 1 0-3.3 3.3l-2.9 2.9a1.32 1.32 0 0 0 0 1.87l1.85 1.85a3.3 3.3 0 1 1 4.31 4.31l1.85 1.85a1.32 1.32 0 0 0 1.87 0l2.9-2.9a3.3 3.3 0 1 0 3.3-3.3Z",
          },
          null,
          -1,
        ),
      ]
    function EV(e, t) {
      return xo(), Eo("svg", _V, [...SV])
    }
    const TV = { render: EV },
      AV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: TV, render: EV }, Symbol.toStringTag, { value: "Module" }),
      ),
      CV = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      PV = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M6.4 4H20v13.59M4 20 20 4",
          },
          null,
          -1,
        ),
      ]
    function DV(e, t) {
      return xo(), Eo("svg", CV, [...PV])
    }
    const RV = { render: DV },
      NV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: RV, render: DV }, Symbol.toStringTag, { value: "Module" }),
      ),
      $V = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      IV = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M.75 4.293h22.5M3.146 9.431h17.708M8.72 19.707h6.56m-9.737-5.138h12.914",
          },
          null,
          -1,
        ),
      ]
    function MV(e, t) {
      return xo(), Eo("svg", $V, [...IV])
    }
    const LV = { render: MV },
      QV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: LV, render: MV }, Symbol.toStringTag, { value: "Module" }),
      ),
      BV = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      jV = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2z",
          },
          null,
          -1,
        ),
      ]
    function UV(e, t) {
      return xo(), Eo("svg", BV, [...jV])
    }
    const FV = { render: UV },
      zV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: FV, render: UV }, Symbol.toStringTag, { value: "Module" }),
      ),
      qV = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 1024 1024" },
      ZV = [
        Ro(
          "path",
          {
            d: "M512 0a512 512 0 0 0-162 998c26 4 35-11 35-25l-1-95c-128 23-161-32-172-60-6-15-31-61-52-73-18-10-44-33-1-33 40-1 69 37 78 52 46 78 120 56 149 43 5-33 18-56 33-69-114-13-234-56-234-253 0-56 20-101 53-137-5-13-23-65 5-136 0 0 43-13 141 53a487 487 0 0 1 256 0c98-66 141-53 141-53 28 71 10 123 5 136 33 36 53 81 53 137 0 197-120 240-234 253 18 16 35 47 35 95l-1 140c0 14 9 30 35 25A512 512 0 0 0 512 0",
          },
          null,
          -1,
        ),
      ]
    function HV(e, t) {
      return xo(), Eo("svg", qV, [...ZV])
    }
    const VV = { render: HV },
      WV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: VV, render: HV }, Symbol.toStringTag, { value: "Module" }),
      ),
      XV = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      YV = [
        Ro(
          "path",
          {
            d: "M23.93 10.67a.76.76 0 0 0-.75-.67H12.75a.76.76 0 0 0-.75.75v3.5a.76.76 0 0 0 .75.75h5.58A7 7 0 1 1 12 5a7 7 0 0 1 4.23 1.42.74.74 0 0 0 1-.07l2.47-2.49a.75.75 0 0 0 .22-.57.77.77 0 0 0-.27-.54A12 12 0 1 0 24 12a12 12 0 0 0-.07-1.33",
          },
          null,
          -1,
        ),
      ]
    function GV(e, t) {
      return xo(), Eo("svg", XV, [...YV])
    }
    const KV = { render: GV },
      JV = Object.freeze(
        Object.defineProperty({ __proto__: null, default: KV, render: GV }, Symbol.toStringTag, { value: "Module" }),
      ),
      eW = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      tW = [
        Ro(
          "path",
          {
            d: "M2.78 21 21.53 3M9 19.05a9.9 9.9 0 0 0 3 .45c4.1.07 8.26-2.81 10.82-5.64a1.65 1.65 0 0 0 0-2.22 20 20 0 0 0-3.07-2.76m-2.66-1.61A11.3 11.3 0 0 0 12 6c-4-.07-8.2 2.75-10.82 5.64a1.65 1.65 0 0 0 0 2.22 20 20 0 0 0 4.93 4M9 15.07a3.85 3.85 0 0 1 5.5-5.28",
          },
          null,
          -1,
        ),
        Ro("path", { d: "M15.75 12.75A3.75 3.75 0 0 1 12 16.5" }, null, -1),
      ]
    function nW(e, t) {
      return xo(), Eo("svg", eW, [...tW])
    }
    const rW = { render: nW },
      aW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: rW, render: nW }, Symbol.toStringTag, { value: "Module" }),
      ),
      oW = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      iW = [
        Ro("path", { d: "M12.9 6.8v6.1h4.7" }, null, -1),
        Ro(
          "path",
          {
            d: "M6.1 17.2c1.6 2.2 4.2 3.6 7.1 3.6 4.8 0 8.8-3.9 8.8-8.8s-3.9-8.8-8.8-8.8-8.8 4-8.8 8.8v1.7M2 11.3l2.4 2.4 2.4-2.4",
          },
          null,
          -1,
        ),
      ]
    function sW(e, t) {
      return xo(), Eo("svg", oW, [...iW])
    }
    const lW = { render: sW },
      cW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: lW, render: sW }, Symbol.toStringTag, { value: "Module" }),
      ),
      dW = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      uW = [
        Ro(
          "path",
          {
            d: "M3.753 13.944v8.25h6v-6a1.5 1.5 0 0 1 1.5-1.5h1.5a1.5 1.5 0 0 1 1.5 1.5v6h6v-8.25m-19.5-1.5L10.942 2.255a1.5 1.5 0 0 1 2.122 0l10.189 10.189",
          },
          null,
          -1,
        ),
      ]
    function pW(e, t) {
      return xo(), Eo("svg", dW, [...uW])
    }
    const hW = { render: pW },
      fW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: hW, render: pW }, Symbol.toStringTag, { value: "Module" }),
      ),
      mW = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      gW = [
        Ro("path", { d: "M12 10.67v7.98M14.66 16 12 18.64 9.34 16" }, null, -1),
        Ro(
          "path",
          { d: "M3.35 7.34h17.3s1.33 0 1.33 1.33v11.98s0 1.33-1.33 1.33H3.35s-1.33 0-1.33-1.33V8.67s0-1.33 1.33-1.33" },
          null,
          -1,
        ),
        Ro(
          "path",
          { d: "m2.2 8 2.13-5.19a1.33 1.33 0 0 1 1.22-.79h12.9a1.33 1.33 0 0 1 1.22.8l2.08 5.1M12 7.34V2.02" },
          null,
          -1,
        ),
      ]
    function bW(e, t) {
      return xo(), Eo("svg", mW, [...gW])
    }
    const vW = { render: bW },
      yW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: vW, render: bW }, Symbol.toStringTag, { value: "Module" }),
      ),
      OW = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      wW = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M12 17v-6 0a.5.5 0 0 0-.5-.5l-.5.001h-1M12 17h-2m2 0h2",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M10.75 7.5a1 1 0 1 1 2 0 1 1 0 0 1-2 0",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function xW(e, t) {
      return xo(), Eo("svg", OW, [...wW])
    }
    const kW = { render: xW },
      _W = Object.freeze(
        Object.defineProperty({ __proto__: null, default: kW, render: xW }, Symbol.toStringTag, { value: "Module" }),
      ),
      SW = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      EW = [
        Ro(
          "path",
          {
            d: "M12.82 14.51 15.36 12l1.76.47a1.56 1.56 0 0 0 1.51-.47 1.58 1.58 0 0 0 .37-1.49l-.47-1.75.82-.76 1.76.47A1.56 1.56 0 0 0 22.62 8 1.58 1.58 0 0 0 23 6.52l-.47-1.75a2.35 2.35 0 0 0-3.33-3.33l-9.71 9.74a6.29 6.29 0 1 0 3.33 3.33",
          },
          null,
          -1,
        ),
        Ro("path", { d: "M4.26 17.84a1.9 1.9 0 1 0 3.8 0 1.9 1.9 0 1 0-3.8 0" }, null, -1),
      ]
    function TW(e, t) {
      return xo(), Eo("svg", SW, [...EW])
    }
    const AW = { render: TW },
      CW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: AW, render: TW }, Symbol.toStringTag, { value: "Module" }),
      ),
      PW = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 14 14" },
      DW = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M1.625.258A.75.75 0 0 0 1.44.75v9.62a1.71 1.71 0 0 0 .942 1.523l.002.001 3.845 1.923.337-.67-.335.67H6.23a1.71 1.71 0 0 0 2.48-1.524v-.214h2.136a1.71 1.71 0 0 0 1.712-1.711V1.712A1.71 1.71 0 0 0 10.847 0H2.191a.75.75 0 0 0-.566.258M8.712 10.58h2.135a.21.21 0 0 0 .212-.211V1.712a.21.21 0 0 0-.212-.212H5.373l2.395 1.195.002.001a1.71 1.71 0 0 1 .942 1.538v.003l-.75-.005h.75z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function RW(e, t) {
      return xo(), Eo("svg", PW, [...DW])
    }
    const NW = { render: RW },
      $W = Object.freeze(
        Object.defineProperty({ __proto__: null, default: NW, render: RW }, Symbol.toStringTag, { value: "Module" }),
      ),
      IW = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      MW = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M6.55 12a5.46 5.46 0 1 0 10.91.481A5.46 5.46 0 0 0 6.55 12m0 0H2m4.55 0H4.73m12.31 2.1a5.46 5.46 0 0 1-6.614-6.887M12 2v4.55m7.08-1.62-3.22 3.22M22 12h-4.54m1.62 7.08L16 16.01M12 22v-4m-7.07 1.08L8 16.01M4.93 4.93l3.22 3.22",
          },
          null,
          -1,
        ),
      ]
    function LW(e, t) {
      return xo(), Eo("svg", IW, [...MW])
    }
    const QW = { render: LW },
      BW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: QW, render: LW }, Symbol.toStringTag, { value: "Module" }),
      ),
      jW = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 10 10" },
      UW = [
        Ro(
          "path",
          {
            d: "M3.5 5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0M5 2.25a.625.625 0 0 1-.625-.625v-1a.625.625 0 0 1 1.25 0v1A.625.625 0 0 1 5 2.25m1.945.805a.623.623 0 0 1 0-.883l.707-.708a.625.625 0 0 1 .884.884l-.708.707a.623.623 0 0 1-.883 0M7.75 5a.625.625 0 0 1 .625-.625h1a.625.625 0 0 1 0 1.25h-1A.625.625 0 0 1 7.75 5m-.805 1.945a.623.623 0 0 1 .883 0l.708.707a.625.625 0 0 1-.884.884l-.707-.708a.623.623 0 0 1 0-.883M5 7.75a.625.625 0 0 1 .625.625v1a.625.625 0 0 1-1.25 0v-1A.625.625 0 0 1 5 7.75m-1.945-.805a.623.623 0 0 1 0 .883l-.707.708a.625.625 0 0 1-.884-.884l.708-.707a.623.623 0 0 1 .883 0M2.25 5a.625.625 0 0 1-.625.625h-1a.625.625 0 0 1 0-1.25h1A.625.625 0 0 1 2.25 5m.805-1.945a.623.623 0 0 1-.883 0l-.708-.707a.625.625 0 0 1 .884-.884l.707.708a.623.623 0 0 1 0 .883",
          },
          null,
          -1,
        ),
      ]
    function FW(e, t) {
      return xo(), Eo("svg", jW, [...UW])
    }
    const zW = { render: FW },
      qW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: zW, render: FW }, Symbol.toStringTag, { value: "Module" }),
      ),
      ZW = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      HW = [
        Ro(
          "path",
          {
            d: "M13.5 18 12 19.5c-1 1-2.3 1.5-3.7 1.5s-2.7-.6-3.7-1.5c-1-1-1.5-2.3-1.5-3.7s.6-2.7 1.5-3.7l1.5-1.5M10.5 6 12 4.5c1-1 2.3-1.5 3.7-1.5s2.7.6 3.7 1.5c1 1 1.5 2.3 1.5 3.7s-.6 2.7-1.5 3.7l-1.5 1.5M9 15l6-6",
          },
          null,
          -1,
        ),
      ]
    function VW(e, t) {
      return xo(), Eo("svg", ZW, [...HW])
    }
    const WW = { render: VW },
      XW = Object.freeze(
        Object.defineProperty({ __proto__: null, default: WW, render: VW }, Symbol.toStringTag, { value: "Module" }),
      ),
      YW = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 14 14" },
      GW = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M7 2a2 2 0 0 0-2 2v1h4V4a2 2 0 0 0-2-2M3 4v1a1.5 1.5 0 0 0-1.5 1.5v6A1.5 1.5 0 0 0 3 14h8a1.5 1.5 0 0 0 1.5-1.5v-6A1.5 1.5 0 0 0 11 5V4a4 4 0 1 0-8 0m4 6.75a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function KW(e, t) {
      return xo(), Eo("svg", YW, [...GW])
    }
    const JW = { render: KW },
      eX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: JW, render: KW }, Symbol.toStringTag, { value: "Module" }),
      ),
      tX = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 593 593" },
      nX = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M347 0c6 0 12 5 12 12v134l94-95c5-5 13-5 17 0l72 72c4 4 5 12 0 16v1l-95 94h134c7 0 12 5 12 12v101c0 7-5 12-12 12H447l95 94c4 5 5 13 0 17l-72 72c-4 4-12 5-16 0h-1l-94-95v134c0 7-5 12-12 12H246c-7 0-12-5-12-12v-70c0-22 9-43 24-59l130-130c14-14 14-37 0-51L259 142a84 84 0 0 1-25-59V12c0-7 5-12 12-12zM138 52h1l219 219c14 14 14 37 0 51L139 542c-4 5-12 5-17 0l-71-70c-4-5-5-12 0-17l95-96H12c-7 0-12-5-12-12V246c0-7 5-12 12-12h134l-95-94c-4-5-4-12 0-17l71-71c4-5 12-5 16 0",
          },
          null,
          -1,
        ),
      ]
    function rX(e, t) {
      return xo(), Eo("svg", tX, [...nX])
    }
    const aX = { render: rX },
      oX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: aX, render: rX }, Symbol.toStringTag, { value: "Module" }),
      ),
      iX = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 662 662" },
      sX = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M331 0a331 331 0 1 1 0 662 331 331 0 0 1 0-662m148.5 109 .6.9a187 187 0 1 1-297.6-.9 267 267 0 1 0 297 0",
          },
          null,
          -1,
        ),
      ]
    function lX(e, t) {
      return xo(), Eo("svg", iX, [...sX])
    }
    const cX = { render: lX },
      dX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: cX, render: lX }, Symbol.toStringTag, { value: "Module" }),
      ),
      uX = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 620 620" },
      pX = [
        Ro(
          "path",
          {
            d: "M-.653 309.29c-.078 82.272 31.848 159.735 89.739 218.178l.283.283c122.379 121.247 319.824 121.184 440.16-.283 119.967-121.1 119.409-316.933-.998-437.339l-.99-.99C468.681 30.845 390.716-1.017 307.893-.67c-82.83.354-160.443 32.994-218.814 91.79C31.209 149.555-.724 227.025-.653 309.29m469.271-160.789.778.778c87.9 87.9 88.325 231.005.707 319.33-77.753 78.46-199.786 87.412-288.959 26.862l198.513-198.513-.007 166.361 83.68-.07v-306.22H157.11l-.008 83.6h160.584L121.994 436.323c-59.347-87.689-50.536-208.59 26.51-286.343 87.836-88.686 231.436-89.31 320.106-1.486Z",
          },
          null,
          -1,
        ),
      ]
    function hX(e, t) {
      return xo(), Eo("svg", uX, [...pX])
    }
    const fX = { render: hX },
      mX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: fX, render: hX }, Symbol.toStringTag, { value: "Module" }),
      ),
      gX = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 642 642" },
      bX = [
        Ro(
          "path",
          {
            d: "M321 0a321 321 0 1 1 0 642 321 321 0 0 1 0-642m51.3 63L321 189.5 269.7 63l1 136.5-95.8-97.2L228 228l-125.7-53.1 97.2 95.8-136.5-1L189.5 321 63 372.3l136.5-1-97.2 95.8 125.7-53-53.1 125.6 95.8-97.2-1 136.5L321 452.5 372.3 579l-1-136.5 95.8 97.2-53-125.7 125.6 53.1-97.2-95.8 136.5 1L452.5 321 579 269.7l-136.5 1 97.2-95.8L414 228l53.1-125.7-95.8 97.2z",
          },
          null,
          -1,
        ),
      ]
    function vX(e, t) {
      return xo(), Eo("svg", gX, [...bX])
    }
    const yX = { render: vX },
      OX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: yX, render: vX }, Symbol.toStringTag, { value: "Module" }),
      ),
      wX = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 620 620" },
      xX = [
        Ro(
          "path",
          {
            d: "M529.2 90.8A310 310 0 1 0 90.8 529.2 310 310 0 0 0 529.2 90.8M122.4 498.2c-54.9-55-15.4-183.5 88.2-287 103.6-103.7 232.1-143.2 287-88.3 54.9 54.8 15.4 183.4-88.3 287-103.5 103.6-232 143.1-286.9 88.3m261.8-262.7A104.7 104.7 0 1 1 236 383.7a104.7 104.7 0 0 1 148.2-148.2",
          },
          null,
          -1,
        ),
      ]
    function kX(e, t) {
      return xo(), Eo("svg", wX, [...xX])
    }
    const _X = { render: kX },
      SX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: _X, render: kX }, Symbol.toStringTag, { value: "Module" }),
      ),
      EX = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 14 14" },
      TX = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M8.75 0a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8.75 0m4.03 2.28a.75.75 0 0 0-1.06-1.06l-1 1a.75.75 0 0 0 1.06 1.06zM9.707 5.707a1 1 0 0 0-1.414-1.414l-8 8a1 1 0 1 0 1.414 1.414zM11.75 4.5a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5zm-1.53 2.22a.75.75 0 0 1 1.06 0l1 1a.75.75 0 0 1-1.06 1.06l-1-1a.75.75 0 0 1 0-1.06m-3.94-5a.75.75 0 0 0-1.06 1.06l1 1a.75.75 0 0 0 1.06-1.06z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function AX(e, t) {
      return xo(), Eo("svg", EX, [...TX])
    }
    const CX = { render: AX },
      PX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: CX, render: AX }, Symbol.toStringTag, { value: "Module" }),
      ),
      DX = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      RX = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M22 6.8H2m20 10.4H2",
          },
          null,
          -1,
        ),
      ]
    function NX(e, t) {
      return xo(), Eo("svg", DX, [...RX])
    }
    const $X = { render: NX },
      IX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: $X, render: NX }, Symbol.toStringTag, { value: "Module" }),
      ),
      MX = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      LX = [
        Ro(
          "path",
          {
            d: "M17.333 5.34c1.39-.22 2.796-.334 4.205-.34.121 0 .238.043.329.122a.44.44 0 0 1 .133.314v13.73a.44.44 0 0 1-.133.306.46.46 0 0 1-.311.13C14.186 19.708 12 22 12 22m0 0V7.38S9.822 5.096 2.462 5a.5.5 0 0 0-.329.122.44.44 0 0 0-.133.314v13.73a.44.44 0 0 0 .133.306.46.46 0 0 0 .311.13C9.814 19.708 12 22 12 22",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M12 22a5.67 5.67 0 0 1 1.367-3.135c.967-1.141 2.237-1.923 3.633-2.236V2.443a.45.45 0 0 0-.051-.21.4.4 0 0 0-.14-.154.47.47 0 0 0-.409-.054 6.44 6.44 0 0 0-3.033 2.063A5.86 5.86 0 0 0 12 7.205",
          },
          null,
          -1,
        ),
      ]
    function QX(e, t) {
      return xo(), Eo("svg", MX, [...LX])
    }
    const BX = { render: QX },
      jX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: BX, render: QX }, Symbol.toStringTag, { value: "Module" }),
      ),
      UX = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 14 14" },
      FX = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M11.821.098a1.62 1.62 0 0 1 2.077 2.076l-3.574 10.712a1.62 1.62 0 0 1-1.168 1.069 1.6 1.6 0 0 1-1.52-.434l-1.918-1.909-2.014 1.042a.5.5 0 0 1-.73-.457l.083-3.184 7.045-5.117a.625.625 0 1 0-.735-1.012L2.203 8.088l-1.73-1.73a1.6 1.6 0 0 1-.437-1.447 1.62 1.62 0 0 1 1.069-1.238h.003z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function zX(e, t) {
      return xo(), Eo("svg", UX, [...FX])
    }
    const qX = { render: zX },
      ZX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: qX, render: zX }, Symbol.toStringTag, { value: "Module" }),
      ),
      HX = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 14 14" },
      VX = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M8 1a1 1 0 0 0-2 0v1.4h-.5A2.7 2.7 0 0 0 2.8 5c0 .5.1 1.1.5 1.6a2.7 2.7 0 0 0 1.7 1L6 8v1.7H4.3a1 1 0 1 0 0 2H6V13a1 1 0 1 0 2 0v-1.3h.5c1.6 0 2.6-1.2 2.7-2.5a2.6 2.6 0 0 0-2.2-3H8V4.3h1.7a1 1 0 0 0 0-2H8zM6 4.5h-.5c-.4 0-.7.3-.7.7s.2.6.5.7H6zM8 8v1.5h.5c.2 0 .4 0 .5-.2l.2-.5-.1-.4-.4-.3H8Z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function WX(e, t) {
      return xo(), Eo("svg", HX, [...VX])
    }
    const XX = { render: WX },
      YX = Object.freeze(
        Object.defineProperty({ __proto__: null, default: XX, render: WX }, Symbol.toStringTag, { value: "Module" }),
      ),
      GX = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      KX = [
        Ro(
          "path",
          {
            d: "M17 3a2.85 2.85 0 0 1 2.064-1.007 2.87 2.87 0 0 1 2.14.834 2.83 2.83 0 0 1 .825 2.131A2.8 2.8 0 0 1 21 7L7.5 20.5 2 22l1.5-5.5z",
          },
          null,
          -1,
        ),
      ]
    function JX(e, t) {
      return xo(), Eo("svg", GX, [...KX])
    }
    const eY = { render: JX },
      tY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: eY, render: JX }, Symbol.toStringTag, { value: "Module" }),
      ),
      nY = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      rY = [
        Ro(
          "path",
          {
            d: "M6 6.663c0-1.582 1.75-2.538 3.082-1.682l8.301 5.337a2 2 0 0 1 0 3.364L9.082 19.02C7.75 19.875 6 18.919 6 17.337z",
          },
          null,
          -1,
        ),
      ]
    function aY(e, t) {
      return xo(), Eo("svg", nY, [...rY])
    }
    const oY = { render: aY },
      iY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: oY, render: aY }, Symbol.toStringTag, { value: "Module" }),
      ),
      sY = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 12 12" },
      lY = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M11 4.3c-.5-.7-1.7-2.2-2.4-2.6C7.9 1.2 7 1 5.9 1s-2.6.5-3.5 1.5C1.5 3.4.9 4.7.9 6s.5 2.6 1.5 3.5c.9.9 2.2 1.5 3.6 1.5s2.6-.6 3.6-1.5c.5-.5.8-.9 1-1.6",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          { stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", d: "M11 1v3.3H7.6" },
          null,
          -1,
        ),
      ]
    function cY(e, t) {
      return xo(), Eo("svg", sY, [...lY])
    }
    const dY = { render: cY },
      uY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: dY, render: cY }, Symbol.toStringTag, { value: "Module" }),
      ),
      pY = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      hY = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M11 19a8 8 0 1 0 0-16 8 8 0 0 0 0 16m10 2-4.35-4.35",
          },
          null,
          -1,
        ),
      ]
    function fY(e, t) {
      return xo(), Eo("svg", pY, [...hY])
    }
    const mY = { render: fY },
      gY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: mY, render: fY }, Symbol.toStringTag, { value: "Module" }),
      ),
      bY = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      vY = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M20 12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2m16 0H4m16 0a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          { fill: "currentColor", d: "M18 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 8a1 1 0 1 0 0-2 1 1 0 0 0 0 2" },
          null,
          -1,
        ),
        Ro(
          "path",
          { stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", d: "M6 8h4m-4 8h4" },
          null,
          -1,
        ),
      ]
    function yY(e, t) {
      return xo(), Eo("svg", bY, [...vY])
    }
    const OY = { render: yY },
      wY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: OY, render: yY }, Symbol.toStringTag, { value: "Module" }),
      ),
      xY = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      kY = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M12 5.251C7.969 5.183 3.8 8 1.179 10.885a1.663 1.663 0 0 0 0 2.226C3.743 15.935 7.9 18.817 12 18.748c4.1.069 8.258-2.813 10.824-5.637a1.663 1.663 0 0 0 0-2.226C20.2 8 16.031 5.183 12 5.251",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M15.75 12A3.75 3.75 0 1 1 12 8.249 3.75 3.75 0 0 1 15.75 12",
          },
          null,
          -1,
        ),
      ]
    function _Y(e, t) {
      return xo(), Eo("svg", xY, [...kY])
    }
    const SY = { render: _Y },
      EY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: SY, render: _Y }, Symbol.toStringTag, { value: "Module" }),
      ),
      TY = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      AY = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M2 5.4h20M2 12h20M2 18.6h13.3",
          },
          null,
          -1,
        ),
      ]
    function CY(e, t) {
      return xo(), Eo("svg", TY, [...AY])
    }
    const PY = { render: CY },
      DY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: PY, render: CY }, Symbol.toStringTag, { value: "Module" }),
      ),
      RY = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      NY = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M13 15h5M6 9l4 3-4 3",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M21 2.8H3.1c-.7 0-1.4.6-1.4 1.4v15.6c0 .7.6 1.4 1.4 1.4H21c.7 0 1.4-.6 1.4-1.4V4.2c0-.8-.5-1.4-1.3-1.4z",
          },
          null,
          -1,
        ),
      ]
    function $Y(e, t) {
      return xo(), Eo("svg", RY, [...NY])
    }
    const IY = { render: $Y },
      MY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: IY, render: $Y }, Symbol.toStringTag, { value: "Module" }),
      ),
      LY = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      QY = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M14.333 22.94c-.848 0-1.604-.5-1.96-1.251-1.783-3.772-3.568-6.116-6.2-7.75H5V2.69h1.779l6.5-1.5h7.82a1.375 1.375 0 0 1 0 2.75h-.5a.625.625 0 1 0 0 1.25h1.5a1.375 1.375 0 0 1 0 2.75h-.5a.625.625 0 1 0 0 1.25h1a1.375 1.375 0 0 1 0 2.75h-1a.625.625 0 0 0 0 1.25h1a1.375 1.375 0 0 1 0 2.75h-7.834c.618 1.618 1.2 3.36 1.497 4.743.276 1.28-.77 2.258-1.93 2.258ZM3.5 14.5a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h1.5a1 1 0 0 1 1 1z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function BY(e, t) {
      return xo(), Eo("svg", LY, [...QY])
    }
    const jY = { render: BY },
      UY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: jY, render: BY }, Symbol.toStringTag, { value: "Module" }),
      ),
      FY = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      zY = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M14.333.375c-.848 0-1.604.5-1.96 1.251-1.783 3.772-3.568 6.116-6.2 7.749H5v11.25h1.779l6.5 1.5h7.82a1.375 1.375 0 0 0 0-2.75h-.5a.625.625 0 1 1 0-1.25h1.5a1.375 1.375 0 0 0 0-2.75h-.5a.625.625 0 1 1 0-1.25h1a1.375 1.375 0 0 0 0-2.75h-1a.625.625 0 1 1 0-1.25h1a1.375 1.375 0 0 0 0-2.75h-7.834c.618-1.617 1.2-3.359 1.497-4.742.276-1.28-.77-2.258-1.93-2.258ZM3.5 8.815a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v12.5a1 1 0 0 0 1 1h1.5a1 1 0 0 0 1-1z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function qY(e, t) {
      return xo(), Eo("svg", FY, [...zY])
    }
    const ZY = { render: qY },
      HY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: ZY, render: qY }, Symbol.toStringTag, { value: "Module" }),
      ),
      VY = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      WY = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "m19.5 5.75-1.51 14.34a1.67 1.67 0 0 1-1.66 1.5H7.67A1.67 1.67 0 0 1 6 20.08L4.5 5.75m-2.08 0h19.16m-13.33 0v-2.5a.83.83 0 0 1 .83-.83h5.84a.83.83 0 0 1 .83.83v2.5M12 9.5v8.75m3.75-8.75-.42 8.75M8.25 9.5l.42 8.75",
          },
          null,
          -1,
        ),
      ]
    function XY(e, t) {
      return xo(), Eo("svg", VY, [...WY])
    }
    const YY = { render: XY },
      GY = Object.freeze(
        Object.defineProperty({ __proto__: null, default: YY, render: XY }, Symbol.toStringTag, { value: "Module" }),
      ),
      KY = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      JY = [
        Ro(
          "path",
          {
            d: "M19.5 9.5h-.75V6.75A6.75 6.75 0 0 0 5.53 4.81a1.25 1.25 0 0 0 2.4.72 4.25 4.25 0 0 1 8.32 1.22V9a.5.5 0 0 1-.5.5H4.5a2 2 0 0 0-2 2V22a2 2 0 0 0 2 2h15a2 2 0 0 0 2-2V11.5a2 2 0 0 0-2-2m-7.5 9a2 2 0 1 1 2-2 2 2 0 0 1-2 2",
          },
          null,
          -1,
        ),
      ]
    function eG(e, t) {
      return xo(), Eo("svg", KY, [...JY])
    }
    const tG = { render: eG },
      nG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: tG, render: eG }, Symbol.toStringTag, { value: "Module" }),
      ),
      rG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      aG = [
        Ro(
          "path",
          {
            d: "M12 0a12 12 0 1 0 12 12A12 12 0 0 0 12 0m4.91 10.41A1 1 0 0 1 16 11h-2.25a.25.25 0 0 0-.25.25v7.25a1.5 1.5 0 0 1-3 0v-7.25a.25.25 0 0 0-.25-.25H8a1 1 0 0 1-.75-1.66l4-4.5a1 1 0 0 1 1.5 0l4 4.5a1 1 0 0 1 .16 1.07",
          },
          null,
          -1,
        ),
      ]
    function oG(e, t) {
      return xo(), Eo("svg", rG, [...aG])
    }
    const iG = { render: oG },
      sG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: iG, render: oG }, Symbol.toStringTag, { value: "Module" }),
      ),
      lG = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      cG = [
        Ro(
          "path",
          {
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M12 4.33v15.32m5.37-9.95L12 4.33 6.63 9.7",
          },
          null,
          -1,
        ),
      ]
    function dG(e, t) {
      return xo(), Eo("svg", lG, [...cG])
    }
    const uG = { render: dG },
      pG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: uG, render: dG }, Symbol.toStringTag, { value: "Module" }),
      ),
      hG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      fG = [
        Ro(
          "path",
          {
            d: "M6.5 6.25a5.5 5.5 0 1 0 11 0 5.5 5.5 0 1 0-11 0m5.5 7a9.51 9.51 0 0 0-9.5 9.5.5.5 0 0 0 .5.5h18a.5.5 0 0 0 .5-.5 9.51 9.51 0 0 0-9.5-9.5",
          },
          null,
          -1,
        ),
      ]
    function mG(e, t) {
      return xo(), Eo("svg", hG, [...fG])
    }
    const gG = { render: mG },
      bG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: gG, render: mG }, Symbol.toStringTag, { value: "Module" }),
      ),
      vG = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 24 24",
      },
      yG = [
        Ro(
          "path",
          {
            d: "M20.25 3.75v19.5M3.75 3.75h16.5m-16.5 19.5V3.75m16.5 19.5H3.75m16.5-19.5H3.75l1.5-3h13.5zM.75 23.25h22.5m-9-2.25a2.25 2.25 0 0 0-4.5 0v2.25h4.5zM7.5 7.13a.37.37 0 1 1 0-.75m0 .75a.37.37 0 1 0 0-.75m4.5.75a.38.38 0 0 1 0-.75m0 .75a.38.38 0 0 0 0-.75m4.5.75a.38.38 0 0 1 0-.75m0 .75a.38.38 0 0 0 0-.75m-9 5.25a.38.38 0 0 1 0-.76m0 .76a.38.38 0 0 0 0-.76m4.5.76a.38.38 0 0 1 0-.76m0 .76a.38.38 0 0 0 0-.76m4.5.76a.38.38 0 0 1 0-.76m0 .76a.38.38 0 0 0 0-.76m-9 5.26a.38.38 0 0 1 0-.75m0 .75a.38.38 0 0 0 0-.75m4.5.75a.38.38 0 0 1 0-.75m0 .75a.38.38 0 0 0 0-.75m4.5.75a.38.38 0 0 1 0-.75m0 .75a.38.38 0 0 0 0-.75",
          },
          null,
          -1,
        ),
      ]
    function OG(e, t) {
      return xo(), Eo("svg", vG, [...yG])
    }
    const wG = { render: OG },
      xG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: wG, render: OG }, Symbol.toStringTag, { value: "Module" }),
      ),
      kG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      _G = [
        Ro(
          "path",
          {
            d: "M9.931 12.645h4.138l-2.07-4.908m0-7.737L.68 3.982l1.726 14.771L12 24l9.596-5.242L23.32 3.984zm7.064 18.31h-2.638l-1.422-3.503H8.996l-1.422 3.504h-2.64L12 2.65z",
          },
          null,
          -1,
        ),
      ]
    function SG(e, t) {
      return xo(), Eo("svg", kG, [..._G])
    }
    const EG = { render: SG },
      TG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: EG, render: SG }, Symbol.toStringTag, { value: "Module" }),
      ),
      AG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      CG = [
        Ro(
          "path",
          {
            d: "M16.074 16.86c-.72.616-2.157 1.035-3.812 1.035-2.032 0-3.735-.632-4.187-1.483-.161.488-.198 1.046-.198 1.402 0 0-.106 1.75 1.111 2.968 0-.632.513-1.145 1.145-1.145 1.083 0 1.082.945 1.081 1.712v.069c0 1.164.711 2.161 1.723 2.582a2.35 2.35 0 0 1-.236-1.029c0-1.11.652-1.523 1.41-2.003.602-.383 1.272-.807 1.733-1.66a3.1 3.1 0 0 0 .378-1.494 3.1 3.1 0 0 0-.148-.954M15.551.6c.196.244.296.572.496 1.229l4.368 14.347a18.2 18.2 0 0 0-5.222-1.768L12.35 4.8a.37.37 0 0 0-.71.002l-2.81 9.603a18.2 18.2 0 0 0-5.245 1.771L7.974 1.827c.2-.656.3-.984.497-1.227a1.6 1.6 0 0 1 .654-.484C9.415 0 9.757 0 10.443 0h3.135c.686 0 1.03 0 1.32.117A1.6 1.6 0 0 1 15.55.6z",
          },
          null,
          -1,
        ),
      ]
    function PG(e, t) {
      return xo(), Eo("svg", AG, [...CG])
    }
    const DG = { render: PG },
      RG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: DG, render: PG }, Symbol.toStringTag, { value: "Module" }),
      ),
      NG = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
      $G = [
        Ro(
          "path",
          {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M6.335.83a.75.75 0 0 0-.67 0L1.667 2.827a.75.75 0 0 0-.417.672V18c0 .271.146.52.382.654l7.989 4.493a.75.75 0 0 0 .747.007l8-4.5A.75.75 0 0 0 18.75 18v-4.537l3.585-1.792A.75.75 0 0 0 22.75 11V6a.75.75 0 0 0-.417-.672l-3.998-1.999a.75.75 0 0 0-.67 0l-3.997 1.999a.7.7 0 0 0-.246.194.75.75 0 0 0-.172.478v4.561l-2.5 1.407V3.5a.75.75 0 0 0-.43-.678L6.336.829Zm7.686 11.019 2.38 1.19-6.422 3.612-2.38-1.19zm3.229-.063-2.5-1.25V7.215l2.5 1.25zm1.5 0 2.5-1.25V7.215l-2.5 1.25zm-9.5 1.025V4.714l-2.5 1.25v8.254zm-1.005 4.65.743.372c.17.091.262.153.262.183v3.202l-6.5-3.657V4.714l2.5 1.25V15.5a.75.75 0 0 0 .415.67s1.122.591 2.108 1.064zm2.505.478 6.5-3.657v3.28l-6.5 3.656v-3.28ZM6 4.66 3.677 3.5 6 2.339 8.323 3.5zM20.323 6 18 4.839 15.677 6 18 7.161z",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function IG(e, t) {
      return xo(), Eo("svg", NG, [...$G])
    }
    const MG = { render: IG },
      LG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: MG, render: IG }, Symbol.toStringTag, { value: "Module" }),
      ),
      QG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      BG = [
        Ro(
          "path",
          {
            d: "M11.573 0a5 5 0 0 0-.359.007L10.85.04c-3.407.307-6.6 2.146-8.622 4.972a11.9 11.9 0 0 0-2.119 5.243c-.096.659-.108.854-.108 1.747s.012 1.089.108 1.748c.652 4.506 3.86 8.292 8.209 9.695.779.25 1.6.422 2.534.525.363.04 1.935.04 2.299 0 1.611-.178 2.977-.577 4.323-1.264.207-.106.247-.134.219-.158-.02-.013-.9-1.193-1.955-2.62l-1.919-2.592-2.404-3.558a339 339 0 0 0-2.422-3.556c-.009-.002-.018 1.579-.023 3.51-.007 3.38-.01 3.515-.052 3.595a.43.43 0 0 1-.206.214c-.075.037-.14.044-.495.044H7.81l-.108-.068a.44.44 0 0 1-.157-.171l-.05-.106.006-4.703.007-4.705.072-.092a.7.7 0 0 1 .174-.143c.096-.047.134-.051.54-.051.478 0 .558.018.682.154a467 467 0 0 1 2.895 4.361l4.735 7.17 1.9 2.879.096-.063a12.3 12.3 0 0 0 2.466-2.163 11.94 11.94 0 0 0 2.824-6.134c.096-.66.108-.854.108-1.748 0-.893-.012-1.088-.108-1.747-.652-4.506-3.859-8.292-8.208-9.695a12.6 12.6 0 0 0-2.499-.523A33 33 0 0 0 11.573 0m4.068 7.217c.347 0 .408.005.486.047a.47.47 0 0 1 .237.277c.018.06.023 1.365.018 4.304l-.006 4.218-.744-1.14-.746-1.14v-3.066c0-1.982.01-3.097.023-3.15a.48.48 0 0 1 .233-.296c.096-.05.13-.054.5-.054z",
          },
          null,
          -1,
        ),
      ]
    function jG(e, t) {
      return xo(), Eo("svg", QG, [...BG])
    }
    const UG = { render: jG },
      FG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: UG, render: jG }, Symbol.toStringTag, { value: "Module" }),
      ),
      zG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      qG = [
        Ro(
          "path",
          {
            d: "M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236m2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38a2.17 2.17 0 0 0-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44a23.5 23.5 0 0 0-3.107-.534A24 24 0 0 0 12.769 4.7c1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442a23 23 0 0 0-3.113.538 15 15 0 0 1-.254-1.42c-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05q.684.704 1.36 1.564c-.44-.02-.89-.034-1.345-.034q-.691-.001-1.36.034c.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093q.61.874 1.183 1.86.557.961 1.018 1.946c-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87a25.6 25.6 0 0 1-4.412.005 27 27 0 0 1-1.183-1.86q-.557-.961-1.018-1.946a25 25 0 0 1 1.013-1.954c.38-.66.773-1.286 1.18-1.868A25 25 0 0 1 12 8.098zm-3.635.254c-.24.377-.48.763-.704 1.16q-.336.585-.635 1.174c-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0q1.044.153 2.006.387c-.18.632-.405 1.282-.66 1.933a26 26 0 0 0-1.345-2.32zm3.063.675q.727.226 1.375.498c1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493a24 24 0 0 0-1.1-2.98c.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98a23 23 0 0 0-1.086 2.964c-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474s1.12-1.742 2.852-2.476c.42-.18.88-.342 1.356-.494m11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39a26 26 0 0 0 1.341-2.338zm-9.945.02c.2.392.41.783.64 1.175q.345.586.705 1.143a22 22 0 0 1-2.006-.386c.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295a1.2 1.2 0 0 1-.553-.132c-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64q.661.032 1.345.034.691.001 1.36-.034c-.44.572-.895 1.095-1.345 1.565q-.684-.706-1.36-1.565",
          },
          null,
          -1,
        ),
      ]
    function ZG(e, t) {
      return xo(), Eo("svg", zG, [...qG])
    }
    const HG = { render: ZG },
      VG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: HG, render: ZG }, Symbol.toStringTag, { value: "Module" }),
      ),
      WG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      XG = [
        Ro(
          "path",
          {
            d: "M23.94 3a.5.5 0 0 0-.44-.25h-2.31l-8.55 13.91a.75.75 0 0 1-1.28 0L2.81 2.77H.5A.5.5 0 0 0 .06 3a.54.54 0 0 0 0 .51l11.5 19a.51.51 0 0 0 .86 0l11.5-19a.54.54 0 0 0 .02-.51",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          { d: "m12 14.84 7.43-12.07H16a.47.47 0 0 0-.43.25L12 9.26 8.43 3A.47.47 0 0 0 8 2.77H4.57Z" },
          null,
          -1,
        ),
      ]
    function YG(e, t) {
      return xo(), Eo("svg", WG, [...XG])
    }
    const GG = { render: YG },
      KG = Object.freeze(
        Object.defineProperty({ __proto__: null, default: GG, render: YG }, Symbol.toStringTag, { value: "Module" }),
      ),
      JG = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      eK = [
        Ro(
          "path",
          {
            d: "m117.5 33.5.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7s-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7s2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6M64 88.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5",
          },
          null,
          -1,
        ),
      ]
    function tK(e, t) {
      return xo(), Eo("svg", JG, [...eK])
    }
    const nK = { render: tK },
      rK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: nK, render: tK }, Symbol.toStringTag, { value: "Module" }),
      ),
      aK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      oK = [
        Ro(
          "path",
          {
            d: "M60.952.266C27.377.266.065 28.77.065 63.806s27.318 63.54 60.887 63.54c33.576 0 60.893-28.505 60.893-63.54S94.528.266 60.952.266m0 6.117c30.39 0 55.025 25.712 55.025 57.423 0 2.482-.167 4.924-.46 7.321-1.495 6.214-4.194 10.358-7.412 13.19-4.941 4.336-11.524 5.738-17.62 5.733a41 41 0 0 1-4.973-.289C97.506 77.4 99.336 57.866 89.864 43.315 80.39 28.763 62.315 23.338 46.882 30.416a24 24 0 0 0-1.68-1.114c-2.41-1.413-7.439-3.482-13.837-3.505-5.361-.022-10.615 1.568-15.133 4.58C26.554 15.317 43.21 6.386 60.952 6.394zM51.341 84.6c.894-4.07 3.343-10.431 5.548-15.655.623-1.481 1.23-2.872 1.777-4.104 3.451 12.822 5.635 20.449 9.546 25.65a18 18 0 0 0 1.913 2.114 28 28 0 0 1-9.173 1.56 28.2 28.2 0 0 1-10.023-1.86q-.098-1.227-.103-2.459a24.5 24.5 0 0 1 .515-5.24zm-7.444 3.77c-7.555-5.703-12.031-14.84-12.04-24.57.008-9.88 4.625-19.138 12.375-24.813 1.637.984 3.121 2.143 4.34 3.477 2.395 2.56 5.077 8.214 6.94 13.082.51 1.312.965 2.567 1.36 3.709C50.16 73.502 45.685 80.608 43.898 88.37zm21.802-18.226c-1.501-4.037-2.374-7.079-2.379-7.084l-.005-.012c-2.747-10.984-5.592-21.025-11.497-28.052a28 28 0 0 1 9.134-1.55c16.06.022 29.074 13.602 29.095 30.36-.007 9.673-4.432 18.764-11.914 24.474a15 15 0 0 1-2.184-.78c-1.137-.514-2.812-2.267-4.329-4.698-2.313-3.635-4.437-8.622-5.927-12.653zm-4.747 51.08c-30.39 0-55.025-25.707-55.025-57.424 0-2.086.114-4.144.32-6.173 4.508-16 15.338-21.92 25.595-22.02 2.08-.007 4.117.282 6.068.774-13.182 12.081-15.74 32.487-5.979 47.7 9.762 15.213 28.817 20.518 44.544 12.403 2.78 1.023 5.96 1.633 9.812 2.137 1.447.186 3.007.277 4.665.277a61.6 61.6 0 0 0 14.997-2.087c-10.29 15.308-27.088 24.417-45.007 24.407z",
          },
          null,
          -1,
        ),
      ]
    function iK(e, t) {
      return xo(), Eo("svg", aK, [...oK])
    }
    const sK = { render: iK },
      lK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: sK, render: iK }, Symbol.toStringTag, { value: "Module" }),
      ),
      cK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      dK = [
        Ro(
          "path",
          {
            d: "m117.5 33.5.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7s-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7s2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6m-53.5 70c-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8M115 62h-3.2l-.9 4h4.1v5h-5l-1.2 6h-4.9l1.2-6h-3.8l-1.2 6h-4.8l1.2-6H94v-5h3.5l.9-4H94v-5h5.3l1.2-6h4.9l-1.2 6h3.8l1.2-6h4.8l-1.2 6h2.2zm-12.7 4h3.8l.9-4h-3.8z",
          },
          null,
          -1,
        ),
      ]
    function uK(e, t) {
      return xo(), Eo("svg", cK, [...dK])
    }
    const pK = { render: uK },
      hK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: pK, render: uK }, Symbol.toStringTag, { value: "Module" }),
      ),
      fK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      mK = [
        Ro(
          "path",
          {
            d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53z",
          },
          null,
          -1,
        ),
      ]
    function gK(e, t) {
      return xo(), Eo("svg", fK, [...mK])
    }
    const bK = { render: gK },
      vK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: bK, render: gK }, Symbol.toStringTag, { value: "Module" }),
      ),
      yK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      OK = [
        Ro(
          "path",
          {
            d: "M108.2 64.8c-.1-.1-.2-.2-.4-.2l-.1-.1c-.1-.1-.2-.1-.2-.2l-.1-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1-.1 0-.1 0-.2-.1l-.3-.1c-.1 0-.1 0-.2-.1l-.3-.1h-.1l-.4-.1h-.2c-.1 0-.2 0-.3-.1h-2.3c-.6-13.3.6-26.8-2.8-39.6 12.9-4.6 2.8-22.3-8.4-14.4-7.4-6.4-17.6-7.8-28.3-7.8-10.5.7-20.4 2.9-27.4 8.4-2.8-1.4-5.5-1.8-7.9-1.1v.1c-.1 0-.3.1-.4.2-.1 0-.3.1-.4.2h-.1c-.1 0-.2.1-.4.2h-.1l-.3.2h-.1l-.3.2h-.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2-.1.1c-.1.1-.2.1-.2.2l-.1.1-.2.2-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1c.4.3.4.4.4.4v.1l-.1.3v.1c0 .1 0 .2-.1.3v3.1c0 .1 0 .2.1.3v.1l.1.3v.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3.1.1.3.3.3.3h.1c1 .9 2 1.6 4 2.2v-.2C23 37.3 26.5 50 26.7 63c-.6 0-.7.4-1.7.5h-.5c-.1 0-.3 0-.5.1-.1 0-.3 0-.4.1l-.4.1h-.1l-.4.1h-.1l-.3.1h-.1l-.3.1s-.1 0-.1.1l-.3.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.4.3c-.1.1-.2.2-.3.2l-.4.4-.1.1c-.1.2-.3.4-.4.5l-.2.3-.3.6-.1.3v.3c0 .5.2.9.9 1.2.2 3.7 3.9 2 5.6.8l.1-.1c.2-.2.5-.3.6-.3h.1l.2-.1c.1 0 .1 0 .2-.1.2-.1.4-.1.5-.2.1 0 .1-.1.1-.2l.1-.1c.1-.2.2-.6.2-1.2l.1-1.3v1.8c-.5 13.1-4 30.7 3.3 42.5 1.3 2.1 2.9 3.9 4.7 5.4h-.5c-.2.2-.5.4-.8.6l-.9.6-.3.2-.6.4-.9.7-1.1 1c-.2.2-.3.4-.4.5l-.4.6-.2.3c-.1.2-.2.4-.2.6l-.1.3q-.3 1.2.6 2.7l.4.4h.2c.1 0 .2 0 .4.1.2.4 1.2 2.5 3.9.9 2.8-1.5 4.7-4.6 8.1-5.1l-.5-.6c5.9 2.8 12.8 4 19 4.2 8.7.3 18.6-.9 26.5-5.2 2.2.7 3.9 3.9 5.8 5.4l.1.1.1.1.1.1.1.1s.1 0 .1.1c0 0 .1 0 .1.1 0 0 .1 0 .1.1h2.1s.1 0 .1-.1h.1s.1 0 .1-.1h.1s.1 0 .1-.1c0 0 .1 0 .1-.1l.1-.1s.1 0 .1-.1l.1-.1h.1l.2-.2.2-.1h.1l.1-.1h.1l.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-1.4s-.3 0-.3-.1l-.3-.1v-.1l.3-.1s.2 0 .2-.1l.1-.1v-2.1s0-.1-.1-.1v-.1s0-.1-.1-.1v-.1s0-.1-.1-.1c0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1v-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1c2-1.9 3.8-4.2 5.1-6.9 5.9-11.8 4.9-26.2 4.1-39.2h.1c.1 0 .2.1.2.1h.3s.1 0 .1.1h.1s.1 0 .1.1l.2.1c1.7 1.2 5.4 2.9 5.6-.8 1.6.6-.3-1.8-1.3-2.5M36 23C32.8 7 58.4 4 59.3 19.6c.8 13-20 16.3-23.3 3.4m36.1 15c-1.3 1.4-2.7 1.2-4.1.7 0 1.9.4 3.9.1 5.9-.5.9-1.5 1-2.3 1.4-1.2-.2-2.1-.9-2.6-2l-.2-.1c-3.9 5.2-6.3-1.1-5.2-5-1.2.1-2.2-.2-3-1.5-1.4-2.6.7-5.8 3.4-6.3.7 3 8.7 2.6 10.1-.2 3.1 1.5 6.5 4.3 3.8 7.1m-7-17.5c-.9-13.8 20.3-17.5 23.4-4 3.5 15-20.8 18.9-23.4 4M41.7 17c-1.9 0-3.5 1.7-3.5 3.8s1.6 3.8 3.5 3.8 3.5-1.7 3.5-3.8-1.5-3.8-3.5-3.8m1.6 5.7c-.5 0-.8-.4-.8-1 0-.5.4-1 .8-1 .5 0 .8.4.8 1 0 .5-.3 1-.8 1m27.8-6.6c-1.9 0-3.4 1.7-3.4 3.8s1.5 3.8 3.4 3.8 3.4-1.7 3.4-3.8-1.5-3.8-3.4-3.8m1.6 5.6c-.4 0-.8-.4-.8-1 0-.5.4-1 .8-1s.8.4.8 1-.4 1-.8 1",
          },
          null,
          -1,
        ),
      ]
    function wK(e, t) {
      return xo(), Eo("svg", yK, [...OK])
    }
    const xK = { render: wK },
      kK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: xK, render: wK }, Symbol.toStringTag, { value: "Module" }),
      ),
      _K = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      SK = [
        Ro(
          "path",
          {
            d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.564-2.438zm7.031 9.75-.232-2.718 10.059.003.23-2.622L5.412 4.41l.698 8.01h9.126l-.326 3.426-2.91.804-2.955-.81-.188-2.11H6.248l.33 4.171L12 19.351l5.379-1.443.744-8.157z",
          },
          null,
          -1,
        ),
      ]
    function EK(e, t) {
      return xo(), Eo("svg", _K, [...SK])
    }
    const TK = { render: EK },
      AK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: TK, render: EK }, Symbol.toStringTag, { value: "Module" }),
      ),
      CK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      PK = [
        Ro(
          "path",
          {
            d: "M111.7 29.7 128 64l-16.3 34.3H16.3L0 64l16.3-34.3zm-5.5 5.7H20L6.3 64l13.6 28.6h86.3L119.8 64zm-76.3 19v8h9.2v-8.1h4.8v20.4h-4.7v-8.4H30v8.4h-4.8V54.4zm34.3 0v3.8h-6.5v16.5H53V58.2h-6.5v-3.8zm18.3 0v3.8H76v16.5h-4.7V58.2h-6.5v-3.8zm16.1.9c1.2.5 2.3 1.4 3.1 2.6.7 1.2 1.1 2.5 1 3.9.1 1.4-.3 2.7-1 3.9-.7 1.1-1.8 2-3.1 2.6-1.5.6-3.1.9-4.7.9h-4.1v5.6H85V54.4h8.9c1.6 0 3.2.3 4.7.9m-5.1 2.9h-3.8v7.1h3.8q2.1 0 3.3-.9c.8-.6 1.2-1.6 1.1-2.6 0-1.1-.3-2.1-1.1-2.6-.8-.7-1.9-1-3.3-1",
          },
          null,
          -1,
        ),
      ]
    function DK(e, t) {
      return xo(), Eo("svg", CK, [...PK])
    }
    const RK = { render: DK },
      NK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: RK, render: DK }, Symbol.toStringTag, { value: "Module" }),
      ),
      $K = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      IK = [
        Ro(
          "path",
          {
            d: "M11.26 15.27c3.37-.15 7.15-1.09 7-2.21a26 26 0 0 1-4.76.59c-3.62.16-6.58-.24-6.61-.9 0-.2.24-.4.69-.58-2.39-.64-3.67.53-3.69 1.22-.1 1.45 3.22 2.06 7.37 1.88m5.91 1.64a23 23 0 0 1-4.07.5c-3.09.14-5.61-.21-5.64-.77 0-.17.21-.34.59-.49-2-.55-3.13.45-3.15 1-.05 1.24 2.78 1.77 6.33 1.61 2.87-.1 6.25-1 5.94-1.85M3.61 20.8a.93.93 0 0 1 .29-.65c-2.09.1-2.54 1.13-2.51 1.76.07 1.39 4.67 2.31 10 2.05 4.44-.22 9.16-1 9.16-2.34a26.3 26.3 0 0 1-7.2 1.23c-5.35.26-9.67-.66-9.74-2.05",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M22.4 12.65c-.55-1.48-2.67-2.34-4.74-1.57a2.47 2.47 0 0 0-1 .81c1.94-.56 3.83 0 4.34 1.41.45 1.21-.3 2.64-1.72 3.54a1.37 1.37 0 0 0 .92-.13c2.25-1.05 2.8-2.58 2.2-4.06m-9.88-1.38s-3.1-2.19-1.92-4.35S14.37 2.43 13.38 0c0 0 .12 1-3.12 3.91s-2.14 6.33 2.26 7.36",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M15.17 4.83s-4.24 1.51-2.83 3.53c1 1.43 2.13 2 1.42 4 0 0 2.83-1.51.71-3.53s.7-4 .7-4M8.69 19.26c-1.6-.43-2.46.35-2.47.81 0 1 2.18 1.39 5 1.27 2.26-.11 4.73-.95 4.67-1.49a16.6 16.6 0 0 1-3.2.4c-2.43.11-4.41-.16-4.43-.61-.04-.13.13-.26.43-.38",
          },
          null,
          -1,
        ),
      ]
    function MK(e, t) {
      return xo(), Eo("svg", $K, [...IK])
    }
    const LK = { render: MK },
      QK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: LK, render: MK }, Symbol.toStringTag, { value: "Module" }),
      ),
      BK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      jK = [
        Ro(
          "path",
          {
            d: "M0 0h24v24H0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179z",
          },
          null,
          -1,
        ),
      ]
    function UK(e, t) {
      return xo(), Eo("svg", BK, [...jK])
    }
    const FK = { render: UK },
      zK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: FK, render: UK }, Symbol.toStringTag, { value: "Module" }),
      ),
      qK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      ZK = [
        Ro(
          "path",
          {
            d: "M4.56 18.71c-1.41-4-.65-8.94 1.77-11.48A5.47 5.47 0 0 1 12 5.71h.15a.8.8 0 0 1 .22.12c4 1.65 4.28 8.57 1.28 11.41a4.15 4.15 0 0 0 3.08-1.35c2.12-2.23 2.76-6.62 1.49-10.22A7.75 7.75 0 0 0 12.81.54H12a11.5 11.5 0 0 0-5.42 21.6 10 10 0 0 1-2.02-3.43",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M23.5 12a11.49 11.49 0 0 0-6.09-10.14 9.9 9.9 0 0 1 2 3.43c1.41 4 .65 9-1.77 11.5a5.42 5.42 0 0 1-4 1.75A6.5 6.5 0 0 1 12 18.3h-.15a.8.8 0 0 1-.22-.12c-4-1.65-4.29-8.57-1.29-11.41a4.14 4.14 0 0 0-3.11 1.32c-2.12 2.22-2.76 6.61-1.49 10.2a7.77 7.77 0 0 0 5.45 5.17H12A11.5 11.5 0 0 0 23.5 12",
          },
          null,
          -1,
        ),
      ]
    function HK(e, t) {
      return xo(), Eo("svg", qK, [...ZK])
    }
    const VK = { render: HK },
      WK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: VK, render: HK }, Symbol.toStringTag, { value: "Module" }),
      ),
      XK = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      YK = [Ro("path", { d: "M0 0h61.4L0 60.4zm0 128L128 0H64.6L0 63.7zm128 0L64.6 66.6 3.3 128z" }, null, -1)]
    function GK(e, t) {
      return xo(), Eo("svg", XK, [...YK])
    }
    const KK = { render: GK },
      JK = Object.freeze(
        Object.defineProperty({ __proto__: null, default: KK, render: GK }, Symbol.toStringTag, { value: "Module" }),
      ),
      eJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      tJ = [
        Ro(
          "path",
          {
            d: "M21.75 5.52 13 .28a2 2 0 0 0-2 0L2.25 5.52a2 2 0 0 0-1 1.69v9.58a2 2 0 0 0 1 1.69l2.62 1.57a3.12 3.12 0 0 0 4.73-2.68V8.12a1 1 0 0 0-2 0v9.25a1.13 1.13 0 0 1-.57 1 1.14 1.14 0 0 1-1.13 0l-2.61-1.58V7.24L12 2l8.73 5.21v9.55L12 22l-1.7-1a1 1 0 1 0-1 1.71l1.72 1a2 2 0 0 0 2 0l8.74-5.24a2 2 0 0 0 1-1.69V7.21a2 2 0 0 0-1.01-1.69",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M15.51 14.76a9.3 9.3 0 0 1-2.24 0 .85.85 0 0 1-.75-.85 1 1 0 0 0-2 0A2.87 2.87 0 0 0 13 16.75a12 12 0 0 0 1.36.08 12 12 0 0 0 1.37-.08 2.87 2.87 0 0 0 2.5-2.84A2.68 2.68 0 0 0 16 11.26l-2.91-.49a.69.69 0 0 1-.58-.68.85.85 0 0 1 .75-.85 9.3 9.3 0 0 1 2.24 0 .85.85 0 0 1 .75.85 1 1 0 0 0 2 0 2.87 2.87 0 0 0-2.5-2.84 12.5 12.5 0 0 0-2.73 0 2.87 2.87 0 0 0-2.51 2.84 2.68 2.68 0 0 0 2.25 2.65l2.91.49a.68.68 0 0 1 .58.68.85.85 0 0 1-.74.85",
          },
          null,
          -1,
        ),
      ]
    function nJ(e, t) {
      return xo(), Eo("svg", eJ, [...tJ])
    }
    const rJ = { render: nJ },
      aJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: rJ, render: nJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      oJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      iJ = [
        Ro(
          "path",
          {
            d: "M63.877 125.392c-32.671 0-60.37-27.594-60.627-60.469a59.94 59.94 0 0 1 17.506-42.759 60.94 60.94 0 0 1 43.279-18.36 60.08 60.08 0 0 1 42.647 17.71 60.15 60.15 0 0 1 18.157 42.522c.151 33.604-26.864 61.021-60.469 61.363h-.493zm.19-118.406a57.77 57.77 0 0 0-41.01 17.427 56.78 56.78 0 0 0-16.63 40.484c.236 31.159 26.495 57.286 57.43 57.286h.414c31.863-.29 57.504-26.266 57.385-58.128a56.97 56.97 0 0 0-17.217-40.273A56.7 56.7 0 0 0 64.068 6.986z",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            d: "M16.89 82.383V46.865h8.64v3.183h-4.583v29.218h4.584v3.183zm29.323-18.111c0 6.478-3.933 10.167-9.26 10.167s-8.877-4.156-8.877-9.831c0-5.939 3.722-10.121 9.167-10.121s8.97 4.36 8.97 9.785m-14.415.29c0 3.932 1.973 7.05 5.36 7.05s5.333-3.183 5.333-7.195c0-3.643-1.796-7.083-5.334-7.083s-5.392 3.328-5.392 7.307zm17.407-9.404c1.69-.29 3.407-.434 5.123-.428a9.17 9.17 0 0 1 5.537 1.223 4.06 4.06 0 0 1 2.006 3.61 4.48 4.48 0 0 1-3.183 4.183c2.269.46 3.9 2.46 3.9 4.775a5.02 5.02 0 0 1-1.861 3.978c-1.368 1.21-3.643 1.796-7.162 1.796a34 34 0 0 1-4.327-.257zm3.499 7.622h1.795c2.433 0 3.801-1.145 3.801-2.782s-1.368-2.644-3.61-2.644a9.8 9.8 0 0 0-2.006.145zm0 8.878c.618.065 1.243.092 1.86.078 2.263 0 4.262-.861 4.262-3.182s-1.94-3.183-4.373-3.183h-1.75zM69.54 54.901h3.517v12.554c0 5.334-2.577 7.116-6.365 7.116a9.3 9.3 0 0 1-2.973-.507l.428-2.834c.703.224 1.44.335 2.183.349 2.006 0 3.183-.921 3.183-4.262l.026-12.416zm13.527 10.456v2.434h-7.32v-2.434zm17.091 8.273a12.3 12.3 0 0 1-4.978.862c-6.129 0-9.851-3.834-9.851-9.707-.283-5.353 3.827-9.923 9.18-10.206.375-.02.757-.02 1.131.006a11.1 11.1 0 0 1 4.775.862l-.783 2.801a9.5 9.5 0 0 0-3.788-.75c-3.932 0-6.76 2.467-6.76 7.116 0 4.235 2.499 6.971 6.734 6.971a9.8 9.8 0 0 0 3.834-.717zM111.2 46.766v35.61h-8.641v-3.182h4.583V49.949h-4.583v-3.183h8.64z",
          },
          null,
          -1,
        ),
      ]
    function sJ(e, t) {
      return xo(), Eo("svg", oJ, [...iJ])
    }
    const lJ = { render: sJ },
      cJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: lJ, render: sJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      dJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      uJ = [
        Ro(
          "path",
          {
            d: "M65.004 115.355c-.461-.894-1.004-2.796-1.356-3.601-.378-.711-1.46-2.692-1.984-3.332-1.164-1.332-1.437-1.438-1.809-3.23-.628-3.067-2.148-8.462-4.042-12.227-1.004-2-2.626-3.606-4.067-5.07-1.246-1.247-4.121-3.31-4.668-3.227-4.766.894-6.226 5.586-8.457 9.27-1.27 2.062-2.516 3.769-3.52 5.937-.898 1.98-.812 4.23-2.331 5.938a15.4 15.4 0 0 0-3.333 5.855c-.195.453-.546 4.957-1.003 6.016l7.02-.438c6.585.461 4.687 2.961 14.858 2.438l16.098-.54a25 25 0 0 0-1.433-3.792zM111.793 8.254H16.207C7.312 8.23.086 15.457.086 24.352v35.105c2.352-.812 5.578-5.75 6.668-6.934 1.789-2.062 2.16-4.77 3.059-6.378 2.062-3.793 2.433-6.477 7.101-6.477 2.164 0 3.063.516 4.5 2.516.996 1.332 2.79 3.957 3.602 5.668 1.004 1.98 2.523 4.582 3.254 5.125.515.351.972.722 1.433.894.707.27 1.356-.27 1.902-.629.622-.539.895-1.52 1.52-2.953.895-2.086 1.813-4.418 2.332-5.312.914-1.461 1.273-3.254 2.25-4.067 1.461-1.246 3.441-1.355 3.957-1.437 2.98-.625 4.336 1.437 5.777 2.707.973.894 2.243 2.605 3.246 4.851.708 1.793 1.606 3.52 2.067 4.5.351.98 1.266 2.606 1.789 4.582.543 1.711 1.809 3.067 2.352 3.961 0 0 .812 2.164 5.476 4.145a35 35 0 0 0 4.336 1.52c2.066.734 4.047.644 6.563.374 1.789 0 2.793-2.625 3.601-4.683.438-1.254.98-4.774 1.25-5.758.27-.996-.437-1.707.192-2.625.722-.977 1.164-1.082 1.519-2.332.914-2.793 5.957-2.875 8.832-2.875 2.414 0 2.063 2.332 6.125 1.52 2.336-.434 4.586.273 7.023.995 2.063.543 4.043 1.168 5.204 2.524.73.898 2.629 5.312.73 5.476.164.188.36.645.625.817-.46 1.707-2.25.46-3.332.27-1.355-.27-2.332 0-3.684.624-2.335.996-5.668.918-7.726 2.625-1.715 1.438-1.715 4.582-2.543 6.371 0 0-2.254 5.696-6.996 9.192-1.278.914-3.715 3.058-8.918 3.871-2.356.355-4.586.355-7.024.27-1.164-.079-2.332-.079-3.52-.079-.706 0-3.062-.109-2.96.164l-.27.645c.024.29.063.602.164.895.102.515.102.976.192 1.437 0 .98-.086 2.063 0 3.066.082 2.063.894 3.957 1.004 6.102.078 2.355 1.246 4.875 2.414 6.77.46.707 1.086.789 1.355 1.71.352.98 0 2.141.188 3.227.625 4.227 1.875 8.73 3.773 12.61v.078c2.332-.352 4.77-1.247 7.836-1.684 5.664-.832 13.5-.461 18.54-.914 12.796-1.168 19.706 5.226 31.148 2.601V24.336c-.063-8.895-7.293-16.102-16.207-16.102zM64.086 83.855q0-.28 0 0m-34.457 14.75c.894-1.98 1.433-4.125 2.144-6.101.73-1.899 1.813-4.61 3.684-5.582-.246-.274-3.957-.375-4.934-.461-1.082-.086-2.171-.273-3.25-.438a135 135 0 0 1-6.125-1.265c-1.168-.274-5.21-1.715-6.02-2.067-2.085-.894-3.421-3.52-4.96-3.246-.977.188-1.98.54-2.605 1.54-.543.812-.731 2.242-1.083 3.226-.437 1.086-1.168 2.164-1.707 3.25-1.277 1.875-3.332 3.582-4.23 5.484-.191.457-.27.895-.457 1.356v21.683c1.082.188 2.16.371 3.328.73 8.996 2.438 11.164 2.606 19.98 1.63l.813-.11c.625-1.437 1.188-6.207 1.629-7.644.352-1.164.812-2.063.996-3.14.164-1.09 0-2.173-.102-3.15-.171-2.628 1.895-3.519 2.899-5.69zm0 0",
          },
          null,
          -1,
        ),
      ]
    function pJ(e, t) {
      return xo(), Eo("svg", dJ, [...uJ])
    }
    const hJ = { render: pJ },
      fJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: hJ, render: pJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      mJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      gJ = [
        Ro(
          "path",
          {
            d: "M7.01 10.207h-.944l-.515 2.648h.838q.834 0 1.242-.314.408-.315.55-1.049.137-.705-.124-.995-.262-.29-1.047-.29M12 5.688C5.373 5.688 0 8.514 0 12s5.373 6.313 12 6.313S24 15.486 24 12s-5.373-6.312-12-6.312m-3.26 7.451c-.261.25-.575.438-.917.551q-.505.163-1.285.164H5.357l-.327 1.681H3.652l1.23-6.326h2.65q1.195 0 1.744.628.549.627.33 1.752a2.8 2.8 0 0 1-.305.847q-.215.383-.561.703m4.024.715.543-2.799q.094-.478-.068-.651-.16-.174-.687-.174H11.46l-.704 3.625H9.388l1.23-6.327h1.367l-.327 1.682h1.218q1.15 0 1.586.401c.436.401.378.7.263 1.299l-.572 2.944zm7.597-2.265a2.8 2.8 0 0 1-.305.847q-.214.383-.561.703a2.44 2.44 0 0 1-.917.551q-.504.163-1.286.164h-1.18l-.327 1.682h-1.378l1.23-6.326h2.649q1.195 0 1.744.628.55.626.331 1.751m-2.595-1.382h-.943l-.516 2.648h.838q.835 0 1.242-.314.407-.315.551-1.049.137-.705-.125-.995c-.262-.29-.524-.29-1.047-.29",
          },
          null,
          -1,
        ),
      ]
    function bJ(e, t) {
      return xo(), Eo("svg", mJ, [...gJ])
    }
    const vJ = { render: bJ },
      yJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: vJ, render: bJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      OJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 121 121" },
      wJ = [
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M73.7 58.9c-1.5-1.8-3.2-3.9-5-5.9C58.5 41.7 48.4 30.3 38 19.2c-4.7-5.1-6.2-10-.6-15.1C43-.9 48.5-.4 53.7 5.3 68.1 21.2 82.4 37.2 97 52.9c5.5 5.9 4.2 9.9-1.8 14.2-23 16.7-46 33.5-68.9 50.4-5.1 3.8-10.1 4.8-14.2-.9-4.6-6.2-.3-9.9 4.4-13.3 17-12.4 34-24.8 50.9-37.4 2.5-1.7 5.9-2.8 6.3-7m7.3 59.8c-6.2 0-12.4.2-18.6-.1-4.9-.2-7.9-3-7.8-8.2.1-4.9 2.5-8.6 7.5-8.7 13.5-.4 27.1-.3 40.7 0 4.3.1 7.5 2.9 7.5 7.4 0 5.1-2.7 9.1-8.2 9.5-7.2.4-14.2.1-21.1.1",
            "clip-rule": "evenodd",
          },
          null,
          -1,
        ),
      ]
    function xJ(e, t) {
      return xo(), Eo("svg", OJ, [...wJ])
    }
    const kJ = { render: xJ },
      _J = Object.freeze(
        Object.defineProperty({ __proto__: null, default: kJ, render: xJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      SJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      EJ = [
        Ro(
          "path",
          {
            d: "m14.25.18.9.2.73.26.59.3.45.32.34.34.25.34.16.33.1.3.04.26.02.2-.01.13V8.5l-.05.63-.13.55-.21.46-.26.38-.3.31-.33.25-.35.19-.35.14-.33.1-.3.07-.26.04-.21.02H8.77l-.69.05-.59.14-.5.22-.41.27-.33.32-.27.35-.2.36-.15.37-.1.35-.07.32-.04.27-.02.21v3.06H3.17l-.21-.03-.28-.07-.32-.12-.35-.18-.36-.26-.36-.36-.35-.46-.32-.59-.28-.73-.21-.88-.14-1.05-.05-1.23.06-1.22.16-1.04.24-.87.32-.71.36-.57.4-.44.42-.33.42-.24.4-.16.36-.1.32-.05.24-.01h.16l.06.01h8.16v-.83H6.18l-.01-2.75-.02-.37.05-.34.11-.31.17-.28.25-.26.31-.23.38-.2.44-.18.51-.15.58-.12.64-.1.71-.06.77-.04.84-.02 1.27.05zm-6.3 1.98-.23.33-.08.41.08.41.23.34.33.22.41.09.41-.09.33-.22.23-.34.08-.41-.08-.41-.23-.33-.33-.22-.41-.09-.41.09zm13.09 3.95.28.06.32.12.35.18.36.27.36.35.35.47.32.59.28.73.21.88.14 1.04.05 1.23-.06 1.23-.16 1.04-.24.86-.32.71-.36.57-.4.45-.42.33-.42.24-.4.16-.36.09-.32.05-.24.02-.16-.01h-8.22v.82h5.84l.01 2.76.02.36-.05.34-.11.31-.17.29-.25.25-.31.24-.38.2-.44.17-.51.15-.58.13-.64.09-.71.07-.77.04-.84.01-1.27-.04-1.07-.14-.9-.2-.73-.25-.59-.3-.45-.33-.34-.34-.25-.34-.16-.33-.1-.3-.04-.25-.02-.2.01-.13v-5.34l.05-.64.13-.54.21-.46.26-.38.3-.32.33-.24.35-.2.35-.14.33-.1.3-.06.26-.04.21-.02.13-.01h5.84l.69-.05.59-.14.5-.21.41-.28.33-.32.27-.35.2-.36.15-.36.1-.35.07-.32.04-.28.02-.21V6.07h2.09l.14.01zm-6.47 14.25-.23.33-.08.41.08.41.23.33.33.23.41.08.41-.08.33-.23.23-.33.08-.41-.08-.41-.23-.33-.33-.23-.41-.08-.41.08z",
          },
          null,
          -1,
        ),
      ]
    function TJ(e, t) {
      return xo(), Eo("svg", SJ, [...EJ])
    }
    const AJ = { render: TJ },
      CJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: AJ, render: TJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      PJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      DJ = [
        Ro(
          "path",
          {
            d: "M64 14.648c-35.346 0-64 19.19-64 42.863C0 78.275 22.046 95.589 51.316 99.53V86.699c-15.55-4.89-26.166-14.693-26.166-25.991 0-16.183 21.779-29.303 48.646-29.303 26.866 0 46.693 8.975 46.693 29.303 0 10.486-5.273 17.95-14.066 22.72 1.204.908 2.22 2.072 2.904 3.419l.388.655C121.025 79.772 128 69.189 128 57.51c0-23.672-28.654-42.863-64-42.863zm20.1 74.88c-2.612.257-5.322.41-8.114.462l.002 9.63a88 88 0 0 0 12.474-2.492l-.501-.941c-.68-1.268-1.347-2.543-2.033-3.807a41 41 0 0 0-1.828-2.851z",
          },
          null,
          -1,
        ),
        Ro(
          "path",
          {
            "fill-rule": "evenodd",
            d: "M97.469 81.036s3.874 1.169 6.124 2.307c.78.396 2.132 1.184 3.106 2.22a8.4 8.4 0 0 1 1.42 2.04l15.266 25.74-24.674.01-11.537-21.666s-2.363-4.06-3.817-5.237c-1.213-.982-1.73-1.331-2.929-1.331h-5.862l.004 28.219-21.834.009V41.263h43.845s19.97.36 19.97 19.359S97.47 81.035 97.47 81.035zm-9.497-24.137-13.218-.009-.006 12.257 13.224-.004s6.124-.019 6.124-6.235c0-6.34-6.124-6.01-6.124-6.01z",
          },
          null,
          -1,
        ),
      ]
    function RJ(e, t) {
      return xo(), Eo("svg", PJ, [...DJ])
    }
    const NJ = { render: RJ },
      $J = Object.freeze(
        Object.defineProperty({ __proto__: null, default: NJ, render: RJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      IJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      MJ = [
        Ro(
          "path",
          {
            d: "M20.156.083c3.033.525 3.893 2.598 3.829 4.77L24 4.822 22.635 22.71 4.89 23.926h.016C3.433 23.864.15 23.729 0 19.139l1.645-3 2.819 6.586.503 1.172 2.805-9.144-.03.007.016-.03 9.255 2.956-1.396-5.431-.99-3.9 8.82-.569-.615-.51L16.5 2.114 20.159.073zM5.13 5.073c3.561-3.533 8.157-5.621 9.922-3.84 1.762 1.777-.105 6.105-3.673 9.636-3.563 3.532-8.103 5.734-9.864 3.957-1.766-1.777.045-6.217 3.612-9.75z",
          },
          null,
          -1,
        ),
      ]
    function LJ(e, t) {
      return xo(), Eo("svg", IJ, [...MJ])
    }
    const QJ = { render: LJ },
      BJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: QJ, render: LJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      jJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      UJ = [
        Ro(
          "path",
          {
            d: "M4.589 24c4.537 0 13.81-1.516 14.821-3v-5.729c-.957 1.408-10.284 2.912-14.821 2.912zm0-7.635c4.537 0 13.81-1.516 14.821-3V7.636c-.957 1.408-10.284 2.912-14.821 2.912zm0-7.636c4.537 0 13.81-1.516 14.821-3V0C18.453 1.408 9.126 2.912 4.589 2.912z",
          },
          null,
          -1,
        ),
      ]
    function FJ(e, t) {
      return xo(), Eo("svg", jJ, [...UJ])
    }
    const zJ = { render: FJ },
      qJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: zJ, render: FJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      ZJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 17 17" },
      HJ = [Ro("path", { d: "m2.4 11.4 5.1-4.6-5.1-4.7L.7 3.7l3.4 3v.1l-3.4 3zm14.2 3.3v-2.2h-8v2.2z" }, null, -1)]
    function VJ(e, t) {
      return xo(), Eo("svg", ZJ, [...HJ])
    }
    const WJ = { render: VJ },
      XJ = Object.freeze(
        Object.defineProperty({ __proto__: null, default: WJ, render: VJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      YJ = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 128 128" },
      GJ = [
        Ro(
          "path",
          {
            d: "M117.3 87.3c.2-.6.4-1.3.5-1.9 7-28-10.1-61.2-39.2-78.6C91.4 24 97 44.9 92 63.2c-.4 1.6-1 3.2-1.6 4.7-.6-.4-1.5-.9-2.5-1.5 0 0-28.9-17.9-60.2-49.4-.9-.8 16.7 25 36.6 46.1-9.4-5.3-35.5-24.3-52-39.4 2 3.4 4.4 6.7 7.1 9.8C33.1 51 51.2 72.6 72.7 89.2c-15.2 9.3-36.6 10-57.9 0C9.5 86.7 4.6 83.7 0 80.3c9 14.4 22.9 26.9 39.9 34.2 20.2 8.7 40.3 8.1 55.2.1.1 0 .1-.1.2-.1.7-.4 1.3-.7 2-1.1 7.2-3.7 21.3-7.4 28.9 7.4 1.7 3.6 5.7-15.6-8.9-33.5",
          },
          null,
          -1,
        ),
      ]
    function KJ(e, t) {
      return xo(), Eo("svg", YJ, [...GJ])
    }
    const JJ = { render: KJ },
      e0 = Object.freeze(
        Object.defineProperty({ __proto__: null, default: JJ, render: KJ }, Symbol.toStringTag, { value: "Module" }),
      ),
      t0 = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      n0 = [
        Ro(
          "path",
          {
            d: "M1.125 0C.502 0 0 .502 0 1.125v21.75C0 23.498.502 24 1.125 24h21.75c.623 0 1.125-.502 1.125-1.125V1.125C24 .502 23.498 0 22.875 0zm17.363 9.75q.918 0 1.627.111a6.4 6.4 0 0 1 1.306.34v2.458a4 4 0 0 0-.643-.361 5 5 0 0 0-.717-.26 5.5 5.5 0 0 0-1.426-.2q-.45 0-.819.086a2.1 2.1 0 0 0-.623.242q-.254.156-.393.374a.9.9 0 0 0-.14.49q0 .294.156.529.156.234.443.444c.287.21.423.276.696.41q.41.203.926.416.705.296 1.266.628.561.333.963.753.402.418.614.957.213.538.214 1.253 0 .986-.373 1.656a3 3 0 0 1-1.012 1.085 4.4 4.4 0 0 1-1.487.596q-.85.18-1.79.18a10 10 0 0 1-1.84-.164 5.5 5.5 0 0 1-1.512-.493v-2.63a5.03 5.03 0 0 0 3.237 1.2q.5 0 .872-.09.373-.09.623-.25.249-.162.373-.38a1.02 1.02 0 0 0-.074-1.089 2.1 2.1 0 0 0-.537-.5 5.6 5.6 0 0 0-.807-.444 28 28 0 0 0-1.007-.436q-1.377-.575-2.053-1.405t-.676-2.005q0-.92.369-1.582.368-.662 1.004-1.089a4.5 4.5 0 0 1 1.47-.629 7.5 7.5 0 0 1 1.77-.201m-15.113.188h9.563v2.166H9.506v9.646H6.789v-9.646H3.375z",
          },
          null,
          -1,
        ),
      ]
    function r0(e, t) {
      return xo(), Eo("svg", t0, [...n0])
    }
    const a0 = { render: r0 },
      o0 = Object.freeze(
        Object.defineProperty({ __proto__: null, default: a0, render: r0 }, Symbol.toStringTag, { value: "Module" }),
      ),
      i0 = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
      s0 = [
        Ro(
          "path",
          {
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M7.8 4.6 1.4 11c-.6.6-.6 1.6 0 2l6.2 6.2m8.6-14.6 6.2 6.2c.6.6.6 1.6 0 2l-6.2 6.6",
          },
          null,
          -1,
        ),
      ]
    function l0(e, t) {
      return xo(), Eo("svg", i0, [...s0])
    }
    const c0 = { render: l0 },
      d0 = Object.freeze(
        Object.defineProperty({ __proto__: null, default: c0, render: l0 }, Symbol.toStringTag, { value: "Module" }),
      ),
      u0 = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      p0 = [
        Ro(
          "path",
          {
            d: "M23.55 10.91 13.09.45a1.55 1.55 0 0 0-2.18 0L8.46 2.9 11 5.48a2.06 2.06 0 0 1 1-.23 2.25 2.25 0 0 1 2.25 2.25 2.2 2.2 0 0 1-.22 1l2.19 2.2a2 2 0 1 1-1.06 1.06L13 9.52a1 1 0 0 1-.21.09v5.54a2 2 0 1 1-1.5 0V9.61A2.24 2.24 0 0 1 9.75 7.5a2.2 2.2 0 0 1 .22-1L7.4 4 .45 11a1.55 1.55 0 0 0 0 2.18l10.46 10.37a1.55 1.55 0 0 0 2.18 0l10.46-10.46a1.55 1.55 0 0 0 0-2.18",
          },
          null,
          -1,
        ),
      ]
    function h0(e, t) {
      return xo(), Eo("svg", u0, [...p0])
    }
    const f0 = { render: h0 },
      m0 = Object.freeze(
        Object.defineProperty({ __proto__: null, default: f0, render: h0 }, Symbol.toStringTag, { value: "Module" }),
      ),
      g0 = { xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", viewBox: "0 0 24 24" },
      b0 = [
        Ro(
          "path",
          {
            d: "M12.001 4.8q-4.8 0-6 4.8 1.8-2.4 4.2-1.8c.913.228 1.565.89 2.288 1.624C13.666 10.618 15.027 12 18.001 12q4.8 0 6-4.8-1.8 2.4-4.2 1.8c-.913-.228-1.565-.89-2.288-1.624C16.337 6.182 14.976 4.8 12.001 4.8m-6 7.2q-4.8 0-6 4.8 1.8-2.4 4.2-1.8c.913.228 1.565.89 2.288 1.624 1.177 1.194 2.538 2.576 5.512 2.576q4.8 0 6-4.8-1.8 2.4-4.2 1.8c-.913-.228-1.565-.89-2.288-1.624C10.337 13.382 8.976 12 6.001 12",
          },
          null,
          -1,
        ),
      ]
    function v0(e, t) {
      return xo(), Eo("svg", g0, [...b0])
    }
    const y0 = { render: v0 },
      O0 = Object.freeze(
        Object.defineProperty({ __proto__: null, default: y0, render: v0 }, Symbol.toStringTag, { value: "Module" }),
      ),
      w0 = "undefined" != typeof document,
      x0 = Object.assign
    function k0(e, t) {
      const n = {}
      for (const r in t) {
        const a = t[r]
        n[r] = S0(a) ? a.map(e) : e(a)
      }
      return n
    }
    const _0 = () => {},
      S0 = Array.isArray,
      E0 = /#/g,
      T0 = /&/g,
      A0 = /\//g,
      C0 = /=/g,
      P0 = /\?/g,
      D0 = /\+/g,
      R0 = /%5B/g,
      N0 = /%5D/g,
      $0 = /%5E/g,
      I0 = /%60/g,
      M0 = /%7B/g,
      L0 = /%7C/g,
      Q0 = /%7D/g,
      B0 = /%20/g
    function j0(e) {
      return encodeURI("" + e)
        .replace(L0, "|")
        .replace(R0, "[")
        .replace(N0, "]")
    }
    function U0(e) {
      return j0(e)
        .replace(D0, "%2B")
        .replace(B0, "+")
        .replace(E0, "%23")
        .replace(T0, "%26")
        .replace(I0, "`")
        .replace(M0, "{")
        .replace(Q0, "}")
        .replace($0, "^")
    }
    function F0(e) {
      return null == e
        ? ""
        : (function (e) {
            return j0(e).replace(E0, "%23").replace(P0, "%3F")
          })(e).replace(A0, "%2F")
    }
    function z0(e) {
      try {
        return decodeURIComponent("" + e)
      } catch (e) {}
      return "" + e
    }
    const q0 = /\/$/
    function Z0(e, t, n = "/") {
      let r,
        a = {},
        o = "",
        i = ""
      const s = t.indexOf("#")
      let l = t.indexOf("?")
      return (
        s < l && s >= 0 && (l = -1),
        l > -1 && ((r = t.slice(0, l)), (o = t.slice(l + 1, s > -1 ? s : t.length)), (a = e(o))),
        s > -1 && ((r = r || t.slice(0, s)), (i = t.slice(s, t.length))),
        (r = (function (e, t) {
          if (e.startsWith("/")) return e
          if (!e) return t
          const n = t.split("/"),
            r = e.split("/"),
            a = r[r.length - 1]
          ;(".." !== a && "." !== a) || r.push("")
          let o,
            i,
            s = n.length - 1
          for (o = 0; o < r.length; o++)
            if (((i = r[o]), "." !== i)) {
              if (".." !== i) break
              s > 1 && s--
            }
          return n.slice(0, s).join("/") + "/" + r.slice(o).join("/")
        })(null != r ? r : t, n)),
        { fullPath: r + (o && "?") + o + i, path: r, query: a, hash: z0(i) }
      )
    }
    function H0(e, t) {
      return t && e.toLowerCase().startsWith(t.toLowerCase()) ? e.slice(t.length) || "/" : e
    }
    function V0(e, t) {
      return (e.aliasOf || e) === (t.aliasOf || t)
    }
    function W0(e, t) {
      if (Object.keys(e).length !== Object.keys(t).length) return !1
      for (const n in e) if (!X0(e[n], t[n])) return !1
      return !0
    }
    function X0(e, t) {
      return S0(e) ? Y0(e, t) : S0(t) ? Y0(t, e) : e === t
    }
    function Y0(e, t) {
      return S0(t) ? e.length === t.length && e.every((e, n) => e === t[n]) : 1 === e.length && e[0] === t
    }
    var G0, K0, J0, e1
    function t1(e) {
      if (!e)
        if (w0) {
          const t = document.querySelector("base")
          e = (e = (t && t.getAttribute("href")) || "/").replace(/^\w+:\/\/[^\/]+/, "")
        } else e = "/"
      return "/" !== e[0] && "#" !== e[0] && (e = "/" + e), ((e) => e.replace(q0, ""))(e)
    }
    ;((K0 = G0 || (G0 = {})).pop = "pop"),
      (K0.push = "push"),
      ((e1 = J0 || (J0 = {})).back = "back"),
      (e1.forward = "forward"),
      (e1.unknown = "")
    const n1 = /^[^#]+#/
    function r1(e, t) {
      return e.replace(n1, "#") + t
    }
    const a1 = () => ({ left: window.scrollX, top: window.scrollY })
    function o1(e, t) {
      return (history.state ? history.state.position - t : -1) + e
    }
    const i1 = new Map()
    function s1(e, t) {
      const { pathname: n, search: r, hash: a } = t,
        o = e.indexOf("#")
      if (o > -1) {
        let t = a.includes(e.slice(o)) ? e.slice(o).length : 1,
          n = a.slice(t)
        return "/" !== n[0] && (n = "/" + n), H0(n, "")
      }
      return H0(n, e) + r + a
    }
    function l1(e, t, n, r = !1, a = !1) {
      return { back: e, current: t, forward: n, replaced: r, position: window.history.length, scroll: a ? a1() : null }
    }
    function c1(e) {
      return "string" == typeof e || "symbol" == typeof e
    }
    const d1 = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0,
      },
      u1 = Symbol("")
    var p1, h1
    function f1(e, t) {
      return x0(new Error(), { type: e, [u1]: !0 }, t)
    }
    function m1(e, t) {
      return e instanceof Error && u1 in e && (null == t || !!(e.type & t))
    }
    ;((h1 = p1 || (p1 = {}))[(h1.aborted = 4)] = "aborted"),
      (h1[(h1.cancelled = 8)] = "cancelled"),
      (h1[(h1.duplicated = 16)] = "duplicated")
    const g1 = "[^/]+?",
      b1 = { sensitive: !1, strict: !1, start: !0, end: !0 },
      v1 = /[.+*?^${}()[\]/\\]/g
    function y1(e, t) {
      let n = 0
      for (; n < e.length && n < t.length; ) {
        const r = t[n] - e[n]
        if (r) return r
        n++
      }
      return e.length < t.length
        ? 1 === e.length && 80 === e[0]
          ? -1
          : 1
        : e.length > t.length
          ? 1 === t.length && 80 === t[0]
            ? 1
            : -1
          : 0
    }
    function O1(e, t) {
      let n = 0
      const r = e.score,
        a = t.score
      for (; n < r.length && n < a.length; ) {
        const e = y1(r[n], a[n])
        if (e) return e
        n++
      }
      if (1 === Math.abs(a.length - r.length)) {
        if (w1(r)) return 1
        if (w1(a)) return -1
      }
      return a.length - r.length
    }
    function w1(e) {
      const t = e[e.length - 1]
      return e.length > 0 && t[t.length - 1] < 0
    }
    const x1 = { type: 0, value: "" },
      k1 = /[a-zA-Z0-9_]/
    function _1(e, t, n) {
      const r = (function (e, t) {
          const n = x0({}, b1, t),
            r = []
          let a = n.start ? "^" : ""
          const o = []
          for (const t of e) {
            const e = t.length ? [] : [90]
            n.strict && !t.length && (a += "/")
            for (let r = 0; r < t.length; r++) {
              const i = t[r]
              let s = 40 + (n.sensitive ? 0.25 : 0)
              if (0 === i.type) r || (a += "/"), (a += i.value.replace(v1, "\\$&")), (s += 40)
              else if (1 === i.type) {
                const { value: e, repeatable: n, optional: l, regexp: c } = i
                o.push({ name: e, repeatable: n, optional: l })
                const d = c || g1
                if (d !== g1) {
                  s += 10
                  try {
                    new RegExp(`(${d})`)
                  } catch (t) {
                    throw new Error(`Invalid custom RegExp for param "${e}" (${d}): ` + t.message)
                  }
                }
                let u = n ? `((?:${d})(?:/(?:${d}))*)` : `(${d})`
                r || (u = l && t.length < 2 ? `(?:/${u})` : "/" + u),
                  l && (u += "?"),
                  (a += u),
                  (s += 20),
                  l && (s += -8),
                  n && (s += -20),
                  ".*" === d && (s += -50)
              }
              e.push(s)
            }
            r.push(e)
          }
          if (n.strict && n.end) {
            const e = r.length - 1
            r[e][r[e].length - 1] += 0.7000000000000001
          }
          n.strict || (a += "/?"), n.end ? (a += "$") : n.strict && (a += "(?:/|$)")
          const i = new RegExp(a, n.sensitive ? "" : "i")
          return {
            re: i,
            score: r,
            keys: o,
            parse: function (e) {
              const t = e.match(i),
                n = {}
              if (!t) return null
              for (let e = 1; e < t.length; e++) {
                const r = t[e] || "",
                  a = o[e - 1]
                n[a.name] = r && a.repeatable ? r.split("/") : r
              }
              return n
            },
            stringify: function (t) {
              let n = "",
                r = !1
              for (const a of e) {
                ;(r && n.endsWith("/")) || (n += "/"), (r = !1)
                for (const e of a)
                  if (0 === e.type) n += e.value
                  else if (1 === e.type) {
                    const { value: o, repeatable: i, optional: s } = e,
                      l = o in t ? t[o] : ""
                    if (S0(l) && !i)
                      throw new Error(`Provided param "${o}" is an array but it is not repeatable (* or + modifiers)`)
                    const c = S0(l) ? l.join("/") : l
                    if (!c) {
                      if (!s) throw new Error(`Missing required param "${o}"`)
                      a.length < 2 && (n.endsWith("/") ? (n = n.slice(0, -1)) : (r = !0))
                    }
                    n += c
                  }
              }
              return n || "/"
            },
          }
        })(
          (function (e) {
            if (!e) return [[]]
            if ("/" === e) return [[x1]]
            if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`)
            function t(e) {
              throw new Error(`ERR (${n})/"${c}": ${e}`)
            }
            let n = 0,
              r = n
            const a = []
            let o
            function i() {
              o && a.push(o), (o = [])
            }
            let s,
              l = 0,
              c = "",
              d = ""
            function u() {
              c &&
                (0 === n
                  ? o.push({ type: 0, value: c })
                  : 1 === n || 2 === n || 3 === n
                    ? (o.length > 1 &&
                        ("*" === s || "+" === s) &&
                        t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
                      o.push({
                        type: 1,
                        value: c,
                        regexp: d,
                        repeatable: "*" === s || "+" === s,
                        optional: "*" === s || "?" === s,
                      }))
                    : t("Invalid state to consume buffer"),
                (c = ""))
            }
            function p() {
              c += s
            }
            for (; l < e.length; )
              if (((s = e[l++]), "\\" !== s || 2 === n))
                switch (n) {
                  case 0:
                    "/" === s ? (c && u(), i()) : ":" === s ? (u(), (n = 1)) : p()
                    break
                  case 4:
                    p(), (n = r)
                    break
                  case 1:
                    "(" === s ? (n = 2) : k1.test(s) ? p() : (u(), (n = 0), "*" !== s && "?" !== s && "+" !== s && l--)
                    break
                  case 2:
                    ")" === s ? ("\\" == d[d.length - 1] ? (d = d.slice(0, -1) + s) : (n = 3)) : (d += s)
                    break
                  case 3:
                    u(), (n = 0), "*" !== s && "?" !== s && "+" !== s && l--, (d = "")
                    break
                  default:
                    t("Unknown state")
                }
              else (r = n), (n = 4)
            return 2 === n && t(`Unfinished custom RegExp for param "${c}"`), u(), i(), a
          })(e.path),
          n,
        ),
        a = x0(r, { record: e, parent: t, children: [], alias: [] })
      return t && !a.record.aliasOf == !t.record.aliasOf && t.children.push(a), a
    }
    function S1(e, t) {
      const n = {}
      for (const r of t) r in e && (n[r] = e[r])
      return n
    }
    function E1(e) {
      const t = {},
        n = e.props || !1
      if ("component" in e) t.default = n
      else for (const r in e.components) t[r] = "object" == typeof n ? n[r] : n
      return t
    }
    function T1(e) {
      for (; e; ) {
        if (e.record.aliasOf) return !0
        e = e.parent
      }
      return !1
    }
    function A1(e) {
      return e.reduce((e, t) => x0(e, t.meta), {})
    }
    function C1(e, t) {
      const n = {}
      for (const r in e) n[r] = r in t ? t[r] : e[r]
      return n
    }
    function P1({ record: e }) {
      return !!(e.name || (e.components && Object.keys(e.components).length) || e.redirect)
    }
    function D1(e) {
      const t = {}
      if ("" === e || "?" === e) return t
      const n = ("?" === e[0] ? e.slice(1) : e).split("&")
      for (let e = 0; e < n.length; ++e) {
        const r = n[e].replace(D0, " "),
          a = r.indexOf("="),
          o = z0(a < 0 ? r : r.slice(0, a)),
          i = a < 0 ? null : z0(r.slice(a + 1))
        if (o in t) {
          let e = t[o]
          S0(e) || (e = t[o] = [e]), e.push(i)
        } else t[o] = i
      }
      return t
    }
    function R1(e) {
      let t = ""
      for (let n in e) {
        const r = e[n]
        ;((n = U0(n).replace(C0, "%3D")), null != r)
          ? (S0(r) ? r.map((e) => e && U0(e)) : [r && U0(r)]).forEach((e) => {
              void 0 !== e && ((t += (t.length ? "&" : "") + n), null != e && (t += "=" + e))
            })
          : void 0 !== r && (t += (t.length ? "&" : "") + n)
      }
      return t
    }
    function N1(e) {
      const t = {}
      for (const n in e) {
        const r = e[n]
        void 0 !== r && (t[n] = S0(r) ? r.map((e) => (null == e ? null : "" + e)) : null == r ? r : "" + r)
      }
      return t
    }
    const $1 = Symbol(""),
      I1 = Symbol(""),
      M1 = Symbol(""),
      L1 = Symbol(""),
      Q1 = Symbol("")
    function B1() {
      let e = []
      return {
        add: function (t) {
          return (
            e.push(t),
            () => {
              const n = e.indexOf(t)
              n > -1 && e.splice(n, 1)
            }
          )
        },
        list: () => e.slice(),
        reset: function () {
          e = []
        },
      }
    }
    function j1(e, t, n, r, a, o = (e) => e()) {
      const i = r && (r.enterCallbacks[a] = r.enterCallbacks[a] || [])
      return () =>
        new Promise((s, l) => {
          const c = (e) => {
              var o
              !1 === e
                ? l(f1(4, { from: n, to: t }))
                : e instanceof Error
                  ? l(e)
                  : "string" == typeof (o = e) || (o && "object" == typeof o)
                    ? l(f1(2, { from: t, to: e }))
                    : (i && r.enterCallbacks[a] === i && "function" == typeof e && i.push(e), s())
            },
            d = o(() => e.call(r && r.instances[a], t, n, c))
          let u = Promise.resolve(d)
          e.length < 3 && (u = u.then(c)), u.catch((e) => l(e))
        })
    }
    function U1(e, t, n, r, a = (e) => e()) {
      const o = []
      for (const s of e)
        for (const e in s.components) {
          let l = s.components[e]
          if ("beforeRouteEnter" === t || s.instances[e])
            if ("object" == typeof (i = l) || "displayName" in i || "props" in i || "__vccOpts" in i) {
              const i = (l.__vccOpts || l)[t]
              i && o.push(j1(i, n, r, s, e, a))
            } else {
              let i = l()
              o.push(() =>
                i.then((o) => {
                  if (!o) return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${s.path}"`))
                  const i = (l = o).__esModule || "Module" === l[Symbol.toStringTag] ? o.default : o
                  var l
                  s.components[e] = i
                  const c = (i.__vccOpts || i)[t]
                  return c && j1(c, n, r, s, e, a)()
                }),
              )
            }
        }
      var i
      return o
    }
    function F1(e) {
      const t = xa(M1),
        n = xa(L1),
        r = ii(() => {
          const n = In(e.to)
          return t.resolve(n)
        }),
        a = ii(() => {
          const { matched: e } = r.value,
            { length: t } = e,
            a = e[t - 1],
            o = n.matched
          if (!a || !o.length) return -1
          const i = o.findIndex(V0.bind(null, a))
          if (i > -1) return i
          const s = q1(e[t - 2])
          return t > 1 && q1(a) === s && o[o.length - 1].path !== s ? o.findIndex(V0.bind(null, e[t - 2])) : i
        }),
        o = ii(
          () =>
            a.value > -1 &&
            (function (e, t) {
              for (const n in t) {
                const r = t[n],
                  a = e[n]
                if ("string" == typeof r) {
                  if (r !== a) return !1
                } else if (!S0(a) || a.length !== r.length || r.some((e, t) => e !== a[t])) return !1
              }
              return !0
            })(n.params, r.value.params),
        ),
        i = ii(() => a.value > -1 && a.value === n.matched.length - 1 && W0(n.params, r.value.params))
      return {
        route: r,
        href: ii(() => r.value.href),
        isActive: o,
        isExactActive: i,
        navigate: function (n = {}) {
          return (function (e) {
            if (
              !(
                e.metaKey ||
                e.altKey ||
                e.ctrlKey ||
                e.shiftKey ||
                e.defaultPrevented ||
                (void 0 !== e.button && 0 !== e.button)
              )
            ) {
              if (e.currentTarget && e.currentTarget.getAttribute) {
                const t = e.currentTarget.getAttribute("target")
                if (/\b_blank\b/i.test(t)) return
              }
              return e.preventDefault && e.preventDefault(), !0
            }
          })(n)
            ? t[In(e.replace) ? "replace" : "push"](In(e.to)).catch(_0)
            : Promise.resolve()
        },
      }
    }
    const z1 = Hr({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: { type: [String, Object], required: !0 },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: { type: String, default: "page" },
      },
      useLink: F1,
      setup(e, { slots: t }) {
        const n = mn(F1(e)),
          { options: r } = xa(M1),
          a = ii(() => ({
            [Z1(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [Z1(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive,
          }))
        return () => {
          const r = t.default && t.default(n)
          return e.custom
            ? r
            : si(
                "a",
                {
                  "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                  href: n.href,
                  onClick: n.navigate,
                  class: a.value,
                },
                r,
              )
        }
      },
    })
    function q1(e) {
      return e ? (e.aliasOf ? e.aliasOf.path : e.path) : ""
    }
    const Z1 = (e, t, n) => (null != e ? e : null != t ? t : n)
    function H1(e, t) {
      if (!e) return null
      const n = e(t)
      return 1 === n.length ? n[0] : n
    }
    const V1 = Hr({
      name: "RouterView",
      inheritAttrs: !1,
      props: { name: { type: String, default: "default" }, route: Object },
      compatConfig: { MODE: 3 },
      setup(e, { attrs: t, slots: n }) {
        const r = xa(Q1),
          a = ii(() => e.route || r.value),
          o = xa(I1, 0),
          i = ii(() => {
            let e = In(o)
            const { matched: t } = a.value
            let n
            for (; (n = t[e]) && !n.components; ) e++
            return e
          }),
          s = ii(() => a.value.matched[i.value])
        wa(
          I1,
          ii(() => i.value + 1),
        ),
          wa($1, s),
          wa(Q1, a)
        const l = Dn()
        return (
          Ya(
            () => [l.value, s.value, e.name],
            ([e, t, n], [r, a, o]) => {
              t &&
                ((t.instances[n] = e),
                a &&
                  a !== t &&
                  e &&
                  e === r &&
                  (t.leaveGuards.size || (t.leaveGuards = a.leaveGuards),
                  t.updateGuards.size || (t.updateGuards = a.updateGuards))),
                !e || !t || (a && V0(t, a) && r) || (t.enterCallbacks[n] || []).forEach((t) => t(e))
            },
            { flush: "post" },
          ),
          () => {
            const r = a.value,
              o = e.name,
              i = s.value,
              c = i && i.components[o]
            if (!c) return H1(n.default, { Component: c, route: r })
            const d = i.props[o],
              u = d ? (!0 === d ? r.params : "function" == typeof d ? d(r) : d) : null,
              p = si(
                c,
                x0({}, u, t, {
                  onVnodeUnmounted: (e) => {
                    e.component.isUnmounted && (i.instances[o] = null)
                  },
                  ref: l,
                }),
              )
            return H1(n.default, { Component: p, route: r }) || p
          }
        )
      },
    })
    function W1(e) {
      const t = (function (e, t) {
          const n = [],
            r = new Map()
          function a(e, n, r) {
            const s = !r,
              l = (function (e) {
                return {
                  path: e.path,
                  redirect: e.redirect,
                  name: e.name,
                  meta: e.meta || {},
                  aliasOf: void 0,
                  beforeEnter: e.beforeEnter,
                  props: E1(e),
                  children: e.children || [],
                  instances: {},
                  leaveGuards: new Set(),
                  updateGuards: new Set(),
                  enterCallbacks: {},
                  components: "components" in e ? e.components || null : e.component && { default: e.component },
                }
              })(e)
            l.aliasOf = r && r.record
            const c = C1(t, e),
              d = [l]
            if ("alias" in e) {
              const t = "string" == typeof e.alias ? [e.alias] : e.alias
              for (const e of t)
                d.push(
                  x0({}, l, { components: r ? r.record.components : l.components, path: e, aliasOf: r ? r.record : l }),
                )
            }
            let u, p
            for (const t of d) {
              const { path: d } = t
              if (n && "/" !== d[0]) {
                const e = n.record.path,
                  r = "/" === e[e.length - 1] ? "" : "/"
                t.path = n.record.path + (d && r + d)
              }
              if (
                ((u = _1(t, n, c)),
                r ? r.alias.push(u) : ((p = p || u), p !== u && p.alias.push(u), s && e.name && !T1(u) && o(e.name)),
                P1(u) && i(u),
                l.children)
              ) {
                const e = l.children
                for (let t = 0; t < e.length; t++) a(e[t], u, r && r.children[t])
              }
              r = r || u
            }
            return p
              ? () => {
                  o(p)
                }
              : _0
          }
          function o(e) {
            if (c1(e)) {
              const t = r.get(e)
              t && (r.delete(e), n.splice(n.indexOf(t), 1), t.children.forEach(o), t.alias.forEach(o))
            } else {
              const t = n.indexOf(e)
              t > -1 &&
                (n.splice(t, 1), e.record.name && r.delete(e.record.name), e.children.forEach(o), e.alias.forEach(o))
            }
          }
          function i(e) {
            const t = (function (e, t) {
              let n = 0,
                r = t.length
              for (; n !== r; ) {
                const a = (n + r) >> 1
                O1(e, t[a]) < 0 ? (r = a) : (n = a + 1)
              }
              const a = (function (e) {
                let t = e
                for (; (t = t.parent); ) if (P1(t) && 0 === O1(e, t)) return t
              })(e)
              return a && (r = t.lastIndexOf(a, r - 1)), r
            })(e, n)
            n.splice(t, 0, e), e.record.name && !T1(e) && r.set(e.record.name, e)
          }
          return (
            (t = C1({ strict: !1, end: !0, sensitive: !1 }, t)),
            e.forEach((e) => a(e)),
            {
              addRoute: a,
              resolve: function (e, t) {
                let a,
                  o,
                  i,
                  s = {}
                if ("name" in e && e.name) {
                  if (((a = r.get(e.name)), !a)) throw f1(1, { location: e })
                  ;(i = a.record.name),
                    (s = x0(
                      S1(
                        t.params,
                        a.keys
                          .filter((e) => !e.optional)
                          .concat(a.parent ? a.parent.keys.filter((e) => e.optional) : [])
                          .map((e) => e.name),
                      ),
                      e.params &&
                        S1(
                          e.params,
                          a.keys.map((e) => e.name),
                        ),
                    )),
                    (o = a.stringify(s))
                } else if (null != e.path)
                  (o = e.path), (a = n.find((e) => e.re.test(o))), a && ((s = a.parse(o)), (i = a.record.name))
                else {
                  if (((a = t.name ? r.get(t.name) : n.find((e) => e.re.test(t.path))), !a))
                    throw f1(1, { location: e, currentLocation: t })
                  ;(i = a.record.name), (s = x0({}, t.params, e.params)), (o = a.stringify(s))
                }
                const l = []
                let c = a
                for (; c; ) l.unshift(c.record), (c = c.parent)
                return { name: i, path: o, params: s, matched: l, meta: A1(l) }
              },
              removeRoute: o,
              getRoutes: function () {
                return n
              },
              getRecordMatcher: function (e) {
                return r.get(e)
              },
            }
          )
        })(e.routes, e),
        n = e.parseQuery || D1,
        r = e.stringifyQuery || R1,
        a = e.history,
        o = B1(),
        i = B1(),
        s = B1(),
        l = Rn(d1)
      let c = d1
      w0 && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual")
      const d = k0.bind(null, (e) => "" + e),
        u = k0.bind(null, F0),
        p = k0.bind(null, z0)
      function h(e, o) {
        if (((o = x0({}, o || l.value)), "string" == typeof e)) {
          const r = Z0(n, e, o.path),
            i = t.resolve({ path: r.path }, o),
            s = a.createHref(r.fullPath)
          return x0(r, i, { params: p(i.params), hash: z0(r.hash), redirectedFrom: void 0, href: s })
        }
        let i
        if (null != e.path) i = x0({}, e, { path: Z0(n, e.path, o.path).path })
        else {
          const t = x0({}, e.params)
          for (const e in t) null == t[e] && delete t[e]
          ;(i = x0({}, e, { params: u(t) })), (o.params = u(o.params))
        }
        const s = t.resolve(i, o),
          c = e.hash || ""
        s.params = d(p(s.params))
        const h = (function (e, t) {
          const n = t.query ? e(t.query) : ""
          return t.path + (n && "?") + n + (t.hash || "")
        })(r, x0({}, e, { hash: ((f = c), j0(f).replace(M0, "{").replace(Q0, "}").replace($0, "^")), path: s.path }))
        var f
        const m = a.createHref(h)
        return x0({ fullPath: h, hash: c, query: r === R1 ? N1(e.query) : e.query || {} }, s, {
          redirectedFrom: void 0,
          href: m,
        })
      }
      function f(e) {
        return "string" == typeof e ? Z0(n, e, l.value.path) : x0({}, e)
      }
      function m(e, t) {
        if (c !== e) return f1(8, { from: t, to: e })
      }
      function g(e) {
        return v(e)
      }
      function b(e) {
        const t = e.matched[e.matched.length - 1]
        if (t && t.redirect) {
          const { redirect: n } = t
          let r = "function" == typeof n ? n(e) : n
          return (
            "string" == typeof r &&
              ((r = r.includes("?") || r.includes("#") ? (r = f(r)) : { path: r }), (r.params = {})),
            x0({ query: e.query, hash: e.hash, params: null != r.path ? {} : e.params }, r)
          )
        }
      }
      function v(e, t) {
        const n = (c = h(e)),
          a = l.value,
          o = e.state,
          i = e.force,
          s = !0 === e.replace,
          d = b(n)
        if (d)
          return v(x0(f(d), { state: "object" == typeof d ? x0({}, o, d.state) : o, force: i, replace: s }), t || n)
        const u = n
        let p
        return (
          (u.redirectedFrom = t),
          !i &&
            (function (e, t, n) {
              const r = t.matched.length - 1,
                a = n.matched.length - 1
              return (
                r > -1 &&
                r === a &&
                V0(t.matched[r], n.matched[a]) &&
                W0(t.params, n.params) &&
                e(t.query) === e(n.query) &&
                t.hash === n.hash
              )
            })(r, a, n) &&
            ((p = f1(16, { to: u, from: a })), P(a, a, !0, !1)),
          (p ? Promise.resolve(p) : w(u, a))
            .catch((e) => (m1(e) ? (m1(e, 2) ? e : C(e)) : A(e, u, a)))
            .then((e) => {
              if (e) {
                if (m1(e, 2))
                  return v(
                    x0({ replace: s }, f(e.to), {
                      state: "object" == typeof e.to ? x0({}, o, e.to.state) : o,
                      force: i,
                    }),
                    t || u,
                  )
              } else e = k(u, a, !0, s, o)
              return x(u, a, e), e
            })
        )
      }
      function y(e, t) {
        const n = m(e, t)
        return n ? Promise.reject(n) : Promise.resolve()
      }
      function O(e) {
        const t = N.values().next().value
        return t && "function" == typeof t.runWithContext ? t.runWithContext(e) : e()
      }
      function w(e, t) {
        let n
        const [r, a, s] = (function (e, t) {
          const n = [],
            r = [],
            a = [],
            o = Math.max(t.matched.length, e.matched.length)
          for (let i = 0; i < o; i++) {
            const o = t.matched[i]
            o && (e.matched.find((e) => V0(e, o)) ? r.push(o) : n.push(o))
            const s = e.matched[i]
            s && (t.matched.find((e) => V0(e, s)) || a.push(s))
          }
          return [n, r, a]
        })(e, t)
        n = U1(r.reverse(), "beforeRouteLeave", e, t)
        for (const a of r)
          a.leaveGuards.forEach((r) => {
            n.push(j1(r, e, t))
          })
        const l = y.bind(null, e, t)
        return (
          n.push(l),
          I(n)
            .then(() => {
              n = []
              for (const r of o.list()) n.push(j1(r, e, t))
              return n.push(l), I(n)
            })
            .then(() => {
              n = U1(a, "beforeRouteUpdate", e, t)
              for (const r of a)
                r.updateGuards.forEach((r) => {
                  n.push(j1(r, e, t))
                })
              return n.push(l), I(n)
            })
            .then(() => {
              n = []
              for (const r of s)
                if (r.beforeEnter)
                  if (S0(r.beforeEnter)) for (const a of r.beforeEnter) n.push(j1(a, e, t))
                  else n.push(j1(r.beforeEnter, e, t))
              return n.push(l), I(n)
            })
            .then(
              () => (
                e.matched.forEach((e) => (e.enterCallbacks = {})),
                (n = U1(s, "beforeRouteEnter", e, t, O)),
                n.push(l),
                I(n)
              ),
            )
            .then(() => {
              n = []
              for (const r of i.list()) n.push(j1(r, e, t))
              return n.push(l), I(n)
            })
            .catch((e) => (m1(e, 8) ? e : Promise.reject(e)))
        )
      }
      function x(e, t, n) {
        s.list().forEach((r) => O(() => r(e, t, n)))
      }
      function k(e, t, n, r, o) {
        const i = m(e, t)
        if (i) return i
        const s = t === d1,
          c = w0 ? history.state : {}
        n && (r || s ? a.replace(e.fullPath, x0({ scroll: s && c && c.scroll }, o)) : a.push(e.fullPath, o)),
          (l.value = e),
          P(e, t, n, s),
          C()
      }
      let _
      let S,
        E = B1(),
        T = B1()
      function A(e, t, n) {
        C(e)
        const r = T.list()
        return r.length ? r.forEach((r) => r(e, t, n)) : console.error(e), Promise.reject(e)
      }
      function C(e) {
        return (
          S ||
            ((S = !e),
            _ ||
              (_ = a.listen((e, t, n) => {
                if (!$.listening) return
                const r = h(e),
                  o = b(r)
                if (o) return void v(x0(o, { replace: !0 }), r).catch(_0)
                c = r
                const i = l.value
                var s, d
                w0 && ((s = o1(i.fullPath, n.delta)), (d = a1()), i1.set(s, d)),
                  w(r, i)
                    .catch((e) =>
                      m1(e, 12)
                        ? e
                        : m1(e, 2)
                          ? (v(e.to, r)
                              .then((e) => {
                                m1(e, 20) && !n.delta && n.type === G0.pop && a.go(-1, !1)
                              })
                              .catch(_0),
                            Promise.reject())
                          : (n.delta && a.go(-n.delta, !1), A(e, r, i)),
                    )
                    .then((e) => {
                      ;(e = e || k(r, i, !1)) &&
                        (n.delta && !m1(e, 8) ? a.go(-n.delta, !1) : n.type === G0.pop && m1(e, 20) && a.go(-1, !1)),
                        x(r, i, e)
                    })
                    .catch(_0)
              })),
            E.list().forEach(([t, n]) => (e ? n(e) : t())),
            E.reset()),
          e
        )
      }
      function P(t, n, r, a) {
        const { scrollBehavior: o } = e
        if (!w0 || !o) return Promise.resolve()
        const i =
          (!r &&
            (function (e) {
              const t = i1.get(e)
              return i1.delete(e), t
            })(o1(t.fullPath, 0))) ||
          ((a || !r) && history.state && history.state.scroll) ||
          null
        return rr()
          .then(() => o(t, n, i))
          .then(
            (e) =>
              e &&
              (function (e) {
                let t
                if ("el" in e) {
                  const n = e.el,
                    r = "string" == typeof n && n.startsWith("#"),
                    a = "string" == typeof n ? (r ? document.getElementById(n.slice(1)) : document.querySelector(n)) : n
                  if (!a) return
                  t = (function (e, t) {
                    const n = document.documentElement.getBoundingClientRect(),
                      r = e.getBoundingClientRect()
                    return {
                      behavior: t.behavior,
                      left: r.left - n.left - (t.left || 0),
                      top: r.top - n.top - (t.top || 0),
                    }
                  })(a, e)
                } else t = e
                "scrollBehavior" in document.documentElement.style
                  ? window.scrollTo(t)
                  : window.scrollTo(null != t.left ? t.left : window.scrollX, null != t.top ? t.top : window.scrollY)
              })(e),
          )
          .catch((e) => A(e, t, n))
      }
      const D = (e) => a.go(e)
      let R
      const N = new Set(),
        $ = {
          currentRoute: l,
          listening: !0,
          addRoute: function (e, n) {
            let r, a
            return c1(e) ? ((r = t.getRecordMatcher(e)), (a = n)) : (a = e), t.addRoute(a, r)
          },
          removeRoute: function (e) {
            const n = t.getRecordMatcher(e)
            n && t.removeRoute(n)
          },
          hasRoute: function (e) {
            return !!t.getRecordMatcher(e)
          },
          getRoutes: function () {
            return t.getRoutes().map((e) => e.record)
          },
          resolve: h,
          options: e,
          push: g,
          replace: function (e) {
            return g(x0(f(e), { replace: !0 }))
          },
          go: D,
          back: () => D(-1),
          forward: () => D(1),
          beforeEach: o.add,
          beforeResolve: i.add,
          afterEach: s.add,
          onError: T.add,
          isReady: function () {
            return S && l.value !== d1
              ? Promise.resolve()
              : new Promise((e, t) => {
                  E.add([e, t])
                })
          },
          install(e) {
            e.component("RouterLink", z1),
              e.component("RouterView", V1),
              (e.config.globalProperties.$router = this),
              Object.defineProperty(e.config.globalProperties, "$route", { enumerable: !0, get: () => In(l) }),
              w0 && !R && l.value === d1 && ((R = !0), g(a.location).catch((e) => {}))
            const t = {}
            for (const e in d1) Object.defineProperty(t, e, { get: () => l.value[e], enumerable: !0 })
            e.provide(M1, this), e.provide(L1, gn(t)), e.provide(Q1, l)
            const n = e.unmount
            N.add(e),
              (e.unmount = function () {
                N.delete(e), N.size < 1 && ((c = d1), _ && _(), (_ = null), (l.value = d1), (R = !1), (S = !1)), n()
              })
          },
        }
      function I(e) {
        return e.reduce((e, t) => e.then(() => O(t)), Promise.resolve())
      }
      return $
    }
    function X1() {
      return xa(M1)
    }
    var Y1 = ((e) => (
      (e.Request = "request"),
      (e.Examples = "examples"),
      (e.Cookies = "cookies"),
      (e.Collection = "collection"),
      (e.Schema = "schema"),
      (e.Environment = "environment"),
      (e.Servers = "servers"),
      (e.Workspace = "workspace"),
      e
    ))(Y1 || {})
    const G1 = [
        { path: "", redirect: (e) => `${e.fullPath.replace(/\/$/, "")}/request/default` },
        { path: "request", redirect: (e) => `${e.fullPath.replace(/\/$/, "")}/default` },
        { name: "request", path: "request/:request", component: () => Promise.resolve().then(() => Eme) },
        {
          name: "requestExamples",
          path: "request/:request/examples/:examples",
          component: () => Promise.resolve().then(() => Eme),
        },
      ],
      K1 = [
        { path: "/", redirect: "/workspace/default/request/default" },
        { path: "/workspace", redirect: "/workspace/default/request/default" },
        { path: "/workspace/:workspace", children: G1 },
      ],
      J1 = [
        { path: "/", redirect: "/workspace/default/request/default" },
        { path: "/workspace", redirect: "/workspace/default/request/default" },
        {
          path: "/workspace/:workspace",
          children: [
            ...G1,
            { path: "environment", redirect: (e) => `${e.fullPath.replace(/\/$/, "")}/default` },
            {
              name: "environment",
              path: "environment/:environment",
              component: () => Promise.resolve().then(() => Zme),
            },
            { path: "cookies", redirect: (e) => `${e.fullPath.replace(/\/$/, "")}/default` },
            { name: "cookies", path: "cookies/:cookies", component: () => Promise.resolve().then(() => Jme) },
            { path: "servers", redirect: (e) => `${e.fullPath.replace(/\/$/, "")}/default` },
            { name: "servers", path: "servers/:servers", component: () => Promise.resolve().then(() => age) },
          ],
        },
      ],
      e2 = W1({
        history: (function (e) {
          const t = (function (e) {
              const { history: t, location: n } = window,
                r = { value: s1(e, n) },
                a = { value: t.state }
              function o(r, o, i) {
                const s = e.indexOf("#"),
                  l =
                    s > -1
                      ? (n.host && document.querySelector("base") ? e : e.slice(s)) + r
                      : location.protocol + "//" + location.host + e + r
                try {
                  t[i ? "replaceState" : "pushState"](o, "", l), (a.value = o)
                } catch (e) {
                  console.error(e), n[i ? "replace" : "assign"](l)
                }
              }
              return (
                a.value ||
                  o(
                    r.value,
                    { back: null, current: r.value, forward: null, position: t.length - 1, replaced: !0, scroll: null },
                    !0,
                  ),
                {
                  location: r,
                  state: a,
                  push: function (e, n) {
                    const i = x0({}, a.value, t.state, { forward: e, scroll: a1() })
                    o(i.current, i, !0),
                      o(e, x0({}, l1(r.value, e, null), { position: i.position + 1 }, n), !1),
                      (r.value = e)
                  },
                  replace: function (e, n) {
                    o(
                      e,
                      x0({}, t.state, l1(a.value.back, e, a.value.forward, !0), n, { position: a.value.position }),
                      !0,
                    ),
                      (r.value = e)
                  },
                }
              )
            })((e = t1(e))),
            n = (function (e, t, n, r) {
              let a = [],
                o = [],
                i = null
              const s = ({ state: o }) => {
                const s = s1(e, location),
                  l = n.value,
                  c = t.value
                let d = 0
                if (o) {
                  if (((n.value = s), (t.value = o), i && i === l)) return void (i = null)
                  d = c ? o.position - c.position : 0
                } else r(s)
                a.forEach((e) => {
                  e(n.value, l, { delta: d, type: G0.pop, direction: d ? (d > 0 ? J0.forward : J0.back) : J0.unknown })
                })
              }
              function l() {
                const { history: e } = window
                e.state && e.replaceState(x0({}, e.state, { scroll: a1() }), "")
              }
              return (
                window.addEventListener("popstate", s),
                window.addEventListener("beforeunload", l, { passive: !0 }),
                {
                  pauseListeners: function () {
                    i = n.value
                  },
                  listen: function (e) {
                    a.push(e)
                    const t = () => {
                      const t = a.indexOf(e)
                      t > -1 && a.splice(t, 1)
                    }
                    return o.push(t), t
                  },
                  destroy: function () {
                    for (const e of o) e()
                    ;(o = []), window.removeEventListener("popstate", s), window.removeEventListener("beforeunload", l)
                  },
                }
              )
            })(e, t.state, t.location, t.replace),
            r = x0(
              {
                location: "",
                base: e,
                go: function (e, t = !0) {
                  t || n.pauseListeners(), history.go(e)
                },
                createHref: r1.bind(null, e),
              },
              t,
              n,
            )
          return (
            Object.defineProperty(r, "location", { enumerable: !0, get: () => t.location.value }),
            Object.defineProperty(r, "state", { enumerable: !0, get: () => t.state.value }),
            r
          )
        })(),
        routes: J1,
      }),
      t2 = W1({
        history: (function (e = "") {
          let t = [],
            n = [""],
            r = 0
          function a(e) {
            r++, r !== n.length && n.splice(r), n.push(e)
          }
          const o = {
            location: "",
            state: {},
            base: (e = t1(e)),
            createHref: r1.bind(null, e),
            replace(e) {
              n.splice(r--, 1), a(e)
            },
            push(e, t) {
              a(e)
            },
            listen: (e) => (
              t.push(e),
              () => {
                const n = t.indexOf(e)
                n > -1 && t.splice(n, 1)
              }
            ),
            destroy() {
              ;(t = []), (n = [""]), (r = 0)
            },
            go(e, a = !0) {
              const o = this.location,
                i = e < 0 ? J0.back : J0.forward
              ;(r = Math.max(0, Math.min(r + e, n.length - 1))),
                a &&
                  (function (e, n, { direction: r, delta: a }) {
                    const o = { direction: r, delta: a, type: G0.pop }
                    for (const r of t) r(e, n, o)
                  })(this.location, o, { direction: i, delta: e })
            },
          }
          return Object.defineProperty(o, "location", { enumerable: !0, get: () => n[r] }), o
        })(),
        routes: K1,
      }),
      n2 = ii(() => {
        const e = {
            collection: "default",
            environment: "default",
            request: "default",
            examples: "default",
            schema: "default",
            cookies: "default",
            servers: "default",
            workspace: "default",
          },
          t = t2.currentRoute.value.matched.length ? t2.currentRoute.value : e2.currentRoute.value
        return (
          t &&
            Object.values(Y1).forEach((n) => {
              t.params[n] && (e[n] = t.params[n])
            }),
          e
        )
      })
    var r2, a2, o2
    ;((a2 = r2 || (r2 = {})).assertEqual = (e) => e),
      (a2.assertIs = function (e) {}),
      (a2.assertNever = function (e) {
        throw new Error()
      }),
      (a2.arrayToEnum = (e) => {
        const t = {}
        for (const n of e) t[n] = n
        return t
      }),
      (a2.getValidEnumValues = (e) => {
        const t = a2.objectKeys(e).filter((t) => "number" != typeof e[e[t]]),
          n = {}
        for (const r of t) n[r] = e[r]
        return a2.objectValues(n)
      }),
      (a2.objectValues = (e) =>
        a2.objectKeys(e).map(function (t) {
          return e[t]
        })),
      (a2.objectKeys =
        "function" == typeof Object.keys
          ? (e) => Object.keys(e)
          : (e) => {
              const t = []
              for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t.push(n)
              return t
            }),
      (a2.find = (e, t) => {
        for (const n of e) if (t(n)) return n
      }),
      (a2.isInteger =
        "function" == typeof Number.isInteger
          ? (e) => Number.isInteger(e)
          : (e) => "number" == typeof e && isFinite(e) && Math.floor(e) === e),
      (a2.joinValues = function (e, t = " | ") {
        return e.map((e) => ("string" == typeof e ? `'${e}'` : e)).join(t)
      }),
      (a2.jsonStringifyReplacer = (e, t) => ("bigint" == typeof t ? t.toString() : t)),
      ((o2 || (o2 = {})).mergeShapes = (e, t) => ({ ...e, ...t }))
    const i2 = r2.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set",
      ]),
      s2 = (e) => {
        switch (typeof e) {
          case "undefined":
            return i2.undefined
          case "string":
            return i2.string
          case "number":
            return isNaN(e) ? i2.nan : i2.number
          case "boolean":
            return i2.boolean
          case "function":
            return i2.function
          case "bigint":
            return i2.bigint
          case "symbol":
            return i2.symbol
          case "object":
            return Array.isArray(e)
              ? i2.array
              : null === e
                ? i2.null
                : e.then && "function" == typeof e.then && e.catch && "function" == typeof e.catch
                  ? i2.promise
                  : "undefined" != typeof Map && e instanceof Map
                    ? i2.map
                    : "undefined" != typeof Set && e instanceof Set
                      ? i2.set
                      : "undefined" != typeof Date && e instanceof Date
                        ? i2.date
                        : i2.object
          default:
            return i2.unknown
        }
      },
      l2 = r2.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite",
      ])
    class c2 extends Error {
      constructor(e) {
        super(),
          (this.issues = []),
          (this.addIssue = (e) => {
            this.issues = [...this.issues, e]
          }),
          (this.addIssues = (e = []) => {
            this.issues = [...this.issues, ...e]
          })
        const t = new.target.prototype
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : (this.__proto__ = t),
          (this.name = "ZodError"),
          (this.issues = e)
      }
      get errors() {
        return this.issues
      }
      format(e) {
        const t =
            e ||
            function (e) {
              return e.message
            },
          n = { _errors: [] },
          r = (e) => {
            for (const a of e.issues)
              if ("invalid_union" === a.code) a.unionErrors.map(r)
              else if ("invalid_return_type" === a.code) r(a.returnTypeError)
              else if ("invalid_arguments" === a.code) r(a.argumentsError)
              else if (0 === a.path.length) n._errors.push(t(a))
              else {
                let e = n,
                  r = 0
                for (; r < a.path.length; ) {
                  const n = a.path[r]
                  r === a.path.length - 1
                    ? ((e[n] = e[n] || { _errors: [] }), e[n]._errors.push(t(a)))
                    : (e[n] = e[n] || { _errors: [] }),
                    (e = e[n]),
                    r++
                }
              }
          }
        return r(this), n
      }
      static assert(e) {
        if (!(e instanceof c2)) throw new Error(`Not a ZodError: ${e}`)
      }
      toString() {
        return this.message
      }
      get message() {
        return JSON.stringify(this.issues, r2.jsonStringifyReplacer, 2)
      }
      get isEmpty() {
        return 0 === this.issues.length
      }
      flatten(e = (e) => e.message) {
        const t = {},
          n = []
        for (const r of this.issues)
          r.path.length > 0 ? ((t[r.path[0]] = t[r.path[0]] || []), t[r.path[0]].push(e(r))) : n.push(e(r))
        return { formErrors: n, fieldErrors: t }
      }
      get formErrors() {
        return this.flatten()
      }
    }
    c2.create = (e) => new c2(e)
    const d2 = (e, t) => {
      let n
      switch (e.code) {
        case l2.invalid_type:
          n = e.received === i2.undefined ? "Required" : `Expected ${e.expected}, received ${e.received}`
          break
        case l2.invalid_literal:
          n = `Invalid literal value, expected ${JSON.stringify(e.expected, r2.jsonStringifyReplacer)}`
          break
        case l2.unrecognized_keys:
          n = `Unrecognized key(s) in object: ${r2.joinValues(e.keys, ", ")}`
          break
        case l2.invalid_union:
          n = "Invalid input"
          break
        case l2.invalid_union_discriminator:
          n = `Invalid discriminator value. Expected ${r2.joinValues(e.options)}`
          break
        case l2.invalid_enum_value:
          n = `Invalid enum value. Expected ${r2.joinValues(e.options)}, received '${e.received}'`
          break
        case l2.invalid_arguments:
          n = "Invalid function arguments"
          break
        case l2.invalid_return_type:
          n = "Invalid function return type"
          break
        case l2.invalid_date:
          n = "Invalid date"
          break
        case l2.invalid_string:
          "object" == typeof e.validation
            ? "includes" in e.validation
              ? ((n = `Invalid input: must include "${e.validation.includes}"`),
                "number" == typeof e.validation.position &&
                  (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`))
              : "startsWith" in e.validation
                ? (n = `Invalid input: must start with "${e.validation.startsWith}"`)
                : "endsWith" in e.validation
                  ? (n = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : r2.assertNever(e.validation)
            : (n = "regex" !== e.validation ? `Invalid ${e.validation}` : "Invalid")
          break
        case l2.too_small:
          n =
            "array" === e.type
              ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)`
              : "string" === e.type
                ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)`
                : "number" === e.type
                  ? `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}`
                  : "date" === e.type
                    ? `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}`
                    : "Invalid input"
          break
        case l2.too_big:
          n =
            "array" === e.type
              ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)`
              : "string" === e.type
                ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)`
                : "number" === e.type
                  ? `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`
                  : "bigint" === e.type
                    ? `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`
                    : "date" === e.type
                      ? `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}`
                      : "Invalid input"
          break
        case l2.custom:
          n = "Invalid input"
          break
        case l2.invalid_intersection_types:
          n = "Intersection results could not be merged"
          break
        case l2.not_multiple_of:
          n = `Number must be a multiple of ${e.multipleOf}`
          break
        case l2.not_finite:
          n = "Number must be finite"
          break
        default:
          ;(n = t.defaultError), r2.assertNever(e)
      }
      return { message: n }
    }
    let u2 = d2
    function p2() {
      return u2
    }
    const h2 = (e) => {
      const { data: t, path: n, errorMaps: r, issueData: a } = e,
        o = [...n, ...(a.path || [])],
        i = { ...a, path: o }
      if (void 0 !== a.message) return { ...a, path: o, message: a.message }
      let s = ""
      const l = r
        .filter((e) => !!e)
        .slice()
        .reverse()
      for (const e of l) s = e(i, { data: t, defaultError: s }).message
      return { ...a, path: o, message: s }
    }
    function f2(e, t) {
      const n = p2(),
        r = h2({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === d2 ? void 0 : d2].filter((e) => !!e),
        })
      e.common.issues.push(r)
    }
    class m2 {
      constructor() {
        this.value = "valid"
      }
      dirty() {
        "valid" === this.value && (this.value = "dirty")
      }
      abort() {
        "aborted" !== this.value && (this.value = "aborted")
      }
      static mergeArray(e, t) {
        const n = []
        for (const r of t) {
          if ("aborted" === r.status) return g2
          "dirty" === r.status && e.dirty(), n.push(r.value)
        }
        return { status: e.value, value: n }
      }
      static async mergeObjectAsync(e, t) {
        const n = []
        for (const e of t) {
          const t = await e.key,
            r = await e.value
          n.push({ key: t, value: r })
        }
        return m2.mergeObjectSync(e, n)
      }
      static mergeObjectSync(e, t) {
        const n = {}
        for (const r of t) {
          const { key: t, value: a } = r
          if ("aborted" === t.status) return g2
          if ("aborted" === a.status) return g2
          "dirty" === t.status && e.dirty(),
            "dirty" === a.status && e.dirty(),
            "__proto__" === t.value || (void 0 === a.value && !r.alwaysSet) || (n[t.value] = a.value)
        }
        return { status: e.value, value: n }
      }
    }
    const g2 = Object.freeze({ status: "aborted" }),
      b2 = (e) => ({ status: "dirty", value: e }),
      v2 = (e) => ({ status: "valid", value: e }),
      y2 = (e) => "aborted" === e.status,
      O2 = (e) => "dirty" === e.status,
      w2 = (e) => "valid" === e.status,
      x2 = (e) => "undefined" != typeof Promise && e instanceof Promise
    function k2(e, t, n, r) {
      if ("function" == typeof t ? e !== t || !r : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it")
      return t.get(e)
    }
    function _2(e, t, n, r, a) {
      if ("function" == typeof t ? e !== t || !a : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it")
      return t.set(e, n), n
    }
    var S2, E2, T2, A2
    "function" == typeof SuppressedError && SuppressedError,
      ((E2 = S2 || (S2 = {})).errToObj = (e) => ("string" == typeof e ? { message: e } : e || {})),
      (E2.toString = (e) => ("string" == typeof e ? e : null == e ? void 0 : e.message))
    class C2 {
      constructor(e, t, n, r) {
        ;(this._cachedPath = []), (this.parent = e), (this.data = t), (this._path = n), (this._key = r)
      }
      get path() {
        return (
          this._cachedPath.length ||
            (this._key instanceof Array
              ? this._cachedPath.push(...this._path, ...this._key)
              : this._cachedPath.push(...this._path, this._key)),
          this._cachedPath
        )
      }
    }
    const P2 = (e, t) => {
      if (w2(t)) return { success: !0, data: t.value }
      if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.")
      return {
        success: !1,
        get error() {
          if (this._error) return this._error
          const t = new c2(e.common.issues)
          return (this._error = t), this._error
        },
      }
    }
    function D2(e) {
      if (!e) return {}
      const { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e
      if (t && (n || r))
        throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.')
      return t
        ? { errorMap: t, description: a }
        : {
            errorMap: (t, a) => {
              var o, i
              const { message: s } = e
              return "invalid_enum_value" === t.code
                ? { message: null != s ? s : a.defaultError }
                : void 0 === a.data
                  ? { message: null !== (o = null != s ? s : r) && void 0 !== o ? o : a.defaultError }
                  : "invalid_type" !== t.code
                    ? { message: a.defaultError }
                    : { message: null !== (i = null != s ? s : n) && void 0 !== i ? i : a.defaultError }
            },
            description: a,
          }
    }
    class R2 {
      constructor(e) {
        ;(this.spa = this.safeParseAsync),
          (this._def = e),
          (this.parse = this.parse.bind(this)),
          (this.safeParse = this.safeParse.bind(this)),
          (this.parseAsync = this.parseAsync.bind(this)),
          (this.safeParseAsync = this.safeParseAsync.bind(this)),
          (this.spa = this.spa.bind(this)),
          (this.refine = this.refine.bind(this)),
          (this.refinement = this.refinement.bind(this)),
          (this.superRefine = this.superRefine.bind(this)),
          (this.optional = this.optional.bind(this)),
          (this.nullable = this.nullable.bind(this)),
          (this.nullish = this.nullish.bind(this)),
          (this.array = this.array.bind(this)),
          (this.promise = this.promise.bind(this)),
          (this.or = this.or.bind(this)),
          (this.and = this.and.bind(this)),
          (this.transform = this.transform.bind(this)),
          (this.brand = this.brand.bind(this)),
          (this.default = this.default.bind(this)),
          (this.catch = this.catch.bind(this)),
          (this.describe = this.describe.bind(this)),
          (this.pipe = this.pipe.bind(this)),
          (this.readonly = this.readonly.bind(this)),
          (this.isNullable = this.isNullable.bind(this)),
          (this.isOptional = this.isOptional.bind(this))
      }
      get description() {
        return this._def.description
      }
      _getType(e) {
        return s2(e.data)
      }
      _getOrReturnCtx(e, t) {
        return (
          t || {
            common: e.parent.common,
            data: e.data,
            parsedType: s2(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent,
          }
        )
      }
      _processInputParams(e) {
        return {
          status: new m2(),
          ctx: {
            common: e.parent.common,
            data: e.data,
            parsedType: s2(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent,
          },
        }
      }
      _parseSync(e) {
        const t = this._parse(e)
        if (x2(t)) throw new Error("Synchronous parse encountered promise.")
        return t
      }
      _parseAsync(e) {
        const t = this._parse(e)
        return Promise.resolve(t)
      }
      parse(e, t) {
        const n = this.safeParse(e, t)
        if (n.success) return n.data
        throw n.error
      }
      safeParse(e, t) {
        var n
        const r = {
            common: {
              issues: [],
              async: null !== (n = null == t ? void 0 : t.async) && void 0 !== n && n,
              contextualErrorMap: null == t ? void 0 : t.errorMap,
            },
            path: (null == t ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: s2(e),
          },
          a = this._parseSync({ data: e, path: r.path, parent: r })
        return P2(r, a)
      }
      async parseAsync(e, t) {
        const n = await this.safeParseAsync(e, t)
        if (n.success) return n.data
        throw n.error
      }
      async safeParseAsync(e, t) {
        const n = {
            common: { issues: [], contextualErrorMap: null == t ? void 0 : t.errorMap, async: !0 },
            path: (null == t ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: s2(e),
          },
          r = this._parse({ data: e, path: n.path, parent: n }),
          a = await (x2(r) ? r : Promise.resolve(r))
        return P2(n, a)
      }
      refine(e, t) {
        const n = (e) => ("string" == typeof t || void 0 === t ? { message: t } : "function" == typeof t ? t(e) : t)
        return this._refinement((t, r) => {
          const a = e(t),
            o = () => r.addIssue({ code: l2.custom, ...n(t) })
          return "undefined" != typeof Promise && a instanceof Promise
            ? a.then((e) => !!e || (o(), !1))
            : !!a || (o(), !1)
        })
      }
      refinement(e, t) {
        return this._refinement((n, r) => !!e(n) || (r.addIssue("function" == typeof t ? t(n, r) : t), !1))
      }
      _refinement(e) {
        return new E5({ schema: this, typeName: Q5.ZodEffects, effect: { type: "refinement", refinement: e } })
      }
      superRefine(e) {
        return this._refinement(e)
      }
      optional() {
        return T5.create(this, this._def)
      }
      nullable() {
        return A5.create(this, this._def)
      }
      nullish() {
        return this.nullable().optional()
      }
      array() {
        return s5.create(this, this._def)
      }
      promise() {
        return S5.create(this, this._def)
      }
      or(e) {
        return d5.create([this, e], this._def)
      }
      and(e) {
        return f5.create(this, e, this._def)
      }
      transform(e) {
        return new E5({
          ...D2(this._def),
          schema: this,
          typeName: Q5.ZodEffects,
          effect: { type: "transform", transform: e },
        })
      }
      default(e) {
        const t = "function" == typeof e ? e : () => e
        return new C5({ ...D2(this._def), innerType: this, defaultValue: t, typeName: Q5.ZodDefault })
      }
      brand() {
        return new N5({ typeName: Q5.ZodBranded, type: this, ...D2(this._def) })
      }
      catch(e) {
        const t = "function" == typeof e ? e : () => e
        return new P5({ ...D2(this._def), innerType: this, catchValue: t, typeName: Q5.ZodCatch })
      }
      describe(e) {
        return new (0, this.constructor)({ ...this._def, description: e })
      }
      pipe(e) {
        return $5.create(this, e)
      }
      readonly() {
        return I5.create(this)
      }
      isOptional() {
        return this.safeParse(void 0).success
      }
      isNullable() {
        return this.safeParse(null).success
      }
    }
    const N2 = /^c[^\s-]{8,}$/i,
      $2 = /^[0-9a-z]+$/,
      I2 = /^[0-9A-HJKMNP-TV-Z]{26}$/,
      M2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
      L2 = /^[a-z0-9_-]{21}$/i,
      Q2 =
        /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
      B2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
    let j2
    const U2 =
        /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      F2 =
        /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      z2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      q2 =
        "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
      Z2 = new RegExp(`^${q2}$`)
    function H2(e) {
      let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"
      return e.precision ? (t = `${t}\\.\\d{${e.precision}}`) : null == e.precision && (t = `${t}(\\.\\d+)?`), t
    }
    function V2(e) {
      let t = `${q2}T${H2(e)}`
      const n = []
      return (
        n.push(e.local ? "Z?" : "Z"),
        e.offset && n.push("([+-]\\d{2}:?\\d{2})"),
        (t = `${t}(${n.join("|")})`),
        new RegExp(`^${t}$`)
      )
    }
    class W2 extends R2 {
      _parse(e) {
        if ((this._def.coerce && (e.data = String(e.data)), this._getType(e) !== i2.string)) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.string, received: t.parsedType }), g2
        }
        const t = new m2()
        let n
        for (const o of this._def.checks)
          if ("min" === o.kind)
            e.data.length < o.value &&
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, {
                code: l2.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: o.message,
              }),
              t.dirty())
          else if ("max" === o.kind)
            e.data.length > o.value &&
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, {
                code: l2.too_big,
                maximum: o.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: o.message,
              }),
              t.dirty())
          else if ("length" === o.kind) {
            const r = e.data.length > o.value,
              a = e.data.length < o.value
            ;(r || a) &&
              ((n = this._getOrReturnCtx(e, n)),
              r
                ? f2(n, {
                    code: l2.too_big,
                    maximum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: o.message,
                  })
                : a &&
                  f2(n, {
                    code: l2.too_small,
                    minimum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: o.message,
                  }),
              t.dirty())
          } else if ("email" === o.kind)
            B2.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, { validation: "email", code: l2.invalid_string, message: o.message }),
              t.dirty())
          else if ("emoji" === o.kind)
            j2 || (j2 = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")),
              j2.test(e.data) ||
                ((n = this._getOrReturnCtx(e, n)),
                f2(n, { validation: "emoji", code: l2.invalid_string, message: o.message }),
                t.dirty())
          else if ("uuid" === o.kind)
            M2.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, { validation: "uuid", code: l2.invalid_string, message: o.message }),
              t.dirty())
          else if ("nanoid" === o.kind)
            L2.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, { validation: "nanoid", code: l2.invalid_string, message: o.message }),
              t.dirty())
          else if ("cuid" === o.kind)
            N2.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, { validation: "cuid", code: l2.invalid_string, message: o.message }),
              t.dirty())
          else if ("cuid2" === o.kind)
            $2.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, { validation: "cuid2", code: l2.invalid_string, message: o.message }),
              t.dirty())
          else if ("ulid" === o.kind)
            I2.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, { validation: "ulid", code: l2.invalid_string, message: o.message }),
              t.dirty())
          else if ("url" === o.kind)
            try {
              new URL(e.data)
            } catch (r) {
              ;(n = this._getOrReturnCtx(e, n)),
                f2(n, { validation: "url", code: l2.invalid_string, message: o.message }),
                t.dirty()
            }
          else
            "regex" === o.kind
              ? ((o.regex.lastIndex = 0),
                o.regex.test(e.data) ||
                  ((n = this._getOrReturnCtx(e, n)),
                  f2(n, { validation: "regex", code: l2.invalid_string, message: o.message }),
                  t.dirty()))
              : "trim" === o.kind
                ? (e.data = e.data.trim())
                : "includes" === o.kind
                  ? e.data.includes(o.value, o.position) ||
                    ((n = this._getOrReturnCtx(e, n)),
                    f2(n, {
                      code: l2.invalid_string,
                      validation: { includes: o.value, position: o.position },
                      message: o.message,
                    }),
                    t.dirty())
                  : "toLowerCase" === o.kind
                    ? (e.data = e.data.toLowerCase())
                    : "toUpperCase" === o.kind
                      ? (e.data = e.data.toUpperCase())
                      : "startsWith" === o.kind
                        ? e.data.startsWith(o.value) ||
                          ((n = this._getOrReturnCtx(e, n)),
                          f2(n, { code: l2.invalid_string, validation: { startsWith: o.value }, message: o.message }),
                          t.dirty())
                        : "endsWith" === o.kind
                          ? e.data.endsWith(o.value) ||
                            ((n = this._getOrReturnCtx(e, n)),
                            f2(n, { code: l2.invalid_string, validation: { endsWith: o.value }, message: o.message }),
                            t.dirty())
                          : "datetime" === o.kind
                            ? V2(o).test(e.data) ||
                              ((n = this._getOrReturnCtx(e, n)),
                              f2(n, { code: l2.invalid_string, validation: "datetime", message: o.message }),
                              t.dirty())
                            : "date" === o.kind
                              ? Z2.test(e.data) ||
                                ((n = this._getOrReturnCtx(e, n)),
                                f2(n, { code: l2.invalid_string, validation: "date", message: o.message }),
                                t.dirty())
                              : "time" === o.kind
                                ? new RegExp(`^${H2(o)}$`).test(e.data) ||
                                  ((n = this._getOrReturnCtx(e, n)),
                                  f2(n, { code: l2.invalid_string, validation: "time", message: o.message }),
                                  t.dirty())
                                : "duration" === o.kind
                                  ? Q2.test(e.data) ||
                                    ((n = this._getOrReturnCtx(e, n)),
                                    f2(n, { validation: "duration", code: l2.invalid_string, message: o.message }),
                                    t.dirty())
                                  : "ip" === o.kind
                                    ? ((r = e.data),
                                      (("v4" !== (a = o.version) && a) || !U2.test(r)) &&
                                        (("v6" !== a && a) || !F2.test(r)) &&
                                        ((n = this._getOrReturnCtx(e, n)),
                                        f2(n, { validation: "ip", code: l2.invalid_string, message: o.message }),
                                        t.dirty()))
                                    : "base64" === o.kind
                                      ? z2.test(e.data) ||
                                        ((n = this._getOrReturnCtx(e, n)),
                                        f2(n, { validation: "base64", code: l2.invalid_string, message: o.message }),
                                        t.dirty())
                                      : r2.assertNever(o)
        var r, a
        return { status: t.value, value: e.data }
      }
      _regex(e, t, n) {
        return this.refinement((t) => e.test(t), { validation: t, code: l2.invalid_string, ...S2.errToObj(n) })
      }
      _addCheck(e) {
        return new W2({ ...this._def, checks: [...this._def.checks, e] })
      }
      email(e) {
        return this._addCheck({ kind: "email", ...S2.errToObj(e) })
      }
      url(e) {
        return this._addCheck({ kind: "url", ...S2.errToObj(e) })
      }
      emoji(e) {
        return this._addCheck({ kind: "emoji", ...S2.errToObj(e) })
      }
      uuid(e) {
        return this._addCheck({ kind: "uuid", ...S2.errToObj(e) })
      }
      nanoid(e) {
        return this._addCheck({ kind: "nanoid", ...S2.errToObj(e) })
      }
      cuid(e) {
        return this._addCheck({ kind: "cuid", ...S2.errToObj(e) })
      }
      cuid2(e) {
        return this._addCheck({ kind: "cuid2", ...S2.errToObj(e) })
      }
      ulid(e) {
        return this._addCheck({ kind: "ulid", ...S2.errToObj(e) })
      }
      base64(e) {
        return this._addCheck({ kind: "base64", ...S2.errToObj(e) })
      }
      ip(e) {
        return this._addCheck({ kind: "ip", ...S2.errToObj(e) })
      }
      datetime(e) {
        var t, n
        return "string" == typeof e
          ? this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: e })
          : this._addCheck({
              kind: "datetime",
              precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision,
              offset: null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t,
              local: null !== (n = null == e ? void 0 : e.local) && void 0 !== n && n,
              ...S2.errToObj(null == e ? void 0 : e.message),
            })
      }
      date(e) {
        return this._addCheck({ kind: "date", message: e })
      }
      time(e) {
        return "string" == typeof e
          ? this._addCheck({ kind: "time", precision: null, message: e })
          : this._addCheck({
              kind: "time",
              precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision,
              ...S2.errToObj(null == e ? void 0 : e.message),
            })
      }
      duration(e) {
        return this._addCheck({ kind: "duration", ...S2.errToObj(e) })
      }
      regex(e, t) {
        return this._addCheck({ kind: "regex", regex: e, ...S2.errToObj(t) })
      }
      includes(e, t) {
        return this._addCheck({
          kind: "includes",
          value: e,
          position: null == t ? void 0 : t.position,
          ...S2.errToObj(null == t ? void 0 : t.message),
        })
      }
      startsWith(e, t) {
        return this._addCheck({ kind: "startsWith", value: e, ...S2.errToObj(t) })
      }
      endsWith(e, t) {
        return this._addCheck({ kind: "endsWith", value: e, ...S2.errToObj(t) })
      }
      min(e, t) {
        return this._addCheck({ kind: "min", value: e, ...S2.errToObj(t) })
      }
      max(e, t) {
        return this._addCheck({ kind: "max", value: e, ...S2.errToObj(t) })
      }
      length(e, t) {
        return this._addCheck({ kind: "length", value: e, ...S2.errToObj(t) })
      }
      nonempty(e) {
        return this.min(1, S2.errToObj(e))
      }
      trim() {
        return new W2({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] })
      }
      toLowerCase() {
        return new W2({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] })
      }
      toUpperCase() {
        return new W2({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] })
      }
      get isDatetime() {
        return !!this._def.checks.find((e) => "datetime" === e.kind)
      }
      get isDate() {
        return !!this._def.checks.find((e) => "date" === e.kind)
      }
      get isTime() {
        return !!this._def.checks.find((e) => "time" === e.kind)
      }
      get isDuration() {
        return !!this._def.checks.find((e) => "duration" === e.kind)
      }
      get isEmail() {
        return !!this._def.checks.find((e) => "email" === e.kind)
      }
      get isURL() {
        return !!this._def.checks.find((e) => "url" === e.kind)
      }
      get isEmoji() {
        return !!this._def.checks.find((e) => "emoji" === e.kind)
      }
      get isUUID() {
        return !!this._def.checks.find((e) => "uuid" === e.kind)
      }
      get isNANOID() {
        return !!this._def.checks.find((e) => "nanoid" === e.kind)
      }
      get isCUID() {
        return !!this._def.checks.find((e) => "cuid" === e.kind)
      }
      get isCUID2() {
        return !!this._def.checks.find((e) => "cuid2" === e.kind)
      }
      get isULID() {
        return !!this._def.checks.find((e) => "ulid" === e.kind)
      }
      get isIP() {
        return !!this._def.checks.find((e) => "ip" === e.kind)
      }
      get isBase64() {
        return !!this._def.checks.find((e) => "base64" === e.kind)
      }
      get minLength() {
        let e = null
        for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value)
        return e
      }
      get maxLength() {
        let e = null
        for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value)
        return e
      }
    }
    function X2(e, t) {
      const n = (e.toString().split(".")[1] || "").length,
        r = (t.toString().split(".")[1] || "").length,
        a = n > r ? n : r
      return (parseInt(e.toFixed(a).replace(".", "")) % parseInt(t.toFixed(a).replace(".", ""))) / Math.pow(10, a)
    }
    W2.create = (e) => {
      var t
      return new W2({
        checks: [],
        typeName: Q5.ZodString,
        coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
        ...D2(e),
      })
    }
    class Y2 extends R2 {
      constructor() {
        super(...arguments), (this.min = this.gte), (this.max = this.lte), (this.step = this.multipleOf)
      }
      _parse(e) {
        if ((this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== i2.number)) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.number, received: t.parsedType }), g2
        }
        let t
        const n = new m2()
        for (const r of this._def.checks)
          "int" === r.kind
            ? r2.isInteger(e.data) ||
              ((t = this._getOrReturnCtx(e, t)),
              f2(t, { code: l2.invalid_type, expected: "integer", received: "float", message: r.message }),
              n.dirty())
            : "min" === r.kind
              ? (r.inclusive ? e.data < r.value : e.data <= r.value) &&
                ((t = this._getOrReturnCtx(e, t)),
                f2(t, {
                  code: l2.too_small,
                  minimum: r.value,
                  type: "number",
                  inclusive: r.inclusive,
                  exact: !1,
                  message: r.message,
                }),
                n.dirty())
              : "max" === r.kind
                ? (r.inclusive ? e.data > r.value : e.data >= r.value) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  f2(t, {
                    code: l2.too_big,
                    maximum: r.value,
                    type: "number",
                    inclusive: r.inclusive,
                    exact: !1,
                    message: r.message,
                  }),
                  n.dirty())
                : "multipleOf" === r.kind
                  ? 0 !== X2(e.data, r.value) &&
                    ((t = this._getOrReturnCtx(e, t)),
                    f2(t, { code: l2.not_multiple_of, multipleOf: r.value, message: r.message }),
                    n.dirty())
                  : "finite" === r.kind
                    ? Number.isFinite(e.data) ||
                      ((t = this._getOrReturnCtx(e, t)), f2(t, { code: l2.not_finite, message: r.message }), n.dirty())
                    : r2.assertNever(r)
        return { status: n.value, value: e.data }
      }
      gte(e, t) {
        return this.setLimit("min", e, !0, S2.toString(t))
      }
      gt(e, t) {
        return this.setLimit("min", e, !1, S2.toString(t))
      }
      lte(e, t) {
        return this.setLimit("max", e, !0, S2.toString(t))
      }
      lt(e, t) {
        return this.setLimit("max", e, !1, S2.toString(t))
      }
      setLimit(e, t, n, r) {
        return new Y2({
          ...this._def,
          checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: S2.toString(r) }],
        })
      }
      _addCheck(e) {
        return new Y2({ ...this._def, checks: [...this._def.checks, e] })
      }
      int(e) {
        return this._addCheck({ kind: "int", message: S2.toString(e) })
      }
      positive(e) {
        return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: S2.toString(e) })
      }
      negative(e) {
        return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: S2.toString(e) })
      }
      nonpositive(e) {
        return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: S2.toString(e) })
      }
      nonnegative(e) {
        return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: S2.toString(e) })
      }
      multipleOf(e, t) {
        return this._addCheck({ kind: "multipleOf", value: e, message: S2.toString(t) })
      }
      finite(e) {
        return this._addCheck({ kind: "finite", message: S2.toString(e) })
      }
      safe(e) {
        return this._addCheck({
          kind: "min",
          inclusive: !0,
          value: Number.MIN_SAFE_INTEGER,
          message: S2.toString(e),
        })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: S2.toString(e) })
      }
      get minValue() {
        let e = null
        for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value)
        return e
      }
      get maxValue() {
        let e = null
        for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value)
        return e
      }
      get isInt() {
        return !!this._def.checks.find((e) => "int" === e.kind || ("multipleOf" === e.kind && r2.isInteger(e.value)))
      }
      get isFinite() {
        let e = null,
          t = null
        for (const n of this._def.checks) {
          if ("finite" === n.kind || "int" === n.kind || "multipleOf" === n.kind) return !0
          "min" === n.kind
            ? (null === t || n.value > t) && (t = n.value)
            : "max" === n.kind && (null === e || n.value < e) && (e = n.value)
        }
        return Number.isFinite(t) && Number.isFinite(e)
      }
    }
    Y2.create = (e) =>
      new Y2({ checks: [], typeName: Q5.ZodNumber, coerce: (null == e ? void 0 : e.coerce) || !1, ...D2(e) })
    class G2 extends R2 {
      constructor() {
        super(...arguments), (this.min = this.gte), (this.max = this.lte)
      }
      _parse(e) {
        if ((this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== i2.bigint)) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.bigint, received: t.parsedType }), g2
        }
        let t
        const n = new m2()
        for (const r of this._def.checks)
          "min" === r.kind
            ? (r.inclusive ? e.data < r.value : e.data <= r.value) &&
              ((t = this._getOrReturnCtx(e, t)),
              f2(t, {
                code: l2.too_small,
                type: "bigint",
                minimum: r.value,
                inclusive: r.inclusive,
                message: r.message,
              }),
              n.dirty())
            : "max" === r.kind
              ? (r.inclusive ? e.data > r.value : e.data >= r.value) &&
                ((t = this._getOrReturnCtx(e, t)),
                f2(t, {
                  code: l2.too_big,
                  type: "bigint",
                  maximum: r.value,
                  inclusive: r.inclusive,
                  message: r.message,
                }),
                n.dirty())
              : "multipleOf" === r.kind
                ? e.data % r.value !== BigInt(0) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  f2(t, { code: l2.not_multiple_of, multipleOf: r.value, message: r.message }),
                  n.dirty())
                : r2.assertNever(r)
        return { status: n.value, value: e.data }
      }
      gte(e, t) {
        return this.setLimit("min", e, !0, S2.toString(t))
      }
      gt(e, t) {
        return this.setLimit("min", e, !1, S2.toString(t))
      }
      lte(e, t) {
        return this.setLimit("max", e, !0, S2.toString(t))
      }
      lt(e, t) {
        return this.setLimit("max", e, !1, S2.toString(t))
      }
      setLimit(e, t, n, r) {
        return new G2({
          ...this._def,
          checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: S2.toString(r) }],
        })
      }
      _addCheck(e) {
        return new G2({ ...this._def, checks: [...this._def.checks, e] })
      }
      positive(e) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: S2.toString(e) })
      }
      negative(e) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: S2.toString(e) })
      }
      nonpositive(e) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: S2.toString(e) })
      }
      nonnegative(e) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: S2.toString(e) })
      }
      multipleOf(e, t) {
        return this._addCheck({ kind: "multipleOf", value: e, message: S2.toString(t) })
      }
      get minValue() {
        let e = null
        for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value)
        return e
      }
      get maxValue() {
        let e = null
        for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value)
        return e
      }
    }
    G2.create = (e) => {
      var t
      return new G2({
        checks: [],
        typeName: Q5.ZodBigInt,
        coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
        ...D2(e),
      })
    }
    class K2 extends R2 {
      _parse(e) {
        if ((this._def.coerce && (e.data = Boolean(e.data)), this._getType(e) !== i2.boolean)) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.boolean, received: t.parsedType }), g2
        }
        return v2(e.data)
      }
    }
    K2.create = (e) => new K2({ typeName: Q5.ZodBoolean, coerce: (null == e ? void 0 : e.coerce) || !1, ...D2(e) })
    class J2 extends R2 {
      _parse(e) {
        if ((this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== i2.date)) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.date, received: t.parsedType }), g2
        }
        if (isNaN(e.data.getTime())) return f2(this._getOrReturnCtx(e), { code: l2.invalid_date }), g2
        const t = new m2()
        let n
        for (const r of this._def.checks)
          "min" === r.kind
            ? e.data.getTime() < r.value &&
              ((n = this._getOrReturnCtx(e, n)),
              f2(n, {
                code: l2.too_small,
                message: r.message,
                inclusive: !0,
                exact: !1,
                minimum: r.value,
                type: "date",
              }),
              t.dirty())
            : "max" === r.kind
              ? e.data.getTime() > r.value &&
                ((n = this._getOrReturnCtx(e, n)),
                f2(n, {
                  code: l2.too_big,
                  message: r.message,
                  inclusive: !0,
                  exact: !1,
                  maximum: r.value,
                  type: "date",
                }),
                t.dirty())
              : r2.assertNever(r)
        return { status: t.value, value: new Date(e.data.getTime()) }
      }
      _addCheck(e) {
        return new J2({ ...this._def, checks: [...this._def.checks, e] })
      }
      min(e, t) {
        return this._addCheck({ kind: "min", value: e.getTime(), message: S2.toString(t) })
      }
      max(e, t) {
        return this._addCheck({ kind: "max", value: e.getTime(), message: S2.toString(t) })
      }
      get minDate() {
        let e = null
        for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value)
        return null != e ? new Date(e) : null
      }
      get maxDate() {
        let e = null
        for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value)
        return null != e ? new Date(e) : null
      }
    }
    J2.create = (e) =>
      new J2({ checks: [], coerce: (null == e ? void 0 : e.coerce) || !1, typeName: Q5.ZodDate, ...D2(e) })
    class e5 extends R2 {
      _parse(e) {
        if (this._getType(e) !== i2.symbol) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.symbol, received: t.parsedType }), g2
        }
        return v2(e.data)
      }
    }
    e5.create = (e) => new e5({ typeName: Q5.ZodSymbol, ...D2(e) })
    class t5 extends R2 {
      _parse(e) {
        if (this._getType(e) !== i2.undefined) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.undefined, received: t.parsedType }), g2
        }
        return v2(e.data)
      }
    }
    t5.create = (e) => new t5({ typeName: Q5.ZodUndefined, ...D2(e) })
    class n5 extends R2 {
      _parse(e) {
        if (this._getType(e) !== i2.null) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.null, received: t.parsedType }), g2
        }
        return v2(e.data)
      }
    }
    n5.create = (e) => new n5({ typeName: Q5.ZodNull, ...D2(e) })
    class r5 extends R2 {
      constructor() {
        super(...arguments), (this._any = !0)
      }
      _parse(e) {
        return v2(e.data)
      }
    }
    r5.create = (e) => new r5({ typeName: Q5.ZodAny, ...D2(e) })
    class a5 extends R2 {
      constructor() {
        super(...arguments), (this._unknown = !0)
      }
      _parse(e) {
        return v2(e.data)
      }
    }
    a5.create = (e) => new a5({ typeName: Q5.ZodUnknown, ...D2(e) })
    class o5 extends R2 {
      _parse(e) {
        const t = this._getOrReturnCtx(e)
        return f2(t, { code: l2.invalid_type, expected: i2.never, received: t.parsedType }), g2
      }
    }
    o5.create = (e) => new o5({ typeName: Q5.ZodNever, ...D2(e) })
    class i5 extends R2 {
      _parse(e) {
        if (this._getType(e) !== i2.undefined) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.void, received: t.parsedType }), g2
        }
        return v2(e.data)
      }
    }
    i5.create = (e) => new i5({ typeName: Q5.ZodVoid, ...D2(e) })
    class s5 extends R2 {
      _parse(e) {
        const { ctx: t, status: n } = this._processInputParams(e),
          r = this._def
        if (t.parsedType !== i2.array)
          return f2(t, { code: l2.invalid_type, expected: i2.array, received: t.parsedType }), g2
        if (null !== r.exactLength) {
          const e = t.data.length > r.exactLength.value,
            a = t.data.length < r.exactLength.value
          ;(e || a) &&
            (f2(t, {
              code: e ? l2.too_big : l2.too_small,
              minimum: a ? r.exactLength.value : void 0,
              maximum: e ? r.exactLength.value : void 0,
              type: "array",
              inclusive: !0,
              exact: !0,
              message: r.exactLength.message,
            }),
            n.dirty())
        }
        if (
          (null !== r.minLength &&
            t.data.length < r.minLength.value &&
            (f2(t, {
              code: l2.too_small,
              minimum: r.minLength.value,
              type: "array",
              inclusive: !0,
              exact: !1,
              message: r.minLength.message,
            }),
            n.dirty()),
          null !== r.maxLength &&
            t.data.length > r.maxLength.value &&
            (f2(t, {
              code: l2.too_big,
              maximum: r.maxLength.value,
              type: "array",
              inclusive: !0,
              exact: !1,
              message: r.maxLength.message,
            }),
            n.dirty()),
          t.common.async)
        )
          return Promise.all([...t.data].map((e, n) => r.type._parseAsync(new C2(t, e, t.path, n)))).then((e) =>
            m2.mergeArray(n, e),
          )
        const a = [...t.data].map((e, n) => r.type._parseSync(new C2(t, e, t.path, n)))
        return m2.mergeArray(n, a)
      }
      get element() {
        return this._def.type
      }
      min(e, t) {
        return new s5({ ...this._def, minLength: { value: e, message: S2.toString(t) } })
      }
      max(e, t) {
        return new s5({ ...this._def, maxLength: { value: e, message: S2.toString(t) } })
      }
      length(e, t) {
        return new s5({ ...this._def, exactLength: { value: e, message: S2.toString(t) } })
      }
      nonempty(e) {
        return this.min(1, e)
      }
    }
    function l5(e) {
      if (e instanceof c5) {
        const t = {}
        for (const n in e.shape) {
          const r = e.shape[n]
          t[n] = T5.create(l5(r))
        }
        return new c5({ ...e._def, shape: () => t })
      }
      return e instanceof s5
        ? new s5({ ...e._def, type: l5(e.element) })
        : e instanceof T5
          ? T5.create(l5(e.unwrap()))
          : e instanceof A5
            ? A5.create(l5(e.unwrap()))
            : e instanceof m5
              ? m5.create(e.items.map((e) => l5(e)))
              : e
    }
    s5.create = (e, t) =>
      new s5({ type: e, minLength: null, maxLength: null, exactLength: null, typeName: Q5.ZodArray, ...D2(t) })
    class c5 extends R2 {
      constructor() {
        super(...arguments), (this._cached = null), (this.nonstrict = this.passthrough), (this.augment = this.extend)
      }
      _getCached() {
        if (null !== this._cached) return this._cached
        const e = this._def.shape(),
          t = r2.objectKeys(e)
        return (this._cached = { shape: e, keys: t })
      }
      _parse(e) {
        if (this._getType(e) !== i2.object) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.object, received: t.parsedType }), g2
        }
        const { status: t, ctx: n } = this._processInputParams(e),
          { shape: r, keys: a } = this._getCached(),
          o = []
        if (!(this._def.catchall instanceof o5 && "strip" === this._def.unknownKeys))
          for (const e in n.data) a.includes(e) || o.push(e)
        const i = []
        for (const e of a) {
          const t = r[e],
            a = n.data[e]
          i.push({
            key: { status: "valid", value: e },
            value: t._parse(new C2(n, a, n.path, e)),
            alwaysSet: e in n.data,
          })
        }
        if (this._def.catchall instanceof o5) {
          const e = this._def.unknownKeys
          if ("passthrough" === e)
            for (const e of o)
              i.push({ key: { status: "valid", value: e }, value: { status: "valid", value: n.data[e] } })
          else if ("strict" === e) o.length > 0 && (f2(n, { code: l2.unrecognized_keys, keys: o }), t.dirty())
          else if ("strip" !== e) throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
          const e = this._def.catchall
          for (const t of o) {
            const r = n.data[t]
            i.push({
              key: { status: "valid", value: t },
              value: e._parse(new C2(n, r, n.path, t)),
              alwaysSet: t in n.data,
            })
          }
        }
        return n.common.async
          ? Promise.resolve()
              .then(async () => {
                const e = []
                for (const t of i) {
                  const n = await t.key,
                    r = await t.value
                  e.push({ key: n, value: r, alwaysSet: t.alwaysSet })
                }
                return e
              })
              .then((e) => m2.mergeObjectSync(t, e))
          : m2.mergeObjectSync(t, i)
      }
      get shape() {
        return this._def.shape()
      }
      strict(e) {
        return (
          S2.errToObj,
          new c5({
            ...this._def,
            unknownKeys: "strict",
            ...(void 0 !== e
              ? {
                  errorMap: (t, n) => {
                    var r, a, o, i
                    const s =
                      null !==
                        (o =
                          null === (a = (r = this._def).errorMap) || void 0 === a ? void 0 : a.call(r, t, n).message) &&
                      void 0 !== o
                        ? o
                        : n.defaultError
                    return "unrecognized_keys" === t.code
                      ? { message: null !== (i = S2.errToObj(e).message) && void 0 !== i ? i : s }
                      : { message: s }
                  },
                }
              : {}),
          })
        )
      }
      strip() {
        return new c5({ ...this._def, unknownKeys: "strip" })
      }
      passthrough() {
        return new c5({ ...this._def, unknownKeys: "passthrough" })
      }
      extend(e) {
        return new c5({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) })
      }
      merge(e) {
        return new c5({
          unknownKeys: e._def.unknownKeys,
          catchall: e._def.catchall,
          shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
          typeName: Q5.ZodObject,
        })
      }
      setKey(e, t) {
        return this.augment({ [e]: t })
      }
      catchall(e) {
        return new c5({ ...this._def, catchall: e })
      }
      pick(e) {
        const t = {}
        return (
          r2.objectKeys(e).forEach((n) => {
            e[n] && this.shape[n] && (t[n] = this.shape[n])
          }),
          new c5({ ...this._def, shape: () => t })
        )
      }
      omit(e) {
        const t = {}
        return (
          r2.objectKeys(this.shape).forEach((n) => {
            e[n] || (t[n] = this.shape[n])
          }),
          new c5({ ...this._def, shape: () => t })
        )
      }
      deepPartial() {
        return l5(this)
      }
      partial(e) {
        const t = {}
        return (
          r2.objectKeys(this.shape).forEach((n) => {
            const r = this.shape[n]
            e && !e[n] ? (t[n] = r) : (t[n] = r.optional())
          }),
          new c5({ ...this._def, shape: () => t })
        )
      }
      required(e) {
        const t = {}
        return (
          r2.objectKeys(this.shape).forEach((n) => {
            if (e && !e[n]) t[n] = this.shape[n]
            else {
              let e = this.shape[n]
              for (; e instanceof T5; ) e = e._def.innerType
              t[n] = e
            }
          }),
          new c5({ ...this._def, shape: () => t })
        )
      }
      keyof() {
        return x5(r2.objectKeys(this.shape))
      }
    }
    ;(c5.create = (e, t) =>
      new c5({ shape: () => e, unknownKeys: "strip", catchall: o5.create(), typeName: Q5.ZodObject, ...D2(t) })),
      (c5.strictCreate = (e, t) =>
        new c5({ shape: () => e, unknownKeys: "strict", catchall: o5.create(), typeName: Q5.ZodObject, ...D2(t) })),
      (c5.lazycreate = (e, t) =>
        new c5({ shape: e, unknownKeys: "strip", catchall: o5.create(), typeName: Q5.ZodObject, ...D2(t) }))
    class d5 extends R2 {
      _parse(e) {
        const { ctx: t } = this._processInputParams(e),
          n = this._def.options
        if (t.common.async)
          return Promise.all(
            n.map(async (e) => {
              const n = { ...t, common: { ...t.common, issues: [] }, parent: null }
              return { result: await e._parseAsync({ data: t.data, path: t.path, parent: n }), ctx: n }
            }),
          ).then(function (e) {
            for (const t of e) if ("valid" === t.result.status) return t.result
            for (const n of e)
              if ("dirty" === n.result.status) return t.common.issues.push(...n.ctx.common.issues), n.result
            const n = e.map((e) => new c2(e.ctx.common.issues))
            return f2(t, { code: l2.invalid_union, unionErrors: n }), g2
          })
        {
          let e
          const r = []
          for (const a of n) {
            const n = { ...t, common: { ...t.common, issues: [] }, parent: null },
              o = a._parseSync({ data: t.data, path: t.path, parent: n })
            if ("valid" === o.status) return o
            "dirty" !== o.status || e || (e = { result: o, ctx: n }), n.common.issues.length && r.push(n.common.issues)
          }
          if (e) return t.common.issues.push(...e.ctx.common.issues), e.result
          const a = r.map((e) => new c2(e))
          return f2(t, { code: l2.invalid_union, unionErrors: a }), g2
        }
      }
      get options() {
        return this._def.options
      }
    }
    d5.create = (e, t) => new d5({ options: e, typeName: Q5.ZodUnion, ...D2(t) })
    const u5 = (e) =>
      e instanceof O5
        ? u5(e.schema)
        : e instanceof E5
          ? u5(e.innerType())
          : e instanceof w5
            ? [e.value]
            : e instanceof k5
              ? e.options
              : e instanceof _5
                ? r2.objectValues(e.enum)
                : e instanceof C5
                  ? u5(e._def.innerType)
                  : e instanceof t5
                    ? [void 0]
                    : e instanceof n5
                      ? [null]
                      : e instanceof T5
                        ? [void 0, ...u5(e.unwrap())]
                        : e instanceof A5
                          ? [null, ...u5(e.unwrap())]
                          : e instanceof N5 || e instanceof I5
                            ? u5(e.unwrap())
                            : e instanceof P5
                              ? u5(e._def.innerType)
                              : []
    class p5 extends R2 {
      _parse(e) {
        const { ctx: t } = this._processInputParams(e)
        if (t.parsedType !== i2.object)
          return f2(t, { code: l2.invalid_type, expected: i2.object, received: t.parsedType }), g2
        const n = this.discriminator,
          r = t.data[n],
          a = this.optionsMap.get(r)
        return a
          ? t.common.async
            ? a._parseAsync({ data: t.data, path: t.path, parent: t })
            : a._parseSync({ data: t.data, path: t.path, parent: t })
          : (f2(t, { code: l2.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n] }),
            g2)
      }
      get discriminator() {
        return this._def.discriminator
      }
      get options() {
        return this._def.options
      }
      get optionsMap() {
        return this._def.optionsMap
      }
      static create(e, t, n) {
        const r = new Map()
        for (const n of t) {
          const t = u5(n.shape[e])
          if (!t.length)
            throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`)
          for (const a of t) {
            if (r.has(a)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`)
            r.set(a, n)
          }
        }
        return new p5({ typeName: Q5.ZodDiscriminatedUnion, discriminator: e, options: t, optionsMap: r, ...D2(n) })
      }
    }
    function h5(e, t) {
      const n = s2(e),
        r = s2(t)
      if (e === t) return { valid: !0, data: e }
      if (n === i2.object && r === i2.object) {
        const n = r2.objectKeys(t),
          r = r2.objectKeys(e).filter((e) => -1 !== n.indexOf(e)),
          a = { ...e, ...t }
        for (const n of r) {
          const r = h5(e[n], t[n])
          if (!r.valid) return { valid: !1 }
          a[n] = r.data
        }
        return { valid: !0, data: a }
      }
      if (n === i2.array && r === i2.array) {
        if (e.length !== t.length) return { valid: !1 }
        const n = []
        for (let r = 0; r < e.length; r++) {
          const a = h5(e[r], t[r])
          if (!a.valid) return { valid: !1 }
          n.push(a.data)
        }
        return { valid: !0, data: n }
      }
      return n === i2.date && r === i2.date && +e == +t ? { valid: !0, data: e } : { valid: !1 }
    }
    class f5 extends R2 {
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e),
          r = (e, r) => {
            if (y2(e) || y2(r)) return g2
            const a = h5(e.value, r.value)
            return a.valid
              ? ((O2(e) || O2(r)) && t.dirty(), { status: t.value, value: a.data })
              : (f2(n, { code: l2.invalid_intersection_types }), g2)
          }
        return n.common.async
          ? Promise.all([
              this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
              this._def.right._parseAsync({ data: n.data, path: n.path, parent: n }),
            ]).then(([e, t]) => r(e, t))
          : r(
              this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
              this._def.right._parseSync({ data: n.data, path: n.path, parent: n }),
            )
      }
    }
    f5.create = (e, t, n) => new f5({ left: e, right: t, typeName: Q5.ZodIntersection, ...D2(n) })
    class m5 extends R2 {
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e)
        if (n.parsedType !== i2.array)
          return f2(n, { code: l2.invalid_type, expected: i2.array, received: n.parsedType }), g2
        if (n.data.length < this._def.items.length)
          return (
            f2(n, { code: l2.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), g2
          )
        !this._def.rest &&
          n.data.length > this._def.items.length &&
          (f2(n, { code: l2.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }),
          t.dirty())
        const r = [...n.data]
          .map((e, t) => {
            const r = this._def.items[t] || this._def.rest
            return r ? r._parse(new C2(n, e, n.path, t)) : null
          })
          .filter((e) => !!e)
        return n.common.async ? Promise.all(r).then((e) => m2.mergeArray(t, e)) : m2.mergeArray(t, r)
      }
      get items() {
        return this._def.items
      }
      rest(e) {
        return new m5({ ...this._def, rest: e })
      }
    }
    m5.create = (e, t) => {
      if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])")
      return new m5({ items: e, typeName: Q5.ZodTuple, rest: null, ...D2(t) })
    }
    class g5 extends R2 {
      get keySchema() {
        return this._def.keyType
      }
      get valueSchema() {
        return this._def.valueType
      }
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e)
        if (n.parsedType !== i2.object)
          return f2(n, { code: l2.invalid_type, expected: i2.object, received: n.parsedType }), g2
        const r = [],
          a = this._def.keyType,
          o = this._def.valueType
        for (const e in n.data)
          r.push({
            key: a._parse(new C2(n, e, n.path, e)),
            value: o._parse(new C2(n, n.data[e], n.path, e)),
            alwaysSet: e in n.data,
          })
        return n.common.async ? m2.mergeObjectAsync(t, r) : m2.mergeObjectSync(t, r)
      }
      get element() {
        return this._def.valueType
      }
      static create(e, t, n) {
        return new g5(
          t instanceof R2
            ? { keyType: e, valueType: t, typeName: Q5.ZodRecord, ...D2(n) }
            : { keyType: W2.create(), valueType: e, typeName: Q5.ZodRecord, ...D2(t) },
        )
      }
    }
    class b5 extends R2 {
      get keySchema() {
        return this._def.keyType
      }
      get valueSchema() {
        return this._def.valueType
      }
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e)
        if (n.parsedType !== i2.map)
          return f2(n, { code: l2.invalid_type, expected: i2.map, received: n.parsedType }), g2
        const r = this._def.keyType,
          a = this._def.valueType,
          o = [...n.data.entries()].map(([e, t], o) => ({
            key: r._parse(new C2(n, e, n.path, [o, "key"])),
            value: a._parse(new C2(n, t, n.path, [o, "value"])),
          }))
        if (n.common.async) {
          const e = new Map()
          return Promise.resolve().then(async () => {
            for (const n of o) {
              const r = await n.key,
                a = await n.value
              if ("aborted" === r.status || "aborted" === a.status) return g2
              ;("dirty" !== r.status && "dirty" !== a.status) || t.dirty(), e.set(r.value, a.value)
            }
            return { status: t.value, value: e }
          })
        }
        {
          const e = new Map()
          for (const n of o) {
            const r = n.key,
              a = n.value
            if ("aborted" === r.status || "aborted" === a.status) return g2
            ;("dirty" !== r.status && "dirty" !== a.status) || t.dirty(), e.set(r.value, a.value)
          }
          return { status: t.value, value: e }
        }
      }
    }
    b5.create = (e, t, n) => new b5({ valueType: t, keyType: e, typeName: Q5.ZodMap, ...D2(n) })
    class v5 extends R2 {
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e)
        if (n.parsedType !== i2.set)
          return f2(n, { code: l2.invalid_type, expected: i2.set, received: n.parsedType }), g2
        const r = this._def
        null !== r.minSize &&
          n.data.size < r.minSize.value &&
          (f2(n, {
            code: l2.too_small,
            minimum: r.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: r.minSize.message,
          }),
          t.dirty()),
          null !== r.maxSize &&
            n.data.size > r.maxSize.value &&
            (f2(n, {
              code: l2.too_big,
              maximum: r.maxSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: r.maxSize.message,
            }),
            t.dirty())
        const a = this._def.valueType
        function o(e) {
          const n = new Set()
          for (const r of e) {
            if ("aborted" === r.status) return g2
            "dirty" === r.status && t.dirty(), n.add(r.value)
          }
          return { status: t.value, value: n }
        }
        const i = [...n.data.values()].map((e, t) => a._parse(new C2(n, e, n.path, t)))
        return n.common.async ? Promise.all(i).then((e) => o(e)) : o(i)
      }
      min(e, t) {
        return new v5({ ...this._def, minSize: { value: e, message: S2.toString(t) } })
      }
      max(e, t) {
        return new v5({ ...this._def, maxSize: { value: e, message: S2.toString(t) } })
      }
      size(e, t) {
        return this.min(e, t).max(e, t)
      }
      nonempty(e) {
        return this.min(1, e)
      }
    }
    v5.create = (e, t) => new v5({ valueType: e, minSize: null, maxSize: null, typeName: Q5.ZodSet, ...D2(t) })
    class y5 extends R2 {
      constructor() {
        super(...arguments), (this.validate = this.implement)
      }
      _parse(e) {
        const { ctx: t } = this._processInputParams(e)
        if (t.parsedType !== i2.function)
          return f2(t, { code: l2.invalid_type, expected: i2.function, received: t.parsedType }), g2
        function n(e, n) {
          return h2({
            data: e,
            path: t.path,
            errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, p2(), d2].filter((e) => !!e),
            issueData: { code: l2.invalid_arguments, argumentsError: n },
          })
        }
        function r(e, n) {
          return h2({
            data: e,
            path: t.path,
            errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, p2(), d2].filter((e) => !!e),
            issueData: { code: l2.invalid_return_type, returnTypeError: n },
          })
        }
        const a = { errorMap: t.common.contextualErrorMap },
          o = t.data
        if (this._def.returns instanceof S5) {
          const e = this
          return v2(async function (...t) {
            const i = new c2([]),
              s = await e._def.args.parseAsync(t, a).catch((e) => {
                throw (i.addIssue(n(t, e)), i)
              }),
              l = await Reflect.apply(o, this, s)
            return await e._def.returns._def.type.parseAsync(l, a).catch((e) => {
              throw (i.addIssue(r(l, e)), i)
            })
          })
        }
        {
          const e = this
          return v2(function (...t) {
            const i = e._def.args.safeParse(t, a)
            if (!i.success) throw new c2([n(t, i.error)])
            const s = Reflect.apply(o, this, i.data),
              l = e._def.returns.safeParse(s, a)
            if (!l.success) throw new c2([r(s, l.error)])
            return l.data
          })
        }
      }
      parameters() {
        return this._def.args
      }
      returnType() {
        return this._def.returns
      }
      args(...e) {
        return new y5({ ...this._def, args: m5.create(e).rest(a5.create()) })
      }
      returns(e) {
        return new y5({ ...this._def, returns: e })
      }
      implement(e) {
        return this.parse(e)
      }
      strictImplement(e) {
        return this.parse(e)
      }
      static create(e, t, n) {
        return new y5({
          args: e || m5.create([]).rest(a5.create()),
          returns: t || a5.create(),
          typeName: Q5.ZodFunction,
          ...D2(n),
        })
      }
    }
    class O5 extends R2 {
      get schema() {
        return this._def.getter()
      }
      _parse(e) {
        const { ctx: t } = this._processInputParams(e)
        return this._def.getter()._parse({ data: t.data, path: t.path, parent: t })
      }
    }
    O5.create = (e, t) => new O5({ getter: e, typeName: Q5.ZodLazy, ...D2(t) })
    class w5 extends R2 {
      _parse(e) {
        if (e.data !== this._def.value) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { received: t.data, code: l2.invalid_literal, expected: this._def.value }), g2
        }
        return { status: "valid", value: e.data }
      }
      get value() {
        return this._def.value
      }
    }
    function x5(e, t) {
      return new k5({ values: e, typeName: Q5.ZodEnum, ...D2(t) })
    }
    w5.create = (e, t) => new w5({ value: e, typeName: Q5.ZodLiteral, ...D2(t) })
    class k5 extends R2 {
      constructor() {
        super(...arguments), T2.set(this, void 0)
      }
      _parse(e) {
        if ("string" != typeof e.data) {
          const t = this._getOrReturnCtx(e),
            n = this._def.values
          return f2(t, { expected: r2.joinValues(n), received: t.parsedType, code: l2.invalid_type }), g2
        }
        if ((k2(this, T2) || _2(this, T2, new Set(this._def.values)), !k2(this, T2).has(e.data))) {
          const t = this._getOrReturnCtx(e),
            n = this._def.values
          return f2(t, { received: t.data, code: l2.invalid_enum_value, options: n }), g2
        }
        return v2(e.data)
      }
      get options() {
        return this._def.values
      }
      get enum() {
        const e = {}
        for (const t of this._def.values) e[t] = t
        return e
      }
      get Values() {
        const e = {}
        for (const t of this._def.values) e[t] = t
        return e
      }
      get Enum() {
        const e = {}
        for (const t of this._def.values) e[t] = t
        return e
      }
      extract(e, t = this._def) {
        return k5.create(e, { ...this._def, ...t })
      }
      exclude(e, t = this._def) {
        return k5.create(
          this.options.filter((t) => !e.includes(t)),
          { ...this._def, ...t },
        )
      }
    }
    ;(T2 = new WeakMap()), (k5.create = x5)
    class _5 extends R2 {
      constructor() {
        super(...arguments), A2.set(this, void 0)
      }
      _parse(e) {
        const t = r2.getValidEnumValues(this._def.values),
          n = this._getOrReturnCtx(e)
        if (n.parsedType !== i2.string && n.parsedType !== i2.number) {
          const e = r2.objectValues(t)
          return f2(n, { expected: r2.joinValues(e), received: n.parsedType, code: l2.invalid_type }), g2
        }
        if (
          (k2(this, A2) || _2(this, A2, new Set(r2.getValidEnumValues(this._def.values))), !k2(this, A2).has(e.data))
        ) {
          const e = r2.objectValues(t)
          return f2(n, { received: n.data, code: l2.invalid_enum_value, options: e }), g2
        }
        return v2(e.data)
      }
      get enum() {
        return this._def.values
      }
    }
    ;(A2 = new WeakMap()), (_5.create = (e, t) => new _5({ values: e, typeName: Q5.ZodNativeEnum, ...D2(t) }))
    class S5 extends R2 {
      unwrap() {
        return this._def.type
      }
      _parse(e) {
        const { ctx: t } = this._processInputParams(e)
        if (t.parsedType !== i2.promise && !1 === t.common.async)
          return f2(t, { code: l2.invalid_type, expected: i2.promise, received: t.parsedType }), g2
        const n = t.parsedType === i2.promise ? t.data : Promise.resolve(t.data)
        return v2(n.then((e) => this._def.type.parseAsync(e, { path: t.path, errorMap: t.common.contextualErrorMap })))
      }
    }
    S5.create = (e, t) => new S5({ type: e, typeName: Q5.ZodPromise, ...D2(t) })
    class E5 extends R2 {
      innerType() {
        return this._def.schema
      }
      sourceType() {
        return this._def.schema._def.typeName === Q5.ZodEffects ? this._def.schema.sourceType() : this._def.schema
      }
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e),
          r = this._def.effect || null,
          a = {
            addIssue: (e) => {
              f2(n, e), e.fatal ? t.abort() : t.dirty()
            },
            get path() {
              return n.path
            },
          }
        if (((a.addIssue = a.addIssue.bind(a)), "preprocess" === r.type)) {
          const e = r.transform(n.data, a)
          if (n.common.async)
            return Promise.resolve(e).then(async (e) => {
              if ("aborted" === t.value) return g2
              const r = await this._def.schema._parseAsync({ data: e, path: n.path, parent: n })
              return "aborted" === r.status ? g2 : "dirty" === r.status || "dirty" === t.value ? b2(r.value) : r
            })
          {
            if ("aborted" === t.value) return g2
            const r = this._def.schema._parseSync({ data: e, path: n.path, parent: n })
            return "aborted" === r.status ? g2 : "dirty" === r.status || "dirty" === t.value ? b2(r.value) : r
          }
        }
        if ("refinement" === r.type) {
          const e = (e) => {
            const t = r.refinement(e, a)
            if (n.common.async) return Promise.resolve(t)
            if (t instanceof Promise)
              throw new Error(
                "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
              )
            return e
          }
          if (!1 === n.common.async) {
            const r = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n })
            return "aborted" === r.status
              ? g2
              : ("dirty" === r.status && t.dirty(), e(r.value), { status: t.value, value: r.value })
          }
          return this._def.schema
            ._parseAsync({ data: n.data, path: n.path, parent: n })
            .then((n) =>
              "aborted" === n.status
                ? g2
                : ("dirty" === n.status && t.dirty(), e(n.value).then(() => ({ status: t.value, value: n.value }))),
            )
        }
        if ("transform" === r.type) {
          if (!1 === n.common.async) {
            const e = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n })
            if (!w2(e)) return e
            const o = r.transform(e.value, a)
            if (o instanceof Promise)
              throw new Error(
                "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
              )
            return { status: t.value, value: o }
          }
          return this._def.schema
            ._parseAsync({ data: n.data, path: n.path, parent: n })
            .then((e) =>
              w2(e) ? Promise.resolve(r.transform(e.value, a)).then((e) => ({ status: t.value, value: e })) : e,
            )
        }
        r2.assertNever(r)
      }
    }
    ;(E5.create = (e, t, n) => new E5({ schema: e, typeName: Q5.ZodEffects, effect: t, ...D2(n) })),
      (E5.createWithPreprocess = (e, t, n) =>
        new E5({ schema: t, effect: { type: "preprocess", transform: e }, typeName: Q5.ZodEffects, ...D2(n) }))
    class T5 extends R2 {
      _parse(e) {
        return this._getType(e) === i2.undefined ? v2(void 0) : this._def.innerType._parse(e)
      }
      unwrap() {
        return this._def.innerType
      }
    }
    T5.create = (e, t) => new T5({ innerType: e, typeName: Q5.ZodOptional, ...D2(t) })
    class A5 extends R2 {
      _parse(e) {
        return this._getType(e) === i2.null ? v2(null) : this._def.innerType._parse(e)
      }
      unwrap() {
        return this._def.innerType
      }
    }
    A5.create = (e, t) => new A5({ innerType: e, typeName: Q5.ZodNullable, ...D2(t) })
    class C5 extends R2 {
      _parse(e) {
        const { ctx: t } = this._processInputParams(e)
        let n = t.data
        return (
          t.parsedType === i2.undefined && (n = this._def.defaultValue()),
          this._def.innerType._parse({ data: n, path: t.path, parent: t })
        )
      }
      removeDefault() {
        return this._def.innerType
      }
    }
    C5.create = (e, t) =>
      new C5({
        innerType: e,
        typeName: Q5.ZodDefault,
        defaultValue: "function" == typeof t.default ? t.default : () => t.default,
        ...D2(t),
      })
    class P5 extends R2 {
      _parse(e) {
        const { ctx: t } = this._processInputParams(e),
          n = { ...t, common: { ...t.common, issues: [] } },
          r = this._def.innerType._parse({ data: n.data, path: n.path, parent: { ...n } })
        return x2(r)
          ? r.then((e) => ({
              status: "valid",
              value:
                "valid" === e.status
                  ? e.value
                  : this._def.catchValue({
                      get error() {
                        return new c2(n.common.issues)
                      },
                      input: n.data,
                    }),
            }))
          : {
              status: "valid",
              value:
                "valid" === r.status
                  ? r.value
                  : this._def.catchValue({
                      get error() {
                        return new c2(n.common.issues)
                      },
                      input: n.data,
                    }),
            }
      }
      removeCatch() {
        return this._def.innerType
      }
    }
    P5.create = (e, t) =>
      new P5({
        innerType: e,
        typeName: Q5.ZodCatch,
        catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
        ...D2(t),
      })
    class D5 extends R2 {
      _parse(e) {
        if (this._getType(e) !== i2.nan) {
          const t = this._getOrReturnCtx(e)
          return f2(t, { code: l2.invalid_type, expected: i2.nan, received: t.parsedType }), g2
        }
        return { status: "valid", value: e.data }
      }
    }
    D5.create = (e) => new D5({ typeName: Q5.ZodNaN, ...D2(e) })
    const R5 = Symbol("zod_brand")
    class N5 extends R2 {
      _parse(e) {
        const { ctx: t } = this._processInputParams(e),
          n = t.data
        return this._def.type._parse({ data: n, path: t.path, parent: t })
      }
      unwrap() {
        return this._def.type
      }
    }
    class $5 extends R2 {
      _parse(e) {
        const { status: t, ctx: n } = this._processInputParams(e)
        if (n.common.async)
          return (async () => {
            const e = await this._def.in._parseAsync({ data: n.data, path: n.path, parent: n })
            return "aborted" === e.status
              ? g2
              : "dirty" === e.status
                ? (t.dirty(), b2(e.value))
                : this._def.out._parseAsync({ data: e.value, path: n.path, parent: n })
          })()
        {
          const e = this._def.in._parseSync({ data: n.data, path: n.path, parent: n })
          return "aborted" === e.status
            ? g2
            : "dirty" === e.status
              ? (t.dirty(), { status: "dirty", value: e.value })
              : this._def.out._parseSync({ data: e.value, path: n.path, parent: n })
        }
      }
      static create(e, t) {
        return new $5({ in: e, out: t, typeName: Q5.ZodPipeline })
      }
    }
    class I5 extends R2 {
      _parse(e) {
        const t = this._def.innerType._parse(e),
          n = (e) => (w2(e) && (e.value = Object.freeze(e.value)), e)
        return x2(t) ? t.then((e) => n(e)) : n(t)
      }
      unwrap() {
        return this._def.innerType
      }
    }
    function M5(e, t = {}, n) {
      return e
        ? r5.create().superRefine((r, a) => {
            var o, i
            if (!e(r)) {
              const e = "function" == typeof t ? t(r) : "string" == typeof t ? { message: t } : t,
                s = null === (i = null !== (o = e.fatal) && void 0 !== o ? o : n) || void 0 === i || i,
                l = "string" == typeof e ? { message: e } : e
              a.addIssue({ code: "custom", ...l, fatal: s })
            }
          })
        : r5.create()
    }
    I5.create = (e, t) => new I5({ innerType: e, typeName: Q5.ZodReadonly, ...D2(t) })
    const L5 = { object: c5.lazycreate }
    var Q5, B5
    ;((B5 = Q5 || (Q5 = {})).ZodString = "ZodString"),
      (B5.ZodNumber = "ZodNumber"),
      (B5.ZodNaN = "ZodNaN"),
      (B5.ZodBigInt = "ZodBigInt"),
      (B5.ZodBoolean = "ZodBoolean"),
      (B5.ZodDate = "ZodDate"),
      (B5.ZodSymbol = "ZodSymbol"),
      (B5.ZodUndefined = "ZodUndefined"),
      (B5.ZodNull = "ZodNull"),
      (B5.ZodAny = "ZodAny"),
      (B5.ZodUnknown = "ZodUnknown"),
      (B5.ZodNever = "ZodNever"),
      (B5.ZodVoid = "ZodVoid"),
      (B5.ZodArray = "ZodArray"),
      (B5.ZodObject = "ZodObject"),
      (B5.ZodUnion = "ZodUnion"),
      (B5.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
      (B5.ZodIntersection = "ZodIntersection"),
      (B5.ZodTuple = "ZodTuple"),
      (B5.ZodRecord = "ZodRecord"),
      (B5.ZodMap = "ZodMap"),
      (B5.ZodSet = "ZodSet"),
      (B5.ZodFunction = "ZodFunction"),
      (B5.ZodLazy = "ZodLazy"),
      (B5.ZodLiteral = "ZodLiteral"),
      (B5.ZodEnum = "ZodEnum"),
      (B5.ZodEffects = "ZodEffects"),
      (B5.ZodNativeEnum = "ZodNativeEnum"),
      (B5.ZodOptional = "ZodOptional"),
      (B5.ZodNullable = "ZodNullable"),
      (B5.ZodDefault = "ZodDefault"),
      (B5.ZodCatch = "ZodCatch"),
      (B5.ZodPromise = "ZodPromise"),
      (B5.ZodBranded = "ZodBranded"),
      (B5.ZodPipeline = "ZodPipeline"),
      (B5.ZodReadonly = "ZodReadonly")
    const j5 = W2.create,
      U5 = Y2.create,
      F5 = D5.create,
      z5 = G2.create,
      q5 = K2.create,
      Z5 = J2.create,
      H5 = e5.create,
      V5 = t5.create,
      W5 = n5.create,
      X5 = r5.create,
      Y5 = a5.create,
      G5 = o5.create,
      K5 = i5.create,
      J5 = s5.create,
      e3 = c5.create,
      t3 = c5.strictCreate,
      n3 = d5.create,
      r3 = p5.create,
      a3 = f5.create,
      o3 = m5.create,
      i3 = g5.create,
      s3 = b5.create,
      l3 = v5.create,
      c3 = y5.create,
      d3 = O5.create,
      u3 = w5.create,
      p3 = k5.create,
      h3 = _5.create,
      f3 = S5.create,
      m3 = E5.create,
      g3 = T5.create,
      b3 = A5.create,
      v3 = E5.createWithPreprocess,
      y3 = $5.create,
      O3 = {
        string: (e) => W2.create({ ...e, coerce: !0 }),
        number: (e) => Y2.create({ ...e, coerce: !0 }),
        boolean: (e) => K2.create({ ...e, coerce: !0 }),
        bigint: (e) => G2.create({ ...e, coerce: !0 }),
        date: (e) => J2.create({ ...e, coerce: !0 }),
      },
      w3 = g2
    var x3 = Object.freeze({
      __proto__: null,
      defaultErrorMap: d2,
      setErrorMap: function (e) {
        u2 = e
      },
      getErrorMap: p2,
      makeIssue: h2,
      EMPTY_PATH: [],
      addIssueToContext: f2,
      ParseStatus: m2,
      INVALID: g2,
      DIRTY: b2,
      OK: v2,
      isAborted: y2,
      isDirty: O2,
      isValid: w2,
      isAsync: x2,
      get util() {
        return r2
      },
      get objectUtil() {
        return o2
      },
      ZodParsedType: i2,
      getParsedType: s2,
      ZodType: R2,
      datetimeRegex: V2,
      ZodString: W2,
      ZodNumber: Y2,
      ZodBigInt: G2,
      ZodBoolean: K2,
      ZodDate: J2,
      ZodSymbol: e5,
      ZodUndefined: t5,
      ZodNull: n5,
      ZodAny: r5,
      ZodUnknown: a5,
      ZodNever: o5,
      ZodVoid: i5,
      ZodArray: s5,
      ZodObject: c5,
      ZodUnion: d5,
      ZodDiscriminatedUnion: p5,
      ZodIntersection: f5,
      ZodTuple: m5,
      ZodRecord: g5,
      ZodMap: b5,
      ZodSet: v5,
      ZodFunction: y5,
      ZodLazy: O5,
      ZodLiteral: w5,
      ZodEnum: k5,
      ZodNativeEnum: _5,
      ZodPromise: S5,
      ZodEffects: E5,
      ZodTransformer: E5,
      ZodOptional: T5,
      ZodNullable: A5,
      ZodDefault: C5,
      ZodCatch: P5,
      ZodNaN: D5,
      BRAND: R5,
      ZodBranded: N5,
      ZodPipeline: $5,
      ZodReadonly: I5,
      custom: M5,
      Schema: R2,
      ZodSchema: R2,
      late: L5,
      get ZodFirstPartyTypeKind() {
        return Q5
      },
      coerce: O3,
      any: X5,
      array: J5,
      bigint: z5,
      boolean: q5,
      date: Z5,
      discriminatedUnion: r3,
      effect: m3,
      enum: p3,
      function: c3,
      instanceof: (e, t = { message: `Input not instance of ${e.name}` }) => M5((t) => t instanceof e, t),
      intersection: a3,
      lazy: d3,
      literal: u3,
      map: s3,
      nan: F5,
      nativeEnum: h3,
      never: G5,
      null: W5,
      nullable: b3,
      number: U5,
      object: e3,
      oboolean: () => q5().optional(),
      onumber: () => U5().optional(),
      optional: g3,
      ostring: () => j5().optional(),
      pipeline: y3,
      preprocess: v3,
      promise: f3,
      record: i3,
      set: l3,
      strictObject: t3,
      string: j5,
      symbol: H5,
      transformer: m3,
      tuple: o3,
      undefined: V5,
      union: n3,
      unknown: Y5,
      void: K5,
      NEVER: w3,
      ZodIssueCode: l2,
      quotelessJson: (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
      ZodError: c2,
    })
    const k3 = x3
        .string()
        .min(7)
        .optional()
        .default(() => NL()),
      _3 = x3.object({
        uid: k3,
        name: x3.string().default("Default Workspace"),
        description: x3.string().default("Basic Scalar Workspace"),
        isReadOnly: x3.boolean().default(!1),
        collectionUids: x3.array(x3.string()).default([]),
        environmentUids: x3.array(x3.string()).default([]),
        cookieUids: x3.array(x3.string()).default([]),
        proxyUrl: x3.string().optional(),
        themeId: x3
          .enum([
            "alternate",
            "default",
            "moon",
            "purple",
            "solarized",
            "bluePlanet",
            "deepSpace",
            "saturn",
            "kepler",
            "mars",
            "none",
          ])
          .optional()
          .default("default"),
      }),
      S3 = (e) => _3.parse(e),
      E3 = x3.record(x3.string(), x3.array(x3.string()).optional().default([])),
      T3 = x3.object({
        name: x3.string().optional().default("name"),
        identifier: x3.string().optional(),
        url: x3.string().url().optional(),
      }),
      A3 = x3.object({
        name: x3.string().optional(),
        url: x3.string().url().optional(),
        email: x3.string().email().optional(),
      }),
      C3 = x3.object({
        title: x3.string().optional().default("default"),
        summary: x3.string().optional(),
        description: x3.string().optional(),
        termsOfService: x3.string().optional(),
        contact: A3.optional(),
        license: T3.optional(),
        version: x3.string().default("0.0.1"),
      }),
      P3 = x3.object({ description: x3.string().optional(), url: x3.string().default("") }),
      D3 = x3.object({
        name: x3.string().optional().default("default"),
        description: x3.string().optional(),
        externalDocs: P3.optional(),
      }),
      R3 = x3.object({
        openapi: x3
          .union([x3.string(), x3.literal("3.1.0"), x3.literal("4.0.0")])
          .optional()
          .default("3.1.0"),
        security: x3.array(E3).optional().default([]),
        info: C3.optional(),
        serverUids: x3.array(x3.string()).default([]),
        tags: x3.array(D3).default([]),
        externalDocs: P3.optional(),
      }),
      N3 = x3.object({
        uid: k3,
        spec: R3.optional().default({}),
        selectedSecuritySchemes: x3
          .array(
            x3.object({
              uid: x3.string(),
              flowKey: x3.enum(["implicit", "clientCredentials", "password", "authorizationCode"]).optional(),
            }),
          )
          .default([]),
        selectedServerUid: x3.string().default(""),
        childUids: x3.array(x3.string()).default([]),
      }),
      $3 = (e) => ms(N3.parse({}), e),
      I3 = x3.object({
        uid: k3,
        name: x3.string().default("Default Cookie"),
        value: x3.string().default("Default Value"),
        domain: x3.string().optional(),
        expires: x3.date().optional(),
        httpOnly: x3.boolean().optional(),
        maxAge: x3.number().optional(),
        partitioned: x3.boolean().optional(),
        path: x3.string().optional(),
        sameSite: x3.union([x3.literal("Lax"), x3.literal("Strict"), x3.literal("None")]).default("None"),
        secure: x3.boolean().optional(),
      }),
      M3 = (e) => ms(I3.parse({}), e),
      L3 = x3.object({ key: x3.string(), value: x3.string() }),
      Q3 = x3.object({
        uid: k3,
        name: x3.string().optional().default("Default Environment"),
        color: x3.string().optional().default("blue"),
        raw: x3
          .string()
          .optional()
          .default(JSON.stringify({ exampleKey: "exampleValue" }, null, 2)),
        parsed: x3.array(L3).optional().default([]),
        isDefault: x3.boolean().optional(),
      }),
      B3 = x3.object({
        uid: k3,
        name: x3.string().optional().default("Folder"),
        description: x3.string().optional(),
        childUids: x3.array(x3.string()).default([]),
      }),
      j3 = (e) => ms(B3.parse({}), e),
      U3 = x3.string().optional().default("default"),
      F3 = x3.string().optional(),
      z3 = x3.string().optional().default(""),
      q3 = x3.object({
        type: x3.literal("apiKey"),
        uid: U3,
        description: F3,
        name: x3.string().optional().default("default"),
        in: x3.enum(["query", "header", "cookie"]).optional().default("header"),
        value: z3,
      }),
      Z3 = x3.object({
        type: x3.literal("http"),
        uid: U3,
        description: F3,
        scheme: x3.enum(["basic", "bearer"]).optional().default("basic"),
        bearerFormat: x3
          .union([x3.literal("JWT"), x3.string()])
          .optional()
          .default("JWT"),
        value: z3,
        secondValue: z3,
      }),
      H3 = x3.string().optional().default("https://scalar.com"),
      V3 = x3.string().optional().default("https://scalar.com"),
      W3 = x3.string().optional(),
      X3 = x3
        .union([
          x3.map(x3.string(), x3.string().optional()),
          x3.record(x3.string(), x3.string().optional()),
          x3.object({}),
        ])
        .optional(),
      Y3 = x3.array(x3.string()).optional().default([]),
      G3 = x3
        .object({
          implicit: x3
            .object({ authorizationUrl: H3, refreshUrl: W3, scopes: X3, selectedScopes: Y3, token: z3 })
            .optional(),
          password: x3
            .object({
              tokenUrl: V3,
              refreshUrl: W3,
              scopes: X3,
              value: z3,
              secondValue: z3,
              selectedScopes: Y3,
              clientSecret: z3,
              token: z3,
            })
            .optional(),
          clientCredentials: x3
            .object({ tokenUrl: V3, refreshUrl: W3, scopes: X3, clientSecret: z3, selectedScopes: Y3, token: z3 })
            .optional(),
          authorizationCode: x3
            .object({
              authorizationUrl: H3,
              tokenUrl: V3,
              refreshUrl: W3,
              scopes: X3,
              clientSecret: z3,
              selectedScopes: Y3,
              token: z3,
            })
            .optional(),
        })
        .optional()
        .default({ implicit: {} }),
      K3 = x3.object({
        type: x3.literal("oauth2"),
        uid: U3,
        description: F3,
        flows: G3,
        clientId: z3,
        redirectUri: x3.string().optional().default(""),
      }),
      J3 = x3.object({
        type: x3.literal("openIdConnect"),
        uid: U3,
        description: F3,
        openIdConnectUrl: x3.string().optional().default(""),
      }),
      e4 = x3.union([q3, Z3, K3, J3]),
      t4 = (e) => ms(e4.parse({ type: e.type }), e),
      n4 = x3.object({
        uid: k3,
        enum: x3.array(x3.string()).optional(),
        default: x3.string().optional().default("default"),
        description: x3.string().optional(),
        value: x3.string().optional(),
      }),
      r4 = x3.object({
        uid: k3,
        url: x3.string().optional().default(""),
        description: x3.string().optional(),
        variables: x3.record(x3.string(), n4).nullable().optional(),
      }),
      a4 = (e) => ms(r4.parse({}), e),
      o4 = x3.object({ path: x3.string(), collectionRef: x3.string().optional(), isExternal: x3.boolean() }),
      i4 = x3.any(),
      s4 = x3.record(x3.string(), x3.any()),
      l4 = x3.object({
        path: x3.string().optional().default(""),
        method: x3.enum(Object.keys(Ed)).optional().default("GET"),
        uid: k3,
        ref: o4.nullable().default(null),
        tags: x3.string().array().default(["default"]),
        summary: x3.string().optional(),
        description: x3.string().optional(),
        operationId: x3.string().optional(),
        parameters: x3
          .object({ path: s4, query: s4, headers: s4, cookies: s4 })
          .default({ path: {}, query: {}, headers: {}, cookies: {} }),
        security: x3.array(E3).optional(),
        requestBody: i4.optional(),
        childUids: k3.array().default([]),
        history: x3.any().array().default([]),
      }),
      c4 = (e) => ms(l4.parse({}), e),
      d4 = x3.object({
        key: x3.string().default(""),
        value: x3.union([x3.string(), x3.number()]).transform(String).default(""),
        enabled: x3.boolean().default(!0),
        file: x3.instanceof(File).optional(),
        description: x3.string().optional(),
        refUid: k3.optional(),
        required: x3.boolean().optional(),
        enum: x3.array(x3.string()).optional(),
        type: x3.string().optional(),
        format: x3.string().optional(),
        minimum: x3.number().optional(),
        maximum: x3.number().optional(),
        default: x3.any().optional(),
        nullable: x3.boolean().optional(),
      }),
      u4 = (e) => ms(d4.parse({}), e),
      p4 = x3.object({
        uid: k3,
        url: x3.string().optional().default(""),
        requestUid: x3.string().min(7),
        name: x3.string().optional().default("Name"),
        body: x3
          .object({
            raw: x3
              .object({
                encoding: x3
                  .union([
                    x3.literal("json"),
                    x3.literal("text"),
                    x3.literal("html"),
                    x3.literal("text"),
                    x3.literal("javascript"),
                    x3.literal("xml"),
                    x3.literal("yaml"),
                    x3.literal("edn"),
                  ])
                  .default("json"),
                value: x3.string().default(""),
              })
              .default({}),
            formData: x3
              .object({
                encoding: x3.union([x3.literal("form-data"), x3.literal("urlencoded")]).default("form-data"),
                value: d4.array().default([]),
              })
              .default({}),
            binary: x3.instanceof(File).optional(),
            activeBody: x3.union([x3.literal("raw"), x3.literal("formData"), x3.literal("binary")]).default("raw"),
          })
          .optional()
          .default({}),
        parameters: x3
          .object({
            path: d4.array().default([]),
            query: d4.array().default([]),
            headers: d4.array().default([]),
            cookies: d4.array().default([]),
          })
          .optional()
          .default({}),
        auth: x3.record(x3.string(), x3.any()).default({}),
      }),
      h4 = x3.object({ name: x3.string().min(1), description: x3.string().optional() }),
      f4 = { cookie: "cookies", header: "headers", path: "path", query: "query" },
      m4 = async (e) => {
        var t, n, r, a, o
        const i = [],
          s = [],
          l = ((e) => {
            if ("string" != typeof e) return e
            const t = wd.parseSafe(e, null)
            if (t) return t
            if (e.length > 0 && ["{", "["].includes(e[0])) throw Error("Invalid JSON or YAML")
            return Od.parseSafe(e, (e) => {
              throw Error(e)
            })
          })(e),
          { filesystem: c } = await pm(l),
          { schema: d, errors: u } = await um(c)
        ;(!(null == u ? void 0 : u.length) && d) ||
          console.warn(
            "Please open an issue on https://github.com/scalar/scalar\n",
            "Scalar OpenAPI Parser Warning:\n",
            u,
          )
        const p = new Set()
        Object.entries((null == d ? void 0 : d.paths) || {}).forEach(([e, t]) => {
          t &&
            ["get", "put", "post", "delete", "options", "head", "patch", "trace"].forEach((n) => {
              const r = t[n]
              if (!r) return
              if ("$ref" in r)
                return void i.push(`${n.toUpperCase}:${e} - Importing of $ref paths is not yet supported`)
              const a = { path: {}, query: {}, headers: {}, cookies: {} }
              ;[...(t.parameters || []), ...(r.parameters || [])]
                .filter((e) => e)
                .forEach((e) => {
                  const t = e
                  "name" in t && f4[t.in] && (a[f4[t.in]][t.name] = t)
                })
              const o = c4({
                method: n.toUpperCase(),
                path: e,
                tags: r.tags || ["default"],
                description: r.description,
                operationId: r.operationId,
                security: r.security,
                summary: r.summary,
                externalDocs: r.externalDocs,
                requestBody: r.requestBody,
                parameters: a,
              })
              o.tags.forEach((e) => p.add(e)), s.push(o)
            })
        })
        const h = (function (e, t, n = !0) {
          if (n) {
            const n = t.safeParse(e)
            if (!n.success)
              throw (
                (console.error("Zod Schema Error"),
                console.group(),
                n.error.issues.forEach((e) => {
                  console.log(`Path: ${e.path.join(", ")} \nError: ${e.message}`)
                }),
                console.groupEnd(),
                new Error("Zod validation failure"))
              )
            return n.data
          }
          {
            const n = t.safeParse(e)
            return n.success ? n.data : null
          }
        })(null == d ? void 0 : d.tags, h4.array(), !1) ?? [{ name: "default" }]
        p.forEach((e) => {
          h.some((t) => t.name === e) ||
            (i.push(`The tag *${p}* is does not have an explicit tag object in the specification file. `),
            h.push({ name: e }))
        })
        const f = []
        h.forEach((e) => {
          const t = j3({ ...e, childUids: s.filter((t) => t.tags.includes(e.name)).map((e) => e.uid) })
          f.push(t)
        })
        const m = (
            (null == (t = l.servers) ? void 0 : t.length)
              ? l.servers
              : [
                  {
                    url: "undefined" != typeof window ? window.location.origin : "http://localhost",
                    description: "Replace with your API server",
                  },
                ]
          ).map((e) => a4(e)),
          g =
            null ==
            (r = Object.keys(
              ((null == (n = null == d ? void 0 : d.components) ? void 0 : n.securitySchemes) ||
                (null == d ? void 0 : d.securityDefinitions)) ??
                {},
            ))
              ? void 0
              : r[0],
          b =
            null ==
            (o =
              (null == (a = null == d ? void 0 : d.components) ? void 0 : a.securitySchemes) ||
              (null == d ? void 0 : d.securityDefinitions))
              ? void 0
              : o[g ?? ""],
          v = "oauth2" === (null == b ? void 0 : b.type) ? Object.keys(b.flows ?? {})[0] : void 0,
          y = g ? [{ uid: g, ...(v ? { flowKey: v } : {}) }] : [],
          O = $3({
            spec: {
              openapi: null == d ? void 0 : d.openapi,
              info: null == d ? void 0 : d.info,
              security: (null == d ? void 0 : d.security) || (null == d ? void 0 : d.securityDefinitions),
              externalDocs: null == d ? void 0 : d.externalDocs,
              serverUids: m.map(({ uid: e }) => e),
              tags: h,
            },
            selectedSecuritySchemes: y,
            selectedServerUid: m[0].uid,
            childUids: f.map(({ uid: e }) => e),
          }),
          w = null == d ? void 0 : d.components,
          x = null == d ? void 0 : d.securityDefinitions
        return { tags: h, folders: f, servers: m, requests: s, collection: O, components: w, securityDefinitions: x }
      }
    function g4(e, t, n) {
      const r = t.split("."),
        a = r.at(-1)
      return r.reduce((e, t) => (t === a && (e[t] = n), e[t]), e), e
    }
    function b4(e, t) {
      return t.split(".").reduce((e, t) => e[t], e)
    }
    class v4 {
      constructor(e, t = 5e3, n = !1) {
        r(this, "parentData"),
          r(this, "maxRecords"),
          r(this, "records", []),
          r(this, "sideEffects", []),
          r(this, "idx", 0),
          r(this, "debug"),
          (this.maxRecords = t),
          (this.parentData = e),
          (this.debug = n)
      }
      _unsavedMutate(e, t) {
        g4(this.parentData, e, t), this.runSideEffects(e)
      }
      addSideEffect(e, t, n, r = !0) {
        this.sideEffects.push({ triggers: e, effect: t, name: n }),
          r && (t(this.parentData), this.debug && console.info(`Running mutation side effect: ${n}`, "debug"))
      }
      runSideEffects(e) {
        this.sideEffects.forEach(({ effect: t, triggers: n, name: r }) => {
          ;(n.some((t) => e.includes(t)) || e.length < 1) &&
            (t(this.parentData), this.debug && console.info(`Running mutation side effect: ${r}`, "debug"))
        })
      }
      mutate(e, t, n = null) {
        this.idx < this.records.length - 1 && this.records.splice(this.idx + 1)
        const r = b4(this.parentData, e)
        r !== t &&
          (g4(this.parentData, e, t),
          this.runSideEffects(e),
          this.records.push({ prev: n ?? r, value: t, path: e }),
          (this.idx = this.records.length - 1),
          this.records.length > this.maxRecords && this.records.shift(),
          this.debug && console.info(`Set object '${this.idx}' '${e}' to ${t}`, "debug"))
      }
      undo() {
        if (this.idx < 0 || this.records.length < 1) return !1
        this.debug && console.info("Undoing Mutation", "debug")
        const e = this.records[this.idx]
        return (this.idx -= 1), this._unsavedMutate(e.path, e.prev), !0
      }
      redo() {
        if (this.idx > this.records.length - 2) return !1
        this.debug && console.info("Redoing Mutation", "debug")
        const e = this.records[this.idx + 1]
        return (this.idx += 1), this._unsavedMutate(e.path, e.value), !0
      }
    }
    function y4(e, t, n, r = 500) {
      function a(n) {
        const r = t[n]
        return r || console.warn(`Missing ${e[n] ? "mutator" : "object"} for uid: ${n}`), r ?? null
      }
      const o = n ? Tm(() => localStorage.setItem(n, JSON.stringify(e)), 328, { maxWait: 1e3 }) : () => null
      return {
        add: (n) => {
          ;(e[n.uid] = n), (t[n.uid] = new v4(n, r)), o()
        },
        delete: (n) => {
          delete e[n], delete t[n], o()
        },
        set: (n) => {
          ;(e[n.uid] = n), (t[n.uid] = new v4(n, r)), o()
        },
        edit: (e, t, n) => {
          const r = a(e)
          null == r || r.mutate(t, n), o()
        },
        untrackedEdit: (e, t, n) => {
          const r = a(e)
          null == r || r._unsavedMutate(t, n), o()
        },
        undo: (e) => {
          const t = a(e)
          null == t || t.undo(), o()
        },
        redo: (e) => {
          const t = a(e)
          null == t || t.redo(), o()
        },
      }
    }
    const O4 = mn({}),
      w4 = (e, t) => (O4[e] = t),
      x4 = (e) => {
        O4[e] = !O4[e]
      },
      k4 = () => ({ collapsedSidebarFolders: O4, setCollapsedSidebarFolder: w4, toggleSidebarFolder: x4 }),
      { setCollapsedSidebarFolder: _4 } = k4()
    var S4
    const E4 = !!(
        typeof window < "u" &&
        null != (S4 = null == document ? void 0 : document.getElementById("scalar-client")) &&
        S4.getAttribute("data-persist")
      ),
      T4 = mn({}),
      A4 = y4(T4, mn({}), E4 && "request"),
      C4 = (e, t, n) => {
        const r = c4(e),
          a = M4(r, n)
        return (
          r.childUids.push(a.uid),
          A4.add(r),
          t &&
            (a8[t]
              ? o8.edit(t, "childUids", [...a8[t].childUids, r.uid])
              : d8[t] && u8.edit(t, "childUids", [...d8[t].childUids, r.uid])),
          r
        )
      },
      P4 = (e, t) => {
        e.childUids.forEach((e) => $4.delete(e)),
          a8[t]
            ? o8.edit(
                t,
                "childUids",
                a8[t].childUids.filter((t) => t !== e.uid),
              )
            : d8[t] &&
              u8.edit(
                t,
                "childUids",
                d8[t].childUids.filter((t) => t !== e.uid),
              ),
          A4.delete(e.uid)
      },
      D4 = ii(() => {
        var e, t
        const n = n2.value[Y1.Request],
          r = null == (t = null == (e = n8.value) ? void 0 : e[0]) ? void 0 : t.uid,
          a = T4[n] ?? T4[r]
        return (
          (function (e, t) {
            var n, r
            e2.currentRoute.value &&
              !t &&
              null != (n = e2.currentRoute.value) &&
              n.params[e] &&
              "default" !== (null == (r = e2.currentRoute.value) ? void 0 : r.params[e]) &&
              e2.currentRoute.value.path.includes(e) &&
              e2.push({ params: { ...e2.currentRoute.value.params, [e]: "default" } })
          })(Y1.Request, a),
          a && R4(a.uid).forEach((e) => _4(e, !0)),
          a
        )
      }),
      R4 = (e, t = []) => {
        const n = Object.values(a8).find((t) => t.childUids.includes(e))
        if (n) return [...t, n.uid]
        const r = Object.values(d8).find(({ childUids: t }) => t.includes(e))
        return r ? R4(r.uid, [...t, r.uid]) : t
      },
      N4 = mn({}),
      $4 = y4(N4, mn({}), E4 && "requestExample"),
      I4 = (e) => {
        var t, n, r, a, o, i, s
        return u4({
          key: e.name,
          value:
            e.schema && "default" in e.schema
              ? e.schema.default
              : e.schema && "examples" in e.schema && e.schema.examples.length > 0
                ? e.schema.examples[0]
                : "",
          description: e.description,
          required: e.required,
          enabled: !!e.required,
          enum: null == (t = e.schema) ? void 0 : t.enum,
          type: null == (n = e.schema) ? void 0 : n.type,
          format: null == (r = e.schema) ? void 0 : r.format,
          minimum: null == (a = e.schema) ? void 0 : a.minimum,
          maximum: null == (o = e.schema) ? void 0 : o.maximum,
          default: null == (i = e.schema) ? void 0 : i.default,
          nullable: null == (s = e.schema) ? void 0 : s.nullable,
        })
      },
      M4 = (e, t, n) => {
        var r
        const a = {
            path: Object.values(e.parameters.path).map(I4),
            query: Object.values(e.parameters.query).map(I4),
            headers: Object.values(e.parameters.headers).map(I4),
            cookies: Object.values(e.parameters.cookies).map(I4),
          },
          o = { activeBody: "raw", raw: { encoding: "json", value: "" } }
        if (e.requestBody) {
          const t = xp({ httpVerb: e.method, path: e.path, information: { requestBody: e.requestBody } })
          "application/json" === (null == (r = null == t ? void 0 : t.postData) ? void 0 : r.mimeType) &&
            (a.headers.push({ key: "Content-Type", value: "application/json", enabled: !0 }),
            (o.activeBody = "raw"),
            (o.raw.value = t.postData.text))
        }
        const i = n ?? Ad((e.summary ?? "Example") + " #1", (t) => e.childUids.some((e) => t === N4[e].name)),
          s =
            ((l = {
              url: null != t && t.url ? `{{${null == t ? void 0 : t.url}}}${e.path}` : e.path,
              requestUid: e.uid,
              parameters: a,
              name: i,
              body: o,
            }),
            ms(p4.parse({ requestUid: l.requestUid }), l))
        var l
        return $4.add(s), s
      },
      L4 = (e, t) => {
        const n = M4(e, e8.value[0], t)
        return A4.edit(e.uid, "childUids", [...e.childUids, n.uid]), n
      },
      Q4 = (e) => {
        A4.edit(
          e.requestUid,
          "childUids",
          T4[e.requestUid].childUids.filter((t) => t !== e.uid),
        ),
          $4.delete(e.uid)
      },
      B4 = ii(() => {
        var e
        return N4[n2.value[Y1.Examples]] ?? N4[(null == (e = D4.value) ? void 0 : e.childUids[0]) ?? ""]
      }),
      j4 = ii(() =>
        Object.values(T4)
          .flatMap((e) => e.history)
          .filter((e) => e.request && e.response)
          .sort((e, t) => t.timestamp - e.timestamp),
      ),
      U4 = mn({
        default:
          ((x8 = {
            uid: "default",
            name: "Global Environment",
            color: "blue",
            raw: JSON.stringify({ exampleKey: "exampleValue" }, null, 2),
            parsed: [],
            isDefault: !0,
          }),
          ms(Q3.parse({}), x8)),
      }),
      F4 = y4(U4, mn({}), E4 && "environment"),
      z4 = (e) => {
        "default" !== e ? F4.delete(e) : console.warn("Default environment cannot be deleted.")
      },
      q4 = ii(() => {
        const e = e8.value.map((e) => ({ key: e.url, value: e.url })),
          t = Object.values(U4)
            .map((e) => {
              try {
                return { _scalarEnvId: e.uid, ...JSON.parse(e.raw) }
              } catch {
                return null
              }
            })
            .filter((e) => e)
            .flatMap((e) =>
              Object.entries(e).flatMap(([t, n]) =>
                "_scalarEnvId" !== t ? [{ _scalarEnvId: e._scalarEnvId, key: t, value: n }] : [],
              ),
            )
        return [...e, ...t]
      }),
      Z4 = mn({
        default: M3({
          uid: "default",
          name: "Cookie",
          value: "",
          domain: "",
          path: "/",
          secure: !1,
          httpOnly: !1,
          sameSite: "None",
        }),
      }),
      H4 = y4(Z4, mn({}), E4 && "cookie"),
      V4 = ii(() => n2.value[Y1.Cookies]),
      W4 = mn({}),
      X4 = y4(W4, mn({}), E4 && "workspace"),
      Y4 = (e = {}) => {
        const t = S3(e)
        X4.add(t)
        const n = i8({ spec: { info: { title: "Drafts" } } }, t.uid)
        return C4({ summary: "My First Request" }, n.uid), t
      },
      G4 = (e) => {
        "default" !== e ? X4.delete(e) : console.warn("Default environment cannot be deleted.")
      },
      K4 = ii(() => W4[n2.value[Y1.Workspace]] ?? W4[Object.keys(W4)[0]]),
      J4 = ii(() => {
        var e
        return null == (e = K4.value)
          ? void 0
          : e.collectionUids
              .map((e) => a8[e])
              .sort((e, t) => {
                var n, r, a, o
                return "Drafts" === (null == (r = null == (n = e.spec) ? void 0 : n.info) ? void 0 : r.title)
                  ? 1
                  : "Drafts" === (null == (o = null == (a = t.spec) ? void 0 : a.info) ? void 0 : o.title)
                    ? -1
                    : 0
              })
      }),
      e8 = ii(() => {
        var e
        return null == (e = J4.value) ? void 0 : e.flatMap((e) => e.spec.serverUids.map((e) => v8[e]))
      }),
      t8 = (e) => T4[e] ?? d8[e].childUids.flatMap((e) => t8(e)),
      n8 = ii(() => {
        var e
        return null == (e = J4.value) ? void 0 : e.flatMap((e) => e.childUids.flatMap((e) => t8(e)))
      }),
      r8 = ii(() => {
        var e
        return (null == (e = K4.value) ? void 0 : e.isReadOnly) ?? !1
      }),
      a8 = mn({}),
      o8 = y4(a8, mn({}), E4 && "collection"),
      i8 = (e, t) => {
        const n = $3(e)
        return X4.edit(t, "collectionUids", [...W4[t].collectionUids, n.uid]), o8.add(n), n
      },
      s8 = (e) => {
        var t, n, r
        if (K4.value) {
          if (
            "Drafts" ===
            (null == (r = null == (n = null == (t = a8[e]) ? void 0 : t.spec) ? void 0 : n.info) ? void 0 : r.title)
          )
            return void console.warn("The drafts collection cannot be deleted")
          if (1 === Object.values(a8).length) return void console.warn("You must have at least one collection")
          X4.edit(
            K4.value.uid,
            "collectionUids",
            K4.value.collectionUids.filter((t) => t !== e),
          ),
            o8.delete(e)
        }
      },
      l8 = ii(() => {
        const e = Object.values(a8)[0]
        if (!D4.value) return e
        const t = R4(D4.value.uid)
        if (!t.length) return null
        const n = t[t.length - 1]
        return a8[n] ?? e
      }),
      c8 = ii(() => l8.value && v8[l8.value.selectedServerUid]),
      d8 = mn({}),
      u8 = y4(d8, mn({}), E4 && "folder"),
      p8 = (e, t) => {
        const n = j3(e)
        if (t)
          if (a8[t]) o8.edit(t, "childUids", [...a8[t].childUids, n.uid])
          else {
            if (!d8[t]) return void console.error("Could not find folder's parent ID")
            u8.edit(t, "childUids", [...d8[t].childUids, n.uid])
          }
        u8.add(n)
      },
      h8 = (e, t) => {
        a8[t]
          ? o8.edit(
              t,
              "childUids",
              a8[t].childUids.filter((t) => t !== e),
            )
          : d8[t] &&
            u8.edit(
              t,
              "childUids",
              d8[t].childUids.filter((t) => t !== e),
            ),
          u8.delete(e)
      },
      f8 = mn({}),
      m8 = y4(f8, mn({}), E4 && "securityScheme"),
      g8 = ii(() => {
        var e
        return null == (e = l8.value)
          ? void 0
          : e.selectedSecuritySchemes.map((e) => {
              const t = f8[e.uid]
              return { scheme: t, ...(e.flowKey && "flows" in t && t.flows ? { flow: t.flows[e.flowKey] } : {}) }
            })[0]
      }),
      b8 = ii(() => {
        var e, t
        return (
          (null == (e = D4.value) ? void 0 : e.security) ?? (null == (t = l8.value) ? void 0 : t.spec.security) ?? []
        )
      }),
      v8 = mn({}),
      y8 = y4(v8, mn({}), E4 && "server"),
      O8 = (e, t) => {
        const n = a4(e)
        t && o8.edit(t, "spec.serverUids", [...a8[t].spec.serverUids, n.uid]), y8.add(n)
      },
      w8 = (e, t) => {
        o8.edit(
          t,
          "spec.serverUids",
          a8[t].spec.serverUids.filter((t) => t !== e),
        ),
          y8.delete(e)
      }
    var x8
    async function k8(e, t = "default", n = !0) {
      var r
      const a = _n(e),
        o = await m4(a)
      n && X4.add(S3({ uid: t })),
        o.requests.forEach((e) => C4(e, void 0, o.servers[0])),
        i8(o.collection, t),
        o.folders.forEach((e) => p8(e)),
        o.servers.forEach((e) => O8(e)),
        Object.entries(
          ((null == (r = o.components) ? void 0 : r.securitySchemes) || o.securityDefinitions) ?? {},
        ).forEach(([e, t]) => m8.add(t4({ ...t, uid: e })))
    }
    async function _8(e, t) {
      try {
        const n = await Sd(e, t)
        await k8(n)
      } catch (e) {
        console.error("Failed to fetch spec from URL:", e)
      }
    }
    const S8 = aw(),
      E8 = () => ({
        workspaces: W4,
        collections: a8,
        cookies: Z4,
        environments: U4,
        folders: d8,
        requestExamples: N4,
        requests: T4,
        servers: v8,
        securitySchemes: f8,
        activeCollection: l8,
        activeCookieId: V4,
        activeExample: B4,
        activeRequest: D4,
        activeSecurityRequirements: b8,
        activeSecurityScheme: g8,
        activeServer: c8,
        activeWorkspace: K4,
        activeWorkspaceCollections: J4,
        activeWorkspaceServers: e8,
        activeParsedEnvironments: q4,
        activeWorkspaceRequests: n8,
        modalState: S8,
        isReadOnly: r8,
        importSpecFile: k8,
        importSpecFromUrl: _8,
        cookieMutators: H4,
        collectionMutators: { ...o8, rawAdd: o8.add, add: i8, delete: s8 },
        environmentMutators: { ...F4, delete: z4 },
        folderMutators: { ...u8, rawAdd: u8.add, add: p8, delete: h8 },
        requestMutators: { ...A4, rawAdd: A4.add, add: C4, delete: P4 },
        requestExampleMutators: { ...$4, rawAdd: $4.add, add: L4, delete: Q4 },
        requestsHistory: j4,
        securitySchemeMutators: m8,
        serverMutators: { ...y8, rawAdd: y8.add, add: O8, delete: w8 },
        workspaceMutators: { ...X4, rawAdd: X4.add, add: Y4, delete: G4 },
      }),
      T8 = (e, t) => {
        const n = e.__vccOpts || e
        for (const [e, r] of t) n[e] = r
        return n
      }
    Dn(!1)
    const A8 = [
        { name: "request", icon: "ExternalLink" },
        { name: "cookies", icon: "Cookie" },
        { name: "environment", icon: "Brackets" },
        { name: "servers", icon: "Server" },
      ],
      { activeRequest: C8 } = E8(),
      P8 = mn([{ label: "", path: "", icon: "Add" }]),
      D8 = Dn(0)
    Ya(
      () => e2.currentRoute.value.path,
      () => {
        !(function () {
          var e
          const t = A8.find((e) => e2.currentRoute.value.name == e.name)
          var n
          t &&
            ("request" === (null == t ? void 0 : t.name)
              ? (P8[D8.value] = {
                  label: (null == (e = C8.value) ? void 0 : e.summary) || "",
                  path: e2.currentRoute.value.path,
                  icon: t.icon,
                })
              : (P8[D8.value] = {
                  label: ((n = null == t ? void 0 : t.name), n[0].toUpperCase() + n.slice(1) || ""),
                  path: e2.currentRoute.value.path,
                  icon: t.icon,
                }))
        })()
      },
      { immediate: !0 },
    )
    const R8 = Hr({
        __name: "ScalarHotkey",
        props: { hotkey: {} },
        emits: ["hotkeyPressed"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = ii(() => (Hz() ? "" : "")),
            o = ii(() =>
              new Map([
                ["", "enter"],
                ["N", "n"],
              ]).get(n.hotkey),
            ),
            i = ii(() => `${a.value}${n.hotkey}`),
            s = Qm({
              passive: !1,
              onEventFired(e) {
                !Hz() && e.ctrlKey && e.key === o.value && (e.preventDefault(), e.stopPropagation())
              },
            })
          return (
            Am(s[`${Hz() ? "meta" : "control"}_${n.hotkey}`], () => {
              r("hotkeyPressed", o.value || "")
            }),
            (e, t) => (
              xo(),
              Eo(
                "div",
                Fo(e.$attrs, {
                  class:
                    "bg-b-2 border-b-3 inline-block overflow-hidden rounded border-1/2 bg-inherit text-xxs rounded-b px-1 font-medium uppercase",
                }),
                at(i.value),
                17,
              )
            )
          )
        },
      }),
      N8 = Mm(Symbol()),
      $8 = Hr({
        __name: "HttpMethod",
        props: { isSquare: { type: Boolean, default: !1 }, method: {}, isEditable: { type: Boolean, default: !1 } },
        emits: ["change"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = ii(() =>
              ((e) => {
                const t = e.trim().toUpperCase()
                return t in Ed ? Ed[t] : { short: t, color: "text-c-2", backgroundColor: "bg-c-2" }
              })(n.method),
            ),
            o = Object.entries(Ed).map(([e, { short: t }]) => ({ id: e, label: t })),
            i = ii({
              get: () => o.find(({ id: e }) => e === n.method),
              set: (e) => (null == e ? void 0 : e.id) && r("change", e.id),
            }),
            s = iO({
              base: "text-center font-code text-3xs justify-center items-center flex",
              variants: {
                isSquare: { true: "px-2.5 rounded-md shadow-border", false: "rounded-full" },
                isEditable: { true: "px-0 hover:bg-mix-b-2", false: "cusor-pointer" },
              },
            }),
            l = ii(() => a.value.short)
          return (e, t) =>
            e.isEditable
              ? (xo(),
                To(
                  In(vL),
                  {
                    key: 0,
                    modelValue: i.value,
                    "onUpdate:modelValue": t[0] || (t[0] = (e) => (i.value = e)),
                    options: In(o),
                  },
                  {
                    default: yr(() => [
                      Ro(
                        "div",
                        { class: Ge(["h-full", { "pointer-events-none": !e.isEditable }]) },
                        [
                          Ro(
                            "button",
                            {
                              class: Ge([
                                "relative h-full gap-1",
                                In(sO)(In(s)({ isSquare: e.isSquare, isEditable: e.isEditable }), a.value.color),
                              ]),
                              type: "button",
                            },
                            [
                              Ro("span", null, at(l.value), 1),
                              e.isEditable
                                ? (xo(),
                                  To(
                                    In(BI),
                                    { key: 0, class: Ge(a.value.color), icon: "ChevronDown", size: "xs" },
                                    null,
                                    8,
                                    ["class"],
                                  ))
                                : Qo("", !0),
                            ],
                            2,
                          ),
                        ],
                        2,
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ["modelValue", "options"],
                ))
              : (xo(),
                Eo(
                  "div",
                  {
                    key: 1,
                    class: Ge([
                      "relative gap-1",
                      In(sO)(
                        In(s)({ isSquare: e.isSquare, isEditable: e.isEditable }),
                        a.value.color,
                        e.isSquare && a.value.backgroundColor,
                      ),
                    ]),
                    type: "button",
                  },
                  at(a.value.short),
                  3,
                ))
        },
      })
    function I8({ multiple: e, accept: t, onChange: n, onError: r } = {}) {
      const a = Dn(null)
      let o
      return (
        typeof document < "u" &&
          ((o = document.createElement("input")),
          (o.type = "file"),
          (o.onchange = (e) => {
            const t = e.target
            ;(a.value = t.files), null == n || n(a.value)
          }),
          (o.onerror = () => (null == r ? void 0 : r())),
          (o.multiple = e),
          (o.accept = t)),
        {
          files: bn(a),
          open: () => {
            if (!o) return null == r ? void 0 : r()
            o.click()
          },
        }
      )
    }
    const M8 = { class: "scalar" },
      L8 = { className: "scalar-container" },
      Q8 = { className: "scalar-app scalar-client" },
      B8 = Hr({
        __name: "ApiClientModal",
        props: { modalState: {} },
        setup(e) {
          const t = e
          return (
            Am(Qm().escape, () => {
              t.modalState.open && t.modalState.hide()
            }),
            Ya(
              () => t.modalState.open,
              (e) => {
                e
                  ? (document.documentElement.style.overflow = "hidden")
                  : document.documentElement.style.removeProperty("overflow")
              },
            ),
            Rr(() => DQ()),
            Mr(() => document.documentElement.style.removeProperty("overflow")),
            (e, t) =>
              Fr(
                (xo(),
                Eo(
                  "div",
                  M8,
                  [
                    Ro("div", L8, [
                      Ro("div", Q8, [No(In(V1), { key: "$route.fullPath" })]),
                      Ro("div", { class: "scalar-app-exit", onClick: t[0] || (t[0] = (t) => e.modalState.hide()) }),
                    ]),
                  ],
                  512,
                )),
                [[mi, e.modalState.open]],
              )
          )
        },
      }),
      j8 = T8(B8, [["__scopeId", "data-v-5357614d"]]),
      U8 = Object.freeze(
        Object.defineProperty(
          {
            __proto__: null,
            ApiClientModal: j8,
            createApiClientModal: async (e, t, n = !0) => {
              var r, a, o
              const {
                activeCollection: i,
                activeWorkspace: s,
                collectionMutators: l,
                importSpecFile: c,
                importSpecFromUrl: d,
                modalState: u,
                requests: p,
                securitySchemeMutators: h,
                securitySchemes: f,
                serverMutators: m,
                workspaceMutators: g,
              } = E8()
              null != (r = t.spec) && r.url
                ? await d(t.spec.url, t.proxyUrl)
                : null != (a = t.spec) && a.content
                  ? await c(null == (o = t.spec) ? void 0 : o.content)
                  : g.add({ uid: "default", name: "Workspace", proxyUrl: "https://proxy.scalar.com" })
              const b = Ji(j8, { modalState: u })
              b.use(t2)
              const v = (t = e) => {
                t
                  ? b.mount(t)
                  : console.error(
                      "[@scalar/api-client-modal] Could not create the API client.",
                      "Invalid HTML element provided.",
                      "Read more: https://github.com/scalar/scalar/tree/main/packages/api-client-modal",
                    )
              }
              return (
                s.value &&
                  (n && v(),
                  g.edit(s.value.uid, "isReadOnly", !0),
                  t.proxyUrl && g.edit(s.value.uid, "proxyUrl", t.proxyUrl),
                  t.themeId && g.edit(s.value.uid, "themeId", t.themeId)),
                {
                  app: b,
                  updateConfig(e, n = !0) {
                    n ? Object.assign(t, e) : Pd(t, e), e.spec && c(e.spec)
                  },
                  updateServerUrl: (e) => {
                    var t
                    return m.edit((null == (t = i.value) ? void 0 : t.selectedServerUid) ?? "", "url", e)
                  },
                  updateAuth: (e) => {
                    var t, n
                    if (
                      (Object.values(f).forEach((t) => {
                        const n = (e, n = "value") => e.length && !b4(t, n).length && h.edit(t.uid, n, e)
                        switch (t.type) {
                          case "apiKey":
                            n(e.apiKey.token)
                            break
                          case "http":
                            "bearer" === t.scheme
                              ? n(e.http.bearer.token)
                              : "basic" === t.scheme &&
                                (n(e.http.basic.username), n(e.http.basic.password, "secondValue"))
                            break
                          case "oauth2":
                            n(e.oAuth2.clientId, "clientId"),
                              t.flows.implicit
                                ? (n(e.oAuth2.accessToken, "flows.implicit.token"),
                                  n(e.oAuth2.scopes, "flows.implicit.selectedScopes"))
                                : t.flows.password &&
                                  (n(e.oAuth2.accessToken, "flows.password.token"),
                                  n(e.oAuth2.scopes, "flows.password.selectedScopes"),
                                  n(e.oAuth2.username, "flows.password.value"),
                                  n(e.oAuth2.password, "flows.password.secondValue"))
                        }
                      }),
                      e.preferredSecurityScheme)
                    ) {
                      const r = { uid: e.preferredSecurityScheme },
                        a = null == (t = e.securitySchemes) ? void 0 : t[e.preferredSecurityScheme ?? ""]
                      "oauth2" === (null == a ? void 0 : a.type) &&
                        (r.flowKey = null != (n = a.flows) && n.implicit ? "implicit" : "password"),
                        l.edit(i.value.uid, "selectedSecuritySchemes", [r])
                    }
                  },
                  updateSpec: (e) => {
                    null != e && e.url
                      ? d(e.url, t.proxyUrl)
                      : null != e && e.content
                        ? c(null == e ? void 0 : e.content)
                        : console.error(
                            "[@scalar/api-client-modal] Could not create the API client.",
                            "Please provide an OpenAPI document: { spec: { url: '' } }",
                            "Read more: https://github.com/scalar/scalar/tree/main/packages/api-client-modal",
                          )
                  },
                  open: (e) => {
                    const t = Object.values(p).find(({ path: t, method: n }) => !e || (t === e.path && n === e.method))
                    t && t2.push(`/workspace/default/request/${t.uid}`), (u.open = !0)
                  },
                  mount: v,
                  modalState: u,
                }
              )
            },
            modalRouter: t2,
            router: e2,
            useWorkspace: E8,
          },
          Symbol.toStringTag,
          { value: "Module" },
        ),
      )
    class F8 {
      lineAt(e) {
        if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`)
        return this.lineInner(e, !1, 1, 0)
      }
      line(e) {
        if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`)
        return this.lineInner(e, !0, 1, 0)
      }
      replace(e, t, n) {
        ;[e, t] = G8(this, e, t)
        let r = []
        return (
          this.decompose(0, e, r, 2),
          n.length && n.decompose(0, n.length, r, 3),
          this.decompose(t, this.length, r, 1),
          q8.from(r, this.length - (t - e) + n.length)
        )
      }
      append(e) {
        return this.replace(this.length, this.length, e)
      }
      slice(e, t = this.length) {
        ;[e, t] = G8(this, e, t)
        let n = []
        return this.decompose(e, t, n, 0), q8.from(n, t - e)
      }
      eq(e) {
        if (e == this) return !0
        if (e.length != this.length || e.lines != this.lines) return !1
        let t = this.scanIdentical(e, 1),
          n = this.length - this.scanIdentical(e, -1),
          r = new V8(this),
          a = new V8(e)
        for (let e = t, o = t; ; ) {
          if ((r.next(e), a.next(e), (e = 0), r.lineBreak != a.lineBreak || r.done != a.done || r.value != a.value))
            return !1
          if (((o += r.value.length), r.done || o >= n)) return !0
        }
      }
      iter(e = 1) {
        return new V8(this, e)
      }
      iterRange(e, t = this.length) {
        return new W8(this, e, t)
      }
      iterLines(e, t) {
        let n
        if (null == e) n = this.iter()
        else {
          null == t && (t = this.lines + 1)
          let r = this.line(e).from
          n = this.iterRange(r, Math.max(r, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to))
        }
        return new X8(n)
      }
      toString() {
        return this.sliceString(0)
      }
      toJSON() {
        let e = []
        return this.flatten(e), e
      }
      constructor() {}
      static of(e) {
        if (0 == e.length) throw new RangeError("A document must have at least one line")
        return 1 != e.length || e[0] ? (e.length <= 32 ? new z8(e) : q8.from(z8.split(e, []))) : F8.empty
      }
    }
    class z8 extends F8 {
      constructor(
        e,
        t = (function (e) {
          let t = -1
          for (let n of e) t += n.length + 1
          return t
        })(e),
      ) {
        super(), (this.text = e), (this.length = t)
      }
      get lines() {
        return this.text.length
      }
      get children() {
        return null
      }
      lineInner(e, t, n, r) {
        for (let a = 0; ; a++) {
          let o = this.text[a],
            i = r + o.length
          if ((t ? n : i) >= e) return new Y8(r, i, n, o)
          ;(r = i + 1), n++
        }
      }
      decompose(e, t, n, r) {
        let a =
          e <= 0 && t >= this.length ? this : new z8(H8(this.text, e, t), Math.min(t, this.length) - Math.max(0, e))
        if (1 & r) {
          let e = n.pop(),
            t = Z8(a.text, e.text.slice(), 0, a.length)
          if (t.length <= 32) n.push(new z8(t, e.length + a.length))
          else {
            let e = t.length >> 1
            n.push(new z8(t.slice(0, e)), new z8(t.slice(e)))
          }
        } else n.push(a)
      }
      replace(e, t, n) {
        if (!(n instanceof z8)) return super.replace(e, t, n)
        ;[e, t] = G8(this, e, t)
        let r = Z8(this.text, Z8(n.text, H8(this.text, 0, e)), t),
          a = this.length + n.length - (t - e)
        return r.length <= 32 ? new z8(r, a) : q8.from(z8.split(r, []), a)
      }
      sliceString(e, t = this.length, n = "\n") {
        ;[e, t] = G8(this, e, t)
        let r = ""
        for (let a = 0, o = 0; a <= t && o < this.text.length; o++) {
          let i = this.text[o],
            s = a + i.length
          a > e && o && (r += n), e < s && t > a && (r += i.slice(Math.max(0, e - a), t - a)), (a = s + 1)
        }
        return r
      }
      flatten(e) {
        for (let t of this.text) e.push(t)
      }
      scanIdentical() {
        return 0
      }
      static split(e, t) {
        let n = [],
          r = -1
        for (let a of e) n.push(a), (r += a.length + 1), 32 == n.length && (t.push(new z8(n, r)), (n = []), (r = -1))
        return r > -1 && t.push(new z8(n, r)), t
      }
    }
    class q8 extends F8 {
      constructor(e, t) {
        super(), (this.children = e), (this.length = t), (this.lines = 0)
        for (let t of e) this.lines += t.lines
      }
      lineInner(e, t, n, r) {
        for (let a = 0; ; a++) {
          let o = this.children[a],
            i = r + o.length,
            s = n + o.lines - 1
          if ((t ? s : i) >= e) return o.lineInner(e, t, n, r)
          ;(r = i + 1), (n = s + 1)
        }
      }
      decompose(e, t, n, r) {
        for (let a = 0, o = 0; o <= t && a < this.children.length; a++) {
          let i = this.children[a],
            s = o + i.length
          if (e <= s && t >= o) {
            let a = r & ((o <= e ? 1 : 0) | (s >= t ? 2 : 0))
            o >= e && s <= t && !a ? n.push(i) : i.decompose(e - o, t - o, n, a)
          }
          o = s + 1
        }
      }
      replace(e, t, n) {
        if ((([e, t] = G8(this, e, t)), n.lines < this.lines))
          for (let r = 0, a = 0; r < this.children.length; r++) {
            let o = this.children[r],
              i = a + o.length
            if (e >= a && t <= i) {
              let s = o.replace(e - a, t - a, n),
                l = this.lines - o.lines + s.lines
              if (s.lines < l >> 4 && s.lines > l >> 6) {
                let a = this.children.slice()
                return (a[r] = s), new q8(a, this.length - (t - e) + n.length)
              }
              return super.replace(a, i, s)
            }
            a = i + 1
          }
        return super.replace(e, t, n)
      }
      sliceString(e, t = this.length, n = "\n") {
        ;[e, t] = G8(this, e, t)
        let r = ""
        for (let a = 0, o = 0; a < this.children.length && o <= t; a++) {
          let i = this.children[a],
            s = o + i.length
          o > e && a && (r += n), e < s && t > o && (r += i.sliceString(e - o, t - o, n)), (o = s + 1)
        }
        return r
      }
      flatten(e) {
        for (let t of this.children) t.flatten(e)
      }
      scanIdentical(e, t) {
        if (!(e instanceof q8)) return 0
        let n = 0,
          [r, a, o, i] =
            t > 0
              ? [0, 0, this.children.length, e.children.length]
              : [this.children.length - 1, e.children.length - 1, -1, -1]
        for (; ; r += t, a += t) {
          if (r == o || a == i) return n
          let s = this.children[r],
            l = e.children[a]
          if (s != l) return n + s.scanIdentical(l, t)
          n += s.length + 1
        }
      }
      static from(e, t = e.reduce((e, t) => e + t.length + 1, -1)) {
        let n = 0
        for (let t of e) n += t.lines
        if (n < 32) {
          let n = []
          for (let t of e) t.flatten(n)
          return new z8(n, t)
        }
        let r = Math.max(32, n >> 5),
          a = r << 1,
          o = r >> 1,
          i = [],
          s = 0,
          l = -1,
          c = []
        function d(e) {
          let t
          if (e.lines > a && e instanceof q8) for (let t of e.children) d(t)
          else
            e.lines > o && (s > o || !s)
              ? (u(), i.push(e))
              : e instanceof z8 && s && (t = c[c.length - 1]) instanceof z8 && e.lines + t.lines <= 32
                ? ((s += e.lines),
                  (l += e.length + 1),
                  (c[c.length - 1] = new z8(t.text.concat(e.text), t.length + 1 + e.length)))
                : (s + e.lines > r && u(), (s += e.lines), (l += e.length + 1), c.push(e))
        }
        function u() {
          0 != s && (i.push(1 == c.length ? c[0] : q8.from(c, l)), (l = -1), (s = c.length = 0))
        }
        for (let t of e) d(t)
        return u(), 1 == i.length ? i[0] : new q8(i, t)
      }
    }
    function Z8(e, t, n = 0, r = 1e9) {
      for (let a = 0, o = 0, i = !0; o < e.length && a <= r; o++) {
        let s = e[o],
          l = a + s.length
        l >= n &&
          (l > r && (s = s.slice(0, r - a)),
          a < n && (s = s.slice(n - a)),
          i ? ((t[t.length - 1] += s), (i = !1)) : t.push(s)),
          (a = l + 1)
      }
      return t
    }
    function H8(e, t, n) {
      return Z8(e, [""], t, n)
    }
    F8.empty = new z8([""], 0)
    class V8 {
      constructor(e, t = 1) {
        ;(this.dir = t),
          (this.done = !1),
          (this.lineBreak = !1),
          (this.value = ""),
          (this.nodes = [e]),
          (this.offsets = [t > 0 ? 1 : (e instanceof z8 ? e.text.length : e.children.length) << 1])
      }
      nextInner(e, t) {
        for (this.done = this.lineBreak = !1; ; ) {
          let n = this.nodes.length - 1,
            r = this.nodes[n],
            a = this.offsets[n],
            o = a >> 1,
            i = r instanceof z8 ? r.text.length : r.children.length
          if (o == (t > 0 ? i : 0)) {
            if (0 == n) return (this.done = !0), (this.value = ""), this
            t > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop()
          } else if ((1 & a) == (t > 0 ? 0 : 1)) {
            if (((this.offsets[n] += t), 0 == e)) return (this.lineBreak = !0), (this.value = "\n"), this
            e--
          } else if (r instanceof z8) {
            let a = r.text[o + (t < 0 ? -1 : 0)]
            if (((this.offsets[n] += t), a.length > Math.max(0, e)))
              return (this.value = 0 == e ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e)), this
            e -= a.length
          } else {
            let a = r.children[o + (t < 0 ? -1 : 0)]
            e > a.length
              ? ((e -= a.length), (this.offsets[n] += t))
              : (t < 0 && this.offsets[n]--,
                this.nodes.push(a),
                this.offsets.push(t > 0 ? 1 : (a instanceof z8 ? a.text.length : a.children.length) << 1))
          }
        }
      }
      next(e = 0) {
        return e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)), this.nextInner(e, this.dir)
      }
    }
    class W8 {
      constructor(e, t, n) {
        ;(this.value = ""),
          (this.done = !1),
          (this.cursor = new V8(e, t > n ? -1 : 1)),
          (this.pos = t > n ? e.length : 0),
          (this.from = Math.min(t, n)),
          (this.to = Math.max(t, n))
      }
      nextInner(e, t) {
        if (t < 0 ? this.pos <= this.from : this.pos >= this.to) return (this.value = ""), (this.done = !0), this
        e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos)
        let n = t < 0 ? this.pos - this.from : this.to - this.pos
        e > n && (e = n), (n -= e)
        let { value: r } = this.cursor.next(e)
        return (
          (this.pos += (r.length + e) * t),
          (this.value = r.length <= n ? r : t < 0 ? r.slice(r.length - n) : r.slice(0, n)),
          (this.done = !this.value),
          this
        )
      }
      next(e = 0) {
        return (
          e < 0 ? (e = Math.max(e, this.from - this.pos)) : e > 0 && (e = Math.min(e, this.to - this.pos)),
          this.nextInner(e, this.cursor.dir)
        )
      }
      get lineBreak() {
        return this.cursor.lineBreak && "" != this.value
      }
    }
    class X8 {
      constructor(e) {
        ;(this.inner = e), (this.afterBreak = !0), (this.value = ""), (this.done = !1)
      }
      next(e = 0) {
        let { done: t, lineBreak: n, value: r } = this.inner.next(e)
        return (
          t && this.afterBreak
            ? ((this.value = ""), (this.afterBreak = !1))
            : t
              ? ((this.done = !0), (this.value = ""))
              : n
                ? this.afterBreak
                  ? (this.value = "")
                  : ((this.afterBreak = !0), this.next())
                : ((this.value = r), (this.afterBreak = !1)),
          this
        )
      }
      get lineBreak() {
        return !1
      }
    }
    "undefined" != typeof Symbol &&
      ((F8.prototype[Symbol.iterator] = function () {
        return this.iter()
      }),
      (V8.prototype[Symbol.iterator] =
        W8.prototype[Symbol.iterator] =
        X8.prototype[Symbol.iterator] =
          function () {
            return this
          }))
    class Y8 {
      constructor(e, t, n, r) {
        ;(this.from = e), (this.to = t), (this.number = n), (this.text = r)
      }
      get length() {
        return this.to - this.from
      }
    }
    function G8(e, t, n) {
      return [(t = Math.max(0, Math.min(e.length, t))), Math.max(t, Math.min(e.length, n))]
    }
    let K8 =
      "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o"
        .split(",")
        .map((e) => (e ? parseInt(e, 36) : 1))
    for (let e = 1; e < K8.length; e++) K8[e] += K8[e - 1]
    function J8(e) {
      for (let t = 1; t < K8.length; t += 2) if (K8[t] > e) return K8[t - 1] <= e
      return !1
    }
    function e7(e) {
      return e >= 127462 && e <= 127487
    }
    const t7 = 8205
    function n7(e, t, n = !0, r = !0) {
      return (n ? r7 : a7)(e, t, r)
    }
    function r7(e, t, n) {
      if (t == e.length) return t
      t && o7(e.charCodeAt(t)) && i7(e.charCodeAt(t - 1)) && t--
      let r = s7(e, t)
      for (t += c7(r); t < e.length; ) {
        let a = s7(e, t)
        if (r == t7 || a == t7 || (n && J8(a))) (t += c7(a)), (r = a)
        else {
          if (!e7(a)) break
          {
            let n = 0,
              r = t - 2
            for (; r >= 0 && e7(s7(e, r)); ) n++, (r -= 2)
            if (n % 2 == 0) break
            t += 2
          }
        }
      }
      return t
    }
    function a7(e, t, n) {
      for (; t > 0; ) {
        let r = r7(e, t - 2, n)
        if (r < t) return r
        t--
      }
      return 0
    }
    function o7(e) {
      return e >= 56320 && e < 57344
    }
    function i7(e) {
      return e >= 55296 && e < 56320
    }
    function s7(e, t) {
      let n = e.charCodeAt(t)
      if (!i7(n) || t + 1 == e.length) return n
      let r = e.charCodeAt(t + 1)
      return o7(r) ? r - 56320 + ((n - 55296) << 10) + 65536 : n
    }
    function l7(e) {
      return e <= 65535
        ? String.fromCharCode(e)
        : ((e -= 65536), String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)))
    }
    function c7(e) {
      return e < 65536 ? 1 : 2
    }
    const d7 = /\r\n?|\n/
    var u7 = (function (e) {
      return (
        (e[(e.Simple = 0)] = "Simple"),
        (e[(e.TrackDel = 1)] = "TrackDel"),
        (e[(e.TrackBefore = 2)] = "TrackBefore"),
        (e[(e.TrackAfter = 3)] = "TrackAfter"),
        e
      )
    })(u7 || (u7 = {}))
    class p7 {
      constructor(e) {
        this.sections = e
      }
      get length() {
        let e = 0
        for (let t = 0; t < this.sections.length; t += 2) e += this.sections[t]
        return e
      }
      get newLength() {
        let e = 0
        for (let t = 0; t < this.sections.length; t += 2) {
          let n = this.sections[t + 1]
          e += n < 0 ? this.sections[t] : n
        }
        return e
      }
      get empty() {
        return 0 == this.sections.length || (2 == this.sections.length && this.sections[1] < 0)
      }
      iterGaps(e) {
        for (let t = 0, n = 0, r = 0; t < this.sections.length; ) {
          let a = this.sections[t++],
            o = this.sections[t++]
          o < 0 ? (e(n, r, a), (r += a)) : (r += o), (n += a)
        }
      }
      iterChangedRanges(e, t = !1) {
        g7(this, e, t)
      }
      get invertedDesc() {
        let e = []
        for (let t = 0; t < this.sections.length; ) {
          let n = this.sections[t++],
            r = this.sections[t++]
          r < 0 ? e.push(n, r) : e.push(r, n)
        }
        return new p7(e)
      }
      composeDesc(e) {
        return this.empty ? e : e.empty ? this : v7(this, e)
      }
      mapDesc(e, t = !1) {
        return e.empty ? this : b7(this, e, t)
      }
      mapPos(e, t = -1, n = u7.Simple) {
        let r = 0,
          a = 0
        for (let o = 0; o < this.sections.length; ) {
          let i = this.sections[o++],
            s = this.sections[o++],
            l = r + i
          if (s < 0) {
            if (l > e) return a + (e - r)
            a += i
          } else {
            if (
              n != u7.Simple &&
              l >= e &&
              ((n == u7.TrackDel && r < e && l > e) || (n == u7.TrackBefore && r < e) || (n == u7.TrackAfter && l > e))
            )
              return null
            if (l > e || (l == e && t < 0 && !i)) return e == r || t < 0 ? a : a + s
            a += s
          }
          r = l
        }
        if (e > r) throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`)
        return a
      }
      touchesRange(e, t = e) {
        for (let n = 0, r = 0; n < this.sections.length && r <= t; ) {
          let a = r + this.sections[n++]
          if (this.sections[n++] >= 0 && r <= t && a >= e) return !(r < e && a > t) || "cover"
          r = a
        }
        return !1
      }
      toString() {
        let e = ""
        for (let t = 0; t < this.sections.length; ) {
          let n = this.sections[t++],
            r = this.sections[t++]
          e += (e ? " " : "") + n + (r >= 0 ? ":" + r : "")
        }
        return e
      }
      toJSON() {
        return this.sections
      }
      static fromJSON(e) {
        if (!Array.isArray(e) || e.length % 2 || e.some((e) => "number" != typeof e))
          throw new RangeError("Invalid JSON representation of ChangeDesc")
        return new p7(e)
      }
      static create(e) {
        return new p7(e)
      }
    }
    class h7 extends p7 {
      constructor(e, t) {
        super(e), (this.inserted = t)
      }
      apply(e) {
        if (this.length != e.length) throw new RangeError("Applying change set to a document with the wrong length")
        return g7(this, (t, n, r, a, o) => (e = e.replace(r, r + (n - t), o)), !1), e
      }
      mapDesc(e, t = !1) {
        return b7(this, e, t, !0)
      }
      invert(e) {
        let t = this.sections.slice(),
          n = []
        for (let r = 0, a = 0; r < t.length; r += 2) {
          let o = t[r],
            i = t[r + 1]
          if (i >= 0) {
            ;(t[r] = i), (t[r + 1] = o)
            let s = r >> 1
            for (; n.length < s; ) n.push(F8.empty)
            n.push(o ? e.slice(a, a + o) : F8.empty)
          }
          a += o
        }
        return new h7(t, n)
      }
      compose(e) {
        return this.empty ? e : e.empty ? this : v7(this, e, !0)
      }
      map(e, t = !1) {
        return e.empty ? this : b7(this, e, t, !0)
      }
      iterChanges(e, t = !1) {
        g7(this, e, t)
      }
      get desc() {
        return p7.create(this.sections)
      }
      filter(e) {
        let t = [],
          n = [],
          r = [],
          a = new y7(this)
        e: for (let o = 0, i = 0; ; ) {
          let s = o == e.length ? 1e9 : e[o++]
          for (; i < s || (i == s && 0 == a.len); ) {
            if (a.done) break e
            let e = Math.min(a.len, s - i)
            f7(r, e, -1)
            let o = -1 == a.ins ? -1 : 0 == a.off ? a.ins : 0
            f7(t, e, o), o > 0 && m7(n, t, a.text), a.forward(e), (i += e)
          }
          let l = e[o++]
          for (; i < l; ) {
            if (a.done) break e
            let e = Math.min(a.len, l - i)
            f7(t, e, -1), f7(r, e, -1 == a.ins ? -1 : 0 == a.off ? a.ins : 0), a.forward(e), (i += e)
          }
        }
        return { changes: new h7(t, n), filtered: p7.create(r) }
      }
      toJSON() {
        let e = []
        for (let t = 0; t < this.sections.length; t += 2) {
          let n = this.sections[t],
            r = this.sections[t + 1]
          r < 0 ? e.push(n) : 0 == r ? e.push([n]) : e.push([n].concat(this.inserted[t >> 1].toJSON()))
        }
        return e
      }
      static of(e, t, n) {
        let r = [],
          a = [],
          o = 0,
          i = null
        function s(e = !1) {
          if (!e && !r.length) return
          o < t && f7(r, t - o, -1)
          let n = new h7(r, a)
          ;(i = i ? i.compose(n.map(i)) : n), (r = []), (a = []), (o = 0)
        }
        return (
          (function e(l) {
            if (Array.isArray(l)) for (let t of l) e(t)
            else if (l instanceof h7) {
              if (l.length != t) throw new RangeError(`Mismatched change set length (got ${l.length}, expected ${t})`)
              s(), (i = i ? i.compose(l.map(i)) : l)
            } else {
              let { from: e, to: i = e, insert: c } = l
              if (e > i || e < 0 || i > t)
                throw new RangeError(`Invalid change range ${e} to ${i} (in doc of length ${t})`)
              let d = c ? ("string" == typeof c ? F8.of(c.split(n || d7)) : c) : F8.empty,
                u = d.length
              if (e == i && 0 == u) return
              e < o && s(), e > o && f7(r, e - o, -1), f7(r, i - e, u), m7(a, r, d), (o = i)
            }
          })(e),
          s(!i),
          i
        )
      }
      static empty(e) {
        return new h7(e ? [e, -1] : [], [])
      }
      static fromJSON(e) {
        if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet")
        let t = [],
          n = []
        for (let r = 0; r < e.length; r++) {
          let a = e[r]
          if ("number" == typeof a) t.push(a, -1)
          else {
            if (!Array.isArray(a) || "number" != typeof a[0] || a.some((e, t) => t && "string" != typeof e))
              throw new RangeError("Invalid JSON representation of ChangeSet")
            if (1 == a.length) t.push(a[0], 0)
            else {
              for (; n.length < r; ) n.push(F8.empty)
              ;(n[r] = F8.of(a.slice(1))), t.push(a[0], n[r].length)
            }
          }
        }
        return new h7(t, n)
      }
      static createSet(e, t) {
        return new h7(e, t)
      }
    }
    function f7(e, t, n, r = !1) {
      if (0 == t && n <= 0) return
      let a = e.length - 2
      a >= 0 && n <= 0 && n == e[a + 1]
        ? (e[a] += t)
        : 0 == t && 0 == e[a]
          ? (e[a + 1] += n)
          : r
            ? ((e[a] += t), (e[a + 1] += n))
            : e.push(t, n)
    }
    function m7(e, t, n) {
      if (0 == n.length) return
      let r = (t.length - 2) >> 1
      if (r < e.length) e[e.length - 1] = e[e.length - 1].append(n)
      else {
        for (; e.length < r; ) e.push(F8.empty)
        e.push(n)
      }
    }
    function g7(e, t, n) {
      let r = e.inserted
      for (let a = 0, o = 0, i = 0; i < e.sections.length; ) {
        let s = e.sections[i++],
          l = e.sections[i++]
        if (l < 0) (a += s), (o += s)
        else {
          let c = a,
            d = o,
            u = F8.empty
          for (
            ;
            (c += s),
              (d += l),
              l && r && (u = u.append(r[(i - 2) >> 1])),
              !(n || i == e.sections.length || e.sections[i + 1] < 0);

          )
            (s = e.sections[i++]), (l = e.sections[i++])
          t(a, c, o, d, u), (a = c), (o = d)
        }
      }
    }
    function b7(e, t, n, r = !1) {
      let a = [],
        o = r ? [] : null,
        i = new y7(e),
        s = new y7(t)
      for (let e = -1; ; )
        if (-1 == i.ins && -1 == s.ins) {
          let e = Math.min(i.len, s.len)
          f7(a, e, -1), i.forward(e), s.forward(e)
        } else if (s.ins >= 0 && (i.ins < 0 || e == i.i || (0 == i.off && (s.len < i.len || (s.len == i.len && !n))))) {
          let t = s.len
          for (f7(a, s.ins, -1); t; ) {
            let n = Math.min(i.len, t)
            i.ins >= 0 && e < i.i && i.len <= n && (f7(a, 0, i.ins), o && m7(o, a, i.text), (e = i.i)),
              i.forward(n),
              (t -= n)
          }
          s.next()
        } else {
          if (!(i.ins >= 0)) {
            if (i.done && s.done) return o ? h7.createSet(a, o) : p7.create(a)
            throw new Error("Mismatched change set lengths")
          }
          {
            let t = 0,
              n = i.len
            for (; n; )
              if (-1 == s.ins) {
                let e = Math.min(n, s.len)
                ;(t += e), (n -= e), s.forward(e)
              } else {
                if (!(0 == s.ins && s.len < n)) break
                ;(n -= s.len), s.next()
              }
            f7(a, t, e < i.i ? i.ins : 0), o && e < i.i && m7(o, a, i.text), (e = i.i), i.forward(i.len - n)
          }
        }
    }
    function v7(e, t, n = !1) {
      let r = [],
        a = n ? [] : null,
        o = new y7(e),
        i = new y7(t)
      for (let e = !1; ; ) {
        if (o.done && i.done) return a ? h7.createSet(r, a) : p7.create(r)
        if (0 == o.ins) f7(r, o.len, 0, e), o.next()
        else if (0 != i.len || i.done) {
          if (o.done || i.done) throw new Error("Mismatched change set lengths")
          {
            let t = Math.min(o.len2, i.len),
              n = r.length
            if (-1 == o.ins) {
              let n = -1 == i.ins ? -1 : i.off ? 0 : i.ins
              f7(r, t, n, e), a && n && m7(a, r, i.text)
            } else
              -1 == i.ins
                ? (f7(r, o.off ? 0 : o.len, t, e), a && m7(a, r, o.textBit(t)))
                : (f7(r, o.off ? 0 : o.len, i.off ? 0 : i.ins, e), a && !i.off && m7(a, r, i.text))
            ;(e = (o.ins > t || (i.ins >= 0 && i.len > t)) && (e || r.length > n)), o.forward2(t), i.forward(t)
          }
        } else f7(r, 0, i.ins, e), a && m7(a, r, i.text), i.next()
      }
    }
    class y7 {
      constructor(e) {
        ;(this.set = e), (this.i = 0), this.next()
      }
      next() {
        let { sections: e } = this.set
        this.i < e.length ? ((this.len = e[this.i++]), (this.ins = e[this.i++])) : ((this.len = 0), (this.ins = -2)),
          (this.off = 0)
      }
      get done() {
        return -2 == this.ins
      }
      get len2() {
        return this.ins < 0 ? this.len : this.ins
      }
      get text() {
        let { inserted: e } = this.set,
          t = (this.i - 2) >> 1
        return t >= e.length ? F8.empty : e[t]
      }
      textBit(e) {
        let { inserted: t } = this.set,
          n = (this.i - 2) >> 1
        return n >= t.length && !e ? F8.empty : t[n].slice(this.off, null == e ? void 0 : this.off + e)
      }
      forward(e) {
        e == this.len ? this.next() : ((this.len -= e), (this.off += e))
      }
      forward2(e) {
        ;-1 == this.ins ? this.forward(e) : e == this.ins ? this.next() : ((this.ins -= e), (this.off += e))
      }
    }
    class O7 {
      constructor(e, t, n) {
        ;(this.from = e), (this.to = t), (this.flags = n)
      }
      get anchor() {
        return 32 & this.flags ? this.to : this.from
      }
      get head() {
        return 32 & this.flags ? this.from : this.to
      }
      get empty() {
        return this.from == this.to
      }
      get assoc() {
        return 8 & this.flags ? -1 : 16 & this.flags ? 1 : 0
      }
      get bidiLevel() {
        let e = 7 & this.flags
        return 7 == e ? null : e
      }
      get goalColumn() {
        let e = this.flags >> 6
        return 16777215 == e ? void 0 : e
      }
      map(e, t = -1) {
        let n, r
        return (
          this.empty ? (n = r = e.mapPos(this.from, t)) : ((n = e.mapPos(this.from, 1)), (r = e.mapPos(this.to, -1))),
          n == this.from && r == this.to ? this : new O7(n, r, this.flags)
        )
      }
      extend(e, t = e) {
        if (e <= this.anchor && t >= this.anchor) return w7.range(e, t)
        let n = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t
        return w7.range(this.anchor, n)
      }
      eq(e, t = !1) {
        return !(this.anchor != e.anchor || this.head != e.head || (t && this.empty && this.assoc != e.assoc))
      }
      toJSON() {
        return { anchor: this.anchor, head: this.head }
      }
      static fromJSON(e) {
        if (!e || "number" != typeof e.anchor || "number" != typeof e.head)
          throw new RangeError("Invalid JSON representation for SelectionRange")
        return w7.range(e.anchor, e.head)
      }
      static create(e, t, n) {
        return new O7(e, t, n)
      }
    }
    class w7 {
      constructor(e, t) {
        ;(this.ranges = e), (this.mainIndex = t)
      }
      map(e, t = -1) {
        return e.empty
          ? this
          : w7.create(
              this.ranges.map((n) => n.map(e, t)),
              this.mainIndex,
            )
      }
      eq(e, t = !1) {
        if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1
        for (let n = 0; n < this.ranges.length; n++) if (!this.ranges[n].eq(e.ranges[n], t)) return !1
        return !0
      }
      get main() {
        return this.ranges[this.mainIndex]
      }
      asSingle() {
        return 1 == this.ranges.length ? this : new w7([this.main], 0)
      }
      addRange(e, t = !0) {
        return w7.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1)
      }
      replaceRange(e, t = this.mainIndex) {
        let n = this.ranges.slice()
        return (n[t] = e), w7.create(n, this.mainIndex)
      }
      toJSON() {
        return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex }
      }
      static fromJSON(e) {
        if (!e || !Array.isArray(e.ranges) || "number" != typeof e.main || e.main >= e.ranges.length)
          throw new RangeError("Invalid JSON representation for EditorSelection")
        return new w7(
          e.ranges.map((e) => O7.fromJSON(e)),
          e.main,
        )
      }
      static single(e, t = e) {
        return new w7([w7.range(e, t)], 0)
      }
      static create(e, t = 0) {
        if (0 == e.length) throw new RangeError("A selection needs at least one range")
        for (let n = 0, r = 0; r < e.length; r++) {
          let a = e[r]
          if (a.empty ? a.from <= n : a.from < n) return w7.normalized(e.slice(), t)
          n = a.to
        }
        return new w7(e, t)
      }
      static cursor(e, t = 0, n, r) {
        return O7.create(
          e,
          e,
          (0 == t ? 0 : t < 0 ? 8 : 16) | (null == n ? 7 : Math.min(6, n)) | ((null != r ? r : 16777215) << 6),
        )
      }
      static range(e, t, n, r) {
        let a = ((null != n ? n : 16777215) << 6) | (null == r ? 7 : Math.min(6, r))
        return t < e ? O7.create(t, e, 48 | a) : O7.create(e, t, (t > e ? 8 : 0) | a)
      }
      static normalized(e, t = 0) {
        let n = e[t]
        e.sort((e, t) => e.from - t.from), (t = e.indexOf(n))
        for (let n = 1; n < e.length; n++) {
          let r = e[n],
            a = e[n - 1]
          if (r.empty ? r.from <= a.to : r.from < a.to) {
            let o = a.from,
              i = Math.max(r.to, a.to)
            n <= t && t--, e.splice(--n, 2, r.anchor > r.head ? w7.range(i, o) : w7.range(o, i))
          }
        }
        return new w7(e, t)
      }
    }
    function x7(e, t) {
      for (let n of e.ranges) if (n.to > t) throw new RangeError("Selection points outside of document")
    }
    let k7 = 0
    class _7 {
      constructor(e, t, n, r, a) {
        ;(this.combine = e),
          (this.compareInput = t),
          (this.compare = n),
          (this.isStatic = r),
          (this.id = k7++),
          (this.default = e([])),
          (this.extensions = "function" == typeof a ? a(this) : a)
      }
      get reader() {
        return this
      }
      static define(e = {}) {
        return new _7(
          e.combine || ((e) => e),
          e.compareInput || ((e, t) => e === t),
          e.compare || (e.combine ? (e, t) => e === t : S7),
          !!e.static,
          e.enables,
        )
      }
      of(e) {
        return new E7([], this, 0, e)
      }
      compute(e, t) {
        if (this.isStatic) throw new Error("Can't compute a static facet")
        return new E7(e, this, 1, t)
      }
      computeN(e, t) {
        if (this.isStatic) throw new Error("Can't compute a static facet")
        return new E7(e, this, 2, t)
      }
      from(e, t) {
        return t || (t = (e) => e), this.compute([e], (n) => t(n.field(e)))
      }
    }
    function S7(e, t) {
      return e == t || (e.length == t.length && e.every((e, n) => e === t[n]))
    }
    class E7 {
      constructor(e, t, n, r) {
        ;(this.dependencies = e), (this.facet = t), (this.type = n), (this.value = r), (this.id = k7++)
      }
      dynamicSlot(e) {
        var t
        let n = this.value,
          r = this.facet.compareInput,
          a = this.id,
          o = e[a] >> 1,
          i = 2 == this.type,
          s = !1,
          l = !1,
          c = []
        for (let n of this.dependencies)
          "doc" == n
            ? (s = !0)
            : "selection" == n
              ? (l = !0)
              : 1 & (null !== (t = e[n.id]) && void 0 !== t ? t : 1) || c.push(e[n.id])
        return {
          create: (e) => ((e.values[o] = n(e)), 1),
          update(e, t) {
            if ((s && t.docChanged) || (l && (t.docChanged || t.selection)) || A7(e, c)) {
              let t = n(e)
              if (i ? !T7(t, e.values[o], r) : !r(t, e.values[o])) return (e.values[o] = t), 1
            }
            return 0
          },
          reconfigure: (e, t) => {
            let s,
              l = t.config.address[a]
            if (null != l) {
              let a = B7(t, l)
              if (
                this.dependencies.every((n) =>
                  n instanceof _7 ? t.facet(n) === e.facet(n) : !(n instanceof D7) || t.field(n, !1) == e.field(n, !1),
                ) ||
                (i ? T7((s = n(e)), a, r) : r((s = n(e)), a))
              )
                return (e.values[o] = a), 0
            } else s = n(e)
            return (e.values[o] = s), 1
          },
        }
      }
    }
    function T7(e, t, n) {
      if (e.length != t.length) return !1
      for (let r = 0; r < e.length; r++) if (!n(e[r], t[r])) return !1
      return !0
    }
    function A7(e, t) {
      let n = !1
      for (let r of t) 1 & Q7(e, r) && (n = !0)
      return n
    }
    function C7(e, t, n) {
      let r = n.map((t) => e[t.id]),
        a = n.map((e) => e.type),
        o = r.filter((e) => !(1 & e)),
        i = e[t.id] >> 1
      function s(e) {
        let n = []
        for (let t = 0; t < r.length; t++) {
          let o = B7(e, r[t])
          if (2 == a[t]) for (let e of o) n.push(e)
          else n.push(o)
        }
        return t.combine(n)
      }
      return {
        create(e) {
          for (let t of r) Q7(e, t)
          return (e.values[i] = s(e)), 1
        },
        update(e, n) {
          if (!A7(e, o)) return 0
          let r = s(e)
          return t.compare(r, e.values[i]) ? 0 : ((e.values[i] = r), 1)
        },
        reconfigure(e, a) {
          let o = A7(e, r),
            l = a.config.facets[t.id],
            c = a.facet(t)
          if (l && !o && S7(n, l)) return (e.values[i] = c), 0
          let d = s(e)
          return t.compare(d, c) ? ((e.values[i] = c), 0) : ((e.values[i] = d), 1)
        },
      }
    }
    const P7 = _7.define({ static: !0 })
    class D7 {
      constructor(e, t, n, r, a) {
        ;(this.id = e),
          (this.createF = t),
          (this.updateF = n),
          (this.compareF = r),
          (this.spec = a),
          (this.provides = void 0)
      }
      static define(e) {
        let t = new D7(k7++, e.create, e.update, e.compare || ((e, t) => e === t), e)
        return e.provide && (t.provides = e.provide(t)), t
      }
      create(e) {
        let t = e.facet(P7).find((e) => e.field == this)
        return ((null == t ? void 0 : t.create) || this.createF)(e)
      }
      slot(e) {
        let t = e[this.id] >> 1
        return {
          create: (e) => ((e.values[t] = this.create(e)), 1),
          update: (e, n) => {
            let r = e.values[t],
              a = this.updateF(r, n)
            return this.compareF(r, a) ? 0 : ((e.values[t] = a), 1)
          },
          reconfigure: (e, n) =>
            null != n.config.address[this.id]
              ? ((e.values[t] = n.field(this)), 0)
              : ((e.values[t] = this.create(e)), 1),
        }
      }
      init(e) {
        return [this, P7.of({ field: this, create: e })]
      }
      get extension() {
        return this
      }
    }
    function R7(e) {
      return (t) => new $7(t, e)
    }
    const N7 = { highest: R7(0), high: R7(1), default: R7(2), low: R7(3), lowest: R7(4) }
    class $7 {
      constructor(e, t) {
        ;(this.inner = e), (this.prec = t)
      }
    }
    class I7 {
      of(e) {
        return new M7(this, e)
      }
      reconfigure(e) {
        return I7.reconfigure.of({ compartment: this, extension: e })
      }
      get(e) {
        return e.config.compartments.get(this)
      }
    }
    class M7 {
      constructor(e, t) {
        ;(this.compartment = e), (this.inner = t)
      }
    }
    class L7 {
      constructor(e, t, n, r, a, o) {
        for (
          this.base = e,
            this.compartments = t,
            this.dynamicSlots = n,
            this.address = r,
            this.staticValues = a,
            this.facets = o,
            this.statusTemplate = [];
          this.statusTemplate.length < n.length;

        )
          this.statusTemplate.push(0)
      }
      staticFacet(e) {
        let t = this.address[e.id]
        return null == t ? e.default : this.staticValues[t >> 1]
      }
      static resolve(e, t, n) {
        let r = [],
          a = Object.create(null),
          o = new Map()
        for (let n of (function (e, t, n) {
          let r = [[], [], [], [], []],
            a = new Map()
          return (
            (function e(o, i) {
              let s = a.get(o)
              if (null != s) {
                if (s <= i) return
                let e = r[s].indexOf(o)
                e > -1 && r[s].splice(e, 1), o instanceof M7 && n.delete(o.compartment)
              }
              if ((a.set(o, i), Array.isArray(o))) for (let t of o) e(t, i)
              else if (o instanceof M7) {
                if (n.has(o.compartment)) throw new RangeError("Duplicate use of compartment in extensions")
                let r = t.get(o.compartment) || o.inner
                n.set(o.compartment, r), e(r, i)
              } else if (o instanceof $7) e(o.inner, o.prec)
              else if (o instanceof D7) r[i].push(o), o.provides && e(o.provides, i)
              else if (o instanceof E7) r[i].push(o), o.facet.extensions && e(o.facet.extensions, 2)
              else {
                let t = o.extension
                if (!t)
                  throw new Error(
                    `Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`,
                  )
                e(t, i)
              }
            })(e, 2),
            r.reduce((e, t) => e.concat(t))
          )
        })(e, t, o))
          n instanceof D7 ? r.push(n) : (a[n.facet.id] || (a[n.facet.id] = [])).push(n)
        let i = Object.create(null),
          s = [],
          l = []
        for (let e of r) (i[e.id] = l.length << 1), l.push((t) => e.slot(t))
        let c = null == n ? void 0 : n.config.facets
        for (let e in a) {
          let t = a[e],
            r = t[0].facet,
            o = (c && c[e]) || []
          if (t.every((e) => 0 == e.type))
            if (((i[r.id] = (s.length << 1) | 1), S7(o, t))) s.push(n.facet(r))
            else {
              let e = r.combine(t.map((e) => e.value))
              s.push(n && r.compare(e, n.facet(r)) ? n.facet(r) : e)
            }
          else {
            for (let e of t)
              0 == e.type
                ? ((i[e.id] = (s.length << 1) | 1), s.push(e.value))
                : ((i[e.id] = l.length << 1), l.push((t) => e.dynamicSlot(t)))
            ;(i[r.id] = l.length << 1), l.push((e) => C7(e, r, t))
          }
        }
        let d = l.map((e) => e(i))
        return new L7(e, o, d, i, s, a)
      }
    }
    function Q7(e, t) {
      if (1 & t) return 2
      let n = t >> 1,
        r = e.status[n]
      if (4 == r) throw new Error("Cyclic dependency between fields and/or facets")
      if (2 & r) return r
      e.status[n] = 4
      let a = e.computeSlot(e, e.config.dynamicSlots[n])
      return (e.status[n] = 2 | a)
    }
    function B7(e, t) {
      return 1 & t ? e.config.staticValues[t >> 1] : e.values[t >> 1]
    }
    const j7 = _7.define(),
      U7 = _7.define({ combine: (e) => e.some((e) => e), static: !0 }),
      F7 = _7.define({ combine: (e) => (e.length ? e[0] : void 0), static: !0 }),
      z7 = _7.define(),
      q7 = _7.define(),
      Z7 = _7.define(),
      H7 = _7.define({ combine: (e) => !!e.length && e[0] })
    class V7 {
      constructor(e, t) {
        ;(this.type = e), (this.value = t)
      }
      static define() {
        return new W7()
      }
    }
    class W7 {
      of(e) {
        return new V7(this, e)
      }
    }
    class X7 {
      constructor(e) {
        this.map = e
      }
      of(e) {
        return new Y7(this, e)
      }
    }
    class Y7 {
      constructor(e, t) {
        ;(this.type = e), (this.value = t)
      }
      map(e) {
        let t = this.type.map(this.value, e)
        return void 0 === t ? void 0 : t == this.value ? this : new Y7(this.type, t)
      }
      is(e) {
        return this.type == e
      }
      static define(e = {}) {
        return new X7(e.map || ((e) => e))
      }
      static mapEffects(e, t) {
        if (!e.length) return e
        let n = []
        for (let r of e) {
          let e = r.map(t)
          e && n.push(e)
        }
        return n
      }
    }
    ;(Y7.reconfigure = Y7.define()), (Y7.appendConfig = Y7.define())
    class G7 {
      constructor(e, t, n, r, a, o) {
        ;(this.startState = e),
          (this.changes = t),
          (this.selection = n),
          (this.effects = r),
          (this.annotations = a),
          (this.scrollIntoView = o),
          (this._doc = null),
          (this._state = null),
          n && x7(n, t.newLength),
          a.some((e) => e.type == G7.time) || (this.annotations = a.concat(G7.time.of(Date.now())))
      }
      static create(e, t, n, r, a, o) {
        return new G7(e, t, n, r, a, o)
      }
      get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc))
      }
      get newSelection() {
        return this.selection || this.startState.selection.map(this.changes)
      }
      get state() {
        return this._state || this.startState.applyTransaction(this), this._state
      }
      annotation(e) {
        for (let t of this.annotations) if (t.type == e) return t.value
      }
      get docChanged() {
        return !this.changes.empty
      }
      get reconfigured() {
        return this.startState.config != this.state.config
      }
      isUserEvent(e) {
        let t = this.annotation(G7.userEvent)
        return !(!t || !(t == e || (t.length > e.length && t.slice(0, e.length) == e && "." == t[e.length])))
      }
    }
    function K7(e, t) {
      let n = []
      for (let r = 0, a = 0; ; ) {
        let o, i
        if (r < e.length && (a == t.length || t[a] >= e[r])) (o = e[r++]), (i = e[r++])
        else {
          if (!(a < t.length)) return n
          ;(o = t[a++]), (i = t[a++])
        }
        !n.length || n[n.length - 1] < o ? n.push(o, i) : n[n.length - 1] < i && (n[n.length - 1] = i)
      }
    }
    function J7(e, t, n) {
      var r
      let a, o, i
      return (
        n
          ? ((a = t.changes), (o = h7.empty(t.changes.length)), (i = e.changes.compose(t.changes)))
          : ((a = t.changes.map(e.changes)), (o = e.changes.mapDesc(t.changes, !0)), (i = e.changes.compose(a))),
        {
          changes: i,
          selection: t.selection ? t.selection.map(o) : null === (r = e.selection) || void 0 === r ? void 0 : r.map(a),
          effects: Y7.mapEffects(e.effects, a).concat(Y7.mapEffects(t.effects, o)),
          annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
          scrollIntoView: e.scrollIntoView || t.scrollIntoView,
        }
      )
    }
    function e6(e, t, n) {
      let r = t.selection,
        a = r6(t.annotations)
      return (
        t.userEvent && (a = a.concat(G7.userEvent.of(t.userEvent))),
        {
          changes: t.changes instanceof h7 ? t.changes : h7.of(t.changes || [], n, e.facet(F7)),
          selection: r && (r instanceof w7 ? r : w7.single(r.anchor, r.head)),
          effects: r6(t.effects),
          annotations: a,
          scrollIntoView: !!t.scrollIntoView,
        }
      )
    }
    function t6(e, t, n) {
      let r = e6(e, t.length ? t[0] : {}, e.doc.length)
      t.length && !1 === t[0].filter && (n = !1)
      for (let a = 1; a < t.length; a++) {
        !1 === t[a].filter && (n = !1)
        let o = !!t[a].sequential
        r = J7(r, e6(e, t[a], o ? r.changes.newLength : e.doc.length), o)
      }
      let a = G7.create(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView)
      return (function (e) {
        let t = e.startState,
          n = t.facet(Z7),
          r = e
        for (let a = n.length - 1; a >= 0; a--) {
          let o = n[a](e)
          o && Object.keys(o).length && (r = J7(r, e6(t, o, e.changes.newLength), !0))
        }
        return r == e ? e : G7.create(t, e.changes, e.selection, r.effects, r.annotations, r.scrollIntoView)
      })(
        n
          ? (function (e) {
              let t = e.startState,
                n = !0
              for (let r of t.facet(z7)) {
                let t = r(e)
                if (!1 === t) {
                  n = !1
                  break
                }
                Array.isArray(t) && (n = !0 === n ? t : K7(n, t))
              }
              if (!0 !== n) {
                let r, a
                if (!1 === n) (a = e.changes.invertedDesc), (r = h7.empty(t.doc.length))
                else {
                  let t = e.changes.filter(n)
                  ;(r = t.changes), (a = t.filtered.mapDesc(t.changes).invertedDesc)
                }
                e = G7.create(
                  t,
                  r,
                  e.selection && e.selection.map(a),
                  Y7.mapEffects(e.effects, a),
                  e.annotations,
                  e.scrollIntoView,
                )
              }
              let r = t.facet(q7)
              for (let n = r.length - 1; n >= 0; n--) {
                let a = r[n](e)
                e =
                  a instanceof G7
                    ? a
                    : Array.isArray(a) && 1 == a.length && a[0] instanceof G7
                      ? a[0]
                      : t6(t, r6(a), !1)
              }
              return e
            })(a)
          : a,
      )
    }
    ;(G7.time = V7.define()), (G7.userEvent = V7.define()), (G7.addToHistory = V7.define()), (G7.remote = V7.define())
    const n6 = []
    function r6(e) {
      return null == e ? n6 : Array.isArray(e) ? e : [e]
    }
    var a6 = (function (e) {
      return (e[(e.Word = 0)] = "Word"), (e[(e.Space = 1)] = "Space"), (e[(e.Other = 2)] = "Other"), e
    })(a6 || (a6 = {}))
    const o6 =
      /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
    let i6
    try {
      i6 = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u")
    } catch (e) {}
    class s6 {
      constructor(e, t, n, r, a, o) {
        ;(this.config = e),
          (this.doc = t),
          (this.selection = n),
          (this.values = r),
          (this.status = e.statusTemplate.slice()),
          (this.computeSlot = a),
          o && (o._state = this)
        for (let e = 0; e < this.config.dynamicSlots.length; e++) Q7(this, e << 1)
        this.computeSlot = null
      }
      field(e, t = !0) {
        let n = this.config.address[e.id]
        if (null != n) return Q7(this, n), B7(this, n)
        if (t) throw new RangeError("Field is not present in this state")
      }
      update(...e) {
        return t6(this, e, !0)
      }
      applyTransaction(e) {
        let t,
          n = this.config,
          { base: r, compartments: a } = n
        for (let t of e.effects)
          t.is(I7.reconfigure)
            ? (n && ((a = new Map()), n.compartments.forEach((e, t) => a.set(t, e)), (n = null)),
              a.set(t.value.compartment, t.value.extension))
            : t.is(Y7.reconfigure)
              ? ((n = null), (r = t.value))
              : t.is(Y7.appendConfig) && ((n = null), (r = r6(r).concat(t.value)))
        n
          ? (t = e.startState.values.slice())
          : ((n = L7.resolve(r, a, this)),
            (t = new s6(
              n,
              this.doc,
              this.selection,
              n.dynamicSlots.map(() => null),
              (e, t) => t.reconfigure(e, this),
              null,
            ).values))
        let o = e.startState.facet(U7) ? e.newSelection : e.newSelection.asSingle()
        new s6(n, e.newDoc, o, t, (t, n) => n.update(t, e), e)
      }
      replaceSelection(e) {
        return (
          "string" == typeof e && (e = this.toText(e)),
          this.changeByRange((t) => ({
            changes: { from: t.from, to: t.to, insert: e },
            range: w7.cursor(t.from + e.length),
          }))
        )
      }
      changeByRange(e) {
        let t = this.selection,
          n = e(t.ranges[0]),
          r = this.changes(n.changes),
          a = [n.range],
          o = r6(n.effects)
        for (let n = 1; n < t.ranges.length; n++) {
          let i = e(t.ranges[n]),
            s = this.changes(i.changes),
            l = s.map(r)
          for (let e = 0; e < n; e++) a[e] = a[e].map(l)
          let c = r.mapDesc(s, !0)
          a.push(i.range.map(c)), (r = r.compose(l)), (o = Y7.mapEffects(o, l).concat(Y7.mapEffects(r6(i.effects), c)))
        }
        return { changes: r, selection: w7.create(a, t.mainIndex), effects: o }
      }
      changes(e = []) {
        return e instanceof h7 ? e : h7.of(e, this.doc.length, this.facet(s6.lineSeparator))
      }
      toText(e) {
        return F8.of(e.split(this.facet(s6.lineSeparator) || d7))
      }
      sliceDoc(e = 0, t = this.doc.length) {
        return this.doc.sliceString(e, t, this.lineBreak)
      }
      facet(e) {
        let t = this.config.address[e.id]
        return null == t ? e.default : (Q7(this, t), B7(this, t))
      }
      toJSON(e) {
        let t = { doc: this.sliceDoc(), selection: this.selection.toJSON() }
        if (e)
          for (let n in e) {
            let r = e[n]
            r instanceof D7 && null != this.config.address[r.id] && (t[n] = r.spec.toJSON(this.field(e[n]), this))
          }
        return t
      }
      static fromJSON(e, t = {}, n) {
        if (!e || "string" != typeof e.doc) throw new RangeError("Invalid JSON representation for EditorState")
        let r = []
        if (n)
          for (let t in n)
            if (Object.prototype.hasOwnProperty.call(e, t)) {
              let a = n[t],
                o = e[t]
              r.push(a.init((e) => a.spec.fromJSON(o, e)))
            }
        return s6.create({
          doc: e.doc,
          selection: w7.fromJSON(e.selection),
          extensions: t.extensions ? r.concat([t.extensions]) : r,
        })
      }
      static create(e = {}) {
        let t = L7.resolve(e.extensions || [], new Map()),
          n = e.doc instanceof F8 ? e.doc : F8.of((e.doc || "").split(t.staticFacet(s6.lineSeparator) || d7)),
          r = e.selection
            ? e.selection instanceof w7
              ? e.selection
              : w7.single(e.selection.anchor, e.selection.head)
            : w7.single(0)
        return (
          x7(r, n.length),
          t.staticFacet(U7) || (r = r.asSingle()),
          new s6(
            t,
            n,
            r,
            t.dynamicSlots.map(() => null),
            (e, t) => t.create(e),
            null,
          )
        )
      }
      get tabSize() {
        return this.facet(s6.tabSize)
      }
      get lineBreak() {
        return this.facet(s6.lineSeparator) || "\n"
      }
      get readOnly() {
        return this.facet(H7)
      }
      phrase(e, ...t) {
        for (let t of this.facet(s6.phrases))
          if (Object.prototype.hasOwnProperty.call(t, e)) {
            e = t[e]
            break
          }
        return (
          t.length &&
            (e = e.replace(/\$(\$|\d*)/g, (e, n) => {
              if ("$" == n) return "$"
              let r = +(n || 1)
              return !r || r > t.length ? e : t[r - 1]
            })),
          e
        )
      }
      languageDataAt(e, t, n = -1) {
        let r = []
        for (let a of this.facet(j7))
          for (let o of a(this, t, n)) Object.prototype.hasOwnProperty.call(o, e) && r.push(o[e])
        return r
      }
      charCategorizer(e) {
        return (function (e) {
          return (t) => {
            if (!/\S/.test(t)) return a6.Space
            if (
              (function (e) {
                if (i6) return i6.test(e)
                for (let t = 0; t < e.length; t++) {
                  let n = e[t]
                  if (/\w/.test(n) || (n > "" && (n.toUpperCase() != n.toLowerCase() || o6.test(n)))) return !0
                }
                return !1
              })(t)
            )
              return a6.Word
            for (let n = 0; n < e.length; n++) if (t.indexOf(e[n]) > -1) return a6.Word
            return a6.Other
          }
        })(this.languageDataAt("wordChars", e).join(""))
      }
      wordAt(e) {
        let { text: t, from: n, length: r } = this.doc.lineAt(e),
          a = this.charCategorizer(e),
          o = e - n,
          i = e - n
        for (; o > 0; ) {
          let e = n7(t, o, !1)
          if (a(t.slice(e, o)) != a6.Word) break
          o = e
        }
        for (; i < r; ) {
          let e = n7(t, i)
          if (a(t.slice(i, e)) != a6.Word) break
          i = e
        }
        return o == i ? null : w7.range(o + n, i + n)
      }
    }
    function l6(e, t, n = {}) {
      let r = {}
      for (let t of e)
        for (let e of Object.keys(t)) {
          let a = t[e],
            o = r[e]
          if (void 0 === o) r[e] = a
          else if (o === a || void 0 === a);
          else {
            if (!Object.hasOwnProperty.call(n, e)) throw new Error("Config merge conflict for field " + e)
            r[e] = n[e](o, a)
          }
        }
      for (let e in t) void 0 === r[e] && (r[e] = t[e])
      return r
    }
    ;(s6.allowMultipleSelections = U7),
      (s6.tabSize = _7.define({ combine: (e) => (e.length ? e[0] : 4) })),
      (s6.lineSeparator = F7),
      (s6.readOnly = H7),
      (s6.phrases = _7.define({
        compare(e, t) {
          let n = Object.keys(e),
            r = Object.keys(t)
          return n.length == r.length && n.every((n) => e[n] == t[n])
        },
      })),
      (s6.languageData = j7),
      (s6.changeFilter = z7),
      (s6.transactionFilter = q7),
      (s6.transactionExtender = Z7),
      (I7.reconfigure = Y7.define())
    class c6 {
      eq(e) {
        return this == e
      }
      range(e, t = e) {
        return d6.create(e, t, this)
      }
    }
    ;(c6.prototype.startSide = c6.prototype.endSide = 0),
      (c6.prototype.point = !1),
      (c6.prototype.mapMode = u7.TrackDel)
    let d6 = class e {
      constructor(e, t, n) {
        ;(this.from = e), (this.to = t), (this.value = n)
      }
      static create(t, n, r) {
        return new e(t, n, r)
      }
    }
    function u6(e, t) {
      return e.from - t.from || e.value.startSide - t.value.startSide
    }
    class p6 {
      constructor(e, t, n, r) {
        ;(this.from = e), (this.to = t), (this.value = n), (this.maxPoint = r)
      }
      get length() {
        return this.to[this.to.length - 1]
      }
      findIndex(e, t, n, r = 0) {
        let a = n ? this.to : this.from
        for (let o = r, i = a.length; ; ) {
          if (o == i) return o
          let r = (o + i) >> 1,
            s = a[r] - e || (n ? this.value[r].endSide : this.value[r].startSide) - t
          if (r == o) return s >= 0 ? o : i
          s >= 0 ? (i = r) : (o = r + 1)
        }
      }
      between(e, t, n, r) {
        for (let a = this.findIndex(t, -1e9, !0), o = this.findIndex(n, 1e9, !1, a); a < o; a++)
          if (!1 === r(this.from[a] + e, this.to[a] + e, this.value[a])) return !1
      }
      map(e, t) {
        let n = [],
          r = [],
          a = [],
          o = -1,
          i = -1
        for (let s = 0; s < this.value.length; s++) {
          let l,
            c,
            d = this.value[s],
            u = this.from[s] + e,
            p = this.to[s] + e
          if (u == p) {
            let e = t.mapPos(u, d.startSide, d.mapMode)
            if (null == e) continue
            if (((l = c = e), d.startSide != d.endSide && ((c = t.mapPos(u, d.endSide)), c < l))) continue
          } else if (
            ((l = t.mapPos(u, d.startSide)),
            (c = t.mapPos(p, d.endSide)),
            l > c || (l == c && d.startSide > 0 && d.endSide <= 0))
          )
            continue
          ;(c - l || d.endSide - d.startSide) < 0 ||
            (o < 0 && (o = l), d.point && (i = Math.max(i, c - l)), n.push(d), r.push(l - o), a.push(c - o))
        }
        return { mapped: n.length ? new p6(r, a, n, i) : null, pos: o }
      }
    }
    class h6 {
      constructor(e, t, n, r) {
        ;(this.chunkPos = e), (this.chunk = t), (this.nextLayer = n), (this.maxPoint = r)
      }
      static create(e, t, n, r) {
        return new h6(e, t, n, r)
      }
      get length() {
        let e = this.chunk.length - 1
        return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length)
      }
      get size() {
        if (this.isEmpty) return 0
        let e = this.nextLayer.size
        for (let t of this.chunk) e += t.value.length
        return e
      }
      chunkEnd(e) {
        return this.chunkPos[e] + this.chunk[e].length
      }
      update(e) {
        let { add: t = [], sort: n = !1, filterFrom: r = 0, filterTo: a = this.length } = e,
          o = e.filter
        if (0 == t.length && !o) return this
        if ((n && (t = t.slice().sort(u6)), this.isEmpty)) return t.length ? h6.of(t) : this
        let i = new g6(this, null, -1).goto(0),
          s = 0,
          l = [],
          c = new f6()
        for (; i.value || s < t.length; )
          if (s < t.length && (i.from - t[s].from || i.startSide - t[s].value.startSide) >= 0) {
            let e = t[s++]
            c.addInner(e.from, e.to, e.value) || l.push(e)
          } else
            1 == i.rangeIndex &&
            i.chunkIndex < this.chunk.length &&
            (s == t.length || this.chunkEnd(i.chunkIndex) < t[s].from) &&
            (!o || r > this.chunkEnd(i.chunkIndex) || a < this.chunkPos[i.chunkIndex]) &&
            c.addChunk(this.chunkPos[i.chunkIndex], this.chunk[i.chunkIndex])
              ? i.nextChunk()
              : ((!o || r > i.to || a < i.from || o(i.from, i.to, i.value)) &&
                  (c.addInner(i.from, i.to, i.value) || l.push(d6.create(i.from, i.to, i.value))),
                i.next())
        return c.finishInner(
          this.nextLayer.isEmpty && !l.length
            ? h6.empty
            : this.nextLayer.update({ add: l, filter: o, filterFrom: r, filterTo: a }),
        )
      }
      map(e) {
        if (e.empty || this.isEmpty) return this
        let t = [],
          n = [],
          r = -1
        for (let a = 0; a < this.chunk.length; a++) {
          let o = this.chunkPos[a],
            i = this.chunk[a],
            s = e.touchesRange(o, o + i.length)
          if (!1 === s) (r = Math.max(r, i.maxPoint)), t.push(i), n.push(e.mapPos(o))
          else if (!0 === s) {
            let { mapped: a, pos: s } = i.map(o, e)
            a && ((r = Math.max(r, a.maxPoint)), t.push(a), n.push(s))
          }
        }
        let a = this.nextLayer.map(e)
        return 0 == t.length ? a : new h6(n, t, a || h6.empty, r)
      }
      between(e, t, n) {
        if (!this.isEmpty) {
          for (let r = 0; r < this.chunk.length; r++) {
            let a = this.chunkPos[r],
              o = this.chunk[r]
            if (t >= a && e <= a + o.length && !1 === o.between(a, e - a, t - a, n)) return
          }
          this.nextLayer.between(e, t, n)
        }
      }
      iter(e = 0) {
        return b6.from([this]).goto(e)
      }
      get isEmpty() {
        return this.nextLayer == this
      }
      static iter(e, t = 0) {
        return b6.from(e).goto(t)
      }
      static compare(e, t, n, r, a = -1) {
        let o = e.filter((e) => e.maxPoint > 0 || (!e.isEmpty && e.maxPoint >= a)),
          i = t.filter((e) => e.maxPoint > 0 || (!e.isEmpty && e.maxPoint >= a)),
          s = m6(o, i, n),
          l = new y6(o, s, a),
          c = new y6(i, s, a)
        n.iterGaps((e, t, n) => O6(l, e, c, t, n, r)), n.empty && 0 == n.length && O6(l, 0, c, 0, 0, r)
      }
      static eq(e, t, n = 0, r) {
        null == r && (r = 999999999)
        let a = e.filter((e) => !e.isEmpty && t.indexOf(e) < 0),
          o = t.filter((t) => !t.isEmpty && e.indexOf(t) < 0)
        if (a.length != o.length) return !1
        if (!a.length) return !0
        let i = m6(a, o),
          s = new y6(a, i, 0).goto(n),
          l = new y6(o, i, 0).goto(n)
        for (;;) {
          if (s.to != l.to || !w6(s.active, l.active) || (s.point && (!l.point || !s.point.eq(l.point)))) return !1
          if (s.to > r) return !0
          s.next(), l.next()
        }
      }
      static spans(e, t, n, r, a = -1) {
        let o = new y6(e, null, a).goto(t),
          i = t,
          s = o.openStart
        for (;;) {
          let e = Math.min(o.to, n)
          if (o.point) {
            let n = o.activeForPoint(o.to),
              a = o.pointFrom < t ? n.length + 1 : o.point.startSide < 0 ? n.length : Math.min(n.length, s)
            r.point(i, e, o.point, n, a, o.pointRank), (s = Math.min(o.openEnd(e), n.length))
          } else e > i && (r.span(i, e, o.active, s), (s = o.openEnd(e)))
          if (o.to > n) return s + (o.point && o.to > n ? 1 : 0)
          ;(i = o.to), o.next()
        }
      }
      static of(e, t = !1) {
        let n = new f6()
        for (let r of e instanceof d6
          ? [e]
          : t
            ? (function (e) {
                if (e.length > 1)
                  for (let t = e[0], n = 1; n < e.length; n++) {
                    let r = e[n]
                    if (u6(t, r) > 0) return e.slice().sort(u6)
                    t = r
                  }
                return e
              })(e)
            : e)
          n.add(r.from, r.to, r.value)
        return n.finish()
      }
      static join(e) {
        if (!e.length) return h6.empty
        let t = e[e.length - 1]
        for (let n = e.length - 2; n >= 0; n--)
          for (let r = e[n]; r != h6.empty; r = r.nextLayer)
            t = new h6(r.chunkPos, r.chunk, t, Math.max(r.maxPoint, t.maxPoint))
        return t
      }
    }
    ;(h6.empty = new h6([], [], null, -1)), (h6.empty.nextLayer = h6.empty)
    class f6 {
      finishChunk(e) {
        this.chunks.push(new p6(this.from, this.to, this.value, this.maxPoint)),
          this.chunkPos.push(this.chunkStart),
          (this.chunkStart = -1),
          (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
          (this.maxPoint = -1),
          e && ((this.from = []), (this.to = []), (this.value = []))
      }
      constructor() {
        ;(this.chunks = []),
          (this.chunkPos = []),
          (this.chunkStart = -1),
          (this.last = null),
          (this.lastFrom = -1e9),
          (this.lastTo = -1e9),
          (this.from = []),
          (this.to = []),
          (this.value = []),
          (this.maxPoint = -1),
          (this.setMaxPoint = -1),
          (this.nextLayer = null)
      }
      add(e, t, n) {
        this.addInner(e, t, n) || (this.nextLayer || (this.nextLayer = new f6())).add(e, t, n)
      }
      addInner(e, t, n) {
        let r = e - this.lastTo || n.startSide - this.last.endSide
        if (r <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
          throw new Error("Ranges must be added sorted by `from` position and `startSide`")
        return !(
          r < 0 ||
          (250 == this.from.length && this.finishChunk(!0),
          this.chunkStart < 0 && (this.chunkStart = e),
          this.from.push(e - this.chunkStart),
          this.to.push(t - this.chunkStart),
          (this.last = n),
          (this.lastFrom = e),
          (this.lastTo = t),
          this.value.push(n),
          n.point && (this.maxPoint = Math.max(this.maxPoint, t - e)),
          0)
        )
      }
      addChunk(e, t) {
        if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0) return !1
        this.from.length && this.finishChunk(!0),
          (this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint)),
          this.chunks.push(t),
          this.chunkPos.push(e)
        let n = t.value.length - 1
        return (this.last = t.value[n]), (this.lastFrom = t.from[n] + e), (this.lastTo = t.to[n] + e), !0
      }
      finish() {
        return this.finishInner(h6.empty)
      }
      finishInner(e) {
        if ((this.from.length && this.finishChunk(!1), 0 == this.chunks.length)) return e
        let t = h6.create(
          this.chunkPos,
          this.chunks,
          this.nextLayer ? this.nextLayer.finishInner(e) : e,
          this.setMaxPoint,
        )
        return (this.from = null), t
      }
    }
    function m6(e, t, n) {
      let r = new Map()
      for (let t of e)
        for (let e = 0; e < t.chunk.length; e++) t.chunk[e].maxPoint <= 0 && r.set(t.chunk[e], t.chunkPos[e])
      let a = new Set()
      for (let e of t)
        for (let t = 0; t < e.chunk.length; t++) {
          let o = r.get(e.chunk[t])
          null == o ||
            (n ? n.mapPos(o) : o) != e.chunkPos[t] ||
            (null == n ? void 0 : n.touchesRange(o, o + e.chunk[t].length)) ||
            a.add(e.chunk[t])
        }
      return a
    }
    class g6 {
      constructor(e, t, n, r = 0) {
        ;(this.layer = e), (this.skip = t), (this.minPoint = n), (this.rank = r)
      }
      get startSide() {
        return this.value ? this.value.startSide : 0
      }
      get endSide() {
        return this.value ? this.value.endSide : 0
      }
      goto(e, t = -1e9) {
        return (this.chunkIndex = this.rangeIndex = 0), this.gotoInner(e, t, !1), this
      }
      gotoInner(e, t, n) {
        for (; this.chunkIndex < this.layer.chunk.length; ) {
          let t = this.layer.chunk[this.chunkIndex]
          if (
            !((this.skip && this.skip.has(t)) || this.layer.chunkEnd(this.chunkIndex) < e || t.maxPoint < this.minPoint)
          )
            break
          this.chunkIndex++, (n = !1)
        }
        if (this.chunkIndex < this.layer.chunk.length) {
          let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0)
          ;(!n || this.rangeIndex < r) && this.setRangeIndex(r)
        }
        this.next()
      }
      forward(e, t) {
        ;(this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0)
      }
      next() {
        for (;;) {
          if (this.chunkIndex == this.layer.chunk.length) {
            ;(this.from = this.to = 1e9), (this.value = null)
            break
          }
          {
            let e = this.layer.chunkPos[this.chunkIndex],
              t = this.layer.chunk[this.chunkIndex],
              n = e + t.from[this.rangeIndex]
            if (
              ((this.from = n),
              (this.to = e + t.to[this.rangeIndex]),
              (this.value = t.value[this.rangeIndex]),
              this.setRangeIndex(this.rangeIndex + 1),
              this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint))
            )
              break
          }
        }
      }
      setRangeIndex(e) {
        if (e == this.layer.chunk[this.chunkIndex].value.length) {
          if ((this.chunkIndex++, this.skip))
            for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
              this.chunkIndex++
          this.rangeIndex = 0
        } else this.rangeIndex = e
      }
      nextChunk() {
        this.chunkIndex++, (this.rangeIndex = 0), this.next()
      }
      compare(e) {
        return (
          this.from - e.from ||
          this.startSide - e.startSide ||
          this.rank - e.rank ||
          this.to - e.to ||
          this.endSide - e.endSide
        )
      }
    }
    class b6 {
      constructor(e) {
        this.heap = e
      }
      static from(e, t = null, n = -1) {
        let r = []
        for (let a = 0; a < e.length; a++)
          for (let o = e[a]; !o.isEmpty; o = o.nextLayer) o.maxPoint >= n && r.push(new g6(o, t, n, a))
        return 1 == r.length ? r[0] : new b6(r)
      }
      get startSide() {
        return this.value ? this.value.startSide : 0
      }
      goto(e, t = -1e9) {
        for (let n of this.heap) n.goto(e, t)
        for (let e = this.heap.length >> 1; e >= 0; e--) v6(this.heap, e)
        return this.next(), this
      }
      forward(e, t) {
        for (let n of this.heap) n.forward(e, t)
        for (let e = this.heap.length >> 1; e >= 0; e--) v6(this.heap, e)
        ;(this.to - e || this.value.endSide - t) < 0 && this.next()
      }
      next() {
        if (0 == this.heap.length) (this.from = this.to = 1e9), (this.value = null), (this.rank = -1)
        else {
          let e = this.heap[0]
          ;(this.from = e.from),
            (this.to = e.to),
            (this.value = e.value),
            (this.rank = e.rank),
            e.value && e.next(),
            v6(this.heap, 0)
        }
      }
    }
    function v6(e, t) {
      for (let n = e[t]; ; ) {
        let r = 1 + (t << 1)
        if (r >= e.length) break
        let a = e[r]
        if ((r + 1 < e.length && a.compare(e[r + 1]) >= 0 && ((a = e[r + 1]), r++), n.compare(a) < 0)) break
        ;(e[r] = n), (e[t] = a), (t = r)
      }
    }
    class y6 {
      constructor(e, t, n) {
        ;(this.minPoint = n),
          (this.active = []),
          (this.activeTo = []),
          (this.activeRank = []),
          (this.minActive = -1),
          (this.point = null),
          (this.pointFrom = 0),
          (this.pointRank = 0),
          (this.to = -1e9),
          (this.endSide = 0),
          (this.openStart = -1),
          (this.cursor = b6.from(e, t, n))
      }
      goto(e, t = -1e9) {
        return (
          this.cursor.goto(e, t),
          (this.active.length = this.activeTo.length = this.activeRank.length = 0),
          (this.minActive = -1),
          (this.to = e),
          (this.endSide = t),
          (this.openStart = -1),
          this.next(),
          this
        )
      }
      forward(e, t) {
        for (
          ;
          this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0;

        )
          this.removeActive(this.minActive)
        this.cursor.forward(e, t)
      }
      removeActive(e) {
        x6(this.active, e),
          x6(this.activeTo, e),
          x6(this.activeRank, e),
          (this.minActive = _6(this.active, this.activeTo))
      }
      addActive(e) {
        let t = 0,
          { value: n, to: r, rank: a } = this.cursor
        for (; t < this.activeRank.length && (a - this.activeRank[t] || r - this.activeTo[t]) > 0; ) t++
        k6(this.active, t, n),
          k6(this.activeTo, t, r),
          k6(this.activeRank, t, a),
          e && k6(e, t, this.cursor.from),
          (this.minActive = _6(this.active, this.activeTo))
      }
      next() {
        let e = this.to,
          t = this.point
        this.point = null
        let n = this.openStart < 0 ? [] : null
        for (;;) {
          let r = this.minActive
          if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
            if (this.activeTo[r] > e) {
              ;(this.to = this.activeTo[r]), (this.endSide = this.active[r].endSide)
              break
            }
            this.removeActive(r), n && x6(n, r)
          } else {
            if (!this.cursor.value) {
              this.to = this.endSide = 1e9
              break
            }
            if (this.cursor.from > e) {
              ;(this.to = this.cursor.from), (this.endSide = this.cursor.startSide)
              break
            }
            {
              let e = this.cursor.value
              if (e.point) {
                if (!(t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)) {
                  ;(this.point = e),
                    (this.pointFrom = this.cursor.from),
                    (this.pointRank = this.cursor.rank),
                    (this.to = this.cursor.to),
                    (this.endSide = e.endSide),
                    this.cursor.next(),
                    this.forward(this.to, this.endSide)
                  break
                }
                this.cursor.next()
              } else this.addActive(n), this.cursor.next()
            }
          }
        }
        if (n) {
          this.openStart = 0
          for (let t = n.length - 1; t >= 0 && n[t] < e; t--) this.openStart++
        }
      }
      activeForPoint(e) {
        if (!this.active.length) return this.active
        let t = []
        for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
          (this.activeTo[n] > e || (this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide)) &&
            t.push(this.active[n])
        return t.reverse()
      }
      openEnd(e) {
        let t = 0
        for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--) t++
        return t
      }
    }
    function O6(e, t, n, r, a, o) {
      e.goto(t), n.goto(r)
      let i = r + a,
        s = r,
        l = r - t
      for (;;) {
        let t = e.to + l - n.to || e.endSide - n.endSide,
          r = t < 0 ? e.to + l : n.to,
          a = Math.min(r, i)
        if (
          (e.point || n.point
            ? (e.point &&
                n.point &&
                (e.point == n.point || e.point.eq(n.point)) &&
                w6(e.activeForPoint(e.to), n.activeForPoint(n.to))) ||
              o.comparePoint(s, a, e.point, n.point)
            : a > s && !w6(e.active, n.active) && o.compareRange(s, a, e.active, n.active),
          r > i)
        )
          break
        ;(s = r), t <= 0 && e.next(), t >= 0 && n.next()
      }
    }
    function w6(e, t) {
      if (e.length != t.length) return !1
      for (let n = 0; n < e.length; n++) if (e[n] != t[n] && !e[n].eq(t[n])) return !1
      return !0
    }
    function x6(e, t) {
      for (let n = t, r = e.length - 1; n < r; n++) e[n] = e[n + 1]
      e.pop()
    }
    function k6(e, t, n) {
      for (let n = e.length - 1; n >= t; n--) e[n + 1] = e[n]
      e[t] = n
    }
    function _6(e, t) {
      let n = -1,
        r = 1e9
      for (let a = 0; a < t.length; a++) (t[a] - r || e[a].endSide - e[n].endSide) < 0 && ((n = a), (r = t[a]))
      return n
    }
    function S6(e, t, n = e.length) {
      let r = 0
      for (let a = 0; a < n; ) 9 == e.charCodeAt(a) ? ((r += t - (r % t)), a++) : (r++, (a = n7(e, a)))
      return r
    }
    const E6 = "undefined" == typeof Symbol ? "__" : Symbol.for(""),
      T6 = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet"),
      A6 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {}
    class C6 {
      constructor(e, t) {
        this.rules = []
        let { finish: n } = t || {}
        function r(e) {
          return /^@/.test(e) ? [e] : e.split(/,\s*/)
        }
        function a(e, t, o, i) {
          let s = [],
            l = /^@(\w+)\b/.exec(e[0]),
            c = l && "keyframes" == l[1]
          if (l && null == t) return o.push(e[0] + ";")
          for (let n in t) {
            let i = t[n]
            if (/&/.test(n))
              a(
                n
                  .split(/,\s*/)
                  .map((t) => e.map((e) => t.replace(/&/, e)))
                  .reduce((e, t) => e.concat(t)),
                i,
                o,
              )
            else if (i && "object" == typeof i) {
              if (!l) throw new RangeError("The value of a property (" + n + ") should be a primitive value.")
              a(r(n), i, s, c)
            } else
              null != i && s.push(n.replace(/_.*/, "").replace(/[A-Z]/g, (e) => "-" + e.toLowerCase()) + ": " + i + ";")
          }
          ;(s.length || c) && o.push((!n || l || i ? e : e.map(n)).join(", ") + " {" + s.join(" ") + "}")
        }
        for (let t in e) a(r(t), e[t], this.rules)
      }
      getRules() {
        return this.rules.join("\n")
      }
      static newName() {
        let e = A6[E6] || 1
        return (A6[E6] = e + 1), "" + e.toString(36)
      }
      static mount(e, t, n) {
        let r = e[T6],
          a = n && n.nonce
        r ? a && r.setNonce(a) : (r = new D6(e, a)), r.mount(Array.isArray(t) ? t : [t], e)
      }
    }
    let P6 = new Map()
    class D6 {
      constructor(e, t) {
        let n = e.ownerDocument || e,
          r = n.defaultView
        if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
          let t = P6.get(n)
          if (t) return (e[T6] = t)
          ;(this.sheet = new r.CSSStyleSheet()), P6.set(n, this)
        } else (this.styleTag = n.createElement("style")), t && this.styleTag.setAttribute("nonce", t)
        ;(this.modules = []), (e[T6] = this)
      }
      mount(e, t) {
        let n = this.sheet,
          r = 0,
          a = 0
        for (let t = 0; t < e.length; t++) {
          let o = e[t],
            i = this.modules.indexOf(o)
          if ((i < a && i > -1 && (this.modules.splice(i, 1), a--, (i = -1)), -1 == i)) {
            if ((this.modules.splice(a++, 0, o), n))
              for (let e = 0; e < o.rules.length; e++) n.insertRule(o.rules[e], r++)
          } else {
            for (; a < i; ) r += this.modules[a++].rules.length
            ;(r += o.rules.length), a++
          }
        }
        if (n)
          t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets])
        else {
          let e = ""
          for (let t = 0; t < this.modules.length; t++) e += this.modules[t].getRules() + "\n"
          this.styleTag.textContent = e
          let n = t.head || t
          this.styleTag.parentNode != n && n.insertBefore(this.styleTag, n.firstChild)
        }
      }
      setNonce(e) {
        this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e)
      }
    }
    for (
      var R6 = {
          8: "Backspace",
          9: "Tab",
          10: "Enter",
          12: "NumLock",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          44: "PrintScreen",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Meta",
          92: "Meta",
          106: "*",
          107: "+",
          108: ",",
          109: "-",
          110: ".",
          111: "/",
          144: "NumLock",
          145: "ScrollLock",
          160: "Shift",
          161: "Shift",
          162: "Control",
          163: "Control",
          164: "Alt",
          165: "Alt",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
        },
        N6 = {
          48: ")",
          49: "!",
          50: "@",
          51: "#",
          52: "$",
          53: "%",
          54: "^",
          55: "&",
          56: "*",
          57: "(",
          59: ":",
          61: "+",
          173: "_",
          186: ":",
          187: "+",
          188: "<",
          189: "_",
          190: ">",
          191: "?",
          192: "~",
          219: "{",
          220: "|",
          221: "}",
          222: '"',
        },
        $6 = "undefined" != typeof navigator && /Mac/.test(navigator.platform),
        I6 =
          "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),
        M6 = 0;
      M6 < 10;
      M6++
    )
      R6[48 + M6] = R6[96 + M6] = String(M6)
    for (M6 = 1; M6 <= 24; M6++) R6[M6 + 111] = "F" + M6
    for (M6 = 65; M6 <= 90; M6++) (R6[M6] = String.fromCharCode(M6 + 32)), (N6[M6] = String.fromCharCode(M6))
    for (var L6 in R6) N6.hasOwnProperty(L6) || (N6[L6] = R6[L6])
    function Q6(e) {
      let t
      return (t = 11 == e.nodeType ? (e.getSelection ? e : e.ownerDocument) : e), t.getSelection()
    }
    function B6(e, t) {
      return !!t && (e == t || e.contains(1 != t.nodeType ? t.parentNode : t))
    }
    function j6(e, t) {
      if (!t.anchorNode) return !1
      try {
        return B6(e, t.anchorNode)
      } catch (e) {
        return !1
      }
    }
    function U6(e) {
      return 3 == e.nodeType ? e9(e, 0, e.nodeValue.length).getClientRects() : 1 == e.nodeType ? e.getClientRects() : []
    }
    function F6(e, t, n, r) {
      return !!n && (Z6(e, t, n, r, -1) || Z6(e, t, n, r, 1))
    }
    function z6(e) {
      for (var t = 0; ; t++) if (!(e = e.previousSibling)) return t
    }
    function q6(e) {
      return 1 == e.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName)
    }
    function Z6(e, t, n, r, a) {
      for (;;) {
        if (e == n && t == r) return !0
        if (t == (a < 0 ? 0 : H6(e))) {
          if ("DIV" == e.nodeName) return !1
          let n = e.parentNode
          if (!n || 1 != n.nodeType) return !1
          ;(t = z6(e) + (a < 0 ? 0 : 1)), (e = n)
        } else {
          if (1 != e.nodeType) return !1
          if (1 == (e = e.childNodes[t + (a < 0 ? -1 : 0)]).nodeType && "false" == e.contentEditable) return !1
          t = a < 0 ? H6(e) : 0
        }
      }
    }
    function H6(e) {
      return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length
    }
    function V6(e, t) {
      let n = t ? e.left : e.right
      return { left: n, right: n, top: e.top, bottom: e.bottom }
    }
    function W6(e) {
      let t = e.visualViewport
      return t
        ? { left: 0, right: t.width, top: 0, bottom: t.height }
        : { left: 0, right: e.innerWidth, top: 0, bottom: e.innerHeight }
    }
    function X6(e, t) {
      let n = t.width / e.offsetWidth,
        r = t.height / e.offsetHeight
      return (
        ((n > 0.995 && n < 1.005) || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1),
        ((r > 0.995 && r < 1.005) || !isFinite(r) || Math.abs(t.height - e.offsetHeight) < 1) && (r = 1),
        { scaleX: n, scaleY: r }
      )
    }
    class Y6 {
      constructor() {
        ;(this.anchorNode = null), (this.anchorOffset = 0), (this.focusNode = null), (this.focusOffset = 0)
      }
      eq(e) {
        return (
          this.anchorNode == e.anchorNode &&
          this.anchorOffset == e.anchorOffset &&
          this.focusNode == e.focusNode &&
          this.focusOffset == e.focusOffset
        )
      }
      setRange(e) {
        let { anchorNode: t, focusNode: n } = e
        this.set(t, Math.min(e.anchorOffset, t ? H6(t) : 0), n, Math.min(e.focusOffset, n ? H6(n) : 0))
      }
      set(e, t, n, r) {
        ;(this.anchorNode = e), (this.anchorOffset = t), (this.focusNode = n), (this.focusOffset = r)
      }
    }
    let G6,
      K6 = null
    function J6(e) {
      if (e.setActive) return e.setActive()
      if (K6) return e.focus(K6)
      let t = []
      for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode);
      if (
        (e.focus(
          null == K6
            ? {
                get preventScroll() {
                  return (K6 = { preventScroll: !0 }), !0
                },
              }
            : void 0,
        ),
        !K6)
      ) {
        K6 = !1
        for (let e = 0; e < t.length; ) {
          let n = t[e++],
            r = t[e++],
            a = t[e++]
          n.scrollTop != r && (n.scrollTop = r), n.scrollLeft != a && (n.scrollLeft = a)
        }
      }
    }
    function e9(e, t, n = t) {
      let r = G6 || (G6 = document.createRange())
      return r.setEnd(e, n), r.setStart(e, t), r
    }
    function t9(e, t, n, r) {
      let a = { key: t, code: t, keyCode: n, which: n, cancelable: !0 }
      r && ({ altKey: a.altKey, ctrlKey: a.ctrlKey, shiftKey: a.shiftKey, metaKey: a.metaKey } = r)
      let o = new KeyboardEvent("keydown", a)
      ;(o.synthetic = !0), e.dispatchEvent(o)
      let i = new KeyboardEvent("keyup", a)
      return (i.synthetic = !0), e.dispatchEvent(i), o.defaultPrevented || i.defaultPrevented
    }
    function n9(e) {
      for (; e.attributes.length; ) e.removeAttributeNode(e.attributes[0])
    }
    function r9(e) {
      return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4)
    }
    function a9(e, t) {
      for (let n = e, r = t; ; ) {
        if (3 == n.nodeType && r > 0) return { node: n, offset: r }
        if (1 == n.nodeType && r > 0) {
          if ("false" == n.contentEditable) return null
          ;(n = n.childNodes[r - 1]), (r = H6(n))
        } else {
          if (!n.parentNode || q6(n)) return null
          ;(r = z6(n)), (n = n.parentNode)
        }
      }
    }
    function o9(e, t) {
      for (let n = e, r = t; ; ) {
        if (3 == n.nodeType && r < n.nodeValue.length) return { node: n, offset: r }
        if (1 == n.nodeType && r < n.childNodes.length) {
          if ("false" == n.contentEditable) return null
          ;(n = n.childNodes[r]), (r = 0)
        } else {
          if (!n.parentNode || q6(n)) return null
          ;(r = z6(n) + 1), (n = n.parentNode)
        }
      }
    }
    class i9 {
      constructor(e, t, n = !0) {
        ;(this.node = e), (this.offset = t), (this.precise = n)
      }
      static before(e, t) {
        return new i9(e.parentNode, z6(e), t)
      }
      static after(e, t) {
        return new i9(e.parentNode, z6(e) + 1, t)
      }
    }
    const s9 = []
    class l9 {
      constructor() {
        ;(this.parent = null), (this.dom = null), (this.flags = 2)
      }
      get overrideDOMText() {
        return null
      }
      get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0
      }
      get posAtEnd() {
        return this.posAtStart + this.length
      }
      posBefore(e) {
        let t = this.posAtStart
        for (let n of this.children) {
          if (n == e) return t
          t += n.length + n.breakAfter
        }
        throw new RangeError("Invalid child in posBefore")
      }
      posAfter(e) {
        return this.posBefore(e) + e.length
      }
      sync(e, t) {
        if (2 & this.flags) {
          let n,
            r = this.dom,
            a = null
          for (let o of this.children) {
            if (7 & o.flags) {
              if (!o.dom && (n = a ? a.nextSibling : r.firstChild)) {
                let e = l9.get(n)
                ;(!e || (!e.parent && e.canReuseDOM(o))) && o.reuseDOM(n)
              }
              o.sync(e, t), (o.flags &= -8)
            }
            if (
              ((n = a ? a.nextSibling : r.firstChild),
              t && !t.written && t.node == r && n != o.dom && (t.written = !0),
              o.dom.parentNode == r)
            )
              for (; n && n != o.dom; ) n = c9(n)
            else r.insertBefore(o.dom, n)
            a = o.dom
          }
          for (n = a ? a.nextSibling : r.firstChild, n && t && t.node == r && (t.written = !0); n; ) n = c9(n)
        } else if (1 & this.flags) for (let n of this.children) 7 & n.flags && (n.sync(e, t), (n.flags &= -8))
      }
      reuseDOM(e) {}
      localPosFromDOM(e, t) {
        let n
        if (e == this.dom) n = this.dom.childNodes[t]
        else {
          let r = 0 == H6(e) ? 0 : 0 == t ? -1 : 1
          for (;;) {
            let t = e.parentNode
            if (t == this.dom) break
            0 == r && t.firstChild != t.lastChild && (r = e == t.firstChild ? -1 : 1), (e = t)
          }
          n = r < 0 ? e : e.nextSibling
        }
        if (n == this.dom.firstChild) return 0
        for (; n && !l9.get(n); ) n = n.nextSibling
        if (!n) return this.length
        for (let e = 0, t = 0; ; e++) {
          let r = this.children[e]
          if (r.dom == n) return t
          t += r.length + r.breakAfter
        }
      }
      domBoundsAround(e, t, n = 0) {
        let r = -1,
          a = -1,
          o = -1,
          i = -1
        for (let s = 0, l = n, c = n; s < this.children.length; s++) {
          let n = this.children[s],
            d = l + n.length
          if (l < e && d > t) return n.domBoundsAround(e, t, l)
          if ((d >= e && -1 == r && ((r = s), (a = l)), l > t && n.dom.parentNode == this.dom)) {
            ;(o = s), (i = c)
            break
          }
          ;(c = d), (l = d + n.breakAfter)
        }
        return {
          from: a,
          to: i < 0 ? n + this.length : i,
          startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
          endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null,
        }
      }
      markDirty(e = !1) {
        ;(this.flags |= 2), this.markParentsDirty(e)
      }
      markParentsDirty(e) {
        for (let t = this.parent; t; t = t.parent) {
          if ((e && (t.flags |= 2), 1 & t.flags)) return
          ;(t.flags |= 1), (e = !1)
        }
      }
      setParent(e) {
        this.parent != e && ((this.parent = e), 7 & this.flags && this.markParentsDirty(!0))
      }
      setDOM(e) {
        this.dom != e && (this.dom && (this.dom.cmView = null), (this.dom = e), (e.cmView = this))
      }
      get rootView() {
        for (let e = this; ; ) {
          let t = e.parent
          if (!t) return e
          e = t
        }
      }
      replaceChildren(e, t, n = s9) {
        this.markDirty()
        for (let r = e; r < t; r++) {
          let e = this.children[r]
          e.parent == this && n.indexOf(e) < 0 && e.destroy()
        }
        this.children.splice(e, t - e, ...n)
        for (let e = 0; e < n.length; e++) n[e].setParent(this)
      }
      ignoreMutation(e) {
        return !1
      }
      ignoreEvent(e) {
        return !1
      }
      childCursor(e = this.length) {
        return new d9(this.children, e, this.children.length)
      }
      childPos(e, t = 1) {
        return this.childCursor().findPos(e, t)
      }
      toString() {
        let e = this.constructor.name.replace("View", "")
        return (
          e +
          (this.children.length
            ? "(" + this.children.join() + ")"
            : this.length
              ? "[" + ("Text" == e ? this.text : this.length) + "]"
              : "") +
          (this.breakAfter ? "#" : "")
        )
      }
      static get(e) {
        return e.cmView
      }
      get isEditable() {
        return !0
      }
      get isWidget() {
        return !1
      }
      get isHidden() {
        return !1
      }
      merge(e, t, n, r, a, o) {
        return !1
      }
      become(e) {
        return !1
      }
      canReuseDOM(e) {
        return e.constructor == this.constructor && !(8 & (this.flags | e.flags))
      }
      getSide() {
        return 0
      }
      destroy() {
        for (let e of this.children) e.parent == this && e.destroy()
        this.parent = null
      }
    }
    function c9(e) {
      let t = e.nextSibling
      return e.parentNode.removeChild(e), t
    }
    l9.prototype.breakAfter = 0
    class d9 {
      constructor(e, t, n) {
        ;(this.children = e), (this.pos = t), (this.i = n), (this.off = 0)
      }
      findPos(e, t = 1) {
        for (;;) {
          if (e > this.pos || (e == this.pos && (t > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)))
            return (this.off = e - this.pos), this
          let n = this.children[--this.i]
          this.pos -= n.length + n.breakAfter
        }
      }
    }
    function u9(e, t, n, r, a, o, i, s, l) {
      let { children: c } = e,
        d = c.length ? c[t] : null,
        u = o.length ? o[o.length - 1] : null,
        p = u ? u.breakAfter : i
      if (!(t == r && d && !i && !p && o.length < 2 && d.merge(n, a, o.length ? u : null, 0 == n, s, l))) {
        if (r < c.length) {
          let e = c[r]
          e && (a < e.length || (e.breakAfter && (null == u ? void 0 : u.breakAfter)))
            ? (t == r && ((e = e.split(a)), (a = 0)),
              !p && u && e.merge(0, a, u, !0, 0, l)
                ? (o[o.length - 1] = e)
                : ((a || (e.children.length && !e.children[0].length)) && e.merge(0, a, null, !1, 0, l), o.push(e)))
            : (null == e ? void 0 : e.breakAfter) && (u ? (u.breakAfter = 1) : (i = 1)),
            r++
        }
        for (
          d &&
          ((d.breakAfter = i),
          n > 0 &&
            (!i && o.length && d.merge(n, d.length, o[0], !1, s, 0)
              ? (d.breakAfter = o.shift().breakAfter)
              : (n < d.length || (d.children.length && 0 == d.children[d.children.length - 1].length)) &&
                d.merge(n, d.length, null, !1, s, 0),
            t++));
          t < r && o.length;

        )
          if (c[r - 1].become(o[o.length - 1])) r--, o.pop(), (l = o.length ? 0 : s)
          else {
            if (!c[t].become(o[0])) break
            t++, o.shift(), (s = o.length ? 0 : l)
          }
        !o.length && t && r < c.length && !c[t - 1].breakAfter && c[r].merge(0, 0, c[t - 1], !1, s, l) && t--,
          (t < r || o.length) && e.replaceChildren(t, r, o)
      }
    }
    function p9(e, t, n, r, a, o) {
      let i = e.childCursor(),
        { i: s, off: l } = i.findPos(n, 1),
        { i: c, off: d } = i.findPos(t, -1),
        u = t - n
      for (let e of r) u += e.length
      ;(e.length += u), u9(e, c, d, s, l, r, 0, a, o)
    }
    let h9 = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" },
      f9 = "undefined" != typeof document ? document : { documentElement: { style: {} } }
    const m9 = /Edge\/(\d+)/.exec(h9.userAgent),
      g9 = /MSIE \d/.test(h9.userAgent),
      b9 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(h9.userAgent),
      v9 = !!(g9 || b9 || m9),
      y9 = !v9 && /gecko\/(\d+)/i.test(h9.userAgent),
      O9 = !v9 && /Chrome\/(\d+)/.exec(h9.userAgent),
      w9 = "webkitFontSmoothing" in f9.documentElement.style,
      x9 = !v9 && /Apple Computer/.test(h9.vendor),
      k9 = x9 && (/Mobile\/\w+/.test(h9.userAgent) || h9.maxTouchPoints > 2)
    var _9 = {
      mac: k9 || /Mac/.test(h9.platform),
      windows: /Win/.test(h9.platform),
      linux: /Linux|X11/.test(h9.platform),
      ie: v9,
      ie_version: g9 ? f9.documentMode || 6 : b9 ? +b9[1] : m9 ? +m9[1] : 0,
      gecko: y9,
      gecko_version: y9 ? +(/Firefox\/(\d+)/.exec(h9.userAgent) || [0, 0])[1] : 0,
      chrome: !!O9,
      chrome_version: O9 ? +O9[1] : 0,
      ios: k9,
      android: /Android\b/.test(h9.userAgent),
      webkit: w9,
      safari: x9,
      webkit_version: w9 ? +(/\bAppleWebKit\/(\d+)/.exec(h9.userAgent) || [0, 0])[1] : 0,
      tabSize: null != f9.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size",
    }
    class S9 extends l9 {
      constructor(e) {
        super(), (this.text = e)
      }
      get length() {
        return this.text.length
      }
      createDOM(e) {
        this.setDOM(e || document.createTextNode(this.text))
      }
      sync(e, t) {
        this.dom || this.createDOM(),
          this.dom.nodeValue != this.text &&
            (t && t.node == this.dom && (t.written = !0), (this.dom.nodeValue = this.text))
      }
      reuseDOM(e) {
        3 == e.nodeType && this.createDOM(e)
      }
      merge(e, t, n) {
        return !(
          8 & this.flags ||
          (n && (!(n instanceof S9) || this.length - (t - e) + n.length > 256 || 8 & n.flags)) ||
          ((this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(t)), this.markDirty(), 0)
        )
      }
      split(e) {
        let t = new S9(this.text.slice(e))
        return (this.text = this.text.slice(0, e)), this.markDirty(), (t.flags |= 8 & this.flags), t
      }
      localPosFromDOM(e, t) {
        return e == this.dom ? t : t ? this.text.length : 0
      }
      domAtPos(e) {
        return new i9(this.dom, e)
      }
      domBoundsAround(e, t, n) {
        return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling }
      }
      coordsAt(e, t) {
        return (function (e, t, n) {
          let r = e.nodeValue.length
          t > r && (t = r)
          let a = t,
            o = t,
            i = 0
          ;(0 == t && n < 0) || (t == r && n >= 0)
            ? _9.chrome || _9.gecko || (t ? (a--, (i = 1)) : o < r && (o++, (i = -1)))
            : n < 0
              ? a--
              : o < r && o++
          let s = e9(e, a, o).getClientRects()
          if (!s.length) return null
          let l = s[(i ? i < 0 : n >= 0) ? 0 : s.length - 1]
          return (
            _9.safari && !i && 0 == l.width && (l = Array.prototype.find.call(s, (e) => e.width) || l),
            i ? V6(l, i < 0) : l || null
          )
        })(this.dom, e, t)
      }
    }
    class E9 extends l9 {
      constructor(e, t = [], n = 0) {
        super(), (this.mark = e), (this.children = t), (this.length = n)
        for (let e of t) e.setParent(this)
      }
      setAttrs(e) {
        if ((n9(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs))
          for (let t in this.mark.attrs) e.setAttribute(t, this.mark.attrs[t])
        return e
      }
      canReuseDOM(e) {
        return super.canReuseDOM(e) && !(8 & (this.flags | e.flags))
      }
      reuseDOM(e) {
        e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), (this.flags |= 6))
      }
      sync(e, t) {
        this.dom
          ? 4 & this.flags && this.setAttrs(this.dom)
          : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
          super.sync(e, t)
      }
      merge(e, t, n, r, a, o) {
        return !(
          (n && (!(n instanceof E9 && n.mark.eq(this.mark)) || (e && a <= 0) || (t < this.length && o <= 0))) ||
          (p9(this, e, t, n ? n.children.slice() : [], a - 1, o - 1), this.markDirty(), 0)
        )
      }
      split(e) {
        let t = [],
          n = 0,
          r = -1,
          a = 0
        for (let o of this.children) {
          let i = n + o.length
          i > e && t.push(n < e ? o.split(e - n) : o), r < 0 && n >= e && (r = a), (n = i), a++
        }
        let o = this.length - e
        return (this.length = e), r > -1 && ((this.children.length = r), this.markDirty()), new E9(this.mark, t, o)
      }
      domAtPos(e) {
        return C9(this, e)
      }
      coordsAt(e, t) {
        return D9(this, e, t)
      }
    }
    class T9 extends l9 {
      static create(e, t, n) {
        return new T9(e, t, n)
      }
      constructor(e, t, n) {
        super(), (this.widget = e), (this.length = t), (this.side = n), (this.prevWidget = null)
      }
      split(e) {
        let t = T9.create(this.widget, this.length - e, this.side)
        return (this.length -= e), t
      }
      sync(e) {
        ;(this.dom && this.widget.updateDOM(this.dom, e)) ||
          (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
          (this.prevWidget = null),
          this.setDOM(this.widget.toDOM(e)),
          this.widget.editable || (this.dom.contentEditable = "false"))
      }
      getSide() {
        return this.side
      }
      merge(e, t, n, r, a, o) {
        return !(
          (n &&
            (!(n instanceof T9 && this.widget.compare(n.widget)) ||
              (e > 0 && a <= 0) ||
              (t < this.length && o <= 0))) ||
          ((this.length = e + (n ? n.length : 0) + (this.length - t)), 0)
        )
      }
      become(e) {
        return (
          e instanceof T9 &&
          e.side == this.side &&
          this.widget.constructor == e.widget.constructor &&
          (this.widget.compare(e.widget) || this.markDirty(!0),
          this.dom && !this.prevWidget && (this.prevWidget = this.widget),
          (this.widget = e.widget),
          (this.length = e.length),
          !0)
        )
      }
      ignoreMutation() {
        return !0
      }
      ignoreEvent(e) {
        return this.widget.ignoreEvent(e)
      }
      get overrideDOMText() {
        if (0 == this.length) return F8.empty
        let e = this
        for (; e.parent; ) e = e.parent
        let { view: t } = e,
          n = t && t.state.doc,
          r = this.posAtStart
        return n ? n.slice(r, r + this.length) : F8.empty
      }
      domAtPos(e) {
        return (this.length ? 0 == e : this.side > 0) ? i9.before(this.dom) : i9.after(this.dom, e == this.length)
      }
      domBoundsAround() {
        return null
      }
      coordsAt(e, t) {
        let n = this.widget.coordsAt(this.dom, e, t)
        if (n) return n
        let r = this.dom.getClientRects(),
          a = null
        if (!r.length) return null
        let o = this.side ? this.side < 0 : e > 0
        for (
          let t = o ? r.length - 1 : 0;
          (a = r[t]), !(e > 0 ? 0 == t : t == r.length - 1 || a.top < a.bottom);
          t += o ? -1 : 1
        );
        return V6(a, !o)
      }
      get isEditable() {
        return !1
      }
      get isWidget() {
        return !0
      }
      get isHidden() {
        return this.widget.isHidden
      }
      destroy() {
        super.destroy(), this.dom && this.widget.destroy(this.dom)
      }
    }
    class A9 extends l9 {
      constructor(e) {
        super(), (this.side = e)
      }
      get length() {
        return 0
      }
      merge() {
        return !1
      }
      become(e) {
        return e instanceof A9 && e.side == this.side
      }
      split() {
        return new A9(this.side)
      }
      sync() {
        if (!this.dom) {
          let e = document.createElement("img")
          ;(e.className = "cm-widgetBuffer"), e.setAttribute("aria-hidden", "true"), this.setDOM(e)
        }
      }
      getSide() {
        return this.side
      }
      domAtPos(e) {
        return this.side > 0 ? i9.before(this.dom) : i9.after(this.dom)
      }
      localPosFromDOM() {
        return 0
      }
      domBoundsAround() {
        return null
      }
      coordsAt(e) {
        return this.dom.getBoundingClientRect()
      }
      get overrideDOMText() {
        return F8.empty
      }
      get isHidden() {
        return !0
      }
    }
    function C9(e, t) {
      let n = e.dom,
        { children: r } = e,
        a = 0
      for (let e = 0; a < r.length; a++) {
        let o = r[a],
          i = e + o.length
        if (!(i == e && o.getSide() <= 0)) {
          if (t > e && t < i && o.dom.parentNode == n) return o.domAtPos(t - e)
          if (t <= e) break
          e = i
        }
      }
      for (let e = a; e > 0; e--) {
        let t = r[e - 1]
        if (t.dom.parentNode == n) return t.domAtPos(t.length)
      }
      for (let e = a; e < r.length; e++) {
        let t = r[e]
        if (t.dom.parentNode == n) return t.domAtPos(0)
      }
      return new i9(n, 0)
    }
    function P9(e, t, n) {
      let r,
        { children: a } = e
      n > 0 && t instanceof E9 && a.length && (r = a[a.length - 1]) instanceof E9 && r.mark.eq(t.mark)
        ? P9(r, t.children[0], n - 1)
        : (a.push(t), t.setParent(e)),
        (e.length += t.length)
    }
    function D9(e, t, n) {
      let r = null,
        a = -1,
        o = null,
        i = -1
      !(function e(t, s) {
        for (let l = 0, c = 0; l < t.children.length && c <= s; l++) {
          let d = t.children[l],
            u = c + d.length
          u >= s &&
            (d.children.length
              ? e(d, s - c)
              : (!o || (o.isHidden && n > 0)) && (u > s || (c == u && d.getSide() > 0))
                ? ((o = d), (i = s - c))
                : (c < s || (c == u && d.getSide() < 0 && !d.isHidden)) && ((r = d), (a = s - c))),
            (c = u)
        }
      })(e, t)
      let s = (n < 0 ? r : o) || r || o
      return s
        ? s.coordsAt(Math.max(0, s == r ? a : i), n)
        : (function (e) {
            let t = e.dom.lastChild
            if (!t) return e.dom.getBoundingClientRect()
            let n = U6(t)
            return n[n.length - 1] || null
          })(e)
    }
    function R9(e, t) {
      for (let n in e)
        "class" == n && t.class
          ? (t.class += " " + e.class)
          : "style" == n && t.style
            ? (t.style += ";" + e.style)
            : (t[n] = e[n])
      return t
    }
    S9.prototype.children = T9.prototype.children = A9.prototype.children = s9
    const N9 = Object.create(null)
    function $9(e, t, n) {
      if (e == t) return !0
      e || (e = N9), t || (t = N9)
      let r = Object.keys(e),
        a = Object.keys(t)
      if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != a.length - (n && a.indexOf(n) > -1 ? 1 : 0)) return !1
      for (let o of r) if (o != n && (-1 == a.indexOf(o) || e[o] !== t[o])) return !1
      return !0
    }
    function I9(e, t, n) {
      let r = !1
      if (t) for (let a in t) (n && a in n) || ((r = !0), "style" == a ? (e.style.cssText = "") : e.removeAttribute(a))
      if (n)
        for (let a in n)
          (t && t[a] == n[a]) || ((r = !0), "style" == a ? (e.style.cssText = n[a]) : e.setAttribute(a, n[a]))
      return r
    }
    function M9(e) {
      let t = Object.create(null)
      for (let n = 0; n < e.attributes.length; n++) {
        let r = e.attributes[n]
        t[r.name] = r.value
      }
      return t
    }
    class L9 extends l9 {
      constructor() {
        super(...arguments),
          (this.children = []),
          (this.length = 0),
          (this.prevAttrs = void 0),
          (this.attrs = null),
          (this.breakAfter = 0)
      }
      merge(e, t, n, r, a, o) {
        if (n) {
          if (!(n instanceof L9)) return !1
          this.dom || n.transferDOM(this)
        }
        return r && this.setDeco(n ? n.attrs : null), p9(this, e, t, n ? n.children.slice() : [], a, o), !0
      }
      split(e) {
        let t = new L9()
        if (((t.breakAfter = this.breakAfter), 0 == this.length)) return t
        let { i: n, off: r } = this.childPos(e)
        r &&
          (t.append(this.children[n].split(r), 0),
          this.children[n].merge(r, this.children[n].length, null, !1, 0, 0),
          n++)
        for (let e = n; e < this.children.length; e++) t.append(this.children[e], 0)
        for (; n > 0 && 0 == this.children[n - 1].length; ) this.children[--n].destroy()
        return (this.children.length = n), this.markDirty(), (this.length = e), t
      }
      transferDOM(e) {
        this.dom &&
          (this.markDirty(),
          e.setDOM(this.dom),
          (e.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs),
          (this.prevAttrs = void 0),
          (this.dom = null))
      }
      setDeco(e) {
        $9(this.attrs, e) || (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()), (this.attrs = e))
      }
      append(e, t) {
        P9(this, e, t)
      }
      addLineDeco(e) {
        let t = e.spec.attributes,
          n = e.spec.class
        t && (this.attrs = R9(t, this.attrs || {})), n && (this.attrs = R9({ class: n }, this.attrs || {}))
      }
      domAtPos(e) {
        return C9(this, e)
      }
      reuseDOM(e) {
        "DIV" == e.nodeName && (this.setDOM(e), (this.flags |= 6))
      }
      sync(e, t) {
        var n
        this.dom
          ? 4 & this.flags &&
            (n9(this.dom), (this.dom.className = "cm-line"), (this.prevAttrs = this.attrs ? null : void 0))
          : (this.setDOM(document.createElement("div")),
            (this.dom.className = "cm-line"),
            (this.prevAttrs = this.attrs ? null : void 0)),
          void 0 !== this.prevAttrs &&
            (I9(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), (this.prevAttrs = void 0)),
          super.sync(e, t)
        let r = this.dom.lastChild
        for (; r && l9.get(r) instanceof E9; ) r = r.lastChild
        if (
          !(
            r &&
            this.length &&
            ("BR" == r.nodeName ||
              0 != (null === (n = l9.get(r)) || void 0 === n ? void 0 : n.isEditable) ||
              (_9.ios && this.children.some((e) => e instanceof S9)))
          )
        ) {
          let e = document.createElement("BR")
          ;(e.cmIgnore = !0), this.dom.appendChild(e)
        }
      }
      measureTextSize() {
        if (0 == this.children.length || this.length > 20) return null
        let e,
          t = 0
        for (let n of this.children) {
          if (!(n instanceof S9) || /[^ -~]/.test(n.text)) return null
          let r = U6(n.dom)
          if (1 != r.length) return null
          ;(t += r[0].width), (e = r[0].height)
        }
        return t
          ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t / this.length, textHeight: e }
          : null
      }
      coordsAt(e, t) {
        let n = D9(this, e, t)
        if (!this.children.length && n && this.parent) {
          let { heightOracle: e } = this.parent.view.viewState,
            t = n.bottom - n.top
          if (Math.abs(t - e.lineHeight) < 2 && e.textHeight < t) {
            let r = (t - e.textHeight) / 2
            return { top: n.top + r, bottom: n.bottom - r, left: n.left, right: n.left }
          }
        }
        return n
      }
      become(e) {
        return !1
      }
      covers() {
        return !0
      }
      static find(e, t) {
        for (let n = 0, r = 0; n < e.children.length; n++) {
          let a = e.children[n],
            o = r + a.length
          if (o >= t) {
            if (a instanceof L9) return a
            if (o > t) break
          }
          r = o + a.breakAfter
        }
        return null
      }
    }
    class Q9 extends l9 {
      constructor(e, t, n) {
        super(), (this.widget = e), (this.length = t), (this.deco = n), (this.breakAfter = 0), (this.prevWidget = null)
      }
      merge(e, t, n, r, a, o) {
        return !(
          (n &&
            (!(n instanceof Q9 && this.widget.compare(n.widget)) ||
              (e > 0 && a <= 0) ||
              (t < this.length && o <= 0))) ||
          ((this.length = e + (n ? n.length : 0) + (this.length - t)), 0)
        )
      }
      domAtPos(e) {
        return 0 == e ? i9.before(this.dom) : i9.after(this.dom, e == this.length)
      }
      split(e) {
        let t = this.length - e
        this.length = e
        let n = new Q9(this.widget, t, this.deco)
        return (n.breakAfter = this.breakAfter), n
      }
      get children() {
        return s9
      }
      sync(e) {
        ;(this.dom && this.widget.updateDOM(this.dom, e)) ||
          (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
          (this.prevWidget = null),
          this.setDOM(this.widget.toDOM(e)),
          this.widget.editable || (this.dom.contentEditable = "false"))
      }
      get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : F8.empty
      }
      domBoundsAround() {
        return null
      }
      become(e) {
        return (
          e instanceof Q9 &&
          e.widget.constructor == this.widget.constructor &&
          (e.widget.compare(this.widget) || this.markDirty(!0),
          this.dom && !this.prevWidget && (this.prevWidget = this.widget),
          (this.widget = e.widget),
          (this.length = e.length),
          (this.deco = e.deco),
          (this.breakAfter = e.breakAfter),
          !0)
        )
      }
      ignoreMutation() {
        return !0
      }
      ignoreEvent(e) {
        return this.widget.ignoreEvent(e)
      }
      get isEditable() {
        return !1
      }
      get isWidget() {
        return !0
      }
      coordsAt(e, t) {
        return this.widget.coordsAt(this.dom, e, t)
      }
      destroy() {
        super.destroy(), this.dom && this.widget.destroy(this.dom)
      }
      covers(e) {
        let { startSide: t, endSide: n } = this.deco
        return t != n && (e < 0 ? t < 0 : n > 0)
      }
    }
    class B9 {
      eq(e) {
        return !1
      }
      updateDOM(e, t) {
        return !1
      }
      compare(e) {
        return this == e || (this.constructor == e.constructor && this.eq(e))
      }
      get estimatedHeight() {
        return -1
      }
      get lineBreaks() {
        return 0
      }
      ignoreEvent(e) {
        return !0
      }
      coordsAt(e, t, n) {
        return null
      }
      get isHidden() {
        return !1
      }
      get editable() {
        return !1
      }
      destroy(e) {}
    }
    var j9 = (function (e) {
      return (
        (e[(e.Text = 0)] = "Text"),
        (e[(e.WidgetBefore = 1)] = "WidgetBefore"),
        (e[(e.WidgetAfter = 2)] = "WidgetAfter"),
        (e[(e.WidgetRange = 3)] = "WidgetRange"),
        e
      )
    })(j9 || (j9 = {}))
    class U9 extends c6 {
      constructor(e, t, n, r) {
        super(), (this.startSide = e), (this.endSide = t), (this.widget = n), (this.spec = r)
      }
      get heightRelevant() {
        return !1
      }
      static mark(e) {
        return new F9(e)
      }
      static widget(e) {
        let t = Math.max(-1e4, Math.min(1e4, e.side || 0)),
          n = !!e.block
        return (
          (t += n && !e.inlineOrder ? (t > 0 ? 3e8 : -4e8) : t > 0 ? 1e8 : -1e8),
          new q9(e, t, t, n, e.widget || null, !1)
        )
      }
      static replace(e) {
        let t,
          n,
          r = !!e.block
        if (e.isBlockGap) (t = -5e8), (n = 4e8)
        else {
          let { start: a, end: o } = Z9(e, r)
          ;(t = (a ? (r ? -3e8 : -1) : 5e8) - 1), (n = 1 + (o ? (r ? 2e8 : 1) : -6e8))
        }
        return new q9(e, t, n, r, e.widget || null, !0)
      }
      static line(e) {
        return new z9(e)
      }
      static set(e, t = !1) {
        return h6.of(e, t)
      }
      hasHeight() {
        return !!this.widget && this.widget.estimatedHeight > -1
      }
    }
    U9.none = h6.empty
    class F9 extends U9 {
      constructor(e) {
        let { start: t, end: n } = Z9(e)
        super(t ? -1 : 5e8, n ? 1 : -6e8, null, e),
          (this.tagName = e.tagName || "span"),
          (this.class = e.class || ""),
          (this.attrs = e.attributes || null)
      }
      eq(e) {
        var t, n
        return (
          this == e ||
          (e instanceof F9 &&
            this.tagName == e.tagName &&
            (this.class || (null === (t = this.attrs) || void 0 === t ? void 0 : t.class)) ==
              (e.class || (null === (n = e.attrs) || void 0 === n ? void 0 : n.class)) &&
            $9(this.attrs, e.attrs, "class"))
        )
      }
      range(e, t = e) {
        if (e >= t) throw new RangeError("Mark decorations may not be empty")
        return super.range(e, t)
      }
    }
    F9.prototype.point = !1
    class z9 extends U9 {
      constructor(e) {
        super(-2e8, -2e8, null, e)
      }
      eq(e) {
        return e instanceof z9 && this.spec.class == e.spec.class && $9(this.spec.attributes, e.spec.attributes)
      }
      range(e, t = e) {
        if (t != e) throw new RangeError("Line decoration ranges must be zero-length")
        return super.range(e, t)
      }
    }
    ;(z9.prototype.mapMode = u7.TrackBefore), (z9.prototype.point = !0)
    class q9 extends U9 {
      constructor(e, t, n, r, a, o) {
        super(t, n, a, e),
          (this.block = r),
          (this.isReplace = o),
          (this.mapMode = r ? (t <= 0 ? u7.TrackBefore : u7.TrackAfter) : u7.TrackDel)
      }
      get type() {
        return this.startSide != this.endSide ? j9.WidgetRange : this.startSide <= 0 ? j9.WidgetBefore : j9.WidgetAfter
      }
      get heightRelevant() {
        return this.block || (!!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0))
      }
      eq(e) {
        return (
          e instanceof q9 &&
          ((t = this.widget) == (n = e.widget) || !!(t && n && t.compare(n))) &&
          this.block == e.block &&
          this.startSide == e.startSide &&
          this.endSide == e.endSide
        )
        var t, n
      }
      range(e, t = e) {
        if (this.isReplace && (e > t || (e == t && this.startSide > 0 && this.endSide <= 0)))
          throw new RangeError("Invalid range for replacement decoration")
        if (!this.isReplace && t != e) throw new RangeError("Widget decorations can only have zero-length ranges")
        return super.range(e, t)
      }
    }
    function Z9(e, t = !1) {
      let { inclusiveStart: n, inclusiveEnd: r } = e
      return (
        null == n && (n = e.inclusive),
        null == r && (r = e.inclusive),
        { start: null != n ? n : t, end: null != r ? r : t }
      )
    }
    function H9(e, t, n, r = 0) {
      let a = n.length - 1
      a >= 0 && n[a] + r >= e ? (n[a] = Math.max(n[a], t)) : n.push(e, t)
    }
    q9.prototype.point = !0
    class V9 {
      constructor(e, t, n, r) {
        ;(this.doc = e),
          (this.pos = t),
          (this.end = n),
          (this.disallowBlockEffectsFor = r),
          (this.content = []),
          (this.curLine = null),
          (this.breakAtStart = 0),
          (this.pendingBuffer = 0),
          (this.bufferMarks = []),
          (this.atCursorPos = !0),
          (this.openStart = -1),
          (this.openEnd = -1),
          (this.text = ""),
          (this.textOff = 0),
          (this.cursor = e.iter()),
          (this.skip = t)
      }
      posCovered() {
        if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos
        let e = this.content[this.content.length - 1]
        return !(e.breakAfter || (e instanceof Q9 && e.deco.endSide < 0))
      }
      getLine() {
        return this.curLine || (this.content.push((this.curLine = new L9())), (this.atCursorPos = !0)), this.curLine
      }
      flushBuffer(e = this.bufferMarks) {
        this.pendingBuffer && (this.curLine.append(W9(new A9(-1), e), e.length), (this.pendingBuffer = 0))
      }
      addBlockWidget(e) {
        this.flushBuffer(), (this.curLine = null), this.content.push(e)
      }
      finish(e) {
        this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : (this.pendingBuffer = 0),
          this.posCovered() ||
            (e && this.content.length && this.content[this.content.length - 1] instanceof Q9) ||
            this.getLine()
      }
      buildText(e, t, n) {
        for (; e > 0; ) {
          if (this.textOff == this.text.length) {
            let { value: t, lineBreak: n, done: r } = this.cursor.next(this.skip)
            if (((this.skip = 0), r)) throw new Error("Ran out of text content when drawing inline views")
            if (n) {
              this.posCovered() || this.getLine(),
                this.content.length ? (this.content[this.content.length - 1].breakAfter = 1) : (this.breakAtStart = 1),
                this.flushBuffer(),
                (this.curLine = null),
                (this.atCursorPos = !0),
                e--
              continue
            }
            ;(this.text = t), (this.textOff = 0)
          }
          let r = Math.min(this.text.length - this.textOff, e, 512)
          this.flushBuffer(t.slice(t.length - n)),
            this.getLine().append(W9(new S9(this.text.slice(this.textOff, this.textOff + r)), t), n),
            (this.atCursorPos = !0),
            (this.textOff += r),
            (e -= r),
            (n = 0)
        }
      }
      span(e, t, n, r) {
        this.buildText(t - e, n, r), (this.pos = t), this.openStart < 0 && (this.openStart = r)
      }
      point(e, t, n, r, a, o) {
        if (this.disallowBlockEffectsFor[o] && n instanceof q9) {
          if (n.block) throw new RangeError("Block decorations may not be specified via plugins")
          if (t > this.doc.lineAt(this.pos).to)
            throw new RangeError("Decorations that replace line breaks may not be specified via plugins")
        }
        let i = t - e
        if (n instanceof q9)
          if (n.block)
            n.startSide > 0 && !this.posCovered() && this.getLine(),
              this.addBlockWidget(new Q9(n.widget || X9.block, i, n))
          else {
            let o = T9.create(n.widget || X9.inline, i, i ? 0 : n.startSide),
              s = this.atCursorPos && !o.isEditable && a <= r.length && (e < t || n.startSide > 0),
              l = !o.isEditable && (e < t || a > r.length || n.startSide <= 0),
              c = this.getLine()
            2 != this.pendingBuffer || s || o.isEditable || (this.pendingBuffer = 0),
              this.flushBuffer(r),
              s && (c.append(W9(new A9(1), r), a), (a = r.length + Math.max(0, a - r.length))),
              c.append(W9(o, r), a),
              (this.atCursorPos = l),
              (this.pendingBuffer = l ? (e < t || a > r.length ? 1 : 2) : 0),
              this.pendingBuffer && (this.bufferMarks = r.slice())
          }
        else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n)
        i &&
          (this.textOff + i <= this.text.length
            ? (this.textOff += i)
            : ((this.skip += i - (this.text.length - this.textOff)), (this.text = ""), (this.textOff = 0)),
          (this.pos = t)),
          this.openStart < 0 && (this.openStart = a)
      }
      static build(e, t, n, r, a) {
        let o = new V9(e, t, n, a)
        return (o.openEnd = h6.spans(r, t, n, o)), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o
      }
    }
    function W9(e, t) {
      for (let n of t) e = new E9(n, [e], e.length)
      return e
    }
    class X9 extends B9 {
      constructor(e) {
        super(), (this.tag = e)
      }
      eq(e) {
        return e.tag == this.tag
      }
      toDOM() {
        return document.createElement(this.tag)
      }
      updateDOM(e) {
        return e.nodeName.toLowerCase() == this.tag
      }
      get isHidden() {
        return !0
      }
    }
    ;(X9.inline = new X9("span")), (X9.block = new X9("div"))
    var Y9 = (function (e) {
      return (e[(e.LTR = 0)] = "LTR"), (e[(e.RTL = 1)] = "RTL"), e
    })(Y9 || (Y9 = {}))
    const G9 = Y9.LTR,
      K9 = Y9.RTL
    function J9(e) {
      let t = []
      for (let n = 0; n < e.length; n++) t.push(1 << +e[n])
      return t
    }
    const eee = J9(
        "88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008",
      ),
      tee = J9(
        "4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333",
      ),
      nee = Object.create(null),
      ree = []
    for (let e of ["()", "[]", "{}"]) {
      let t = e.charCodeAt(0),
        n = e.charCodeAt(1)
      ;(nee[t] = n), (nee[n] = -t)
    }
    function aee(e) {
      return e <= 247
        ? eee[e]
        : 1424 <= e && e <= 1524
          ? 2
          : 1536 <= e && e <= 1785
            ? tee[e - 1536]
            : 1774 <= e && e <= 2220
              ? 4
              : 8192 <= e && e <= 8204
                ? 256
                : 64336 <= e && e <= 65023
                  ? 4
                  : 1
    }
    const oee = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/
    class iee {
      get dir() {
        return this.level % 2 ? K9 : G9
      }
      constructor(e, t, n) {
        ;(this.from = e), (this.to = t), (this.level = n)
      }
      side(e, t) {
        return (this.dir == t) == e ? this.to : this.from
      }
      forward(e, t) {
        return e == (this.dir == t)
      }
      static find(e, t, n, r) {
        let a = -1
        for (let o = 0; o < e.length; o++) {
          let i = e[o]
          if (i.from <= t && i.to >= t) {
            if (i.level == n) return o
            ;(a < 0 || (0 != r ? (r < 0 ? i.from < t : i.to > t) : e[a].level > i.level)) && (a = o)
          }
        }
        if (a < 0) throw new RangeError("Index out of range")
        return a
      }
    }
    function see(e, t) {
      if (e.length != t.length) return !1
      for (let n = 0; n < e.length; n++) {
        let r = e[n],
          a = t[n]
        if (r.from != a.from || r.to != a.to || r.direction != a.direction || !see(r.inner, a.inner)) return !1
      }
      return !0
    }
    const lee = []
    function cee(e, t, n, r, a, o, i) {
      let s = r % 2 ? 2 : 1
      if (r % 2 == a % 2)
        for (let l = t, c = 0; l < n; ) {
          let t = !0,
            d = !1
          if (c == o.length || l < o[c].from) {
            let e = lee[l]
            e != s && ((t = !1), (d = 16 == e))
          }
          let u = t || 1 != s ? null : [],
            p = t ? r : r + 1,
            h = l
          e: for (;;)
            if (c < o.length && h == o[c].from) {
              if (d) break e
              let f = o[c]
              if (!t)
                for (let e = f.to, t = c + 1; ; ) {
                  if (e == n) break e
                  if (!(t < o.length && o[t].from == e)) {
                    if (lee[e] == s) break e
                    break
                  }
                  e = o[t++].to
                }
              c++,
                u
                  ? u.push(f)
                  : (f.from > l && i.push(new iee(l, f.from, p)),
                    dee(e, (f.direction == G9) != !(p % 2) ? r + 1 : r, a, f.inner, f.from, f.to, i),
                    (l = f.to)),
                (h = f.to)
            } else {
              if (h == n || (t ? lee[h] != s : lee[h] == s)) break
              h++
            }
          u ? cee(e, l, h, r + 1, a, u, i) : l < h && i.push(new iee(l, h, p)), (l = h)
        }
      else
        for (let l = n, c = o.length; l > t; ) {
          let n = !0,
            d = !1
          if (!c || l > o[c - 1].to) {
            let e = lee[l - 1]
            e != s && ((n = !1), (d = 16 == e))
          }
          let u = n || 1 != s ? null : [],
            p = n ? r : r + 1,
            h = l
          e: for (;;)
            if (c && h == o[c - 1].to) {
              if (d) break e
              let f = o[--c]
              if (!n)
                for (let e = f.from, n = c; ; ) {
                  if (e == t) break e
                  if (!n || o[n - 1].to != e) {
                    if (lee[e - 1] == s) break e
                    break
                  }
                  e = o[--n].from
                }
              u
                ? u.push(f)
                : (f.to < l && i.push(new iee(f.to, l, p)),
                  dee(e, (f.direction == G9) != !(p % 2) ? r + 1 : r, a, f.inner, f.from, f.to, i),
                  (l = f.from)),
                (h = f.from)
            } else {
              if (h == t || (n ? lee[h - 1] != s : lee[h - 1] == s)) break
              h--
            }
          u ? cee(e, h, l, r + 1, a, u, i) : h < l && i.push(new iee(h, l, p)), (l = h)
        }
    }
    function dee(e, t, n, r, a, o, i) {
      let s = t % 2 ? 2 : 1
      !(function (e, t, n, r, a) {
        for (let o = 0; o <= r.length; o++) {
          let i = o ? r[o - 1].to : t,
            s = o < r.length ? r[o].from : n,
            l = o ? 256 : a
          for (let t = i, n = l, r = l; t < s; t++) {
            let a = aee(e.charCodeAt(t))
            512 == a ? (a = n) : 8 == a && 4 == r && (a = 16), (lee[t] = 4 == a ? 2 : a), 7 & a && (r = a), (n = a)
          }
          for (let e = i, t = l, r = l; e < s; e++) {
            let a = lee[e]
            if (128 == a) e < s - 1 && t == lee[e + 1] && 24 & t ? (a = lee[e] = t) : (lee[e] = 256)
            else if (64 == a) {
              let a = e + 1
              for (; a < s && 64 == lee[a]; ) a++
              let o = (e && 8 == t) || (a < n && 8 == lee[a]) ? (1 == r ? 1 : 8) : 256
              for (let t = e; t < a; t++) lee[t] = o
              e = a - 1
            } else 8 == a && 1 == r && (lee[e] = 1)
            ;(t = a), 7 & a && (r = a)
          }
        }
      })(e, a, o, r, s),
        (function (e, t, n, r, a) {
          let o = 1 == a ? 2 : 1
          for (let i = 0, s = 0, l = 0; i <= r.length; i++) {
            let c = i ? r[i - 1].to : t,
              d = i < r.length ? r[i].from : n
            for (let t, n, r, i = c; i < d; i++)
              if ((n = nee[(t = e.charCodeAt(i))]))
                if (n < 0) {
                  for (let e = s - 3; e >= 0; e -= 3)
                    if (ree[e + 1] == -n) {
                      let t = ree[e + 2],
                        n = 2 & t ? a : 4 & t ? (1 & t ? o : a) : 0
                      n && (lee[i] = lee[ree[e]] = n), (s = e)
                      break
                    }
                } else {
                  if (189 == ree.length) break
                  ;(ree[s++] = i), (ree[s++] = t), (ree[s++] = l)
                }
              else if (2 == (r = lee[i]) || 1 == r) {
                let e = r == a
                l = e ? 0 : 1
                for (let t = s - 3; t >= 0; t -= 3) {
                  let n = ree[t + 2]
                  if (2 & n) break
                  if (e) ree[t + 2] |= 2
                  else {
                    if (4 & n) break
                    ree[t + 2] |= 4
                  }
                }
              }
          }
        })(e, a, o, r, s),
        (function (e, t, n, r) {
          for (let a = 0, o = r; a <= n.length; a++) {
            let i = a ? n[a - 1].to : e,
              s = a < n.length ? n[a].from : t
            for (let l = i; l < s; ) {
              let i = lee[l]
              if (256 == i) {
                let i = l + 1
                for (;;)
                  if (i == s) {
                    if (a == n.length) break
                    ;(i = n[a++].to), (s = a < n.length ? n[a].from : t)
                  } else {
                    if (256 != lee[i]) break
                    i++
                  }
                let c = 1 == o,
                  d = c == (1 == (i < t ? lee[i] : r)) ? (c ? 1 : 2) : r
                for (let t = i, r = a, o = r ? n[r - 1].to : e; t > l; )
                  t == o && ((t = n[--r].from), (o = r ? n[r - 1].to : e)), (lee[--t] = d)
                l = i
              } else (o = i), l++
            }
          }
        })(a, o, r, s),
        cee(e, a, o, t, n, r, i)
    }
    function uee(e) {
      return [new iee(0, e, 0)]
    }
    let pee = ""
    function hee(e, t, n, r, a) {
      var o
      let i = r.head - e.from,
        s = iee.find(t, i, null !== (o = r.bidiLevel) && void 0 !== o ? o : -1, r.assoc),
        l = t[s],
        c = l.side(a, n)
      if (i == c) {
        let e = (s += a ? 1 : -1)
        if (e < 0 || e >= t.length) return null
        ;(l = t[(s = e)]), (i = l.side(!a, n)), (c = l.side(a, n))
      }
      let d = n7(e.text, i, l.forward(a, n))
      ;(d < l.from || d > l.to) && (d = c), (pee = e.text.slice(Math.min(i, d), Math.max(i, d)))
      let u = s == (a ? t.length - 1 : 0) ? null : t[s + (a ? 1 : -1)]
      return u && d == c && u.level + (a ? 0 : 1) < l.level
        ? w7.cursor(u.side(!a, n) + e.from, u.forward(a, n) ? 1 : -1, u.level)
        : w7.cursor(d + e.from, l.forward(a, n) ? -1 : 1, l.level)
    }
    function fee(e, t, n) {
      for (let r = t; r < n; r++) {
        let t = aee(e.charCodeAt(r))
        if (1 == t) return G9
        if (2 == t || 4 == t) return K9
      }
      return G9
    }
    const mee = _7.define(),
      gee = _7.define(),
      bee = _7.define(),
      vee = _7.define(),
      yee = _7.define(),
      Oee = _7.define(),
      wee = _7.define(),
      xee = _7.define({ combine: (e) => e.some((e) => e) }),
      kee = _7.define({ combine: (e) => e.some((e) => e) }),
      _ee = _7.define()
    class See {
      constructor(e, t = "nearest", n = "nearest", r = 5, a = 5, o = !1) {
        ;(this.range = e), (this.y = t), (this.x = n), (this.yMargin = r), (this.xMargin = a), (this.isSnapshot = o)
      }
      map(e) {
        return e.empty ? this : new See(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot)
      }
      clip(e) {
        return this.range.to <= e.doc.length
          ? this
          : new See(w7.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot)
      }
    }
    const Eee = Y7.define({ map: (e, t) => e.map(t) }),
      Tee = Y7.define()
    function Aee(e, t, n) {
      let r = e.facet(vee)
      r.length
        ? r[0](t)
        : window.onerror
          ? window.onerror(String(t), n, void 0, void 0, t)
          : n
            ? console.error(n + ":", t)
            : console.error(t)
    }
    const Cee = _7.define({ combine: (e) => !e.length || e[0] })
    let Pee = 0
    const Dee = _7.define()
    class Ree {
      constructor(e, t, n, r, a) {
        ;(this.id = e),
          (this.create = t),
          (this.domEventHandlers = n),
          (this.domEventObservers = r),
          (this.extension = a(this))
      }
      static define(e, t) {
        const { eventHandlers: n, eventObservers: r, provide: a, decorations: o } = t || {}
        return new Ree(Pee++, e, n, r, (e) => {
          let t = [Dee.of(e)]
          return (
            o &&
              t.push(
                Mee.of((t) => {
                  let n = t.plugin(e)
                  return n ? o(n) : U9.none
                }),
              ),
            a && t.push(a(e)),
            t
          )
        })
      }
      static fromClass(e, t) {
        return Ree.define((t) => new e(t), t)
      }
    }
    class Nee {
      constructor(e) {
        ;(this.spec = e), (this.mustUpdate = null), (this.value = null)
      }
      update(e) {
        if (this.value) {
          if (this.mustUpdate) {
            let e = this.mustUpdate
            if (((this.mustUpdate = null), this.value.update))
              try {
                this.value.update(e)
              } catch (t) {
                if ((Aee(e.state, t, "CodeMirror plugin crashed"), this.value.destroy))
                  try {
                    this.value.destroy()
                  } catch (e) {}
                this.deactivate()
              }
          }
        } else if (this.spec)
          try {
            this.value = this.spec.create(e)
          } catch (t) {
            Aee(e.state, t, "CodeMirror plugin crashed"), this.deactivate()
          }
        return this
      }
      destroy(e) {
        var t
        if (null === (t = this.value) || void 0 === t ? void 0 : t.destroy)
          try {
            this.value.destroy()
          } catch (t) {
            Aee(e.state, t, "CodeMirror plugin crashed")
          }
      }
      deactivate() {
        this.spec = this.value = null
      }
    }
    const $ee = _7.define(),
      Iee = _7.define(),
      Mee = _7.define(),
      Lee = _7.define(),
      Qee = _7.define(),
      Bee = _7.define()
    function jee(e, t) {
      let n = e.state.facet(Bee)
      if (!n.length) return n
      let r = n.map((t) => (t instanceof Function ? t(e) : t)),
        a = []
      return (
        h6.spans(r, t.from, t.to, {
          point() {},
          span(e, n, r, o) {
            let i = e - t.from,
              s = n - t.from,
              l = a
            for (let e = r.length - 1; e >= 0; e--, o--) {
              let n,
                a = r[e].spec.bidiIsolate
              if (
                (null == a && (a = fee(t.text, i, s)),
                o > 0 && l.length && (n = l[l.length - 1]).to == i && n.direction == a)
              )
                (n.to = s), (l = n.inner)
              else {
                let e = { from: i, to: s, direction: a, inner: [] }
                l.push(e), (l = e.inner)
              }
            }
          },
        }),
        a
      )
    }
    const Uee = _7.define()
    function Fee(e) {
      let t = 0,
        n = 0,
        r = 0,
        a = 0
      for (let o of e.state.facet(Uee)) {
        let i = o(e)
        i &&
          (null != i.left && (t = Math.max(t, i.left)),
          null != i.right && (n = Math.max(n, i.right)),
          null != i.top && (r = Math.max(r, i.top)),
          null != i.bottom && (a = Math.max(a, i.bottom)))
      }
      return { left: t, right: n, top: r, bottom: a }
    }
    const zee = _7.define()
    class qee {
      constructor(e, t, n, r) {
        ;(this.fromA = e), (this.toA = t), (this.fromB = n), (this.toB = r)
      }
      join(e) {
        return new qee(
          Math.min(this.fromA, e.fromA),
          Math.max(this.toA, e.toA),
          Math.min(this.fromB, e.fromB),
          Math.max(this.toB, e.toB),
        )
      }
      addToSet(e) {
        let t = e.length,
          n = this
        for (; t > 0; t--) {
          let r = e[t - 1]
          if (!(r.fromA > n.toA)) {
            if (r.toA < n.fromA) break
            ;(n = n.join(r)), e.splice(t - 1, 1)
          }
        }
        return e.splice(t, 0, n), e
      }
      static extendWithRanges(e, t) {
        if (0 == t.length) return e
        let n = []
        for (let r = 0, a = 0, o = 0, i = 0; ; r++) {
          let s = r == e.length ? null : e[r],
            l = o - i,
            c = s ? s.fromB : 1e9
          for (; a < t.length && t[a] < c; ) {
            let e = t[a],
              r = t[a + 1],
              o = Math.max(i, e),
              s = Math.min(c, r)
            if ((o <= s && new qee(o + l, s + l, o, s).addToSet(n), r > c)) break
            a += 2
          }
          if (!s) return n
          new qee(s.fromA, s.toA, s.fromB, s.toB).addToSet(n), (o = s.toA), (i = s.toB)
        }
      }
    }
    class Zee {
      constructor(e, t, n) {
        ;(this.view = e),
          (this.state = t),
          (this.transactions = n),
          (this.flags = 0),
          (this.startState = e.state),
          (this.changes = h7.empty(this.startState.doc.length))
        for (let e of n) this.changes = this.changes.compose(e.changes)
        let r = []
        this.changes.iterChangedRanges((e, t, n, a) => r.push(new qee(e, t, n, a))), (this.changedRanges = r)
      }
      static create(e, t, n) {
        return new Zee(e, t, n)
      }
      get viewportChanged() {
        return (4 & this.flags) > 0
      }
      get heightChanged() {
        return (2 & this.flags) > 0
      }
      get geometryChanged() {
        return this.docChanged || (10 & this.flags) > 0
      }
      get focusChanged() {
        return (1 & this.flags) > 0
      }
      get docChanged() {
        return !this.changes.empty
      }
      get selectionSet() {
        return this.transactions.some((e) => e.selection)
      }
      get empty() {
        return 0 == this.flags && 0 == this.transactions.length
      }
    }
    class Hee extends l9 {
      get length() {
        return this.view.state.doc.length
      }
      constructor(e) {
        super(),
          (this.view = e),
          (this.decorations = []),
          (this.dynamicDecorationMap = [!1]),
          (this.domChanged = null),
          (this.hasComposition = null),
          (this.markedForComposition = new Set()),
          (this.editContextFormatting = U9.none),
          (this.lastCompositionAfterCursor = !1),
          (this.minWidth = 0),
          (this.minWidthFrom = 0),
          (this.minWidthTo = 0),
          (this.impreciseAnchor = null),
          (this.impreciseHead = null),
          (this.forceSelection = !1),
          (this.lastUpdate = Date.now()),
          this.setDOM(e.contentDOM),
          (this.children = [new L9()]),
          this.children[0].setParent(this),
          this.updateDeco(),
          this.updateInner([new qee(0, 0, 0, e.state.doc.length)], 0, null)
      }
      update(e) {
        var t
        let n = e.changedRanges
        this.minWidth > 0 &&
          n.length &&
          (n.every(({ fromA: e, toA: t }) => t < this.minWidthFrom || e > this.minWidthTo)
            ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)),
              (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
            : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0)),
          this.updateEditContextFormatting(e)
        let r = -1
        this.view.inputState.composing >= 0 &&
          !this.view.observer.editContext &&
          ((null === (t = this.domChanged) || void 0 === t ? void 0 : t.newSel)
            ? (r = this.domChanged.newSel.head)
            : (function (e, t) {
                let n = !1
                return (
                  t &&
                    e.iterChangedRanges((e, r) => {
                      e < t.to && r > t.from && (n = !0)
                    }),
                  n
                )
              })(e.changes, this.hasComposition) ||
              e.selectionSet ||
              (r = e.state.selection.main.head))
        let a =
          r > -1
            ? (function (e, t, n) {
                let r = Wee(e, n)
                if (!r) return null
                let { node: a, from: o, to: i } = r,
                  s = a.nodeValue
                if (/[\n\r]/.test(s)) return null
                if (e.state.doc.sliceString(r.from, r.to) != s) return null
                let l = t.invertedDesc,
                  c = new qee(l.mapPos(o), l.mapPos(i), o, i),
                  d = []
                for (let t = a.parentNode; ; t = t.parentNode) {
                  let n = l9.get(t)
                  if (n instanceof E9) d.push({ node: t, deco: n.mark })
                  else {
                    if (n instanceof L9 || ("DIV" == t.nodeName && t.parentNode == e.contentDOM))
                      return { range: c, text: a, marks: d, line: t }
                    if (t == e.contentDOM) return null
                    d.push({
                      node: t,
                      deco: new F9({ inclusive: !0, attributes: M9(t), tagName: t.tagName.toLowerCase() }),
                    })
                  }
                }
              })(this.view, e.changes, r)
            : null
        if (((this.domChanged = null), this.hasComposition)) {
          this.markedForComposition.clear()
          let { from: t, to: r } = this.hasComposition
          n = new qee(t, r, e.changes.mapPos(t, -1), e.changes.mapPos(r, 1)).addToSet(n.slice())
        }
        ;(this.hasComposition = a ? { from: a.range.fromB, to: a.range.toB } : null),
          (_9.ie || _9.chrome) && !a && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0)
        let o = (function (e, t, n) {
          let r = new Xee()
          return h6.compare(e, t, n, r), r.changes
        })(this.decorations, this.updateDeco(), e.changes)
        return (
          (n = qee.extendWithRanges(n, o)),
          !!(7 & this.flags || 0 != n.length) &&
            (this.updateInner(n, e.startState.doc.length, a),
            e.transactions.length && (this.lastUpdate = Date.now()),
            !0)
        )
      }
      updateInner(e, t, n) {
        ;(this.view.viewState.mustMeasureContent = !0), this.updateChildren(e, t, n)
        let { observer: r } = this.view
        r.ignore(() => {
          ;(this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px"),
            (this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "")
          let e = _9.chrome || _9.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0
          this.sync(this.view, e),
            (this.flags &= -8),
            e && (e.written || r.selectionRange.focusNode != e.node) && (this.forceSelection = !0),
            (this.dom.style.height = "")
        }),
          this.markedForComposition.forEach((e) => (e.flags &= -9))
        let a = []
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
          for (let e of this.children) e instanceof Q9 && e.widget instanceof Vee && a.push(e.dom)
        r.updateGaps(a)
      }
      updateChildren(e, t, n) {
        let r = n ? n.range.addToSet(e.slice()) : e,
          a = this.childCursor(t)
        for (let e = r.length - 1; ; e--) {
          let t = e >= 0 ? r[e] : null
          if (!t) break
          let o,
            i,
            s,
            l,
            { fromA: c, toA: d, fromB: u, toB: p } = t
          if (n && n.range.fromB < p && n.range.toB > u) {
            let e = V9.build(this.view.state.doc, u, n.range.fromB, this.decorations, this.dynamicDecorationMap),
              t = V9.build(this.view.state.doc, n.range.toB, p, this.decorations, this.dynamicDecorationMap)
            ;(i = e.breakAtStart), (s = e.openStart), (l = t.openEnd)
            let r = this.compositionView(n)
            t.breakAtStart
              ? (r.breakAfter = 1)
              : t.content.length &&
                r.merge(r.length, r.length, t.content[0], !1, t.openStart, 0) &&
                ((r.breakAfter = t.content[0].breakAfter), t.content.shift()),
              e.content.length && r.merge(0, 0, e.content[e.content.length - 1], !0, 0, e.openEnd) && e.content.pop(),
              (o = e.content.concat(r).concat(t.content))
          } else
            ({
              content: o,
              breakAtStart: i,
              openStart: s,
              openEnd: l,
            } = V9.build(this.view.state.doc, u, p, this.decorations, this.dynamicDecorationMap))
          let { i: h, off: f } = a.findPos(d, 1),
            { i: m, off: g } = a.findPos(c, -1)
          u9(this, m, g, h, f, o, i, s, l)
        }
        n && this.fixCompositionDOM(n)
      }
      updateEditContextFormatting(e) {
        this.editContextFormatting = this.editContextFormatting.map(e.changes)
        for (let t of e.transactions) for (let e of t.effects) e.is(Tee) && (this.editContextFormatting = e.value)
      }
      compositionView(e) {
        let t = new S9(e.text.nodeValue)
        t.flags |= 8
        for (let { deco: n } of e.marks) t = new E9(n, [t], t.length)
        let n = new L9()
        return n.append(t, 0), n
      }
      fixCompositionDOM(e) {
        let t = (e, t) => {
            ;(t.flags |= 8 | (t.children.some((e) => 7 & e.flags) ? 1 : 0)), this.markedForComposition.add(t)
            let n = l9.get(e)
            n && n != t && (n.dom = null), t.setDOM(e)
          },
          n = this.childPos(e.range.fromB, 1),
          r = this.children[n.i]
        t(e.line, r)
        for (let a = e.marks.length - 1; a >= -1; a--)
          (n = r.childPos(n.off, 1)), (r = r.children[n.i]), t(a >= 0 ? e.marks[a].node : e.text, r)
      }
      updateSelection(e = !1, t = !1) {
        ;(!e && this.view.observer.selectionRange.focusNode) || this.view.observer.readSelectionRange()
        let n = this.view.root.activeElement,
          r = n == this.dom,
          a = !r && j6(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n))
        if (!(r || t || a)) return
        let o = this.forceSelection
        this.forceSelection = !1
        let i = this.view.state.selection.main,
          s = this.moveToLine(this.domAtPos(i.anchor)),
          l = i.empty ? s : this.moveToLine(this.domAtPos(i.head))
        if (
          _9.gecko &&
          i.empty &&
          !this.hasComposition &&
          1 == (c = s).node.nodeType &&
          c.node.firstChild &&
          (0 == c.offset || "false" == c.node.childNodes[c.offset - 1].contentEditable) &&
          (c.offset == c.node.childNodes.length || "false" == c.node.childNodes[c.offset].contentEditable)
        ) {
          let e = document.createTextNode("")
          this.view.observer.ignore(() => s.node.insertBefore(e, s.node.childNodes[s.offset] || null)),
            (s = l = new i9(e, 0)),
            (o = !0)
        }
        var c
        let d = this.view.observer.selectionRange
        ;(!o &&
          d.focusNode &&
          ((F6(s.node, s.offset, d.anchorNode, d.anchorOffset) && F6(l.node, l.offset, d.focusNode, d.focusOffset)) ||
            this.suppressWidgetCursorChange(d, i))) ||
          (this.view.observer.ignore(() => {
            _9.android &&
              _9.chrome &&
              this.dom.contains(d.focusNode) &&
              (function (e, t) {
                for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
                  if (1 == n.nodeType && "false" == n.contentEditable) return !0
                return !1
              })(d.focusNode, this.dom) &&
              (this.dom.blur(), this.dom.focus({ preventScroll: !0 }))
            let e = Q6(this.view.root)
            if (e)
              if (i.empty) {
                if (_9.gecko) {
                  let e =
                    ((t = s.node),
                    (r = s.offset),
                    1 != t.nodeType
                      ? 0
                      : (r && "false" == t.childNodes[r - 1].contentEditable ? 1 : 0) |
                        (r < t.childNodes.length && "false" == t.childNodes[r].contentEditable ? 2 : 0))
                  if (e && 3 != e) {
                    let t = (1 == e ? a9 : o9)(s.node, s.offset)
                    t && (s = new i9(t.node, t.offset))
                  }
                }
                e.collapse(s.node, s.offset),
                  null != i.bidiLevel && void 0 !== e.caretBidiLevel && (e.caretBidiLevel = i.bidiLevel)
              } else if (e.extend) {
                e.collapse(s.node, s.offset)
                try {
                  e.extend(l.node, l.offset)
                } catch (e) {}
              } else {
                let t = document.createRange()
                i.anchor > i.head && ([s, l] = [l, s]),
                  t.setEnd(l.node, l.offset),
                  t.setStart(s.node, s.offset),
                  e.removeAllRanges(),
                  e.addRange(t)
              }
            var t, r
            a && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus())
          }),
          this.view.observer.setSelectionRange(s, l)),
          (this.impreciseAnchor = s.precise ? null : new i9(d.anchorNode, d.anchorOffset)),
          (this.impreciseHead = l.precise ? null : new i9(d.focusNode, d.focusOffset))
      }
      suppressWidgetCursorChange(e, t) {
        return (
          this.hasComposition &&
          t.empty &&
          F6(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) &&
          this.posFromDOM(e.focusNode, e.focusOffset) == t.head
        )
      }
      enforceCursorAssoc() {
        if (this.hasComposition) return
        let { view: e } = this,
          t = e.state.selection.main,
          n = Q6(e.root),
          { anchorNode: r, anchorOffset: a } = e.observer.selectionRange
        if (!(n && t.empty && t.assoc && n.modify)) return
        let o = L9.find(this, t.head)
        if (!o) return
        let i = o.posAtStart
        if (t.head == i || t.head == i + o.length) return
        let s = this.coordsAt(t.head, -1),
          l = this.coordsAt(t.head, 1)
        if (!s || !l || s.bottom > l.top) return
        let c = this.domAtPos(t.head + t.assoc)
        n.collapse(c.node, c.offset),
          n.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"),
          e.observer.readSelectionRange()
        let d = e.observer.selectionRange
        e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != t.from && n.collapse(r, a)
      }
      moveToLine(e) {
        let t,
          n = this.dom
        if (e.node != n) return e
        for (let r = e.offset; !t && r < n.childNodes.length; r++) {
          let e = l9.get(n.childNodes[r])
          e instanceof L9 && (t = e.domAtPos(0))
        }
        for (let r = e.offset - 1; !t && r >= 0; r--) {
          let e = l9.get(n.childNodes[r])
          e instanceof L9 && (t = e.domAtPos(e.length))
        }
        return t ? new i9(t.node, t.offset, !0) : e
      }
      nearest(e) {
        for (let t = e; t; ) {
          let e = l9.get(t)
          if (e && e.rootView == this) return e
          t = t.parentNode
        }
        return null
      }
      posFromDOM(e, t) {
        let n = this.nearest(e)
        if (!n) throw new RangeError("Trying to find position for a DOM position outside of the document")
        return n.localPosFromDOM(e, t) + n.posAtStart
      }
      domAtPos(e) {
        let { i: t, off: n } = this.childCursor().findPos(e, -1)
        for (; t < this.children.length - 1; ) {
          let e = this.children[t]
          if (n < e.length || e instanceof L9) break
          t++, (n = 0)
        }
        return this.children[t].domAtPos(n)
      }
      coordsAt(e, t) {
        let n = null,
          r = 0
        for (let a = this.length, o = this.children.length - 1; o >= 0; o--) {
          let i = this.children[o],
            s = a - i.breakAfter,
            l = s - i.length
          if (s < e) break
          if (
            l <= e &&
            (l < e || i.covers(-1)) &&
            (s > e || i.covers(1)) &&
            (!n || (i instanceof L9 && !(n instanceof L9 && t >= 0)))
          )
            (n = i), (r = l)
          else if (n && l == e && s == e && i instanceof Q9 && Math.abs(t) < 2) {
            if (i.deco.startSide < 0) break
            o && (n = null)
          }
          a = l
        }
        return n ? n.coordsAt(e - r, t) : null
      }
      coordsForChar(e) {
        let { i: t, off: n } = this.childPos(e, 1),
          r = this.children[t]
        if (!(r instanceof L9)) return null
        for (; r.children.length; ) {
          let { i: e, off: t } = r.childPos(n, 1)
          for (; ; e++) {
            if (e == r.children.length) return null
            if ((r = r.children[e]).length) break
          }
          n = t
        }
        if (!(r instanceof S9)) return null
        let a = n7(r.text, n)
        if (a == n) return null
        let o = e9(r.dom, n, a).getClientRects()
        for (let e = 0; e < o.length; e++) {
          let t = o[e]
          if (e == o.length - 1 || (t.top < t.bottom && t.left < t.right)) return t
        }
        return null
      }
      measureVisibleLineHeights(e) {
        let t = [],
          { from: n, to: r } = e,
          a = this.view.contentDOM.clientWidth,
          o = a > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
          i = -1,
          s = this.view.textDirection == Y9.LTR
        for (let e = 0, l = 0; l < this.children.length; l++) {
          let c = this.children[l],
            d = e + c.length
          if (d > r) break
          if (e >= n) {
            let n = c.dom.getBoundingClientRect()
            if ((t.push(n.height), o)) {
              let t = c.dom.lastChild,
                r = t ? U6(t) : []
              if (r.length) {
                let t = r[r.length - 1],
                  o = s ? t.right - n.left : n.right - t.left
                o > i && ((i = o), (this.minWidth = a), (this.minWidthFrom = e), (this.minWidthTo = d))
              }
            }
          }
          e = d + c.breakAfter
        }
        return t
      }
      textDirectionAt(e) {
        let { i: t } = this.childPos(e, 1)
        return "rtl" == getComputedStyle(this.children[t].dom).direction ? Y9.RTL : Y9.LTR
      }
      measureTextSize() {
        for (let e of this.children)
          if (e instanceof L9) {
            let t = e.measureTextSize()
            if (t) return t
          }
        let e,
          t,
          n,
          r = document.createElement("div")
        return (
          (r.className = "cm-line"),
          (r.style.width = "99999px"),
          (r.style.position = "absolute"),
          (r.textContent = "abc def ghi jkl mno pqr stu"),
          this.view.observer.ignore(() => {
            this.dom.appendChild(r)
            let a = U6(r.firstChild)[0]
            ;(e = r.getBoundingClientRect().height), (t = a ? a.width / 27 : 7), (n = a ? a.height : e), r.remove()
          }),
          { lineHeight: e, charWidth: t, textHeight: n }
        )
      }
      childCursor(e = this.length) {
        let t = this.children.length
        return t && (e -= this.children[--t].length), new d9(this.children, e, t)
      }
      computeBlockGapDeco() {
        let e = [],
          t = this.view.viewState
        for (let n = 0, r = 0; ; r++) {
          let a = r == t.viewports.length ? null : t.viewports[r],
            o = a ? a.from - 1 : this.length
          if (o > n) {
            let r = (t.lineBlockAt(o).bottom - t.lineBlockAt(n).top) / this.view.scaleY
            e.push(U9.replace({ widget: new Vee(r), block: !0, inclusive: !0, isBlockGap: !0 }).range(n, o))
          }
          if (!a) break
          n = a.to + 1
        }
        return U9.set(e)
      }
      updateDeco() {
        let e = 1,
          t = this.view.state
            .facet(Mee)
            .map((t) => ((this.dynamicDecorationMap[e++] = "function" == typeof t) ? t(this.view) : t)),
          n = !1,
          r = this.view.state.facet(Lee).map((e, t) => {
            let r = "function" == typeof e
            return r && (n = !0), r ? e(this.view) : e
          })
        for (
          r.length && ((this.dynamicDecorationMap[e++] = n), t.push(h6.join(r))),
            this.decorations = [
              this.editContextFormatting,
              ...t,
              this.computeBlockGapDeco(),
              this.view.viewState.lineGapDeco,
            ];
          e < this.decorations.length;

        )
          this.dynamicDecorationMap[e++] = !1
        return this.decorations
      }
      scrollIntoView(e) {
        if (e.isSnapshot) {
          let t = this.view.viewState.lineBlockAt(e.range.head)
          return (this.view.scrollDOM.scrollTop = t.top - e.yMargin), void (this.view.scrollDOM.scrollLeft = e.xMargin)
        }
        for (let t of this.view.state.facet(_ee))
          try {
            if (t(this.view, e.range, e)) return !0
          } catch (e) {
            Aee(this.view.state, e, "scroll handler")
          }
        let t,
          { range: n } = e,
          r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1)
        if (!r) return
        !n.empty &&
          (t = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) &&
          (r = {
            left: Math.min(r.left, t.left),
            top: Math.min(r.top, t.top),
            right: Math.max(r.right, t.right),
            bottom: Math.max(r.bottom, t.bottom),
          })
        let a = Fee(this.view),
          o = { left: r.left - a.left, top: r.top - a.top, right: r.right + a.right, bottom: r.bottom + a.bottom },
          { offsetWidth: i, offsetHeight: s } = this.view.scrollDOM
        !(function (e, t, n, r, a, o, i, s) {
          let l = e.ownerDocument,
            c = l.defaultView || window
          for (let d = e, u = !1; d && !u; )
            if (1 == d.nodeType) {
              let e,
                p = d == l.body,
                h = 1,
                f = 1
              if (p) e = W6(c)
              else {
                if (
                  (/^(fixed|sticky)$/.test(getComputedStyle(d).position) && (u = !0),
                  d.scrollHeight <= d.clientHeight && d.scrollWidth <= d.clientWidth)
                ) {
                  d = d.assignedSlot || d.parentNode
                  continue
                }
                let t = d.getBoundingClientRect()
                ;({ scaleX: h, scaleY: f } = X6(d, t)),
                  (e = {
                    left: t.left,
                    right: t.left + d.clientWidth * h,
                    top: t.top,
                    bottom: t.top + d.clientHeight * f,
                  })
              }
              let m = 0,
                g = 0
              if ("nearest" == a)
                t.top < e.top
                  ? ((g = -(e.top - t.top + i)), n > 0 && t.bottom > e.bottom + g && (g = t.bottom - e.bottom + g + i))
                  : t.bottom > e.bottom &&
                    ((g = t.bottom - e.bottom + i), n < 0 && t.top - g < e.top && (g = -(e.top + g - t.top + i)))
              else {
                let r = t.bottom - t.top,
                  o = e.bottom - e.top
                g =
                  ("center" == a && r <= o
                    ? t.top + r / 2 - o / 2
                    : "start" == a || ("center" == a && n < 0)
                      ? t.top - i
                      : t.bottom - o + i) - e.top
              }
              if (
                ("nearest" == r
                  ? t.left < e.left
                    ? ((m = -(e.left - t.left + o)), n > 0 && t.right > e.right + m && (m = t.right - e.right + m + o))
                    : t.right > e.right &&
                      ((m = t.right - e.right + o), n < 0 && t.left < e.left + m && (m = -(e.left + m - t.left + o)))
                  : (m =
                      ("center" == r
                        ? t.left + (t.right - t.left) / 2 - (e.right - e.left) / 2
                        : ("start" == r) == s
                          ? t.left - o
                          : t.right - (e.right - e.left) + o) - e.left),
                m || g)
              )
                if (p) c.scrollBy(m, g)
                else {
                  let e = 0,
                    n = 0
                  if (g) {
                    let e = d.scrollTop
                    ;(d.scrollTop += g / f), (n = (d.scrollTop - e) * f)
                  }
                  if (m) {
                    let t = d.scrollLeft
                    ;(d.scrollLeft += m / h), (e = (d.scrollLeft - t) * h)
                  }
                  ;(t = { left: t.left - e, top: t.top - n, right: t.right - e, bottom: t.bottom - n }),
                    e && Math.abs(e - m) < 1 && (r = "nearest"),
                    n && Math.abs(n - g) < 1 && (a = "nearest")
                }
              if (p) break
              d = d.assignedSlot || d.parentNode
            } else {
              if (11 != d.nodeType) break
              d = d.host
            }
        })(
          this.view.scrollDOM,
          o,
          n.head < n.anchor ? -1 : 1,
          e.x,
          e.y,
          Math.max(Math.min(e.xMargin, i), -i),
          Math.max(Math.min(e.yMargin, s), -s),
          this.view.textDirection == Y9.LTR,
        )
      }
    }
    class Vee extends B9 {
      constructor(e) {
        super(), (this.height = e)
      }
      toDOM() {
        let e = document.createElement("div")
        return (e.className = "cm-gap"), this.updateDOM(e), e
      }
      eq(e) {
        return e.height == this.height
      }
      updateDOM(e) {
        return (e.style.height = this.height + "px"), !0
      }
      get editable() {
        return !0
      }
      get estimatedHeight() {
        return this.height
      }
      ignoreEvent() {
        return !1
      }
    }
    function Wee(e, t) {
      let n = e.observer.selectionRange
      if (!n.focusNode) return null
      let r = a9(n.focusNode, n.focusOffset),
        a = o9(n.focusNode, n.focusOffset),
        o = r || a
      if (a && r && a.node != r.node) {
        let t = l9.get(a.node)
        if (!t || (t instanceof S9 && t.text != a.node.nodeValue)) o = a
        else if (e.docView.lastCompositionAfterCursor) {
          let e = l9.get(r.node)
          !e || (e instanceof S9 && e.text != r.node.nodeValue) || (o = a)
        }
      }
      if (((e.docView.lastCompositionAfterCursor = o != r), !o)) return null
      let i = t - o.offset
      return { from: i, to: i + o.node.nodeValue.length, node: o.node }
    }
    let Xee = class {
      constructor() {
        this.changes = []
      }
      compareRange(e, t) {
        H9(e, t, this.changes)
      }
      comparePoint(e, t) {
        H9(e, t, this.changes)
      }
    }
    function Yee(e, t) {
      return t.left > e ? t.left - e : Math.max(0, e - t.right)
    }
    function Gee(e, t) {
      return t.top > e ? t.top - e : Math.max(0, e - t.bottom)
    }
    function Kee(e, t) {
      return e.top < t.bottom - 1 && e.bottom > t.top + 1
    }
    function Jee(e, t) {
      return t < e.top ? { top: t, left: e.left, right: e.right, bottom: e.bottom } : e
    }
    function ete(e, t) {
      return t > e.bottom ? { top: e.top, left: e.left, right: e.right, bottom: t } : e
    }
    function tte(e, t, n) {
      let r,
        a,
        o,
        i,
        s,
        l,
        c,
        d,
        u = !1
      for (let p = e.firstChild; p; p = p.nextSibling) {
        let e = U6(p)
        for (let h = 0; h < e.length; h++) {
          let f = e[h]
          a && Kee(a, f) && (f = Jee(ete(f, a.bottom), a.top))
          let m = Yee(t, f),
            g = Gee(n, f)
          if (0 == m && 0 == g) return 3 == p.nodeType ? nte(p, t, n) : tte(p, t, n)
          if (!r || i > g || (i == g && o > m)) {
            ;(r = p), (a = f), (o = m), (i = g)
            let s = g ? (n < f.top ? -1 : 1) : m ? (t < f.left ? -1 : 1) : 0
            u = !s || (s > 0 ? h < e.length - 1 : h > 0)
          }
          0 == m
            ? n > f.bottom && (!c || c.bottom < f.bottom)
              ? ((s = p), (c = f))
              : n < f.top && (!d || d.top > f.top) && ((l = p), (d = f))
            : c && Kee(c, f)
              ? (c = ete(c, f.bottom))
              : d && Kee(d, f) && (d = Jee(d, f.top))
        }
      }
      if ((c && c.bottom >= n ? ((r = s), (a = c)) : d && d.top <= n && ((r = l), (a = d)), !r))
        return { node: e, offset: 0 }
      let p = Math.max(a.left, Math.min(a.right, t))
      return 3 == r.nodeType
        ? nte(r, p, n)
        : u && "false" != r.contentEditable
          ? tte(r, p, n)
          : { node: e, offset: Array.prototype.indexOf.call(e.childNodes, r) + (t >= (a.left + a.right) / 2 ? 1 : 0) }
    }
    function nte(e, t, n) {
      let r = e.nodeValue.length,
        a = -1,
        o = 1e9,
        i = 0
      for (let s = 0; s < r; s++) {
        let r = e9(e, s, s + 1).getClientRects()
        for (let l = 0; l < r.length; l++) {
          let c = r[l]
          if (c.top == c.bottom) continue
          i || (i = t - c.left)
          let d = (c.top > n ? c.top - n : n - c.bottom) - 1
          if (c.left - 1 <= t && c.right + 1 >= t && d < o) {
            let n = t >= (c.left + c.right) / 2,
              r = n
            if (((_9.chrome || _9.gecko) && e9(e, s).getBoundingClientRect().left == c.right && (r = !n), d <= 0))
              return { node: e, offset: s + (r ? 1 : 0) }
            ;(a = s + (r ? 1 : 0)), (o = d)
          }
        }
      }
      return { node: e, offset: a > -1 ? a : i > 0 ? e.nodeValue.length : 0 }
    }
    function rte(e, t, n, r = -1) {
      var a, o
      let i,
        s = e.contentDOM.getBoundingClientRect(),
        l = s.top + e.viewState.paddingTop,
        { docHeight: c } = e.viewState,
        { x: d, y: u } = t,
        p = u - l
      if (p < 0) return 0
      if (p > c) return e.state.doc.length
      for (let t = e.viewState.heightOracle.textHeight / 2, a = !1; (i = e.elementAtHeight(p)), i.type != j9.Text; )
        for (; (p = r > 0 ? i.bottom + t : i.top - t), !(p >= 0 && p <= c); ) {
          if (a) return n ? null : 0
          ;(a = !0), (r = -r)
        }
      u = l + p
      let h = i.from
      if (h < e.viewport.from) return 0 == e.viewport.from ? 0 : n ? null : ate(e, s, i, d, u)
      if (h > e.viewport.to)
        return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : ate(e, s, i, d, u)
      let f = e.dom.ownerDocument,
        m = e.root.elementFromPoint ? e.root : f,
        g = m.elementFromPoint(d, u)
      g && !e.contentDOM.contains(g) && (g = null),
        g ||
          ((d = Math.max(s.left + 1, Math.min(s.right - 1, d))),
          (g = m.elementFromPoint(d, u)),
          g && !e.contentDOM.contains(g) && (g = null))
      let b,
        v = -1
      if (g && 0 != (null === (a = e.docView.nearest(g)) || void 0 === a ? void 0 : a.isEditable))
        if (f.caretPositionFromPoint) {
          let e = f.caretPositionFromPoint(d, u)
          e && ({ offsetNode: b, offset: v } = e)
        } else if (f.caretRangeFromPoint) {
          let t = f.caretRangeFromPoint(d, u)
          t &&
            (({ startContainer: b, startOffset: v } = t),
            (!e.contentDOM.contains(b) ||
              (_9.safari &&
                (function (e, t, n) {
                  let r
                  if (3 != e.nodeType || t != (r = e.nodeValue.length)) return !1
                  for (let t = e.nextSibling; t; t = t.nextSibling) if (1 != t.nodeType || "BR" != t.nodeName) return !1
                  return e9(e, r - 1, r).getBoundingClientRect().left > n
                })(b, v, d)) ||
              (_9.chrome &&
                (function (e, t, n) {
                  if (0 != t) return !1
                  for (let t = e; ; ) {
                    let e = t.parentNode
                    if (!e || 1 != e.nodeType || e.firstChild != t) return !1
                    if (e.classList.contains("cm-line")) break
                    t = e
                  }
                  return (
                    n -
                      (1 == e.nodeType
                        ? e.getBoundingClientRect()
                        : e9(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect()
                      ).left >
                    5
                  )
                })(b, v, d))) &&
              (b = void 0))
        }
      if (!b || !e.docView.dom.contains(b)) {
        let t = L9.find(e.docView, h)
        if (!t) return p > i.top + i.height / 2 ? i.to : i.from
        ;({ node: b, offset: v } = tte(t.dom, d, u))
      }
      let y = e.docView.nearest(b)
      if (!y) return null
      if (y.isWidget && 1 == (null === (o = y.dom) || void 0 === o ? void 0 : o.nodeType)) {
        let e = y.dom.getBoundingClientRect()
        return t.y < e.top || (t.y <= e.bottom && t.x <= (e.left + e.right) / 2) ? y.posAtStart : y.posAtEnd
      }
      return y.localPosFromDOM(b, v) + y.posAtStart
    }
    function ate(e, t, n, r, a) {
      let o = Math.round((r - t.left) * e.defaultCharacterWidth)
      if (e.lineWrapping && n.height > 1.5 * e.defaultLineHeight) {
        let t = e.viewState.heightOracle.textHeight
        o += Math.floor((a - n.top - 0.5 * (e.defaultLineHeight - t)) / t) * e.viewState.heightOracle.lineLength
      }
      let i = e.state.sliceDoc(n.from, n.to)
      return (
        n.from +
        (function (e, t, n, r) {
          for (let r = 0, a = 0; ; ) {
            if (a >= t) return r
            if (r == e.length) break
            ;(a += 9 == e.charCodeAt(r) ? n - (a % n) : 1), (r = n7(e, r))
          }
          return e.length
        })(i, o, e.state.tabSize)
      )
    }
    function ote(e, t, n, r) {
      let a = e.state.doc.lineAt(t.head),
        o = e.bidiSpans(a),
        i = e.textDirectionAt(a.from)
      for (let s = t, l = null; ; ) {
        let t = hee(a, o, i, s, n),
          c = pee
        if (!t) {
          if (a.number == (n ? e.state.doc.lines : 1)) return s
          ;(c = "\n"),
            (a = e.state.doc.line(a.number + (n ? 1 : -1))),
            (o = e.bidiSpans(a)),
            (t = e.visualLineSide(a, !n))
        }
        if (l) {
          if (!l(c)) return s
        } else {
          if (!r) return t
          l = r(c)
        }
        s = t
      }
    }
    function ite(e, t, n) {
      for (;;) {
        let r = 0
        for (let a of e)
          a.between(t - 1, t + 1, (e, a, o) => {
            if (t > e && t < a) {
              let o = r || n || (t - e < a - t ? -1 : 1)
              ;(t = o < 0 ? e : a), (r = o)
            }
          })
        if (!r) return t
      }
    }
    function ste(e, t, n) {
      let r = ite(
        e.state.facet(Qee).map((t) => t(e)),
        n.from,
        t.head > n.from ? -1 : 1,
      )
      return r == n.from ? n : w7.cursor(r, r < n.from ? 1 : -1)
    }
    class lte {
      setSelectionOrigin(e) {
        ;(this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now())
      }
      constructor(e) {
        var t
        ;(this.view = e),
          (this.lastKeyCode = 0),
          (this.lastKeyTime = 0),
          (this.lastTouchTime = 0),
          (this.lastFocusTime = 0),
          (this.lastScrollTop = 0),
          (this.lastScrollLeft = 0),
          (this.pendingIOSKey = void 0),
          (this.tabFocusMode = -1),
          (this.lastSelectionOrigin = null),
          (this.lastSelectionTime = 0),
          (this.lastContextMenu = 0),
          (this.scrollHandlers = []),
          (this.handlers = Object.create(null)),
          (this.composing = -1),
          (this.compositionFirstChange = null),
          (this.compositionEndedAt = 0),
          (this.compositionPendingKey = !1),
          (this.compositionPendingChange = !1),
          (this.mouseSelection = null),
          (this.draggedContent = null),
          (this.handleEvent = this.handleEvent.bind(this)),
          (this.notifiedFocused = e.hasFocus),
          _9.safari && e.contentDOM.addEventListener("input", () => null),
          _9.gecko &&
            ((t = e.contentDOM.ownerDocument),
            $te.has(t) || ($te.add(t), t.addEventListener("copy", () => {}), t.addEventListener("cut", () => {})))
      }
      handleEvent(e) {
        ;(function (e, t) {
          if (!t.bubbles) return !0
          if (t.defaultPrevented) return !1
          for (let n, r = t.target; r != e.contentDOM; r = r.parentNode)
            if (!r || 11 == r.nodeType || ((n = l9.get(r)) && n.ignoreEvent(t))) return !1
          return !0
        })(this.view, e) &&
          !this.ignoreDuringComposition(e) &&
          (("keydown" == e.type && this.keydown(e)) || this.runHandlers(e.type, e))
      }
      runHandlers(e, t) {
        let n = this.handlers[e]
        if (n) {
          for (let e of n.observers) e(this.view, t)
          for (let e of n.handlers) {
            if (t.defaultPrevented) break
            if (e(this.view, t)) {
              t.preventDefault()
              break
            }
          }
        }
      }
      ensureHandlers(e) {
        let t = (function (e) {
            let t = Object.create(null)
            function n(e) {
              return t[e] || (t[e] = { observers: [], handlers: [] })
            }
            for (let t of e) {
              let e = t.spec
              if (e && e.domEventHandlers)
                for (let r in e.domEventHandlers) {
                  let a = e.domEventHandlers[r]
                  a && n(r).handlers.push(cte(t.value, a))
                }
              if (e && e.domEventObservers)
                for (let r in e.domEventObservers) {
                  let a = e.domEventObservers[r]
                  a && n(r).observers.push(cte(t.value, a))
                }
            }
            for (let e in mte) n(e).handlers.push(mte[e])
            for (let e in gte) n(e).observers.push(gte[e])
            return t
          })(e),
          n = this.handlers,
          r = this.view.contentDOM
        for (let e in t)
          if ("scroll" != e) {
            let a = !t[e].handlers.length,
              o = n[e]
            o && a != !o.handlers.length && (r.removeEventListener(e, this.handleEvent), (o = null)),
              o || r.addEventListener(e, this.handleEvent, { passive: a })
          }
        for (let e in n) "scroll" == e || t[e] || r.removeEventListener(e, this.handleEvent)
        this.handlers = t
      }
      keydown(e) {
        if (
          ((this.lastKeyCode = e.keyCode),
          (this.lastKeyTime = Date.now()),
          9 == e.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        )
          return !0
        if (
          (this.tabFocusMode > 0 && 27 != e.keyCode && pte.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1),
          _9.android && _9.chrome && !e.synthetic && (13 == e.keyCode || 8 == e.keyCode))
        )
          return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0
        let t
        return !_9.ios ||
          e.synthetic ||
          e.altKey ||
          e.metaKey ||
          !(
            ((t = dte.find((t) => t.keyCode == e.keyCode)) && !e.ctrlKey) ||
            (ute.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey)
          )
          ? (229 != e.keyCode && this.view.observer.forceFlush(), !1)
          : ((this.pendingIOSKey = t || e), setTimeout(() => this.flushIOSKey(), 250), !0)
      }
      flushIOSKey(e) {
        let t = this.pendingIOSKey
        return (
          !!t &&
          !("Enter" == t.key && e && e.from < e.to && /^\S+$/.test(e.insert.toString())) &&
          ((this.pendingIOSKey = void 0),
          t9(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0))
        )
      }
      ignoreDuringComposition(e) {
        return (
          !!/^key/.test(e.type) &&
          (this.composing > 0 ||
            (!!(_9.safari && !_9.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) &&
              ((this.compositionPendingKey = !1), !0)))
        )
      }
      startMouseSelection(e) {
        this.mouseSelection && this.mouseSelection.destroy(), (this.mouseSelection = e)
      }
      update(e) {
        this.view.observer.update(e),
          this.mouseSelection && this.mouseSelection.update(e),
          this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)),
          e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0)
      }
      destroy() {
        this.mouseSelection && this.mouseSelection.destroy()
      }
    }
    function cte(e, t) {
      return (n, r) => {
        try {
          return t.call(e, r, n)
        } catch (e) {
          Aee(n.state, e)
        }
      }
    }
    const dte = [
        { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
        { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
        { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
        { key: "Delete", keyCode: 46, inputType: "deleteContentForward" },
      ],
      ute = "dthko",
      pte = [16, 17, 18, 20, 91, 92, 224, 225]
    function hte(e) {
      return 0.7 * Math.max(0, e) + 8
    }
    class fte {
      constructor(e, t, n, r) {
        ;(this.view = e),
          (this.startEvent = t),
          (this.style = n),
          (this.mustSelect = r),
          (this.scrollSpeed = { x: 0, y: 0 }),
          (this.scrolling = -1),
          (this.lastEvent = t),
          (this.scrollParent = (function (e) {
            let t = e.ownerDocument
            for (let n = e.parentNode; n && n != t.body; )
              if (1 == n.nodeType) {
                if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth) return n
                n = n.assignedSlot || n.parentNode
              } else {
                if (11 != n.nodeType) break
                n = n.host
              }
            return null
          })(e.contentDOM)),
          (this.atoms = e.state.facet(Qee).map((t) => t(e)))
        let a = e.contentDOM.ownerDocument
        a.addEventListener("mousemove", (this.move = this.move.bind(this))),
          a.addEventListener("mouseup", (this.up = this.up.bind(this))),
          (this.extend = t.shiftKey),
          (this.multiple =
            e.state.facet(s6.allowMultipleSelections) &&
            (function (e, t) {
              let n = e.state.facet(mee)
              return n.length ? n[0](t) : _9.mac ? t.metaKey : t.ctrlKey
            })(e, t)),
          (this.dragging =
            !(
              !(function (e, t) {
                let { main: n } = e.state.selection
                if (n.empty) return !1
                let r = Q6(e.root)
                if (!r || 0 == r.rangeCount) return !0
                let a = r.getRangeAt(0).getClientRects()
                for (let e = 0; e < a.length; e++) {
                  let n = a[e]
                  if (n.left <= t.clientX && n.right >= t.clientX && n.top <= t.clientY && n.bottom >= t.clientY)
                    return !0
                }
                return !1
              })(e, t) || 1 != Ate(t)
            ) && null)
      }
      start(e) {
        !1 === this.dragging && this.select(e)
      }
      move(e) {
        var t, n, r
        if (0 == e.buttons) return this.destroy()
        if (
          this.dragging ||
          (null == this.dragging &&
            ((n = this.startEvent),
            (r = e),
            Math.max(Math.abs(n.clientX - r.clientX), Math.abs(n.clientY - r.clientY)) < 10))
        )
          return
        this.select((this.lastEvent = e))
        let a = 0,
          o = 0,
          i = (null === (t = this.scrollParent) || void 0 === t ? void 0 : t.getBoundingClientRect()) || {
            left: 0,
            top: 0,
            right: this.view.win.innerWidth,
            bottom: this.view.win.innerHeight,
          },
          s = Fee(this.view)
        e.clientX - s.left <= i.left + 6
          ? (a = -hte(i.left - e.clientX))
          : e.clientX + s.right >= i.right - 6 && (a = hte(e.clientX - i.right)),
          e.clientY - s.top <= i.top + 6
            ? (o = -hte(i.top - e.clientY))
            : e.clientY + s.bottom >= i.bottom - 6 && (o = hte(e.clientY - i.bottom)),
          this.setScrollSpeed(a, o)
      }
      up(e) {
        null == this.dragging && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy()
      }
      destroy() {
        this.setScrollSpeed(0, 0)
        let e = this.view.contentDOM.ownerDocument
        e.removeEventListener("mousemove", this.move),
          e.removeEventListener("mouseup", this.up),
          (this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null)
      }
      setScrollSpeed(e, t) {
        ;(this.scrollSpeed = { x: e, y: t }),
          e || t
            ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50))
            : this.scrolling > -1 && (clearInterval(this.scrolling), (this.scrolling = -1))
      }
      scroll() {
        this.scrollParent
          ? ((this.scrollParent.scrollLeft += this.scrollSpeed.x), (this.scrollParent.scrollTop += this.scrollSpeed.y))
          : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
          !1 === this.dragging && this.select(this.lastEvent)
      }
      skipAtoms(e) {
        let t = null
        for (let n = 0; n < e.ranges.length; n++) {
          let r = e.ranges[n],
            a = null
          if (r.empty) {
            let e = ite(this.atoms, r.from, 0)
            e != r.from && (a = w7.cursor(e, -1))
          } else {
            let e = ite(this.atoms, r.from, -1),
              t = ite(this.atoms, r.to, 1)
            ;(e == r.from && t == r.to) || (a = w7.range(r.from == r.anchor ? e : t, r.from == r.head ? e : t))
          }
          a && (t || (t = e.ranges.slice()), (t[n] = a))
        }
        return t ? w7.create(t, e.mainIndex) : e
      }
      select(e) {
        let { view: t } = this,
          n = this.skipAtoms(this.style.get(e, this.extend, this.multiple))
        ;(!this.mustSelect && n.eq(t.state.selection, !1 === this.dragging)) ||
          this.view.dispatch({ selection: n, userEvent: "select.pointer" }),
          (this.mustSelect = !1)
      }
      update(e) {
        e.transactions.some((e) => e.isUserEvent("input.type"))
          ? this.destroy()
          : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20)
      }
    }
    const mte = Object.create(null),
      gte = Object.create(null),
      bte = (_9.ie && _9.ie_version < 15) || (_9.ios && _9.webkit_version < 604)
    function vte(e, t) {
      let n,
        { state: r } = e,
        a = 1,
        o = r.toText(t),
        i = o.lines == r.selection.ranges.length,
        s = null != Pte && r.selection.ranges.every((e) => e.empty) && Pte == o.toString()
      if (s) {
        let e = -1
        n = r.changeByRange((n) => {
          let s = r.doc.lineAt(n.from)
          if (s.from == e) return { range: n }
          e = s.from
          let l = r.toText((i ? o.line(a++).text : t) + r.lineBreak)
          return { changes: { from: s.from, insert: l }, range: w7.cursor(n.from + l.length) }
        })
      } else
        n = i
          ? r.changeByRange((e) => {
              let t = o.line(a++)
              return { changes: { from: e.from, to: e.to, insert: t.text }, range: w7.cursor(e.from + t.length) }
            })
          : r.replaceSelection(o)
      e.dispatch(n, { userEvent: "input.paste", scrollIntoView: !0 })
    }
    function yte(e, t, n, r) {
      if (1 == r) return w7.cursor(t, n)
      if (2 == r)
        return (function (e, t, n = 1) {
          let r = e.charCategorizer(t),
            a = e.doc.lineAt(t),
            o = t - a.from
          if (0 == a.length) return w7.cursor(t)
          0 == o ? (n = 1) : o == a.length && (n = -1)
          let i = o,
            s = o
          n < 0 ? (i = n7(a.text, o, !1)) : (s = n7(a.text, o))
          let l = r(a.text.slice(i, s))
          for (; i > 0; ) {
            let e = n7(a.text, i, !1)
            if (r(a.text.slice(e, i)) != l) break
            i = e
          }
          for (; s < a.length; ) {
            let e = n7(a.text, s)
            if (r(a.text.slice(s, e)) != l) break
            s = e
          }
          return w7.range(i + a.from, s + a.from)
        })(e.state, t, n)
      {
        let n = L9.find(e.docView, t),
          r = e.state.doc.lineAt(n ? n.posAtEnd : t),
          a = n ? n.posAtStart : r.from,
          o = n ? n.posAtEnd : r.to
        return o < e.state.doc.length && o == r.to && o++, w7.range(a, o)
      }
    }
    ;(gte.scroll = (e) => {
      ;(e.inputState.lastScrollTop = e.scrollDOM.scrollTop), (e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft)
    }),
      (mte.keydown = (e, t) => (
        e.inputState.setSelectionOrigin("select"),
        27 == t.keyCode && 0 != e.inputState.tabFocusMode && (e.inputState.tabFocusMode = Date.now() + 2e3),
        !1
      )),
      (gte.touchstart = (e, t) => {
        ;(e.inputState.lastTouchTime = Date.now()), e.inputState.setSelectionOrigin("select.pointer")
      }),
      (gte.touchmove = (e) => {
        e.inputState.setSelectionOrigin("select.pointer")
      }),
      (mte.mousedown = (e, t) => {
        if ((e.observer.flush(), e.inputState.lastTouchTime > Date.now() - 2e3)) return !1
        let n = null
        for (let r of e.state.facet(bee)) if (((n = r(e, t)), n)) break
        if (
          (n ||
            0 != t.button ||
            (n = (function (e, t) {
              let n = kte(e, t),
                r = Ate(t),
                a = e.state.selection
              return {
                update(e) {
                  e.docChanged && ((n.pos = e.changes.mapPos(n.pos)), (a = a.map(e.changes)))
                },
                get(t, o, i) {
                  let s,
                    l = kte(e, t),
                    c = yte(e, l.pos, l.bias, r)
                  if (n.pos != l.pos && !o) {
                    let t = yte(e, n.pos, n.bias, r),
                      a = Math.min(t.from, c.from),
                      o = Math.max(t.to, c.to)
                    c = a < c.from ? w7.range(a, o) : w7.range(o, a)
                  }
                  return o
                    ? a.replaceRange(a.main.extend(c.from, c.to))
                    : i &&
                        1 == r &&
                        a.ranges.length > 1 &&
                        (s = (function (e, t) {
                          for (let n = 0; n < e.ranges.length; n++) {
                            let { from: r, to: a } = e.ranges[n]
                            if (r <= t && a >= t)
                              return w7.create(
                                e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)),
                                e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0),
                              )
                          }
                          return null
                        })(a, l.pos))
                      ? s
                      : i
                        ? a.addRange(c)
                        : w7.create([c])
                },
              }
            })(e, t)),
          n)
        ) {
          let r = !e.hasFocus
          e.inputState.startMouseSelection(new fte(e, t, n, r)),
            r &&
              e.observer.ignore(() => {
                J6(e.contentDOM)
                let t = e.root.activeElement
                t && !t.contains(e.contentDOM) && t.blur()
              })
          let a = e.inputState.mouseSelection
          if (a) return a.start(t), !1 === a.dragging
        }
        return !1
      })
    let Ote = (e, t) => e >= t.top && e <= t.bottom,
      wte = (e, t, n) => Ote(t, n) && e >= n.left && e <= n.right
    function xte(e, t, n, r) {
      let a = L9.find(e.docView, t)
      if (!a) return 1
      let o = t - a.posAtStart
      if (0 == o) return 1
      if (o == a.length) return -1
      let i = a.coordsAt(o, -1)
      if (i && wte(n, r, i)) return -1
      let s = a.coordsAt(o, 1)
      return s && wte(n, r, s) ? 1 : i && Ote(r, i) ? -1 : 1
    }
    function kte(e, t) {
      let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1)
      return { pos: n, bias: xte(e, n, t.clientX, t.clientY) }
    }
    const _te = _9.ie && _9.ie_version <= 11
    let Ste = null,
      Ete = 0,
      Tte = 0
    function Ate(e) {
      if (!_te) return e.detail
      let t = Ste,
        n = Tte
      return (
        (Ste = e),
        (Tte = Date.now()),
        (Ete =
          !t || (n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2)
            ? (Ete + 1) % 3
            : 1)
      )
    }
    function Cte(e, t, n, r) {
      if (!n) return
      let a = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1),
        { draggedContent: o } = e.inputState,
        i =
          r &&
          o &&
          (function (e, t) {
            let n = e.state.facet(gee)
            return n.length ? n[0](t) : _9.mac ? !t.altKey : !t.ctrlKey
          })(e, t)
            ? { from: o.from, to: o.to }
            : null,
        s = { from: a, insert: n },
        l = e.state.changes(i ? [i, s] : s)
      e.focus(),
        e.dispatch({
          changes: l,
          selection: { anchor: l.mapPos(a, -1), head: l.mapPos(a, 1) },
          userEvent: i ? "move.drop" : "input.drop",
        }),
        (e.inputState.draggedContent = null)
    }
    ;(mte.dragstart = (e, t) => {
      let {
        selection: { main: n },
      } = e.state
      if (t.target.draggable) {
        let r = e.docView.nearest(t.target)
        if (r && r.isWidget) {
          let e = r.posAtStart,
            t = e + r.length
          ;(e >= n.to || t <= n.from) && (n = w7.range(e, t))
        }
      }
      let { inputState: r } = e
      return (
        r.mouseSelection && (r.mouseSelection.dragging = !0),
        (r.draggedContent = n),
        t.dataTransfer &&
          (t.dataTransfer.setData("Text", e.state.sliceDoc(n.from, n.to)), (t.dataTransfer.effectAllowed = "copyMove")),
        !1
      )
    }),
      (mte.dragend = (e) => ((e.inputState.draggedContent = null), !1)),
      (mte.drop = (e, t) => {
        if (!t.dataTransfer) return !1
        if (e.state.readOnly) return !0
        let n = t.dataTransfer.files
        if (n && n.length) {
          let r = Array(n.length),
            a = 0,
            o = () => {
              ++a == n.length && Cte(e, t, r.filter((e) => null != e).join(e.state.lineBreak), !1)
            }
          for (let e = 0; e < n.length; e++) {
            let t = new FileReader()
            ;(t.onerror = o),
              (t.onload = () => {
                ;/[\x00-\x08\x0e-\x1f]{2}/.test(t.result) || (r[e] = t.result), o()
              }),
              t.readAsText(n[e])
          }
          return !0
        }
        {
          let n = t.dataTransfer.getData("Text")
          if (n) return Cte(e, t, n, !0), !0
        }
        return !1
      }),
      (mte.paste = (e, t) => {
        if (e.state.readOnly) return !0
        e.observer.flush()
        let n = bte ? null : t.clipboardData
        return n
          ? (vte(e, n.getData("text/plain") || n.getData("text/uri-list")), !0)
          : ((function (e) {
              let t = e.dom.parentNode
              if (!t) return
              let n = t.appendChild(document.createElement("textarea"))
              ;(n.style.cssText = "position: fixed; left: -10000px; top: 10px"),
                n.focus(),
                setTimeout(() => {
                  e.focus(), n.remove(), vte(e, n.value)
                }, 50)
            })(e),
            !1)
      })
    let Pte = null
    mte.copy = mte.cut = (e, t) => {
      let {
        text: n,
        ranges: r,
        linewise: a,
      } = (function (e) {
        let t = [],
          n = [],
          r = !1
        for (let r of e.selection.ranges) r.empty || (t.push(e.sliceDoc(r.from, r.to)), n.push(r))
        if (!t.length) {
          let a = -1
          for (let { from: r } of e.selection.ranges) {
            let o = e.doc.lineAt(r)
            o.number > a && (t.push(o.text), n.push({ from: o.from, to: Math.min(e.doc.length, o.to + 1) })),
              (a = o.number)
          }
          r = !0
        }
        return { text: t.join(e.lineBreak), ranges: n, linewise: r }
      })(e.state)
      if (!n && !a) return !1
      ;(Pte = a ? n : null),
        "cut" != t.type || e.state.readOnly || e.dispatch({ changes: r, scrollIntoView: !0, userEvent: "delete.cut" })
      let o = bte ? null : t.clipboardData
      return o
        ? (o.clearData(), o.setData("text/plain", n), !0)
        : ((function (e, t) {
            let n = e.dom.parentNode
            if (!n) return
            let r = n.appendChild(document.createElement("textarea"))
            ;(r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
              (r.value = t),
              r.focus(),
              (r.selectionEnd = t.length),
              (r.selectionStart = 0),
              setTimeout(() => {
                r.remove(), e.focus()
              }, 50)
          })(e, n),
          !1)
    }
    const Dte = V7.define()
    function Rte(e, t) {
      let n = []
      for (let r of e.facet(wee)) {
        let a = r(e, t)
        a && n.push(a)
      }
      return n ? e.update({ effects: n, annotations: Dte.of(!0) }) : null
    }
    function Nte(e) {
      setTimeout(() => {
        let t = e.hasFocus
        if (t != e.inputState.notifiedFocused) {
          let n = Rte(e.state, t)
          n ? e.dispatch(n) : e.update([])
        }
      }, 10)
    }
    ;(gte.focus = (e) => {
      ;(e.inputState.lastFocusTime = Date.now()),
        e.scrollDOM.scrollTop ||
          (!e.inputState.lastScrollTop && !e.inputState.lastScrollLeft) ||
          ((e.scrollDOM.scrollTop = e.inputState.lastScrollTop),
          (e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft)),
        Nte(e)
    }),
      (gte.blur = (e) => {
        e.observer.clearSelectionRange(), Nte(e)
      }),
      (gte.compositionstart = gte.compositionupdate =
        (e) => {
          e.observer.editContext ||
            (null == e.inputState.compositionFirstChange && (e.inputState.compositionFirstChange = !0),
            e.inputState.composing < 0 && (e.inputState.composing = 0))
        }),
      (gte.compositionend = (e) => {
        e.observer.editContext ||
          ((e.inputState.composing = -1),
          (e.inputState.compositionEndedAt = Date.now()),
          (e.inputState.compositionPendingKey = !0),
          (e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0),
          (e.inputState.compositionFirstChange = null),
          _9.chrome && _9.android
            ? e.observer.flushSoon()
            : e.inputState.compositionPendingChange
              ? Promise.resolve().then(() => e.observer.flush())
              : setTimeout(() => {
                  e.inputState.composing < 0 && e.docView.hasComposition && e.update([])
                }, 50))
      }),
      (gte.contextmenu = (e) => {
        e.inputState.lastContextMenu = Date.now()
      }),
      (mte.beforeinput = (e, t) => {
        var n
        let r
        if (
          _9.chrome &&
          _9.android &&
          (r = dte.find((e) => e.inputType == t.inputType)) &&
          (e.observer.delayAndroidKey(r.key, r.keyCode), "Backspace" == r.key || "Delete" == r.key)
        ) {
          let t = (null === (n = window.visualViewport) || void 0 === n ? void 0 : n.height) || 0
          setTimeout(() => {
            var n
            ;((null === (n = window.visualViewport) || void 0 === n ? void 0 : n.height) || 0) > t + 10 &&
              e.hasFocus &&
              (e.contentDOM.blur(), e.focus())
          }, 100)
        }
        return (
          _9.ios && "deleteContentForward" == t.inputType && e.observer.flushSoon(),
          _9.safari &&
            "insertText" == t.inputType &&
            e.inputState.composing >= 0 &&
            setTimeout(() => gte.compositionend(e, t), 20),
          !1
        )
      })
    const $te = new Set(),
      Ite = ["pre-wrap", "normal", "pre-line", "break-spaces"]
    class Mte {
      constructor(e) {
        ;(this.lineWrapping = e),
          (this.doc = F8.empty),
          (this.heightSamples = {}),
          (this.lineHeight = 14),
          (this.charWidth = 7),
          (this.textHeight = 14),
          (this.lineLength = 30),
          (this.heightChanged = !1)
      }
      heightForGap(e, t) {
        let n = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1
        return (
          this.lineWrapping && (n += Math.max(0, Math.ceil((t - e - n * this.lineLength * 0.5) / this.lineLength))),
          this.lineHeight * n
        )
      }
      heightForLine(e) {
        return this.lineWrapping
          ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
          : this.lineHeight
      }
      setDoc(e) {
        return (this.doc = e), this
      }
      mustRefreshForWrapping(e) {
        return Ite.indexOf(e) > -1 != this.lineWrapping
      }
      mustRefreshForHeights(e) {
        let t = !1
        for (let n = 0; n < e.length; n++) {
          let r = e[n]
          r < 0
            ? n++
            : this.heightSamples[Math.floor(10 * r)] || ((t = !0), (this.heightSamples[Math.floor(10 * r)] = !0))
        }
        return t
      }
      refresh(e, t, n, r, a, o) {
        let i = Ite.indexOf(e) > -1,
          s = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != i
        if (
          ((this.lineWrapping = i),
          (this.lineHeight = t),
          (this.charWidth = n),
          (this.textHeight = r),
          (this.lineLength = a),
          s)
        ) {
          this.heightSamples = {}
          for (let e = 0; e < o.length; e++) {
            let t = o[e]
            t < 0 ? e++ : (this.heightSamples[Math.floor(10 * t)] = !0)
          }
        }
        return s
      }
    }
    class Lte {
      constructor(e, t) {
        ;(this.from = e), (this.heights = t), (this.index = 0)
      }
      get more() {
        return this.index < this.heights.length
      }
    }
    class Qte {
      constructor(e, t, n, r, a) {
        ;(this.from = e), (this.length = t), (this.top = n), (this.height = r), (this._content = a)
      }
      get type() {
        return "number" == typeof this._content
          ? j9.Text
          : Array.isArray(this._content)
            ? this._content
            : this._content.type
      }
      get to() {
        return this.from + this.length
      }
      get bottom() {
        return this.top + this.height
      }
      get widget() {
        return this._content instanceof q9 ? this._content.widget : null
      }
      get widgetLineBreaks() {
        return "number" == typeof this._content ? this._content : 0
      }
      join(e) {
        let t = (Array.isArray(this._content) ? this._content : [this]).concat(
          Array.isArray(e._content) ? e._content : [e],
        )
        return new Qte(this.from, this.length + e.length, this.top, this.height + e.height, t)
      }
    }
    var Bte = (function (e) {
      return (
        (e[(e.ByPos = 0)] = "ByPos"),
        (e[(e.ByHeight = 1)] = "ByHeight"),
        (e[(e.ByPosNoHeight = 2)] = "ByPosNoHeight"),
        e
      )
    })(Bte || (Bte = {}))
    const jte = 0.001
    class Ute {
      constructor(e, t, n = 2) {
        ;(this.length = e), (this.height = t), (this.flags = n)
      }
      get outdated() {
        return (2 & this.flags) > 0
      }
      set outdated(e) {
        this.flags = (e ? 2 : 0) | (-3 & this.flags)
      }
      setHeight(e, t) {
        this.height != t && (Math.abs(this.height - t) > jte && (e.heightChanged = !0), (this.height = t))
      }
      replace(e, t, n) {
        return Ute.of(n)
      }
      decomposeLeft(e, t) {
        t.push(this)
      }
      decomposeRight(e, t) {
        t.push(this)
      }
      applyChanges(e, t, n, r) {
        let a = this,
          o = n.doc
        for (let i = r.length - 1; i >= 0; i--) {
          let { fromA: s, toA: l, fromB: c, toB: d } = r[i],
            u = a.lineAt(s, Bte.ByPosNoHeight, n.setDoc(t), 0, 0),
            p = u.to >= l ? u : a.lineAt(l, Bte.ByPosNoHeight, n, 0, 0)
          for (d += p.to - l, l = p.to; i > 0 && u.from <= r[i - 1].toA; )
            (s = r[i - 1].fromA), (c = r[i - 1].fromB), i--, s < u.from && (u = a.lineAt(s, Bte.ByPosNoHeight, n, 0, 0))
          ;(c += u.from - s), (s = u.from)
          let h = Vte.build(n.setDoc(o), e, c, d)
          a = a.replace(s, l, h)
        }
        return a.updateHeight(n, 0)
      }
      static empty() {
        return new zte(0, 0)
      }
      static of(e) {
        if (1 == e.length) return e[0]
        let t = 0,
          n = e.length,
          r = 0,
          a = 0
        for (;;)
          if (t == n)
            if (r > 2 * a) {
              let a = e[t - 1]
              a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right),
                (n += 1 + a.break),
                (r -= a.size)
            } else {
              if (!(a > 2 * r)) break
              {
                let t = e[n]
                t.break ? e.splice(n, 1, t.left, null, t.right) : e.splice(n, 1, t.left, t.right),
                  (n += 2 + t.break),
                  (a -= t.size)
              }
            }
          else if (r < a) {
            let n = e[t++]
            n && (r += n.size)
          } else {
            let t = e[--n]
            t && (a += t.size)
          }
        let o = 0
        return (
          null == e[t - 1] ? ((o = 1), t--) : null == e[t] && ((o = 1), n++),
          new Zte(Ute.of(e.slice(0, t)), o, Ute.of(e.slice(n)))
        )
      }
    }
    Ute.prototype.size = 1
    class Fte extends Ute {
      constructor(e, t, n) {
        super(e, t), (this.deco = n)
      }
      blockAt(e, t, n, r) {
        return new Qte(r, this.length, n, this.height, this.deco || 0)
      }
      lineAt(e, t, n, r, a) {
        return this.blockAt(0, n, r, a)
      }
      forEachLine(e, t, n, r, a, o) {
        e <= a + this.length && t >= a && o(this.blockAt(0, n, r, a))
      }
      updateHeight(e, t = 0, n = !1, r) {
        return r && r.from <= t && r.more && this.setHeight(e, r.heights[r.index++]), (this.outdated = !1), this
      }
      toString() {
        return `block(${this.length})`
      }
    }
    class zte extends Fte {
      constructor(e, t) {
        super(e, t, null), (this.collapsed = 0), (this.widgetHeight = 0), (this.breaks = 0)
      }
      blockAt(e, t, n, r) {
        return new Qte(r, this.length, n, this.height, this.breaks)
      }
      replace(e, t, n) {
        let r = n[0]
        return 1 == n.length &&
          (r instanceof zte || (r instanceof qte && 4 & r.flags)) &&
          Math.abs(this.length - r.length) < 10
          ? (r instanceof qte ? (r = new zte(r.length, this.height)) : (r.height = this.height),
            this.outdated || (r.outdated = !1),
            r)
          : Ute.of(n)
      }
      updateHeight(e, t = 0, n = !1, r) {
        return (
          r && r.from <= t && r.more
            ? this.setHeight(e, r.heights[r.index++])
            : (n || this.outdated) &&
              this.setHeight(
                e,
                Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight,
              ),
          (this.outdated = !1),
          this
        )
      }
      toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`
      }
    }
    class qte extends Ute {
      constructor(e) {
        super(e, 0)
      }
      heightMetrics(e, t) {
        let n,
          r = e.doc.lineAt(t).number,
          a = e.doc.lineAt(t + this.length).number,
          o = a - r + 1,
          i = 0
        if (e.lineWrapping) {
          let t = Math.min(this.height, e.lineHeight * o)
          ;(n = t / o), this.length > o + 1 && (i = (this.height - t) / (this.length - o - 1))
        } else n = this.height / o
        return { firstLine: r, lastLine: a, perLine: n, perChar: i }
      }
      blockAt(e, t, n, r) {
        let { firstLine: a, lastLine: o, perLine: i, perChar: s } = this.heightMetrics(t, r)
        if (t.lineWrapping) {
          let a =
              r + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length)),
            o = t.doc.lineAt(a),
            l = i + o.length * s,
            c = Math.max(n, e - l / 2)
          return new Qte(o.from, o.length, c, l, 0)
        }
        {
          let r = Math.max(0, Math.min(o - a, Math.floor((e - n) / i))),
            { from: s, length: l } = t.doc.line(a + r)
          return new Qte(s, l, n + i * r, i, 0)
        }
      }
      lineAt(e, t, n, r, a) {
        if (t == Bte.ByHeight) return this.blockAt(e, n, r, a)
        if (t == Bte.ByPosNoHeight) {
          let { from: t, to: r } = n.doc.lineAt(e)
          return new Qte(t, r - t, 0, 0, 0)
        }
        let { firstLine: o, perLine: i, perChar: s } = this.heightMetrics(n, a),
          l = n.doc.lineAt(e),
          c = i + l.length * s,
          d = l.number - o,
          u = r + i * d + s * (l.from - a - d)
        return new Qte(l.from, l.length, Math.max(r, Math.min(u, r + this.height - c)), c, 0)
      }
      forEachLine(e, t, n, r, a, o) {
        ;(e = Math.max(e, a)), (t = Math.min(t, a + this.length))
        let { firstLine: i, perLine: s, perChar: l } = this.heightMetrics(n, a)
        for (let c = e, d = r; c <= t; ) {
          let t = n.doc.lineAt(c)
          if (c == e) {
            let n = t.number - i
            d += s * n + l * (e - a - n)
          }
          let r = s + l * t.length
          o(new Qte(t.from, t.length, d, r, 0)), (d += r), (c = t.to + 1)
        }
      }
      replace(e, t, n) {
        let r = this.length - t
        if (r > 0) {
          let e = n[n.length - 1]
          e instanceof qte ? (n[n.length - 1] = new qte(e.length + r)) : n.push(null, new qte(r - 1))
        }
        if (e > 0) {
          let t = n[0]
          t instanceof qte ? (n[0] = new qte(e + t.length)) : n.unshift(new qte(e - 1), null)
        }
        return Ute.of(n)
      }
      decomposeLeft(e, t) {
        t.push(new qte(e - 1), null)
      }
      decomposeRight(e, t) {
        t.push(null, new qte(this.length - e - 1))
      }
      updateHeight(e, t = 0, n = !1, r) {
        let a = t + this.length
        if (r && r.from <= t + this.length && r.more) {
          let n = [],
            o = Math.max(t, r.from),
            i = -1
          for (r.from > t && n.push(new qte(r.from - t - 1).updateHeight(e, t)); o <= a && r.more; ) {
            let t = e.doc.lineAt(o).length
            n.length && n.push(null)
            let a = r.heights[r.index++]
            ;-1 == i ? (i = a) : Math.abs(a - i) >= jte && (i = -2)
            let s = new zte(t, a)
            ;(s.outdated = !1), n.push(s), (o += t + 1)
          }
          o <= a && n.push(null, new qte(a - o).updateHeight(e, o))
          let s = Ute.of(n)
          return (
            (i < 0 ||
              Math.abs(s.height - this.height) >= jte ||
              Math.abs(i - this.heightMetrics(e, t).perLine) >= jte) &&
              (e.heightChanged = !0),
            s
          )
        }
        return (
          (n || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), (this.outdated = !1)), this
        )
      }
      toString() {
        return `gap(${this.length})`
      }
    }
    class Zte extends Ute {
      constructor(e, t, n) {
        super(e.length + t + n.length, e.height + n.height, t | (e.outdated || n.outdated ? 2 : 0)),
          (this.left = e),
          (this.right = n),
          (this.size = e.size + n.size)
      }
      get break() {
        return 1 & this.flags
      }
      blockAt(e, t, n, r) {
        let a = n + this.left.height
        return e < a ? this.left.blockAt(e, t, n, r) : this.right.blockAt(e, t, a, r + this.left.length + this.break)
      }
      lineAt(e, t, n, r, a) {
        let o = r + this.left.height,
          i = a + this.left.length + this.break,
          s = t == Bte.ByHeight ? e < o : e < i,
          l = s ? this.left.lineAt(e, t, n, r, a) : this.right.lineAt(e, t, n, o, i)
        if (this.break || (s ? l.to < i : l.from > i)) return l
        let c = t == Bte.ByPosNoHeight ? Bte.ByPosNoHeight : Bte.ByPos
        return s ? l.join(this.right.lineAt(i, c, n, o, i)) : this.left.lineAt(i, c, n, r, a).join(l)
      }
      forEachLine(e, t, n, r, a, o) {
        let i = r + this.left.height,
          s = a + this.left.length + this.break
        if (this.break)
          e < s && this.left.forEachLine(e, t, n, r, a, o), t >= s && this.right.forEachLine(e, t, n, i, s, o)
        else {
          let l = this.lineAt(s, Bte.ByPos, n, r, a)
          e < l.from && this.left.forEachLine(e, l.from - 1, n, r, a, o),
            l.to >= e && l.from <= t && o(l),
            t > l.to && this.right.forEachLine(l.to + 1, t, n, i, s, o)
        }
      }
      replace(e, t, n) {
        let r = this.left.length + this.break
        if (t < r) return this.balanced(this.left.replace(e, t, n), this.right)
        if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - r, t - r, n))
        let a = []
        e > 0 && this.decomposeLeft(e, a)
        let o = a.length
        for (let e of n) a.push(e)
        if ((e > 0 && Hte(a, o - 1), t < this.length)) {
          let e = a.length
          this.decomposeRight(t, a), Hte(a, e)
        }
        return Ute.of(a)
      }
      decomposeLeft(e, t) {
        let n = this.left.length
        if (e <= n) return this.left.decomposeLeft(e, t)
        t.push(this.left), this.break && (n++, e >= n && t.push(null)), e > n && this.right.decomposeLeft(e - n, t)
      }
      decomposeRight(e, t) {
        let n = this.left.length,
          r = n + this.break
        if (e >= r) return this.right.decomposeRight(e - r, t)
        e < n && this.left.decomposeRight(e, t), this.break && e < r && t.push(null), t.push(this.right)
      }
      balanced(e, t) {
        return e.size > 2 * t.size || t.size > 2 * e.size
          ? Ute.of(this.break ? [e, null, t] : [e, t])
          : ((this.left = e),
            (this.right = t),
            (this.height = e.height + t.height),
            (this.outdated = e.outdated || t.outdated),
            (this.size = e.size + t.size),
            (this.length = e.length + this.break + t.length),
            this)
      }
      updateHeight(e, t = 0, n = !1, r) {
        let { left: a, right: o } = this,
          i = t + a.length + this.break,
          s = null
        return (
          r && r.from <= t + a.length && r.more ? (s = a = a.updateHeight(e, t, n, r)) : a.updateHeight(e, t, n),
          r && r.from <= i + o.length && r.more ? (s = o = o.updateHeight(e, i, n, r)) : o.updateHeight(e, i, n),
          s ? this.balanced(a, o) : ((this.height = this.left.height + this.right.height), (this.outdated = !1), this)
        )
      }
      toString() {
        return this.left + (this.break ? " " : "-") + this.right
      }
    }
    function Hte(e, t) {
      let n, r
      null == e[t] &&
        (n = e[t - 1]) instanceof qte &&
        (r = e[t + 1]) instanceof qte &&
        e.splice(t - 1, 3, new qte(n.length + 1 + r.length))
    }
    class Vte {
      constructor(e, t) {
        ;(this.pos = e),
          (this.oracle = t),
          (this.nodes = []),
          (this.lineStart = -1),
          (this.lineEnd = -1),
          (this.covering = null),
          (this.writtenTo = e)
      }
      get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering
      }
      span(e, t) {
        if (this.lineStart > -1) {
          let e = Math.min(t, this.lineEnd),
            n = this.nodes[this.nodes.length - 1]
          n instanceof zte
            ? (n.length += e - this.pos)
            : (e > this.pos || !this.isCovered) && this.nodes.push(new zte(e - this.pos, -1)),
            (this.writtenTo = e),
            t > e && (this.nodes.push(null), this.writtenTo++, (this.lineStart = -1))
        }
        this.pos = t
      }
      point(e, t, n) {
        if (e < t || n.heightRelevant) {
          let r = n.widget ? n.widget.estimatedHeight : 0,
            a = n.widget ? n.widget.lineBreaks : 0
          r < 0 && (r = this.oracle.lineHeight)
          let o = t - e
          n.block ? this.addBlock(new Fte(o, r, n)) : (o || a || r >= 5) && this.addLineDeco(r, a, o)
        } else t > e && this.span(e, t)
        this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to)
      }
      enterLine() {
        if (this.lineStart > -1) return
        let { from: e, to: t } = this.oracle.doc.lineAt(this.pos)
        ;(this.lineStart = e),
          (this.lineEnd = t),
          this.writtenTo < e &&
            ((this.writtenTo < e - 1 || null == this.nodes[this.nodes.length - 1]) &&
              this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
            this.nodes.push(null)),
          this.pos > e && this.nodes.push(new zte(this.pos - e, -1)),
          (this.writtenTo = this.pos)
      }
      blankContent(e, t) {
        let n = new qte(t - e)
        return this.oracle.doc.lineAt(e).to == t && (n.flags |= 4), n
      }
      ensureLine() {
        this.enterLine()
        let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null
        if (e instanceof zte) return e
        let t = new zte(0, -1)
        return this.nodes.push(t), t
      }
      addBlock(e) {
        this.enterLine()
        let t = e.deco
        t && t.startSide > 0 && !this.isCovered && this.ensureLine(),
          this.nodes.push(e),
          (this.writtenTo = this.pos = this.pos + e.length),
          t && t.endSide > 0 && (this.covering = e)
      }
      addLineDeco(e, t, n) {
        let r = this.ensureLine()
        ;(r.length += n),
          (r.collapsed += n),
          (r.widgetHeight = Math.max(r.widgetHeight, e)),
          (r.breaks += t),
          (this.writtenTo = this.pos = this.pos + n)
      }
      finish(e) {
        let t = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1]
        !(this.lineStart > -1) || t instanceof zte || this.isCovered
          ? (this.writtenTo < this.pos || null == t) && this.nodes.push(this.blankContent(this.writtenTo, this.pos))
          : this.nodes.push(new zte(0, -1))
        let n = e
        for (let e of this.nodes) e instanceof zte && e.updateHeight(this.oracle, n), (n += e ? e.length : 1)
        return this.nodes
      }
      static build(e, t, n, r) {
        let a = new Vte(n, e)
        return h6.spans(t, n, r, a, 0), a.finish(n)
      }
    }
    class Wte {
      constructor() {
        this.changes = []
      }
      compareRange() {}
      comparePoint(e, t, n, r) {
        ;(e < t || (n && n.heightRelevant) || (r && r.heightRelevant)) && H9(e, t, this.changes, 5)
      }
    }
    function Xte(e, t) {
      let n = e.getBoundingClientRect(),
        r = e.ownerDocument,
        a = r.defaultView || window,
        o = Math.max(0, n.left),
        i = Math.min(a.innerWidth, n.right),
        s = Math.max(0, n.top),
        l = Math.min(a.innerHeight, n.bottom)
      for (let t = e.parentNode; t && t != r.body; )
        if (1 == t.nodeType) {
          let n = t,
            r = window.getComputedStyle(n)
          if ((n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth) && "visible" != r.overflow) {
            let r = n.getBoundingClientRect()
            ;(o = Math.max(o, r.left)),
              (i = Math.min(i, r.right)),
              (s = Math.max(s, r.top)),
              (l = t == e.parentNode ? r.bottom : Math.min(l, r.bottom))
          }
          t = "absolute" == r.position || "fixed" == r.position ? n.offsetParent : n.parentNode
        } else {
          if (11 != t.nodeType) break
          t = t.host
        }
      return {
        left: o - n.left,
        right: Math.max(o, i) - n.left,
        top: s - (n.top + t),
        bottom: Math.max(s, l) - (n.top + t),
      }
    }
    function Yte(e, t) {
      let n = e.getBoundingClientRect()
      return { left: 0, right: n.right - n.left, top: t, bottom: n.bottom - (n.top + t) }
    }
    class Gte {
      constructor(e, t, n) {
        ;(this.from = e), (this.to = t), (this.size = n)
      }
      static same(e, t) {
        if (e.length != t.length) return !1
        for (let n = 0; n < e.length; n++) {
          let r = e[n],
            a = t[n]
          if (r.from != a.from || r.to != a.to || r.size != a.size) return !1
        }
        return !0
      }
      draw(e, t) {
        return U9.replace({ widget: new Kte(this.size * (t ? e.scaleY : e.scaleX), t) }).range(this.from, this.to)
      }
    }
    class Kte extends B9 {
      constructor(e, t) {
        super(), (this.size = e), (this.vertical = t)
      }
      eq(e) {
        return e.size == this.size && e.vertical == this.vertical
      }
      toDOM() {
        let e = document.createElement("div")
        return (
          this.vertical
            ? (e.style.height = this.size + "px")
            : ((e.style.width = this.size + "px"), (e.style.height = "2px"), (e.style.display = "inline-block")),
          e
        )
      }
      get estimatedHeight() {
        return this.vertical ? this.size : -1
      }
    }
    class Jte {
      constructor(e) {
        ;(this.state = e),
          (this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }),
          (this.inView = !0),
          (this.paddingTop = 0),
          (this.paddingBottom = 0),
          (this.contentDOMWidth = 0),
          (this.contentDOMHeight = 0),
          (this.editorHeight = 0),
          (this.editorWidth = 0),
          (this.scrollTop = 0),
          (this.scrolledToBottom = !1),
          (this.scaleX = 1),
          (this.scaleY = 1),
          (this.scrollAnchorPos = 0),
          (this.scrollAnchorHeight = -1),
          (this.scaler = rne),
          (this.scrollTarget = null),
          (this.printing = !1),
          (this.mustMeasureContent = !0),
          (this.defaultTextDirection = Y9.LTR),
          (this.visibleRanges = []),
          (this.mustEnforceCursorAssoc = !1)
        let t = e.facet(Iee).some((e) => "function" != typeof e && "cm-lineWrapping" == e.class)
        ;(this.heightOracle = new Mte(t)),
          (this.stateDeco = e.facet(Mee).filter((e) => "function" != typeof e)),
          (this.heightMap = Ute.empty().applyChanges(this.stateDeco, F8.empty, this.heightOracle.setDoc(e.doc), [
            new qee(0, 0, 0, e.doc.length),
          ]))
        for (let e = 0; e < 2 && ((this.viewport = this.getViewport(0, null)), this.updateForViewport()); e++);
        this.updateViewportLines(),
          (this.lineGaps = this.ensureLineGaps([])),
          (this.lineGapDeco = U9.set(this.lineGaps.map((e) => e.draw(this, !1)))),
          this.computeVisibleRanges()
      }
      updateForViewport() {
        let e = [this.viewport],
          { main: t } = this.state.selection
        for (let n = 0; n <= 1; n++) {
          let r = n ? t.head : t.anchor
          if (!e.some(({ from: e, to: t }) => r >= e && r <= t)) {
            let { from: t, to: n } = this.lineBlockAt(r)
            e.push(new ene(t, n))
          }
        }
        return (this.viewports = e.sort((e, t) => e.from - t.from)), this.updateScaler()
      }
      updateScaler() {
        let e = this.scaler
        return (
          (this.scaler =
            this.heightMap.height <= 7e6 ? rne : new ane(this.heightOracle, this.heightMap, this.viewports)),
          e.eq(this.scaler) ? 0 : 2
        )
      }
      updateViewportLines() {
        ;(this.viewportLines = []),
          this.heightMap.forEachLine(
            this.viewport.from,
            this.viewport.to,
            this.heightOracle.setDoc(this.state.doc),
            0,
            0,
            (e) => {
              this.viewportLines.push(one(e, this.scaler))
            },
          )
      }
      update(e, t = null) {
        this.state = e.state
        let n = this.stateDeco
        this.stateDeco = this.state.facet(Mee).filter((e) => "function" != typeof e)
        let r = e.changedRanges,
          a = qee.extendWithRanges(
            r,
            (function (e, t, n) {
              let r = new Wte()
              return h6.compare(e, t, n, r, 0), r.changes
            })(n, this.stateDeco, e ? e.changes : h7.empty(this.state.doc.length)),
          ),
          o = this.heightMap.height,
          i = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop)
        ;(this.heightMap = this.heightMap.applyChanges(
          this.stateDeco,
          e.startState.doc,
          this.heightOracle.setDoc(this.state.doc),
          a,
        )),
          this.heightMap.height != o && (e.flags |= 2),
          i
            ? ((this.scrollAnchorPos = e.changes.mapPos(i.from, -1)), (this.scrollAnchorHeight = i.top))
            : ((this.scrollAnchorPos = -1), (this.scrollAnchorHeight = this.heightMap.height))
        let s = a.length ? this.mapViewport(this.viewport, e.changes) : this.viewport
        ;((t && (t.range.head < s.from || t.range.head > s.to)) || !this.viewportIsAppropriate(s)) &&
          (s = this.getViewport(0, t))
        let l = s.from != this.viewport.from || s.to != this.viewport.to
        ;(this.viewport = s),
          (e.flags |= this.updateForViewport()),
          (l || !e.changes.empty || 2 & e.flags) && this.updateViewportLines(),
          (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
          (e.flags |= this.computeVisibleRanges()),
          t && (this.scrollTarget = t),
          !this.mustEnforceCursorAssoc &&
            e.selectionSet &&
            e.view.lineWrapping &&
            e.state.selection.main.empty &&
            e.state.selection.main.assoc &&
            !e.state.facet(kee) &&
            (this.mustEnforceCursorAssoc = !0)
      }
      measure(e) {
        let t = e.contentDOM,
          n = window.getComputedStyle(t),
          r = this.heightOracle,
          a = n.whiteSpace
        this.defaultTextDirection = "rtl" == n.direction ? Y9.RTL : Y9.LTR
        let o = this.heightOracle.mustRefreshForWrapping(a),
          i = t.getBoundingClientRect(),
          s = o || this.mustMeasureContent || this.contentDOMHeight != i.height
        ;(this.contentDOMHeight = i.height), (this.mustMeasureContent = !1)
        let l = 0,
          c = 0
        if (i.width && i.height) {
          let { scaleX: e, scaleY: n } = X6(t, i)
          ;((e > 0.005 && Math.abs(this.scaleX - e) > 0.005) || (n > 0.005 && Math.abs(this.scaleY - n) > 0.005)) &&
            ((this.scaleX = e), (this.scaleY = n), (l |= 8), (o = s = !0))
        }
        let d = (parseInt(n.paddingTop) || 0) * this.scaleY,
          u = (parseInt(n.paddingBottom) || 0) * this.scaleY
        ;(this.paddingTop == d && this.paddingBottom == u) ||
          ((this.paddingTop = d), (this.paddingBottom = u), (l |= 10)),
          this.editorWidth != e.scrollDOM.clientWidth &&
            (r.lineWrapping && (s = !0), (this.editorWidth = e.scrollDOM.clientWidth), (l |= 8))
        let p = e.scrollDOM.scrollTop * this.scaleY
        this.scrollTop != p && ((this.scrollAnchorHeight = -1), (this.scrollTop = p)),
          (this.scrolledToBottom = r9(e.scrollDOM))
        let h = (this.printing ? Yte : Xte)(t, this.paddingTop),
          f = h.top - this.pixelViewport.top,
          m = h.bottom - this.pixelViewport.bottom
        this.pixelViewport = h
        let g = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left
        if ((g != this.inView && ((this.inView = g), g && (s = !0)), !this.inView && !this.scrollTarget)) return 0
        let b = i.width
        if (
          ((this.contentDOMWidth == b && this.editorHeight == e.scrollDOM.clientHeight) ||
            ((this.contentDOMWidth = i.width), (this.editorHeight = e.scrollDOM.clientHeight), (l |= 8)),
          s)
        ) {
          let t = e.docView.measureVisibleLineHeights(this.viewport)
          if (
            (r.mustRefreshForHeights(t) && (o = !0),
            o || (r.lineWrapping && Math.abs(b - this.contentDOMWidth) > r.charWidth))
          ) {
            let { lineHeight: n, charWidth: i, textHeight: s } = e.docView.measureTextSize()
            ;(o = n > 0 && r.refresh(a, n, i, s, b / i, t)), o && ((e.docView.minWidth = 0), (l |= 8))
          }
          f > 0 && m > 0 ? (c = Math.max(f, m)) : f < 0 && m < 0 && (c = Math.min(f, m)), (r.heightChanged = !1)
          for (let n of this.viewports) {
            let a = n.from == this.viewport.from ? t : e.docView.measureVisibleLineHeights(n)
            this.heightMap = (
              o
                ? Ute.empty().applyChanges(this.stateDeco, F8.empty, this.heightOracle, [
                    new qee(0, 0, 0, e.state.doc.length),
                  ])
                : this.heightMap
            ).updateHeight(r, 0, o, new Lte(n.from, a))
          }
          r.heightChanged && (l |= 2)
        }
        let v =
          !this.viewportIsAppropriate(this.viewport, c) ||
          (this.scrollTarget &&
            (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to))
        return (
          v &&
            (2 & l && (l |= this.updateScaler()),
            (this.viewport = this.getViewport(c, this.scrollTarget)),
            (l |= this.updateForViewport())),
          (2 & l || v) && this.updateViewportLines(),
          (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
            this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)),
          (l |= this.computeVisibleRanges()),
          this.mustEnforceCursorAssoc && ((this.mustEnforceCursorAssoc = !1), e.docView.enforceCursorAssoc()),
          l
        )
      }
      get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top)
      }
      get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom)
      }
      getViewport(e, t) {
        let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
          r = this.heightMap,
          a = this.heightOracle,
          { visibleTop: o, visibleBottom: i } = this,
          s = new ene(
            r.lineAt(o - 1e3 * n, Bte.ByHeight, a, 0, 0).from,
            r.lineAt(i + 1e3 * (1 - n), Bte.ByHeight, a, 0, 0).to,
          )
        if (t) {
          let { head: e } = t.range
          if (e < s.from || e > s.to) {
            let n,
              o = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top),
              i = r.lineAt(e, Bte.ByPos, a, 0, 0)
            ;(n =
              "center" == t.y
                ? (i.top + i.bottom) / 2 - o / 2
                : "start" == t.y || ("nearest" == t.y && e < s.from)
                  ? i.top
                  : i.bottom - o),
              (s = new ene(
                r.lineAt(n - 500, Bte.ByHeight, a, 0, 0).from,
                r.lineAt(n + o + 500, Bte.ByHeight, a, 0, 0).to,
              ))
          }
        }
        return s
      }
      mapViewport(e, t) {
        let n = t.mapPos(e.from, -1),
          r = t.mapPos(e.to, 1)
        return new ene(
          this.heightMap.lineAt(n, Bte.ByPos, this.heightOracle, 0, 0).from,
          this.heightMap.lineAt(r, Bte.ByPos, this.heightOracle, 0, 0).to,
        )
      }
      viewportIsAppropriate({ from: e, to: t }, n = 0) {
        if (!this.inView) return !0
        let { top: r } = this.heightMap.lineAt(e, Bte.ByPos, this.heightOracle, 0, 0),
          { bottom: a } = this.heightMap.lineAt(t, Bte.ByPos, this.heightOracle, 0, 0),
          { visibleTop: o, visibleBottom: i } = this
        return (
          (0 == e || r <= o - Math.max(10, Math.min(-n, 250))) &&
          (t == this.state.doc.length || a >= i + Math.max(10, Math.min(n, 250))) &&
          r > o - 2e3 &&
          a < i + 2e3
        )
      }
      mapLineGaps(e, t) {
        if (!e.length || t.empty) return e
        let n = []
        for (let r of e) t.touchesRange(r.from, r.to) || n.push(new Gte(t.mapPos(r.from), t.mapPos(r.to), r.size))
        return n
      }
      ensureLineGaps(e, t) {
        let n = this.heightOracle.lineWrapping,
          r = n ? 1e4 : 2e3,
          a = r >> 1,
          o = r << 1
        if (this.defaultTextDirection != Y9.LTR && !n) return []
        let i = [],
          s = (r, o, l, c) => {
            if (o - r < a) return
            let d = this.state.selection.main,
              u = [d.from]
            d.empty || u.push(d.to)
            for (let e of u) if (e > r && e < o) return s(r, e - 10, l, c), void s(e + 10, o, l, c)
            let p = (function (e, t) {
              for (let n of e) if (t(n)) return n
            })(
              e,
              (e) =>
                e.from >= l.from &&
                e.to <= l.to &&
                Math.abs(e.from - r) < a &&
                Math.abs(e.to - o) < a &&
                !u.some((t) => e.from < t && e.to > t),
            )
            if (!p) {
              if (o < l.to && t && n && t.visibleRanges.some((e) => e.from <= o && e.to >= o)) {
                let e = t.moveToLineBoundary(w7.cursor(o), !1, !0).head
                e > r && (o = e)
              }
              p = new Gte(r, o, this.gapSize(l, r, o, c))
            }
            i.push(p)
          },
          l = (e) => {
            if (e.length < o || e.type != j9.Text) return
            let t = (function (e, t, n) {
              let r = [],
                a = e,
                o = 0
              return (
                h6.spans(
                  n,
                  e,
                  t,
                  {
                    span() {},
                    point(e, t) {
                      e > a && (r.push({ from: a, to: e }), (o += e - a)), (a = t)
                    },
                  },
                  20,
                ),
                a < t && (r.push({ from: a, to: t }), (o += t - a)),
                { total: o, ranges: r }
              )
            })(e.from, e.to, this.stateDeco)
            if (t.total < o) return
            let a,
              i,
              l = this.scrollTarget ? this.scrollTarget.range.head : null
            if (n) {
              let n,
                o,
                s = (r / this.heightOracle.lineLength) * this.heightOracle.lineHeight
              if (null != l) {
                let r = nne(t, l),
                  a = ((this.visibleBottom - this.visibleTop) / 2 + s) / e.height
                ;(n = r - a), (o = r + a)
              } else (n = (this.visibleTop - e.top - s) / e.height), (o = (this.visibleBottom - e.top + s) / e.height)
              ;(a = tne(t, n)), (i = tne(t, o))
            } else {
              let e,
                n,
                o = t.total * this.heightOracle.charWidth,
                s = r * this.heightOracle.charWidth
              if (null != l) {
                let r = nne(t, l),
                  a = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + s) / o
                ;(e = r - a), (n = r + a)
              } else (e = (this.pixelViewport.left - s) / o), (n = (this.pixelViewport.right + s) / o)
              ;(a = tne(t, e)), (i = tne(t, n))
            }
            a > e.from && s(e.from, a, e, t), i < e.to && s(i, e.to, e, t)
          }
        for (let e of this.viewportLines) Array.isArray(e.type) ? e.type.forEach(l) : l(e)
        return i
      }
      gapSize(e, t, n, r) {
        let a = nne(r, n) - nne(r, t)
        return this.heightOracle.lineWrapping ? e.height * a : r.total * this.heightOracle.charWidth * a
      }
      updateLineGaps(e) {
        Gte.same(e, this.lineGaps) ||
          ((this.lineGaps = e), (this.lineGapDeco = U9.set(e.map((e) => e.draw(this, this.heightOracle.lineWrapping)))))
      }
      computeVisibleRanges() {
        let e = this.stateDeco
        this.lineGaps.length && (e = e.concat(this.lineGapDeco))
        let t = []
        h6.spans(
          e,
          this.viewport.from,
          this.viewport.to,
          {
            span(e, n) {
              t.push({ from: e, to: n })
            },
            point() {},
          },
          20,
        )
        let n =
          t.length != this.visibleRanges.length ||
          this.visibleRanges.some((e, n) => e.from != t[n].from || e.to != t[n].to)
        return (this.visibleRanges = t), n ? 4 : 0
      }
      lineBlockAt(e) {
        return (
          (e >= this.viewport.from &&
            e <= this.viewport.to &&
            this.viewportLines.find((t) => t.from <= e && t.to >= e)) ||
          one(this.heightMap.lineAt(e, Bte.ByPos, this.heightOracle, 0, 0), this.scaler)
        )
      }
      lineBlockAtHeight(e) {
        return (
          (e >= this.viewportLines[0].top &&
            e <= this.viewportLines[this.viewportLines.length - 1].bottom &&
            this.viewportLines.find((t) => t.top <= e && t.bottom >= e)) ||
          one(this.heightMap.lineAt(this.scaler.fromDOM(e), Bte.ByHeight, this.heightOracle, 0, 0), this.scaler)
        )
      }
      scrollAnchorAt(e) {
        let t = this.lineBlockAtHeight(e + 8)
        return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0]
      }
      elementAtHeight(e) {
        return one(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler)
      }
      get docHeight() {
        return this.scaler.toDOM(this.heightMap.height)
      }
      get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom
      }
    }
    class ene {
      constructor(e, t) {
        ;(this.from = e), (this.to = t)
      }
    }
    function tne({ total: e, ranges: t }, n) {
      if (n <= 0) return t[0].from
      if (n >= 1) return t[t.length - 1].to
      let r = Math.floor(e * n)
      for (let e = 0; ; e++) {
        let { from: n, to: a } = t[e],
          o = a - n
        if (r <= o) return n + r
        r -= o
      }
    }
    function nne(e, t) {
      let n = 0
      for (let { from: r, to: a } of e.ranges) {
        if (t <= a) {
          n += t - r
          break
        }
        n += a - r
      }
      return n / e.total
    }
    const rne = {
      toDOM: (e) => e,
      fromDOM: (e) => e,
      scale: 1,
      eq(e) {
        return e == this
      },
    }
    class ane {
      constructor(e, t, n) {
        let r = 0,
          a = 0,
          o = 0
        ;(this.viewports = n.map(({ from: n, to: a }) => {
          let o = t.lineAt(n, Bte.ByPos, e, 0, 0).top,
            i = t.lineAt(a, Bte.ByPos, e, 0, 0).bottom
          return (r += i - o), { from: n, to: a, top: o, bottom: i, domTop: 0, domBottom: 0 }
        })),
          (this.scale = (7e6 - r) / (t.height - r))
        for (let e of this.viewports)
          (e.domTop = o + (e.top - a) * this.scale), (o = e.domBottom = e.domTop + (e.bottom - e.top)), (a = e.bottom)
      }
      toDOM(e) {
        for (let t = 0, n = 0, r = 0; ; t++) {
          let a = t < this.viewports.length ? this.viewports[t] : null
          if (!a || e < a.top) return r + (e - n) * this.scale
          if (e <= a.bottom) return a.domTop + (e - a.top)
          ;(n = a.bottom), (r = a.domBottom)
        }
      }
      fromDOM(e) {
        for (let t = 0, n = 0, r = 0; ; t++) {
          let a = t < this.viewports.length ? this.viewports[t] : null
          if (!a || e < a.domTop) return n + (e - r) / this.scale
          if (e <= a.domBottom) return a.top + (e - a.domTop)
          ;(n = a.bottom), (r = a.domBottom)
        }
      }
      eq(e) {
        return (
          e instanceof ane &&
          this.scale == e.scale &&
          this.viewports.length == e.viewports.length &&
          this.viewports.every((t, n) => t.from == e.viewports[n].from && t.to == e.viewports[n].to)
        )
      }
    }
    function one(e, t) {
      if (1 == t.scale) return e
      let n = t.toDOM(e.top),
        r = t.toDOM(e.bottom)
      return new Qte(
        e.from,
        e.length,
        n,
        r - n,
        Array.isArray(e._content) ? e._content.map((e) => one(e, t)) : e._content,
      )
    }
    const ine = _7.define({ combine: (e) => e.join(" ") }),
      sne = _7.define({ combine: (e) => e.indexOf(!0) > -1 }),
      lne = C6.newName(),
      cne = C6.newName(),
      dne = C6.newName(),
      une = { "&light": "." + cne, "&dark": "." + dne }
    function pne(e, t, n) {
      return new C6(t, {
        finish: (t) =>
          /&/.test(t)
            ? t.replace(/&\w*/, (t) => {
                if ("&" == t) return e
                if (!n || !n[t]) throw new RangeError(`Unsupported selector: ${t}`)
                return n[t]
              })
            : e + " " + t,
      })
    }
    const hne = pne(
        "." + lne,
        {
          "&": {
            position: "relative !important",
            boxSizing: "border-box",
            "&.cm-focused": { outline: "1px dotted #212121" },
            display: "flex !important",
            flexDirection: "column",
          },
          ".cm-scroller": {
            display: "flex !important",
            alignItems: "flex-start !important",
            fontFamily: "monospace",
            lineHeight: 1.4,
            height: "100%",
            overflowX: "auto",
            position: "relative",
            zIndex: 0,
          },
          ".cm-content": {
            margin: 0,
            flexGrow: 2,
            flexShrink: 0,
            display: "block",
            whiteSpace: "pre",
            wordWrap: "normal",
            boxSizing: "border-box",
            minHeight: "100%",
            padding: "4px 0",
            outline: "none",
            "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" },
          },
          ".cm-lineWrapping": {
            whiteSpace_fallback: "pre-wrap",
            whiteSpace: "break-spaces",
            wordBreak: "break-word",
            overflowWrap: "anywhere",
            flexShrink: 1,
          },
          "&light .cm-content": { caretColor: "black" },
          "&dark .cm-content": { caretColor: "white" },
          ".cm-line": { display: "block", padding: "0 2px 0 6px" },
          ".cm-layer": {
            position: "absolute",
            left: 0,
            top: 0,
            contain: "size style",
            "& > *": { position: "absolute" },
          },
          "&light .cm-selectionBackground": { background: "#d9d9d9" },
          "&dark .cm-selectionBackground": { background: "#222" },
          "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" },
          "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" },
          ".cm-cursorLayer": { pointerEvents: "none" },
          "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" },
          "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
          "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
          ".cm-cursor, .cm-dropCursor": {
            borderLeft: "1.2px solid black",
            marginLeft: "-0.6px",
            pointerEvents: "none",
          },
          ".cm-cursor": { display: "none" },
          "&dark .cm-cursor": { borderLeftColor: "#444" },
          ".cm-dropCursor": { position: "absolute" },
          "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" },
          ".cm-iso": { unicodeBidi: "isolate" },
          ".cm-announced": { position: "fixed", top: "-10000px" },
          "@media print": { ".cm-announced": { display: "none" } },
          "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
          "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
          "&light .cm-specialChar": { color: "red" },
          "&dark .cm-specialChar": { color: "#f78" },
          ".cm-gutters": {
            flexShrink: 0,
            display: "flex",
            height: "100%",
            boxSizing: "border-box",
            insetInlineStart: 0,
            zIndex: 200,
          },
          "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" },
          "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" },
          ".cm-gutter": {
            display: "flex !important",
            flexDirection: "column",
            flexShrink: 0,
            boxSizing: "border-box",
            minHeight: "100%",
            overflow: "hidden",
          },
          ".cm-gutterElement": { boxSizing: "border-box" },
          ".cm-lineNumbers .cm-gutterElement": {
            padding: "0 3px 0 5px",
            minWidth: "20px",
            textAlign: "right",
            whiteSpace: "nowrap",
          },
          "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" },
          "&dark .cm-activeLineGutter": { backgroundColor: "#222227" },
          ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 },
          "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" },
          "&light .cm-panels-top": { borderBottom: "1px solid #ddd" },
          "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" },
          "&dark .cm-panels": { backgroundColor: "#333338", color: "white" },
          ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" },
          ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" },
          ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" },
          ".cm-highlightSpace:before": {
            content: "attr(data-display)",
            position: "absolute",
            pointerEvents: "none",
            color: "#888",
          },
          ".cm-highlightTab": {
            backgroundImage:
              'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>\')',
            backgroundSize: "auto 100%",
            backgroundPosition: "right 90%",
            backgroundRepeat: "no-repeat",
          },
          ".cm-trailingSpace": { backgroundColor: "#ff332255" },
          ".cm-button": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            padding: ".2em 1em",
            borderRadius: "1px",
          },
          "&light .cm-button": {
            backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
            border: "1px solid #888",
            "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" },
          },
          "&dark .cm-button": {
            backgroundImage: "linear-gradient(#393939, #111)",
            border: "1px solid #888",
            "&:active": { backgroundImage: "linear-gradient(#111, #333)" },
          },
          ".cm-textfield": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            border: "1px solid silver",
            padding: ".2em .5em",
          },
          "&light .cm-textfield": { backgroundColor: "white" },
          "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" },
        },
        une,
      ),
      fne = ""
    class mne {
      constructor(e, t) {
        ;(this.points = e), (this.text = ""), (this.lineSeparator = t.facet(s6.lineSeparator))
      }
      append(e) {
        this.text += e
      }
      lineBreak() {
        this.text += fne
      }
      readRange(e, t) {
        if (!e) return this
        let n = e.parentNode
        for (let r = e; ; ) {
          this.findPointBefore(n, r)
          let e = this.text.length
          this.readNode(r)
          let a = r.nextSibling
          if (a == t) break
          let o = l9.get(r),
            i = l9.get(a)
          ;(o && i
            ? o.breakAfter
            : (o ? o.breakAfter : q6(r)) || (q6(a) && ("BR" != r.nodeName || r.cmIgnore) && this.text.length > e)) &&
            this.lineBreak(),
            (r = a)
        }
        return this.findPointBefore(n, t), this
      }
      readTextNode(e) {
        let t = e.nodeValue
        for (let n of this.points) n.node == e && (n.pos = this.text.length + Math.min(n.offset, t.length))
        for (let n = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
          let a,
            o = -1,
            i = 1
          if (
            (this.lineSeparator
              ? ((o = t.indexOf(this.lineSeparator, n)), (i = this.lineSeparator.length))
              : (a = r.exec(t)) && ((o = a.index), (i = a[0].length)),
            this.append(t.slice(n, o < 0 ? t.length : o)),
            o < 0)
          )
            break
          if ((this.lineBreak(), i > 1))
            for (let t of this.points) t.node == e && t.pos > this.text.length && (t.pos -= i - 1)
          n = o + i
        }
      }
      readNode(e) {
        if (e.cmIgnore) return
        let t = l9.get(e),
          n = t && t.overrideDOMText
        if (null != n) {
          this.findPointInside(e, n.length)
          for (let e = n.iter(); !e.next().done; ) e.lineBreak ? this.lineBreak() : this.append(e.value)
        } else
          3 == e.nodeType
            ? this.readTextNode(e)
            : "BR" == e.nodeName
              ? e.nextSibling && this.lineBreak()
              : 1 == e.nodeType && this.readRange(e.firstChild, null)
      }
      findPointBefore(e, t) {
        for (let n of this.points) n.node == e && e.childNodes[n.offset] == t && (n.pos = this.text.length)
      }
      findPointInside(e, t) {
        for (let n of this.points)
          (3 == e.nodeType ? n.node == e : e.contains(n.node)) &&
            (n.pos = this.text.length + (gne(e, n.node, n.offset) ? t : 0))
      }
    }
    function gne(e, t, n) {
      for (;;) {
        if (!t || n < H6(t)) return !1
        if (t == e) return !0
        ;(n = z6(t) + 1), (t = t.parentNode)
      }
    }
    class bne {
      constructor(e, t) {
        ;(this.node = e), (this.offset = t), (this.pos = -1)
      }
    }
    class vne {
      constructor(e, t, n, r) {
        ;(this.typeOver = r), (this.bounds = null), (this.text = ""), (this.domChanged = t > -1)
        let { impreciseHead: a, impreciseAnchor: o } = e.docView
        if (e.state.readOnly && t > -1) this.newSel = null
        else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, n, 0))) {
          let t =
              a || o
                ? []
                : (function (e) {
                    let t = []
                    if (e.root.activeElement != e.contentDOM) return t
                    let { anchorNode: n, anchorOffset: r, focusNode: a, focusOffset: o } = e.observer.selectionRange
                    return n && (t.push(new bne(n, r)), (a == n && o == r) || t.push(new bne(a, o))), t
                  })(e),
            n = new mne(t, e.state)
          n.readRange(this.bounds.startDOM, this.bounds.endDOM),
            (this.text = n.text),
            (this.newSel = (function (e, t) {
              if (0 == e.length) return null
              let n = e[0].pos,
                r = 2 == e.length ? e[1].pos : n
              return n > -1 && r > -1 ? w7.single(n + t, r + t) : null
            })(t, this.bounds.from))
        } else {
          let t = e.observer.selectionRange,
            n =
              (a && a.node == t.focusNode && a.offset == t.focusOffset) || !B6(e.contentDOM, t.focusNode)
                ? e.state.selection.main.head
                : e.docView.posFromDOM(t.focusNode, t.focusOffset),
            r =
              (o && o.node == t.anchorNode && o.offset == t.anchorOffset) || !B6(e.contentDOM, t.anchorNode)
                ? e.state.selection.main.anchor
                : e.docView.posFromDOM(t.anchorNode, t.anchorOffset),
            i = e.viewport
          if (
            (_9.ios || _9.chrome) &&
            e.state.selection.main.empty &&
            n != r &&
            (i.from > 0 || i.to < e.state.doc.length)
          ) {
            let t = Math.min(n, r),
              a = Math.max(n, r),
              o = i.from - t,
              s = i.to - a
            ;(0 != o && 1 != o && 0 != t) ||
              (0 != s && -1 != s && a != e.state.doc.length) ||
              ((n = 0), (r = e.state.doc.length))
          }
          this.newSel = w7.single(r, n)
        }
      }
    }
    function yne(e, t) {
      let n,
        { newSel: r } = t,
        a = e.state.selection.main,
        o = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1
      if (t.bounds) {
        let { from: r, to: i } = t.bounds,
          s = a.from,
          l = null
        ;(8 === o || (_9.android && t.text.length < i - r)) && ((s = a.to), (l = "end"))
        let c = (function (e, t, n, r) {
          let a = Math.min(e.length, t.length),
            o = 0
          for (; o < a && e.charCodeAt(o) == t.charCodeAt(o); ) o++
          if (o == a && e.length == t.length) return null
          let i = e.length,
            s = t.length
          for (; i > 0 && s > 0 && e.charCodeAt(i - 1) == t.charCodeAt(s - 1); ) i--, s--
          return (
            "end" == r && (n -= i + Math.max(0, o - Math.min(i, s)) - o),
            i < o && e.length < t.length
              ? ((o -= n <= o && n >= i ? o - n : 0), (s = o + (s - i)), (i = o))
              : s < o && ((o -= n <= o && n >= s ? o - n : 0), (i = o + (i - s)), (s = o)),
            { from: o, toA: i, toB: s }
          )
        })(e.state.doc.sliceString(r, i, fne), t.text, s - r, l)
        c &&
          (_9.chrome && 13 == o && c.toB == c.from + 2 && t.text.slice(c.from, c.toB) == fne + fne && c.toB--,
          (n = { from: r + c.from, to: r + c.toA, insert: F8.of(t.text.slice(c.from, c.toB).split(fne)) }))
      } else r && ((!e.hasFocus && e.state.facet(Cee)) || r.main.eq(a)) && (r = null)
      if (!n && !r) return !1
      if (
        (!n && t.typeOver && !a.empty && r && r.main.empty
          ? (n = { from: a.from, to: a.to, insert: e.state.doc.slice(a.from, a.to) })
          : n &&
              n.from >= a.from &&
              n.to <= a.to &&
              (n.from != a.from || n.to != a.to) &&
              a.to - a.from - (n.to - n.from) <= 4
            ? (n = {
                from: a.from,
                to: a.to,
                insert: e.state.doc.slice(a.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, a.to)),
              })
            : (_9.mac || _9.android) &&
                n &&
                n.from == n.to &&
                n.from == a.head - 1 &&
                /^\. ?$/.test(n.insert.toString()) &&
                "off" == e.contentDOM.getAttribute("autocorrect")
              ? (r && 2 == n.insert.length && (r = w7.single(r.main.anchor - 1, r.main.head - 1)),
                (n = { from: a.from, to: a.to, insert: F8.of([" "]) }))
              : _9.chrome &&
                n &&
                n.from == n.to &&
                n.from == a.head &&
                "\n " == n.insert.toString() &&
                e.lineWrapping &&
                (r && (r = w7.single(r.main.anchor - 1, r.main.head - 1)),
                (n = { from: a.from, to: a.to, insert: F8.of([" "]) })),
        n)
      )
        return One(e, n, r, o)
      if (r && !r.main.eq(a)) {
        let t = !1,
          n = "select"
        return (
          e.inputState.lastSelectionTime > Date.now() - 50 &&
            ("select" == e.inputState.lastSelectionOrigin && (t = !0), (n = e.inputState.lastSelectionOrigin)),
          e.dispatch({ selection: r, scrollIntoView: t, userEvent: n }),
          !0
        )
      }
      return !1
    }
    function One(e, t, n, r = -1) {
      if (_9.ios && e.inputState.flushIOSKey(t)) return !0
      let a = e.state.selection.main
      if (
        _9.android &&
        ((t.to == a.to &&
          (t.from == a.from || (t.from == a.from - 1 && " " == e.state.sliceDoc(t.from, a.from))) &&
          1 == t.insert.length &&
          2 == t.insert.lines &&
          t9(e.contentDOM, "Enter", 13)) ||
          (((t.from == a.from - 1 && t.to == a.to && 0 == t.insert.length) ||
            (8 == r && t.insert.length < t.to - t.from && t.to > a.head)) &&
            t9(e.contentDOM, "Backspace", 8)) ||
          (t.from == a.from && t.to == a.to + 1 && 0 == t.insert.length && t9(e.contentDOM, "Delete", 46)))
      )
        return !0
      let o,
        i = t.insert.toString()
      e.inputState.composing >= 0 && e.inputState.composing++
      let s = () =>
        o ||
        (o = (function (e, t, n) {
          let r,
            a = e.state,
            o = a.selection.main
          if (
            t.from >= o.from &&
            t.to <= o.to &&
            t.to - t.from >= (o.to - o.from) / 3 &&
            (!n || (n.main.empty && n.main.from == t.from + t.insert.length)) &&
            e.inputState.composing < 0
          ) {
            let n = o.from < t.from ? a.sliceDoc(o.from, t.from) : "",
              i = o.to > t.to ? a.sliceDoc(t.to, o.to) : ""
            r = a.replaceSelection(e.state.toText(n + t.insert.sliceString(0, void 0, e.state.lineBreak) + i))
          } else {
            let i = a.changes(t),
              s = n && n.main.to <= i.newLength ? n.main : void 0
            if (a.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= o.to && t.to >= o.to - 10) {
              let l,
                c = e.state.sliceDoc(t.from, t.to),
                d = n && Wee(e, n.main.head)
              if (d) {
                let e = t.insert.length - (t.to - t.from)
                l = { from: d.from, to: d.to - e }
              } else l = e.state.doc.lineAt(o.head)
              let u = o.to - t.to,
                p = o.to - o.from
              r = a.changeByRange((n) => {
                if (n.from == o.from && n.to == o.to) return { changes: i, range: s || n.map(i) }
                let r = n.to - u,
                  d = r - c.length
                if (n.to - n.from != p || e.state.sliceDoc(d, r) != c || (n.to >= l.from && n.from <= l.to))
                  return { range: n }
                let h = a.changes({ from: d, to: r, insert: t.insert }),
                  f = n.to - o.to
                return {
                  changes: h,
                  range: s ? w7.range(Math.max(0, s.anchor + f), Math.max(0, s.head + f)) : n.map(h),
                }
              })
            } else r = { changes: i, selection: s && a.selection.replaceRange(s) }
          }
          let i = "input.type"
          return (
            (e.composing ||
              (e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50)) &&
              ((e.inputState.compositionPendingChange = !1),
              (i += ".compose"),
              e.inputState.compositionFirstChange && ((i += ".start"), (e.inputState.compositionFirstChange = !1))),
            a.update(r, { userEvent: i, scrollIntoView: !0 })
          )
        })(e, t, n))
      return e.state.facet(Oee).some((n) => n(e, t.from, t.to, i, s)) || e.dispatch(s()), !0
    }
    const wne = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 },
      xne = _9.ie && _9.ie_version <= 11
    class kne {
      constructor(e) {
        ;(this.view = e),
          (this.active = !1),
          (this.editContext = null),
          (this.selectionRange = new Y6()),
          (this.selectionChanged = !1),
          (this.delayedFlush = -1),
          (this.resizeTimeout = -1),
          (this.queue = []),
          (this.delayedAndroidKey = null),
          (this.flushingAndroidKey = -1),
          (this.lastChange = 0),
          (this.scrollTargets = []),
          (this.intersection = null),
          (this.resizeScroll = null),
          (this.intersecting = !1),
          (this.gapIntersection = null),
          (this.gaps = []),
          (this.printQuery = null),
          (this.parentCheck = -1),
          (this.dom = e.contentDOM),
          (this.observer = new MutationObserver((t) => {
            for (let e of t) this.queue.push(e)
            ;((_9.ie && _9.ie_version <= 11) || (_9.ios && e.composing)) &&
            t.some(
              (e) =>
                ("childList" == e.type && e.removedNodes.length) ||
                ("characterData" == e.type && e.oldValue.length > e.target.nodeValue.length),
            )
              ? this.flushSoon()
              : this.flush()
          })),
          window.EditContext &&
            !0 === e.constructor.EDIT_CONTEXT &&
            ((this.editContext = new Ene(e)),
            e.state.facet(Cee) && (e.contentDOM.editContext = this.editContext.editContext)),
          xne &&
            (this.onCharData = (e) => {
              this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue }), this.flushSoon()
            }),
          (this.onSelectionChange = this.onSelectionChange.bind(this)),
          (this.onResize = this.onResize.bind(this)),
          (this.onPrint = this.onPrint.bind(this)),
          (this.onScroll = this.onScroll.bind(this)),
          window.matchMedia && (this.printQuery = window.matchMedia("print")),
          "function" == typeof ResizeObserver &&
            ((this.resizeScroll = new ResizeObserver(() => {
              var e
              ;(null === (e = this.view.docView) || void 0 === e ? void 0 : e.lastUpdate) < Date.now() - 75 &&
                this.onResize()
            })),
            this.resizeScroll.observe(e.scrollDOM)),
          this.addWindowListeners((this.win = e.win)),
          this.start(),
          "function" == typeof IntersectionObserver &&
            ((this.intersection = new IntersectionObserver(
              (e) => {
                this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
                  e.length > 0 &&
                    e[e.length - 1].intersectionRatio > 0 != this.intersecting &&
                    ((this.intersecting = !this.intersecting),
                    this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")))
              },
              { threshold: [0, 0.001] },
            )),
            this.intersection.observe(this.dom),
            (this.gapIntersection = new IntersectionObserver((e) => {
              e.length > 0 &&
                e[e.length - 1].intersectionRatio > 0 &&
                this.onScrollChanged(document.createEvent("Event"))
            }, {}))),
          this.listenForScroll(),
          this.readSelectionRange()
      }
      onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure()
      }
      onScroll(e) {
        this.intersecting && this.flush(!1),
          this.editContext && this.view.requestMeasure(this.editContext.measureReq),
          this.onScrollChanged(e)
      }
      onResize() {
        this.resizeTimeout < 0 &&
          (this.resizeTimeout = setTimeout(() => {
            ;(this.resizeTimeout = -1), this.view.requestMeasure()
          }, 50))
      }
      onPrint(e) {
        ;("change" != e.type || e.matches) &&
          ((this.view.viewState.printing = !0),
          this.view.measure(),
          setTimeout(() => {
            ;(this.view.viewState.printing = !1), this.view.requestMeasure()
          }, 500))
      }
      updateGaps(e) {
        if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, n) => t != e[n]))) {
          this.gapIntersection.disconnect()
          for (let t of e) this.gapIntersection.observe(t)
          this.gaps = e
        }
      }
      onSelectionChange(e) {
        let t = this.selectionChanged
        if (!this.readSelectionRange() || this.delayedAndroidKey) return
        let { view: n } = this,
          r = this.selectionRange
        if (n.state.facet(Cee) ? n.root.activeElement != this.dom : !j6(n.dom, r)) return
        let a = r.anchorNode && n.docView.nearest(r.anchorNode)
        a && a.ignoreEvent(e)
          ? t || (this.selectionChanged = !1)
          : ((_9.ie && _9.ie_version <= 11) || (_9.android && _9.chrome)) &&
              !n.state.selection.main.empty &&
              r.focusNode &&
              F6(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset)
            ? this.flushSoon()
            : this.flush(!1)
      }
      readSelectionRange() {
        let { view: e } = this,
          t = Q6(e.root)
        if (!t) return !1
        let n =
          (_9.safari &&
            11 == e.root.nodeType &&
            (function (e) {
              let t = e.activeElement
              for (; t && t.shadowRoot; ) t = t.shadowRoot.activeElement
              return t
            })(this.dom.ownerDocument) == this.dom &&
            (function (e, t) {
              if (t.getComposedRanges) {
                let n = t.getComposedRanges(e.root)[0]
                if (n) return Sne(e, n)
              }
              let n = null
              function r(e) {
                e.preventDefault(), e.stopImmediatePropagation(), (n = e.getTargetRanges()[0])
              }
              return (
                e.contentDOM.addEventListener("beforeinput", r, !0),
                e.dom.ownerDocument.execCommand("indent"),
                e.contentDOM.removeEventListener("beforeinput", r, !0),
                n ? Sne(e, n) : null
              )
            })(this.view, t)) ||
          t
        if (!n || this.selectionRange.eq(n)) return !1
        let r = j6(this.dom, n)
        return r &&
          !this.selectionChanged &&
          e.inputState.lastFocusTime > Date.now() - 200 &&
          e.inputState.lastTouchTime < Date.now() - 300 &&
          (function (e, t) {
            let n = t.focusNode,
              r = t.focusOffset
            if (!n || t.anchorNode != n || t.anchorOffset != r) return !1
            for (r = Math.min(r, H6(n)); ; )
              if (r) {
                if (1 != n.nodeType) return !1
                let e = n.childNodes[r - 1]
                "false" == e.contentEditable ? r-- : ((n = e), (r = H6(n)))
              } else {
                if (n == e) return !0
                ;(r = z6(n)), (n = n.parentNode)
              }
          })(this.dom, n)
          ? ((this.view.inputState.lastFocusTime = 0), e.docView.updateSelection(), !1)
          : (this.selectionRange.setRange(n), r && (this.selectionChanged = !0), !0)
      }
      setSelectionRange(e, t) {
        this.selectionRange.set(e.node, e.offset, t.node, t.offset), (this.selectionChanged = !1)
      }
      clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0)
      }
      listenForScroll() {
        this.parentCheck = -1
        let e = 0,
          t = null
        for (let n = this.dom; n; )
          if (1 == n.nodeType)
            !t && e < this.scrollTargets.length && this.scrollTargets[e] == n
              ? e++
              : t || (t = this.scrollTargets.slice(0, e)),
              t && t.push(n),
              (n = n.assignedSlot || n.parentNode)
          else {
            if (11 != n.nodeType) break
            n = n.host
          }
        if ((e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t)) {
          for (let e of this.scrollTargets) e.removeEventListener("scroll", this.onScroll)
          for (let e of (this.scrollTargets = t)) e.addEventListener("scroll", this.onScroll)
        }
      }
      ignore(e) {
        if (!this.active) return e()
        try {
          return this.stop(), e()
        } finally {
          this.start(), this.clear()
        }
      }
      start() {
        this.active ||
          (this.observer.observe(this.dom, wne),
          xne && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
          (this.active = !0))
      }
      stop() {
        this.active &&
          ((this.active = !1),
          this.observer.disconnect(),
          xne && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData))
      }
      clear() {
        this.processRecords(), (this.queue.length = 0), (this.selectionChanged = !1)
      }
      delayAndroidKey(e, t) {
        var n
        if (!this.delayedAndroidKey) {
          let e = () => {
            let e = this.delayedAndroidKey
            e &&
              (this.clearDelayedAndroidKey(),
              (this.view.inputState.lastKeyCode = e.keyCode),
              (this.view.inputState.lastKeyTime = Date.now()),
              !this.flush() && e.force && t9(this.dom, e.key, e.keyCode))
          }
          this.flushingAndroidKey = this.view.win.requestAnimationFrame(e)
        }
        ;(this.delayedAndroidKey && "Enter" != e) ||
          (this.delayedAndroidKey = {
            key: e,
            keyCode: t,
            force:
              this.lastChange < Date.now() - 50 ||
              !!(null === (n = this.delayedAndroidKey) || void 0 === n ? void 0 : n.force),
          })
      }
      clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey),
          (this.delayedAndroidKey = null),
          (this.flushingAndroidKey = -1)
      }
      flushSoon() {
        this.delayedFlush < 0 &&
          (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
            ;(this.delayedFlush = -1), this.flush()
          }))
      }
      forceFlush() {
        this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), (this.delayedFlush = -1)),
          this.flush()
      }
      pendingRecords() {
        for (let e of this.observer.takeRecords()) this.queue.push(e)
        return this.queue
      }
      processRecords() {
        let e = this.pendingRecords()
        e.length && (this.queue = [])
        let t = -1,
          n = -1,
          r = !1
        for (let a of e) {
          let e = this.readMutation(a)
          e &&
            (e.typeOver && (r = !0),
            -1 == t ? ({ from: t, to: n } = e) : ((t = Math.min(e.from, t)), (n = Math.max(e.to, n))))
        }
        return { from: t, to: n, typeOver: r }
      }
      readChange() {
        let { from: e, to: t, typeOver: n } = this.processRecords(),
          r = this.selectionChanged && j6(this.dom, this.selectionRange)
        if (e < 0 && !r) return null
        e > -1 && (this.lastChange = Date.now()), (this.view.inputState.lastFocusTime = 0), (this.selectionChanged = !1)
        let a = new vne(this.view, e, t, n)
        return (this.view.docView.domChanged = { newSel: a.newSel ? a.newSel.main : null }), a
      }
      flush(e = !0) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1
        e && this.readSelectionRange()
        let t = this.readChange()
        if (!t) return this.view.requestMeasure(), !1
        let n = this.view.state,
          r = yne(this.view, t)
        return (
          this.view.state == n &&
            (t.domChanged || (t.newSel && !t.newSel.main.eq(this.view.state.selection.main))) &&
            this.view.update([]),
          r
        )
      }
      readMutation(e) {
        let t = this.view.docView.nearest(e.target)
        if (!t || t.ignoreMutation(e)) return null
        if ((t.markDirty("attributes" == e.type), "attributes" == e.type && (t.flags |= 4), "childList" == e.type)) {
          let n = _ne(t, e.previousSibling || e.target.previousSibling, -1),
            r = _ne(t, e.nextSibling || e.target.nextSibling, 1)
          return { from: n ? t.posAfter(n) : t.posAtStart, to: r ? t.posBefore(r) : t.posAtEnd, typeOver: !1 }
        }
        return "characterData" == e.type
          ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }
          : null
      }
      setWindow(e) {
        e != this.win && (this.removeWindowListeners(this.win), (this.win = e), this.addWindowListeners(this.win))
      }
      addWindowListeners(e) {
        e.addEventListener("resize", this.onResize),
          this.printQuery
            ? this.printQuery.addEventListener("change", this.onPrint)
            : e.addEventListener("beforeprint", this.onPrint),
          e.addEventListener("scroll", this.onScroll),
          e.document.addEventListener("selectionchange", this.onSelectionChange)
      }
      removeWindowListeners(e) {
        e.removeEventListener("scroll", this.onScroll),
          e.removeEventListener("resize", this.onResize),
          this.printQuery
            ? this.printQuery.removeEventListener("change", this.onPrint)
            : e.removeEventListener("beforeprint", this.onPrint),
          e.document.removeEventListener("selectionchange", this.onSelectionChange)
      }
      update(e) {
        this.editContext &&
          (this.editContext.update(e),
          e.startState.facet(Cee) != e.state.facet(Cee) &&
            (e.view.contentDOM.editContext = e.state.facet(Cee) ? this.editContext.editContext : null))
      }
      destroy() {
        var e, t, n
        this.stop(),
          null === (e = this.intersection) || void 0 === e || e.disconnect(),
          null === (t = this.gapIntersection) || void 0 === t || t.disconnect(),
          null === (n = this.resizeScroll) || void 0 === n || n.disconnect()
        for (let e of this.scrollTargets) e.removeEventListener("scroll", this.onScroll)
        this.removeWindowListeners(this.win),
          clearTimeout(this.parentCheck),
          clearTimeout(this.resizeTimeout),
          this.win.cancelAnimationFrame(this.delayedFlush),
          this.win.cancelAnimationFrame(this.flushingAndroidKey)
      }
    }
    function _ne(e, t, n) {
      for (; t; ) {
        let r = l9.get(t)
        if (r && r.parent == e) return r
        let a = t.parentNode
        t = a != e.dom ? a : n > 0 ? t.nextSibling : t.previousSibling
      }
      return null
    }
    function Sne(e, t) {
      let n = t.startContainer,
        r = t.startOffset,
        a = t.endContainer,
        o = t.endOffset,
        i = e.docView.domAtPos(e.state.selection.main.anchor)
      return (
        F6(i.node, i.offset, a, o) && ([n, r, a, o] = [a, o, n, r]),
        { anchorNode: n, anchorOffset: r, focusNode: a, focusOffset: o }
      )
    }
    class Ene {
      constructor(e) {
        ;(this.from = 0), (this.to = 0), (this.pendingContextChange = null), this.resetRange(e.state)
        let t = (this.editContext = new window.EditContext({
          text: e.state.doc.sliceString(this.from, this.to),
          selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
          selectionEnd: this.toContextPos(e.state.selection.main.head),
        }))
        t.addEventListener("textupdate", (t) => {
          let { anchor: n } = e.state.selection.main,
            r = {
              from: this.toEditorPos(t.updateRangeStart),
              to: this.toEditorPos(t.updateRangeEnd),
              insert: F8.of(t.text.split("\n")),
            }
          r.from == this.from && n < this.from ? (r.from = n) : r.to == this.to && n > this.to && (r.to = n),
            (r.from != r.to || r.insert.length) &&
              ((this.pendingContextChange = r),
              One(e, r, w7.single(this.toEditorPos(t.selectionStart), this.toEditorPos(t.selectionEnd))),
              this.pendingContextChange && this.revertPending(e.state))
        }),
          t.addEventListener("characterboundsupdate", (n) => {
            let r = [],
              a = null
            for (let t = this.toEditorPos(n.rangeStart), o = this.toEditorPos(n.rangeEnd); t < o; t++) {
              let n = e.coordsForChar(t)
              ;(a = (n && new DOMRect(n.left, n.right, n.right - n.left, n.bottom - n.top)) || a || new DOMRect()),
                r.push(a)
            }
            t.updateCharacterBounds(n.rangeStart, r)
          }),
          t.addEventListener("textformatupdate", (t) => {
            let n = []
            for (let e of t.getTextFormats()) {
              let t = e.underlineStyle,
                r = e.underlineThickness
              if ("None" != t && "None" != r) {
                let a = `text-decoration: underline ${"Dashed" == t ? "dashed " : "Squiggle" == t ? "wavy " : ""}${"Thin" == r ? 1 : 2}px`
                n.push(
                  U9.mark({ attributes: { style: a } }).range(
                    this.toEditorPos(e.rangeStart),
                    this.toEditorPos(e.rangeEnd),
                  ),
                )
              }
            }
            e.dispatch({ effects: Tee.of(U9.set(n)) })
          }),
          t.addEventListener("compositionstart", () => {
            e.inputState.composing < 0 && ((e.inputState.composing = 0), (e.inputState.compositionFirstChange = !0))
          }),
          t.addEventListener("compositionend", () => {
            ;(e.inputState.composing = -1), (e.inputState.compositionFirstChange = null)
          }),
          (this.measureReq = {
            read: (e) => {
              this.editContext.updateControlBounds(e.contentDOM.getBoundingClientRect())
              let t = Q6(e.root)
              t && t.rangeCount && this.editContext.updateSelectionBounds(t.getRangeAt(0).getBoundingClientRect())
            },
          })
      }
      applyEdits(e) {
        let t = 0,
          n = !1,
          r = this.pendingContextChange
        return (
          e.changes.iterChanges((a, o, i, s, l) => {
            if (n) return
            let c = l.length - (o - a)
            if (r && o >= r.to) {
              if (r.from == a && r.to == o && r.insert.eq(l))
                return (r = this.pendingContextChange = null), void (t += c)
              ;(r = null), this.revertPending(e.state)
            }
            if (((a += t), (o += t) <= this.from)) (this.from += c), (this.to += c)
            else if (a < this.to) {
              if (a < this.from || o > this.to || this.to - this.from + l.length > 3e4) return void (n = !0)
              this.editContext.updateText(this.toContextPos(a), this.toContextPos(o), l.toString()), (this.to += c)
            }
            t += c
          }),
          r && !n && this.revertPending(e.state),
          !n
        )
      }
      update(e) {
        this.applyEdits(e) && this.rangeIsValid(e.state)
          ? (e.docChanged || e.selectionSet) && this.setSelection(e.state)
          : ((this.pendingContextChange = null),
            this.resetRange(e.state),
            this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)),
            this.setSelection(e.state)),
          (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq)
      }
      resetRange(e) {
        let { head: t } = e.selection.main
        ;(this.from = Math.max(0, t - 1e4)), (this.to = Math.min(e.doc.length, t + 1e4))
      }
      revertPending(e) {
        let t = this.pendingContextChange
        ;(this.pendingContextChange = null),
          this.editContext.updateText(
            this.toContextPos(t.from),
            this.toContextPos(t.to + t.insert.length),
            e.doc.sliceString(t.from, t.to),
          )
      }
      setSelection(e) {
        let { main: t } = e.selection,
          n = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))),
          r = this.toContextPos(t.head)
        ;(this.editContext.selectionStart == n && this.editContext.selectionEnd == r) ||
          this.editContext.updateSelection(n, r)
      }
      rangeIsValid(e) {
        let { head: t } = e.selection.main
        return !(
          (this.from > 0 && t - this.from < 500) ||
          (this.to < e.doc.length && this.to - t < 500) ||
          this.to - this.from > 3e4
        )
      }
      toEditorPos(e) {
        return e + this.from
      }
      toContextPos(e) {
        return e - this.from
      }
    }
    class Tne {
      get state() {
        return this.viewState.state
      }
      get viewport() {
        return this.viewState.viewport
      }
      get visibleRanges() {
        return this.viewState.visibleRanges
      }
      get inView() {
        return this.viewState.inView
      }
      get composing() {
        return this.inputState.composing > 0
      }
      get compositionStarted() {
        return this.inputState.composing >= 0
      }
      get root() {
        return this._root
      }
      get win() {
        return this.dom.ownerDocument.defaultView || window
      }
      constructor(e = {}) {
        ;(this.plugins = []),
          (this.pluginMap = new Map()),
          (this.editorAttrs = {}),
          (this.contentAttrs = {}),
          (this.bidiCache = []),
          (this.destroyed = !1),
          (this.updateState = 2),
          (this.measureScheduled = -1),
          (this.measureRequests = []),
          (this.contentDOM = document.createElement("div")),
          (this.scrollDOM = document.createElement("div")),
          (this.scrollDOM.tabIndex = -1),
          (this.scrollDOM.className = "cm-scroller"),
          this.scrollDOM.appendChild(this.contentDOM),
          (this.announceDOM = document.createElement("div")),
          (this.announceDOM.className = "cm-announced"),
          this.announceDOM.setAttribute("aria-live", "polite"),
          (this.dom = document.createElement("div")),
          this.dom.appendChild(this.announceDOM),
          this.dom.appendChild(this.scrollDOM),
          e.parent && e.parent.appendChild(this.dom)
        let { dispatch: t } = e
        ;(this.dispatchTransactions =
          e.dispatchTransactions || (t && ((e) => e.forEach((e) => t(e, this)))) || ((e) => this.update(e))),
          (this.dispatch = this.dispatch.bind(this)),
          (this._root =
            e.root ||
            (function (e) {
              for (; e; ) {
                if (e && (9 == e.nodeType || (11 == e.nodeType && e.host))) return e
                e = e.assignedSlot || e.parentNode
              }
              return null
            })(e.parent) ||
            document),
          (this.viewState = new Jte(e.state || s6.create(e))),
          e.scrollTo &&
            e.scrollTo.is(Eee) &&
            (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)),
          (this.plugins = this.state.facet(Dee).map((e) => new Nee(e)))
        for (let e of this.plugins) e.update(this)
        ;(this.observer = new kne(this)),
          (this.inputState = new lte(this)),
          this.inputState.ensureHandlers(this.plugins),
          (this.docView = new Hee(this)),
          this.mountStyles(),
          this.updateAttrs(),
          (this.updateState = 0),
          this.requestMeasure()
      }
      dispatch(...e) {
        let t =
          1 == e.length && e[0] instanceof G7
            ? e
            : 1 == e.length && Array.isArray(e[0])
              ? e[0]
              : [this.state.update(...e)]
        this.dispatchTransactions(t, this)
      }
      update(e) {
        if (0 != this.updateState)
          throw new Error("Calls to EditorView.update are not allowed while an update is in progress")
        let t,
          n = !1,
          r = !1,
          a = this.state
        for (let t of e) {
          if (t.startState != a)
            throw new RangeError(
              "Trying to update state with a transaction that doesn't start from the previous state.",
            )
          a = t.state
        }
        if (this.destroyed) return void (this.viewState.state = a)
        let o = this.hasFocus,
          i = 0,
          s = null
        e.some((e) => e.annotation(Dte))
          ? ((this.inputState.notifiedFocused = o), (i = 1))
          : o != this.inputState.notifiedFocused &&
            ((this.inputState.notifiedFocused = o), (s = Rte(a, o)), s || (i = 1))
        let l = this.observer.delayedAndroidKey,
          c = null
        if (
          (l
            ? (this.observer.clearDelayedAndroidKey(),
              (c = this.observer.readChange()),
              ((c && !this.state.doc.eq(a.doc)) || !this.state.selection.eq(a.selection)) && (c = null))
            : this.observer.clear(),
          a.facet(s6.phrases) != this.state.facet(s6.phrases))
        )
          return this.setState(a)
        ;(t = Zee.create(this, a, e)), (t.flags |= i)
        let d = this.viewState.scrollTarget
        try {
          this.updateState = 2
          for (let t of e) {
            if ((d && (d = d.map(t.changes)), t.scrollIntoView)) {
              let { main: e } = t.state.selection
              d = new See(e.empty ? e : w7.cursor(e.head, e.head > e.anchor ? -1 : 1))
            }
            for (let e of t.effects) e.is(Eee) && (d = e.value.clip(this.state))
          }
          this.viewState.update(t, d),
            (this.bidiCache = Pne.update(this.bidiCache, t.changes)),
            t.empty || (this.updatePlugins(t), this.inputState.update(t)),
            (n = this.docView.update(t)),
            this.state.facet(zee) != this.styleModules && this.mountStyles(),
            (r = this.updateAttrs()),
            this.showAnnouncements(e),
            this.docView.updateSelection(
              n,
              e.some((e) => e.isUserEvent("select.pointer")),
            )
        } finally {
          this.updateState = 0
        }
        if (
          (t.startState.facet(ine) != t.state.facet(ine) && (this.viewState.mustMeasureContent = !0),
          (n || r || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) &&
            this.requestMeasure(),
          n && this.docViewUpdate(),
          !t.empty)
        )
          for (let e of this.state.facet(yee))
            try {
              e(t)
            } catch (e) {
              Aee(this.state, e, "update listener")
            }
        ;(s || c) &&
          Promise.resolve().then(() => {
            s && this.state == s.startState && this.dispatch(s),
              c && !yne(this, c) && l.force && t9(this.contentDOM, l.key, l.keyCode)
          })
      }
      setState(e) {
        if (0 != this.updateState)
          throw new Error("Calls to EditorView.setState are not allowed while an update is in progress")
        if (this.destroyed) return void (this.viewState.state = e)
        this.updateState = 2
        let t = this.hasFocus
        try {
          for (let e of this.plugins) e.destroy(this)
          ;(this.viewState = new Jte(e)), (this.plugins = e.facet(Dee).map((e) => new Nee(e))), this.pluginMap.clear()
          for (let e of this.plugins) e.update(this)
          this.docView.destroy(),
            (this.docView = new Hee(this)),
            this.inputState.ensureHandlers(this.plugins),
            this.mountStyles(),
            this.updateAttrs(),
            (this.bidiCache = [])
        } finally {
          this.updateState = 0
        }
        t && this.focus(), this.requestMeasure()
      }
      updatePlugins(e) {
        let t = e.startState.facet(Dee),
          n = e.state.facet(Dee)
        if (t != n) {
          let r = []
          for (let a of n) {
            let n = t.indexOf(a)
            if (n < 0) r.push(new Nee(a))
            else {
              let t = this.plugins[n]
              ;(t.mustUpdate = e), r.push(t)
            }
          }
          for (let t of this.plugins) t.mustUpdate != e && t.destroy(this)
          ;(this.plugins = r), this.pluginMap.clear()
        } else for (let t of this.plugins) t.mustUpdate = e
        for (let e = 0; e < this.plugins.length; e++) this.plugins[e].update(this)
        t != n && this.inputState.ensureHandlers(this.plugins)
      }
      docViewUpdate() {
        for (let e of this.plugins) {
          let t = e.value
          if (t && t.docViewUpdate)
            try {
              t.docViewUpdate(this)
            } catch (e) {
              Aee(this.state, e, "doc view update listener")
            }
        }
      }
      measure(e = !0) {
        if (this.destroyed) return
        if (
          (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
          this.observer.delayedAndroidKey)
        )
          return (this.measureScheduled = -1), void this.requestMeasure()
        ;(this.measureScheduled = 0), e && this.observer.forceFlush()
        let t = null,
          n = this.scrollDOM,
          r = n.scrollTop * this.scaleY,
          { scrollAnchorPos: a, scrollAnchorHeight: o } = this.viewState
        Math.abs(r - this.viewState.scrollTop) > 1 && (o = -1), (this.viewState.scrollAnchorHeight = -1)
        try {
          for (let e = 0; ; e++) {
            if (o < 0)
              if (r9(n)) (a = -1), (o = this.viewState.heightMap.height)
              else {
                let e = this.viewState.scrollAnchorAt(r)
                ;(a = e.from), (o = e.top)
              }
            this.updateState = 1
            let i = this.viewState.measure(this)
            if (!i && !this.measureRequests.length && null == this.viewState.scrollTarget) break
            if (e > 5) {
              console.warn(
                this.measureRequests.length
                  ? "Measure loop restarted more than 5 times"
                  : "Viewport failed to stabilize",
              )
              break
            }
            let s = []
            4 & i || ([this.measureRequests, s] = [s, this.measureRequests])
            let l = s.map((e) => {
                try {
                  return e.read(this)
                } catch (e) {
                  return Aee(this.state, e), Cne
                }
              }),
              c = Zee.create(this, this.state, []),
              d = !1
            ;(c.flags |= i),
              t ? (t.flags |= i) : (t = c),
              (this.updateState = 2),
              c.empty ||
                (this.updatePlugins(c),
                this.inputState.update(c),
                this.updateAttrs(),
                (d = this.docView.update(c)),
                d && this.docViewUpdate())
            for (let e = 0; e < s.length; e++)
              if (l[e] != Cne)
                try {
                  let t = s[e]
                  t.write && t.write(l[e], this)
                } catch (e) {
                  Aee(this.state, e)
                }
            if ((d && this.docView.updateSelection(!0), !c.viewportChanged && 0 == this.measureRequests.length)) {
              if (this.viewState.editorHeight) {
                if (this.viewState.scrollTarget) {
                  this.docView.scrollIntoView(this.viewState.scrollTarget),
                    (this.viewState.scrollTarget = null),
                    (o = -1)
                  continue
                }
                {
                  let e = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - o
                  if (e > 1 || e < -1) {
                    ;(r += e), (n.scrollTop = r / this.scaleY), (o = -1)
                    continue
                  }
                }
              }
              break
            }
          }
        } finally {
          ;(this.updateState = 0), (this.measureScheduled = -1)
        }
        if (t && !t.empty) for (let e of this.state.facet(yee)) e(t)
      }
      get themeClasses() {
        return lne + " " + (this.state.facet(sne) ? dne : cne) + " " + this.state.facet(ine)
      }
      updateAttrs() {
        let e = Dne(this, $ee, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }),
          t = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: this.state.facet(Cee) ? "true" : "false",
            class: "cm-content",
            style: `${_9.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true",
          }
        this.state.readOnly && (t["aria-readonly"] = "true"), Dne(this, Iee, t)
        let n = this.observer.ignore(() => {
          let n = I9(this.contentDOM, this.contentAttrs, t),
            r = I9(this.dom, this.editorAttrs, e)
          return n || r
        })
        return (this.editorAttrs = e), (this.contentAttrs = t), n
      }
      showAnnouncements(e) {
        let t = !0
        for (let n of e)
          for (let e of n.effects)
            e.is(Tne.announce) &&
              (t && (this.announceDOM.textContent = ""),
              (t = !1),
              (this.announceDOM.appendChild(document.createElement("div")).textContent = e.value))
      }
      mountStyles() {
        this.styleModules = this.state.facet(zee)
        let e = this.state.facet(Tne.cspNonce)
        C6.mount(this.root, this.styleModules.concat(hne).reverse(), e ? { nonce: e } : void 0)
      }
      readMeasured() {
        if (2 == this.updateState) throw new Error("Reading the editor layout isn't allowed during an update")
        0 == this.updateState && this.measureScheduled > -1 && this.measure(!1)
      }
      requestMeasure(e) {
        if (
          (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())),
          e)
        ) {
          if (this.measureRequests.indexOf(e) > -1) return
          if (null != e.key)
            for (let t = 0; t < this.measureRequests.length; t++)
              if (this.measureRequests[t].key === e.key) return void (this.measureRequests[t] = e)
          this.measureRequests.push(e)
        }
      }
      plugin(e) {
        let t = this.pluginMap.get(e)
        return (
          (void 0 === t || (t && t.spec != e)) &&
            this.pluginMap.set(e, (t = this.plugins.find((t) => t.spec == e) || null)),
          t && t.update(this).value
        )
      }
      get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop
      }
      get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom }
      }
      get scaleX() {
        return this.viewState.scaleX
      }
      get scaleY() {
        return this.viewState.scaleY
      }
      elementAtHeight(e) {
        return this.readMeasured(), this.viewState.elementAtHeight(e)
      }
      lineBlockAtHeight(e) {
        return this.readMeasured(), this.viewState.lineBlockAtHeight(e)
      }
      get viewportLineBlocks() {
        return this.viewState.viewportLines
      }
      lineBlockAt(e) {
        return this.viewState.lineBlockAt(e)
      }
      get contentHeight() {
        return this.viewState.contentHeight
      }
      moveByChar(e, t, n) {
        return ste(this, e, ote(this, e, t, n))
      }
      moveByGroup(e, t) {
        return ste(
          this,
          e,
          ote(this, e, t, (t) =>
            (function (e, t, n) {
              let r = e.state.charCategorizer(t),
                a = r(n)
              return (e) => {
                let t = r(e)
                return a == a6.Space && (a = t), a == t
              }
            })(this, e.head, t),
          ),
        )
      }
      visualLineSide(e, t) {
        let n = this.bidiSpans(e),
          r = this.textDirectionAt(e.from),
          a = n[t ? n.length - 1 : 0]
        return w7.cursor(a.side(t, r) + e.from, a.forward(!t, r) ? 1 : -1)
      }
      moveToLineBoundary(e, t, n = !0) {
        return (function (e, t, n, r) {
          let a = (function (e, t) {
              let n = e.lineBlockAt(t)
              if (Array.isArray(n.type))
                for (let e of n.type) if (e.to > t || (e.to == t && (e.to == n.to || e.type == j9.Text))) return e
              return n
            })(e, t.head),
            o =
              r && a.type == j9.Text && (e.lineWrapping || a.widgetLineBreaks)
                ? e.coordsAtPos(t.assoc < 0 && t.head > a.from ? t.head - 1 : t.head)
                : null
          if (o) {
            let t = e.dom.getBoundingClientRect(),
              r = e.textDirectionAt(a.from),
              i = e.posAtCoords({ x: n == (r == Y9.LTR) ? t.right - 1 : t.left + 1, y: (o.top + o.bottom) / 2 })
            if (null != i) return w7.cursor(i, n ? -1 : 1)
          }
          return w7.cursor(n ? a.to : a.from, n ? -1 : 1)
        })(this, e, t, n)
      }
      moveVertically(e, t, n) {
        return ste(
          this,
          e,
          (function (e, t, n, r) {
            let a = t.head,
              o = n ? 1 : -1
            if (a == (n ? e.state.doc.length : 0)) return w7.cursor(a, t.assoc)
            let i,
              s = t.goalColumn,
              l = e.contentDOM.getBoundingClientRect(),
              c = e.coordsAtPos(a, t.assoc || -1),
              d = e.documentTop
            if (c) null == s && (s = c.left - l.left), (i = o < 0 ? c.top : c.bottom)
            else {
              let t = e.viewState.lineBlockAt(a)
              null == s && (s = Math.min(l.right - l.left, e.defaultCharacterWidth * (a - t.from))),
                (i = (o < 0 ? t.top : t.bottom) + d)
            }
            let u = l.left + s,
              p = null != r ? r : e.viewState.heightOracle.textHeight >> 1
            for (let t = 0; ; t += 10) {
              let n = i + (p + t) * o,
                r = rte(e, { x: u, y: n }, !1, o)
              if (n < l.top || n > l.bottom || (o < 0 ? r < a : r > a)) {
                let t = e.docView.coordsForChar(r),
                  a = !t || n < t.top ? -1 : 1
                return w7.cursor(r, a, void 0, s)
              }
            }
          })(this, e, t, n),
        )
      }
      domAtPos(e) {
        return this.docView.domAtPos(e)
      }
      posAtDOM(e, t = 0) {
        return this.docView.posFromDOM(e, t)
      }
      posAtCoords(e, t = !0) {
        return this.readMeasured(), rte(this, e, t)
      }
      coordsAtPos(e, t = 1) {
        this.readMeasured()
        let n = this.docView.coordsAt(e, t)
        if (!n || n.left == n.right) return n
        let r = this.state.doc.lineAt(e),
          a = this.bidiSpans(r)
        return V6(n, (a[iee.find(a, e - r.from, -1, t)].dir == Y9.LTR) == t > 0)
      }
      coordsForChar(e) {
        return this.readMeasured(), this.docView.coordsForChar(e)
      }
      get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth
      }
      get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight
      }
      get textDirection() {
        return this.viewState.defaultTextDirection
      }
      textDirectionAt(e) {
        return !this.state.facet(xee) || e < this.viewport.from || e > this.viewport.to
          ? this.textDirection
          : (this.readMeasured(), this.docView.textDirectionAt(e))
      }
      get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping
      }
      bidiSpans(e) {
        if (e.length > Ane) return uee(e.length)
        let t,
          n = this.textDirectionAt(e.from)
        for (let r of this.bidiCache)
          if (r.from == e.from && r.dir == n && (r.fresh || see(r.isolates, (t = jee(this, e))))) return r.order
        t || (t = jee(this, e))
        let r = (function (e, t, n) {
          if (!e) return [new iee(0, 0, t == K9 ? 1 : 0)]
          if (t == G9 && !n.length && !oee.test(e)) return uee(e.length)
          if (n.length) for (; e.length > lee.length; ) lee[lee.length] = 256
          let r = [],
            a = t == G9 ? 0 : 1
          return dee(e, a, a, n, 0, e.length, r), r
        })(e.text, n, t)
        return this.bidiCache.push(new Pne(e.from, e.to, n, t, !0, r)), r
      }
      get hasFocus() {
        var e
        return (
          (this.dom.ownerDocument.hasFocus() ||
            (_9.safari &&
              (null === (e = this.inputState) || void 0 === e ? void 0 : e.lastContextMenu) > Date.now() - 3e4)) &&
          this.root.activeElement == this.contentDOM
        )
      }
      focus() {
        this.observer.ignore(() => {
          J6(this.contentDOM), this.docView.updateSelection()
        })
      }
      setRoot(e) {
        this._root != e &&
          ((this._root = e),
          this.observer.setWindow((9 == e.nodeType ? e : e.ownerDocument).defaultView || window),
          this.mountStyles())
      }
      destroy() {
        this.root.activeElement == this.contentDOM && this.contentDOM.blur()
        for (let e of this.plugins) e.destroy(this)
        ;(this.plugins = []),
          this.inputState.destroy(),
          this.docView.destroy(),
          this.dom.remove(),
          this.observer.destroy(),
          this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
          (this.destroyed = !0)
      }
      static scrollIntoView(e, t = {}) {
        return Eee.of(new See("number" == typeof e ? w7.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin))
      }
      scrollSnapshot() {
        let { scrollTop: e, scrollLeft: t } = this.scrollDOM,
          n = this.viewState.scrollAnchorAt(e)
        return Eee.of(new See(w7.cursor(n.from), "start", "start", n.top - e, t, !0))
      }
      setTabFocusMode(e) {
        null == e
          ? (this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1)
          : "boolean" == typeof e
            ? (this.inputState.tabFocusMode = e ? 0 : -1)
            : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + e)
      }
      static domEventHandlers(e) {
        return Ree.define(() => ({}), { eventHandlers: e })
      }
      static domEventObservers(e) {
        return Ree.define(() => ({}), { eventObservers: e })
      }
      static theme(e, t) {
        let n = C6.newName(),
          r = [ine.of(n), zee.of(pne(`.${n}`, e))]
        return t && t.dark && r.push(sne.of(!0)), r
      }
      static baseTheme(e) {
        return N7.lowest(zee.of(pne("." + lne, e, une)))
      }
      static findFromDOM(e) {
        var t
        let n = e.querySelector(".cm-content"),
          r = (n && l9.get(n)) || l9.get(e)
        return (null === (t = null == r ? void 0 : r.rootView) || void 0 === t ? void 0 : t.view) || null
      }
    }
    ;(Tne.styleModule = zee),
      (Tne.inputHandler = Oee),
      (Tne.scrollHandler = _ee),
      (Tne.focusChangeEffect = wee),
      (Tne.perLineTextDirection = xee),
      (Tne.exceptionSink = vee),
      (Tne.updateListener = yee),
      (Tne.editable = Cee),
      (Tne.mouseSelectionStyle = bee),
      (Tne.dragMovesSelection = gee),
      (Tne.clickAddsSelectionRange = mee),
      (Tne.decorations = Mee),
      (Tne.outerDecorations = Lee),
      (Tne.atomicRanges = Qee),
      (Tne.bidiIsolatedRanges = Bee),
      (Tne.scrollMargins = Uee),
      (Tne.darkTheme = sne),
      (Tne.cspNonce = _7.define({ combine: (e) => (e.length ? e[0] : "") })),
      (Tne.contentAttributes = Iee),
      (Tne.editorAttributes = $ee),
      (Tne.lineWrapping = Tne.contentAttributes.of({ class: "cm-lineWrapping" })),
      (Tne.announce = Y7.define())
    const Ane = 4096,
      Cne = {}
    class Pne {
      constructor(e, t, n, r, a, o) {
        ;(this.from = e), (this.to = t), (this.dir = n), (this.isolates = r), (this.fresh = a), (this.order = o)
      }
      static update(e, t) {
        if (t.empty && !e.some((e) => e.fresh)) return e
        let n = [],
          r = e.length ? e[e.length - 1].dir : Y9.LTR
        for (let a = Math.max(0, e.length - 10); a < e.length; a++) {
          let o = e[a]
          o.dir != r ||
            t.touchesRange(o.from, o.to) ||
            n.push(new Pne(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order))
        }
        return n
      }
    }
    function Dne(e, t, n) {
      for (let r = e.state.facet(t), a = r.length - 1; a >= 0; a--) {
        let t = r[a],
          o = "function" == typeof t ? t(e) : t
        o && R9(o, n)
      }
      return n
    }
    const Rne = _9.mac ? "mac" : _9.windows ? "win" : _9.linux ? "linux" : "key"
    function Nne(e, t, n) {
      return (
        t.altKey && (e = "Alt-" + e),
        t.ctrlKey && (e = "Ctrl-" + e),
        t.metaKey && (e = "Meta-" + e),
        !1 !== n && t.shiftKey && (e = "Shift-" + e),
        e
      )
    }
    const $ne = N7.default(
        Tne.domEventHandlers({
          keydown: (e, t) =>
            (function (e, t, n, r) {
              Bne = t
              let a = (function (e) {
                  var t =
                    (!(
                      ($6 && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey) ||
                      (I6 && e.shiftKey && e.key && 1 == e.key.length) ||
                      "Unidentified" == e.key
                    ) &&
                      e.key) ||
                    (e.shiftKey ? N6 : R6)[e.keyCode] ||
                    e.key ||
                    "Unidentified"
                  return (
                    "Esc" == t && (t = "Escape"),
                    "Del" == t && (t = "Delete"),
                    "Left" == t && (t = "ArrowLeft"),
                    "Up" == t && (t = "ArrowUp"),
                    "Right" == t && (t = "ArrowRight"),
                    "Down" == t && (t = "ArrowDown"),
                    t
                  )
                })(t),
                o = c7(s7(a, 0)) == a.length && " " != a,
                i = "",
                s = !1,
                l = !1,
                c = !1
              Lne &&
                Lne.view == n &&
                Lne.scope == r &&
                ((i = Lne.prefix + " "), pte.indexOf(t.keyCode) < 0 && ((l = !0), (Lne = null)))
              let d,
                u,
                p = new Set(),
                h = (e) => {
                  if (e) {
                    for (let t of e.run) if (!p.has(t) && (p.add(t), t(n))) return e.stopPropagation && (c = !0), !0
                    e.preventDefault && (e.stopPropagation && (c = !0), (l = !0))
                  }
                  return !1
                },
                f = e[r]
              return (
                f &&
                  (h(f[i + Nne(a, t, !o)])
                    ? (s = !0)
                    : o &&
                        (t.altKey || t.metaKey || t.ctrlKey) &&
                        !(_9.windows && t.ctrlKey && t.altKey) &&
                        (d = R6[t.keyCode]) &&
                        d != a
                      ? (h(f[i + Nne(d, t, !0)]) ||
                          (t.shiftKey && (u = N6[t.keyCode]) != a && u != d && h(f[i + Nne(u, t, !1)]))) &&
                        (s = !0)
                      : o && t.shiftKey && h(f[i + Nne(a, t, !0)]) && (s = !0),
                  !s && h(f._any) && (s = !0)),
                l && (s = !0),
                s && c && t.stopPropagation(),
                (Bne = null),
                s
              )
            })(
              (function (e) {
                let t = e.facet(Ine),
                  n = Mne.get(t)
                return (
                  n ||
                    Mne.set(
                      t,
                      (n = (function (e, t = Rne) {
                        let n = Object.create(null),
                          r = Object.create(null),
                          a = (e, t) => {
                            let n = r[e]
                            if (null == n) r[e] = t
                            else if (n != t)
                              throw new Error(
                                "Key binding " + e + " is used both as a regular binding and as a multi-stroke prefix",
                              )
                          },
                          o = (e, r, o, i, s) => {
                            var l, c
                            let d = n[e] || (n[e] = Object.create(null)),
                              u = r.split(/ (?!$)/).map((e) =>
                                (function (e, t) {
                                  const n = e.split(/-(?!$)/)
                                  let r,
                                    a,
                                    o,
                                    i,
                                    s = n[n.length - 1]
                                  "Space" == s && (s = " ")
                                  for (let e = 0; e < n.length - 1; ++e) {
                                    const s = n[e]
                                    if (/^(cmd|meta|m)$/i.test(s)) i = !0
                                    else if (/^a(lt)?$/i.test(s)) r = !0
                                    else if (/^(c|ctrl|control)$/i.test(s)) a = !0
                                    else if (/^s(hift)?$/i.test(s)) o = !0
                                    else {
                                      if (!/^mod$/i.test(s)) throw new Error("Unrecognized modifier name: " + s)
                                      "mac" == t ? (i = !0) : (a = !0)
                                    }
                                  }
                                  return (
                                    r && (s = "Alt-" + s),
                                    a && (s = "Ctrl-" + s),
                                    i && (s = "Meta-" + s),
                                    o && (s = "Shift-" + s),
                                    s
                                  )
                                })(e, t),
                              )
                            for (let t = 1; t < u.length; t++) {
                              let n = u.slice(0, t).join(" ")
                              a(n, !0),
                                d[n] ||
                                  (d[n] = {
                                    preventDefault: !0,
                                    stopPropagation: !1,
                                    run: [
                                      (t) => {
                                        let r = (Lne = { view: t, prefix: n, scope: e })
                                        return (
                                          setTimeout(() => {
                                            Lne == r && (Lne = null)
                                          }, Qne),
                                          !0
                                        )
                                      },
                                    ],
                                  })
                            }
                            let p = u.join(" ")
                            a(p, !1)
                            let h =
                              d[p] ||
                              (d[p] = {
                                preventDefault: !1,
                                stopPropagation: !1,
                                run:
                                  (null === (c = null === (l = d._any) || void 0 === l ? void 0 : l.run) || void 0 === c
                                    ? void 0
                                    : c.slice()) || [],
                              })
                            o && h.run.push(o), i && (h.preventDefault = !0), s && (h.stopPropagation = !0)
                          }
                        for (let r of e) {
                          let e = r.scope ? r.scope.split(" ") : ["editor"]
                          if (r.any)
                            for (let t of e) {
                              let e = n[t] || (n[t] = Object.create(null))
                              e._any || (e._any = { preventDefault: !1, stopPropagation: !1, run: [] })
                              let { any: a } = r
                              for (let t in e) e[t].run.push((e) => a(e, Bne))
                            }
                          let a = r[t] || r.key
                          if (a)
                            for (let t of e)
                              o(t, a, r.run, r.preventDefault, r.stopPropagation),
                                r.shift && o(t, "Shift-" + a, r.shift, r.preventDefault, r.stopPropagation)
                        }
                        return n
                      })(t.reduce((e, t) => e.concat(t), []))),
                    ),
                  n
                )
              })(t.state),
              e,
              t,
              "editor",
            ),
        }),
      ),
      Ine = _7.define({ enables: $ne }),
      Mne = new WeakMap()
    let Lne = null
    const Qne = 4e3
    let Bne = null
    const jne = {
      ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } },
      ".cm-content": {
        "& :focus": {
          caretColor: "initial !important",
          "&::selection, & ::selection": { backgroundColor: "Highlight !important" },
        },
      },
    }
    function Une(e, t, n, r, a) {
      t.lastIndex = 0
      for (let o, i = e.iterRange(n, r), s = n; !i.next().done; s += i.value.length)
        if (!i.lineBreak) for (; (o = t.exec(i.value)); ) a(s + o.index, o)
    }
    !_9.ios && (jne[".cm-line"].caretColor = jne[".cm-content"].caretColor = "transparent !important")
    class Fne {
      constructor(e) {
        const { regexp: t, decoration: n, decorate: r, boundary: a, maxLength: o = 1e3 } = e
        if (!t.global)
          throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set")
        if (((this.regexp = t), r)) this.addMatch = (e, t, n, a) => r(a, n, n + e[0].length, e, t)
        else if ("function" == typeof n)
          this.addMatch = (e, t, r, a) => {
            let o = n(e, t, r)
            o && a(r, r + e[0].length, o)
          }
        else {
          if (!n) throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator")
          this.addMatch = (e, t, r, a) => a(r, r + e[0].length, n)
        }
        ;(this.boundary = a), (this.maxLength = o)
      }
      createDeco(e) {
        let t = new f6(),
          n = t.add.bind(t)
        for (let { from: t, to: r } of (function (e, t) {
          let n = e.visibleRanges
          if (1 == n.length && n[0].from == e.viewport.from && n[0].to == e.viewport.to) return n
          let r = []
          for (let { from: a, to: o } of n)
            (a = Math.max(e.state.doc.lineAt(a).from, a - t)),
              (o = Math.min(e.state.doc.lineAt(o).to, o + t)),
              r.length && r[r.length - 1].to >= a ? (r[r.length - 1].to = o) : r.push({ from: a, to: o })
          return r
        })(e, this.maxLength))
          Une(e.state.doc, this.regexp, t, r, (t, r) => this.addMatch(r, e, t, n))
        return t.finish()
      }
      updateDeco(e, t) {
        let n = 1e9,
          r = -1
        return (
          e.docChanged &&
            e.changes.iterChanges((t, a, o, i) => {
              i > e.view.viewport.from && o < e.view.viewport.to && ((n = Math.min(o, n)), (r = Math.max(i, r)))
            }),
          e.viewportChanged || r - n > 1e3
            ? this.createDeco(e.view)
            : r > -1
              ? this.updateRange(e.view, t.map(e.changes), n, r)
              : t
        )
      }
      updateRange(e, t, n, r) {
        for (let a of e.visibleRanges) {
          let o = Math.max(a.from, n),
            i = Math.min(a.to, r)
          if (i > o) {
            let n = e.state.doc.lineAt(o),
              r = n.to < i ? e.state.doc.lineAt(i) : n,
              s = Math.max(a.from, n.from),
              l = Math.min(a.to, r.to)
            if (this.boundary) {
              for (; o > n.from; o--)
                if (this.boundary.test(n.text[o - 1 - n.from])) {
                  s = o
                  break
                }
              for (; i < r.to; i++)
                if (this.boundary.test(r.text[i - r.from])) {
                  l = i
                  break
                }
            }
            let c,
              d = [],
              u = (e, t, n) => d.push(n.range(e, t))
            if (n == r)
              for (this.regexp.lastIndex = s - n.from; (c = this.regexp.exec(n.text)) && c.index < l - n.from; )
                this.addMatch(c, e, c.index + n.from, u)
            else Une(e.state.doc, this.regexp, s, l, (t, n) => this.addMatch(n, e, t, u))
            t = t.update({ filterFrom: s, filterTo: l, filter: (e, t) => e < s || t > l, add: d })
          }
        }
        return t
      }
    }
    const zne = null != /x/.unicode ? "gu" : "g",
      qne = new RegExp("[\0-\b\n--\u2028\u2029\ufeff-]", zne),
      Zne = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement",
      }
    let Hne = null
    const Vne = _7.define({
      combine(e) {
        let t = l6(e, { render: null, specialChars: qne, addSpecialChars: null })
        return (
          (t.replaceTabs = !(function () {
            var e
            if (null == Hne && "undefined" != typeof document && document.body) {
              let t = document.body.style
              Hne = null != (null !== (e = t.tabSize) && void 0 !== e ? e : t.MozTabSize)
            }
            return Hne || !1
          })()) && (t.specialChars = new RegExp("\t|" + t.specialChars.source, zne)),
          t.addSpecialChars &&
            (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, zne)),
          t
        )
      },
    })
    function Wne(e = {}) {
      return [
        Vne.of(e),
        Xne ||
          (Xne = Ree.fromClass(
            class {
              constructor(e) {
                ;(this.view = e),
                  (this.decorations = U9.none),
                  (this.decorationCache = Object.create(null)),
                  (this.decorator = this.makeDecorator(e.state.facet(Vne))),
                  (this.decorations = this.decorator.createDeco(e))
              }
              makeDecorator(e) {
                return new Fne({
                  regexp: e.specialChars,
                  decoration: (t, n, r) => {
                    let { doc: a } = n.state,
                      o = s7(t[0], 0)
                    if (9 == o) {
                      let e = a.lineAt(r),
                        t = n.state.tabSize,
                        o = S6(e.text, t, r - e.from)
                      return U9.replace({
                        widget: new Gne(((t - (o % t)) * this.view.defaultCharacterWidth) / this.view.scaleX),
                      })
                    }
                    return this.decorationCache[o] || (this.decorationCache[o] = U9.replace({ widget: new Yne(e, o) }))
                  },
                  boundary: e.replaceTabs ? void 0 : /[^]/,
                })
              }
              update(e) {
                let t = e.state.facet(Vne)
                e.startState.facet(Vne) != t
                  ? ((this.decorator = this.makeDecorator(t)), (this.decorations = this.decorator.createDeco(e.view)))
                  : (this.decorations = this.decorator.updateDeco(e, this.decorations))
              }
            },
            { decorations: (e) => e.decorations },
          )),
      ]
    }
    let Xne = null
    class Yne extends B9 {
      constructor(e, t) {
        super(), (this.options = e), (this.code = t)
      }
      eq(e) {
        return e.code == this.code
      }
      toDOM(e) {
        let t = (n = this.code) >= 32 ? "" : 10 == n ? "" : String.fromCharCode(9216 + n)
        var n
        let r = e.state.phrase("Control character") + " " + (Zne[this.code] || "0x" + this.code.toString(16)),
          a = this.options.render && this.options.render(this.code, r, t)
        if (a) return a
        let o = document.createElement("span")
        return (o.textContent = t), (o.title = r), o.setAttribute("aria-label", r), (o.className = "cm-specialChar"), o
      }
      ignoreEvent() {
        return !1
      }
    }
    class Gne extends B9 {
      constructor(e) {
        super(), (this.width = e)
      }
      eq(e) {
        return e.width == this.width
      }
      toDOM() {
        let e = document.createElement("span")
        return (e.textContent = "\t"), (e.className = "cm-tab"), (e.style.width = this.width + "px"), e
      }
      ignoreEvent() {
        return !1
      }
    }
    class Kne extends B9 {
      constructor(e) {
        super(), (this.content = e)
      }
      toDOM() {
        let e = document.createElement("span")
        return (
          (e.className = "cm-placeholder"),
          (e.style.pointerEvents = "none"),
          e.appendChild("string" == typeof this.content ? document.createTextNode(this.content) : this.content),
          "string" == typeof this.content
            ? e.setAttribute("aria-label", "placeholder " + this.content)
            : e.setAttribute("aria-hidden", "true"),
          e
        )
      }
      coordsAt(e) {
        let t = e.firstChild ? U6(e.firstChild) : []
        if (!t.length) return null
        let n = window.getComputedStyle(e.parentNode),
          r = V6(t[0], "rtl" != n.direction),
          a = parseInt(n.lineHeight)
        return r.bottom - r.top > 1.5 * a ? { left: r.left, right: r.right, top: r.top, bottom: r.top + a } : r
      }
      ignoreEvent() {
        return !1
      }
    }
    const Jne = "-10000px"
    class ere {
      constructor(e, t, n, r) {
        ;(this.facet = t),
          (this.createTooltipView = n),
          (this.removeTooltipView = r),
          (this.input = e.state.facet(t)),
          (this.tooltips = this.input.filter((e) => e))
        let a = null
        this.tooltipViews = this.tooltips.map((e) => (a = n(e, a)))
      }
      update(e, t) {
        var n
        let r = e.state.facet(this.facet),
          a = r.filter((e) => e)
        if (r === this.input) {
          for (let t of this.tooltipViews) t.update && t.update(e)
          return !1
        }
        let o = [],
          i = t ? [] : null
        for (let n = 0; n < a.length; n++) {
          let r = a[n],
            s = -1
          if (r) {
            for (let e = 0; e < this.tooltips.length; e++) {
              let t = this.tooltips[e]
              t && t.create == r.create && (s = e)
            }
            if (s < 0) (o[n] = this.createTooltipView(r, n ? o[n - 1] : null)), i && (i[n] = !!r.above)
            else {
              let r = (o[n] = this.tooltipViews[s])
              i && (i[n] = t[s]), r.update && r.update(e)
            }
          }
        }
        for (let e of this.tooltipViews)
          o.indexOf(e) < 0 && (this.removeTooltipView(e), null === (n = e.destroy) || void 0 === n || n.call(e))
        return (
          t && (i.forEach((e, n) => (t[n] = e)), (t.length = i.length)),
          (this.input = r),
          (this.tooltips = a),
          (this.tooltipViews = o),
          !0
        )
      }
    }
    function tre(e) {
      let { win: t } = e
      return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth }
    }
    const nre = _7.define({
        combine: (e) => {
          var t, n, r
          return {
            position: _9.ios
              ? "absolute"
              : (null === (t = e.find((e) => e.position)) || void 0 === t ? void 0 : t.position) || "fixed",
            parent: (null === (n = e.find((e) => e.parent)) || void 0 === n ? void 0 : n.parent) || null,
            tooltipSpace:
              (null === (r = e.find((e) => e.tooltipSpace)) || void 0 === r ? void 0 : r.tooltipSpace) || tre,
          }
        },
      }),
      rre = new WeakMap(),
      are = Ree.fromClass(
        class {
          constructor(e) {
            ;(this.view = e),
              (this.above = []),
              (this.inView = !0),
              (this.madeAbsolute = !1),
              (this.lastTransaction = 0),
              (this.measureTimeout = -1)
            let t = e.state.facet(nre)
            ;(this.position = t.position),
              (this.parent = t.parent),
              (this.classes = e.themeClasses),
              this.createContainer(),
              (this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }),
              (this.resizeObserver =
                "function" == typeof ResizeObserver ? new ResizeObserver(() => this.measureSoon()) : null),
              (this.manager = new ere(
                e,
                sre,
                (e, t) => this.createTooltip(e, t),
                (e) => {
                  this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove()
                },
              )),
              (this.above = this.manager.tooltips.map((e) => !!e.above)),
              (this.intersectionObserver =
                "function" == typeof IntersectionObserver
                  ? new IntersectionObserver(
                      (e) => {
                        Date.now() > this.lastTransaction - 50 &&
                          e.length > 0 &&
                          e[e.length - 1].intersectionRatio < 1 &&
                          this.measureSoon()
                      },
                      { threshold: [1] },
                    )
                  : null),
              this.observeIntersection(),
              e.win.addEventListener("resize", (this.measureSoon = this.measureSoon.bind(this))),
              this.maybeMeasure()
          }
          createContainer() {
            this.parent
              ? ((this.container = document.createElement("div")),
                (this.container.style.position = "relative"),
                (this.container.className = this.view.themeClasses),
                this.parent.appendChild(this.container))
              : (this.container = this.view.dom)
          }
          observeIntersection() {
            if (this.intersectionObserver) {
              this.intersectionObserver.disconnect()
              for (let e of this.manager.tooltipViews) this.intersectionObserver.observe(e.dom)
            }
          }
          measureSoon() {
            this.measureTimeout < 0 &&
              (this.measureTimeout = setTimeout(() => {
                ;(this.measureTimeout = -1), this.maybeMeasure()
              }, 50))
          }
          update(e) {
            e.transactions.length && (this.lastTransaction = Date.now())
            let t = this.manager.update(e, this.above)
            t && this.observeIntersection()
            let n = t || e.geometryChanged,
              r = e.state.facet(nre)
            if (r.position != this.position && !this.madeAbsolute) {
              this.position = r.position
              for (let e of this.manager.tooltipViews) e.dom.style.position = this.position
              n = !0
            }
            if (r.parent != this.parent) {
              this.parent && this.container.remove(), (this.parent = r.parent), this.createContainer()
              for (let e of this.manager.tooltipViews) this.container.appendChild(e.dom)
              n = !0
            } else
              this.parent &&
                this.view.themeClasses != this.classes &&
                (this.classes = this.container.className = this.view.themeClasses)
            n && this.maybeMeasure()
          }
          createTooltip(e, t) {
            let n = e.create(this.view),
              r = t ? t.dom : null
            if (
              (n.dom.classList.add("cm-tooltip"), e.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow"))
            ) {
              let e = document.createElement("div")
              ;(e.className = "cm-tooltip-arrow"), n.dom.appendChild(e)
            }
            return (
              (n.dom.style.position = this.position),
              (n.dom.style.top = Jne),
              (n.dom.style.left = "0px"),
              this.container.insertBefore(n.dom, r),
              n.mount && n.mount(this.view),
              this.resizeObserver && this.resizeObserver.observe(n.dom),
              n
            )
          }
          destroy() {
            var e, t, n
            this.view.win.removeEventListener("resize", this.measureSoon)
            for (let t of this.manager.tooltipViews)
              t.dom.remove(), null === (e = t.destroy) || void 0 === e || e.call(t)
            this.parent && this.container.remove(),
              null === (t = this.resizeObserver) || void 0 === t || t.disconnect(),
              null === (n = this.intersectionObserver) || void 0 === n || n.disconnect(),
              clearTimeout(this.measureTimeout)
          }
          readMeasure() {
            let e = this.view.dom.getBoundingClientRect(),
              t = 1,
              n = 1,
              r = !1
            if ("fixed" == this.position && this.manager.tooltipViews.length) {
              let { dom: e } = this.manager.tooltipViews[0]
              if (_9.gecko) r = e.offsetParent != this.container.ownerDocument.body
              else if (e.style.top == Jne && "0px" == e.style.left) {
                let t = e.getBoundingClientRect()
                r = Math.abs(t.top + 1e4) > 1 || Math.abs(t.left) > 1
              }
            }
            if (r || "absolute" == this.position)
              if (this.parent) {
                let e = this.parent.getBoundingClientRect()
                e.width &&
                  e.height &&
                  ((t = e.width / this.parent.offsetWidth), (n = e.height / this.parent.offsetHeight))
              } else ({ scaleX: t, scaleY: n } = this.view.viewState)
            return {
              editor: e,
              parent: this.parent ? this.container.getBoundingClientRect() : e,
              pos: this.manager.tooltips.map((e, t) => {
                let n = this.manager.tooltipViews[t]
                return n.getCoords ? n.getCoords(e.pos) : this.view.coordsAtPos(e.pos)
              }),
              size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
              space: this.view.state.facet(nre).tooltipSpace(this.view),
              scaleX: t,
              scaleY: n,
              makeAbsolute: r,
            }
          }
          writeMeasure(e) {
            var t
            if (e.makeAbsolute) {
              ;(this.madeAbsolute = !0), (this.position = "absolute")
              for (let e of this.manager.tooltipViews) e.dom.style.position = "absolute"
            }
            let { editor: n, space: r, scaleX: a, scaleY: o } = e,
              i = []
            for (let s = 0; s < this.manager.tooltips.length; s++) {
              let l = this.manager.tooltips[s],
                c = this.manager.tooltipViews[s],
                { dom: d } = c,
                u = e.pos[s],
                p = e.size[s]
              if (
                !u ||
                u.bottom <= Math.max(n.top, r.top) ||
                u.top >= Math.min(n.bottom, r.bottom) ||
                u.right < Math.max(n.left, r.left) - 0.1 ||
                u.left > Math.min(n.right, r.right) + 0.1
              ) {
                d.style.top = Jne
                continue
              }
              let h = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null,
                f = h ? 7 : 0,
                m = p.right - p.left,
                g = null !== (t = rre.get(c)) && void 0 !== t ? t : p.bottom - p.top,
                b = c.offset || ire,
                v = this.view.textDirection == Y9.LTR,
                y =
                  p.width > r.right - r.left
                    ? v
                      ? r.left
                      : r.right - p.width
                    : v
                      ? Math.min(u.left - (h ? 14 : 0) + b.x, r.right - m)
                      : Math.max(r.left, u.left - m + (h ? 14 : 0) - b.x),
                O = this.above[s]
              !l.strictSide &&
                (O ? u.top - (p.bottom - p.top) - b.y < r.top : u.bottom + (p.bottom - p.top) + b.y > r.bottom) &&
                O == r.bottom - u.bottom > u.top - r.top &&
                (O = this.above[s] = !O)
              let w = (O ? u.top - r.top : r.bottom - u.bottom) - f
              if (w < g && !1 !== c.resize) {
                if (w < this.view.defaultLineHeight) {
                  d.style.top = Jne
                  continue
                }
                rre.set(c, g), (d.style.height = (g = w) / o + "px")
              } else d.style.height && (d.style.height = "")
              let x = O ? u.top - g - f - b.y : u.bottom + f + b.y,
                k = y + m
              if (!0 !== c.overlap)
                for (let e of i)
                  e.left < k &&
                    e.right > y &&
                    e.top < x + g &&
                    e.bottom > x &&
                    (x = O ? e.top - g - 2 - f : e.bottom + f + 2)
              if (
                ("absolute" == this.position
                  ? ((d.style.top = (x - e.parent.top) / o + "px"), (d.style.left = (y - e.parent.left) / a + "px"))
                  : ((d.style.top = x / o + "px"), (d.style.left = y / a + "px")),
                h)
              ) {
                let e = u.left + (v ? b.x : -b.x) - (y + 14 - 7)
                h.style.left = e / a + "px"
              }
              !0 !== c.overlap && i.push({ left: y, top: x, right: k, bottom: x + g }),
                d.classList.toggle("cm-tooltip-above", O),
                d.classList.toggle("cm-tooltip-below", !O),
                c.positioned && c.positioned(e.space)
            }
          }
          maybeMeasure() {
            if (
              this.manager.tooltips.length &&
              (this.view.inView && this.view.requestMeasure(this.measureReq),
              this.inView != this.view.inView && ((this.inView = this.view.inView), !this.inView))
            )
              for (let e of this.manager.tooltipViews) e.dom.style.top = Jne
          }
        },
        {
          eventObservers: {
            scroll() {
              this.maybeMeasure()
            },
          },
        },
      ),
      ore = Tne.baseTheme({
        ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" },
        "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" },
        "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" },
        "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" },
        ".cm-tooltip-arrow": {
          height: "7px",
          width: "14px",
          position: "absolute",
          zIndex: -1,
          overflow: "hidden",
          "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: "7px solid transparent",
            borderRight: "7px solid transparent",
          },
          ".cm-tooltip-above &": {
            bottom: "-7px",
            "&:before": { borderTop: "7px solid #bbb" },
            "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" },
          },
          ".cm-tooltip-below &": {
            top: "-7px",
            "&:before": { borderBottom: "7px solid #bbb" },
            "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" },
          },
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
          "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" },
          "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" },
        },
      }),
      ire = { x: 0, y: 0 },
      sre = _7.define({ enables: [are, ore] }),
      lre = _7.define({ combine: (e) => e.reduce((e, t) => e.concat(t), []) })
    class cre {
      static create(e) {
        return new cre(e)
      }
      constructor(e) {
        ;(this.view = e),
          (this.mounted = !1),
          (this.dom = document.createElement("div")),
          this.dom.classList.add("cm-tooltip-hover"),
          (this.manager = new ere(
            e,
            lre,
            (e, t) => this.createHostedView(e, t),
            (e) => e.dom.remove(),
          ))
      }
      createHostedView(e, t) {
        let n = e.create(this.view)
        return (
          n.dom.classList.add("cm-tooltip-section"),
          this.dom.insertBefore(n.dom, t ? t.dom.nextSibling : this.dom.firstChild),
          this.mounted && n.mount && n.mount(this.view),
          n
        )
      }
      mount(e) {
        for (let t of this.manager.tooltipViews) t.mount && t.mount(e)
        this.mounted = !0
      }
      positioned(e) {
        for (let t of this.manager.tooltipViews) t.positioned && t.positioned(e)
      }
      update(e) {
        this.manager.update(e)
      }
      destroy() {
        var e
        for (let t of this.manager.tooltipViews) null === (e = t.destroy) || void 0 === e || e.call(t)
      }
      passProp(e) {
        let t
        for (let n of this.manager.tooltipViews) {
          let r = n[e]
          if (void 0 !== r)
            if (void 0 === t) t = r
            else if (t !== r) return
        }
        return t
      }
      get offset() {
        return this.passProp("offset")
      }
      get getCoords() {
        return this.passProp("getCoords")
      }
      get overlap() {
        return this.passProp("overlap")
      }
      get resize() {
        return this.passProp("resize")
      }
    }
    const dre = sre.compute([lre], (e) => {
      let t = e.facet(lre)
      return 0 === t.length
        ? null
        : {
            pos: Math.min(...t.map((e) => e.pos)),
            end: Math.max(
              ...t.map((e) => {
                var t
                return null !== (t = e.end) && void 0 !== t ? t : e.pos
              }),
            ),
            create: cre.create,
            above: t[0].above,
            arrow: t.some((e) => e.arrow),
          }
    })
    class ure {
      constructor(e, t, n, r, a) {
        ;(this.view = e),
          (this.source = t),
          (this.field = n),
          (this.setHover = r),
          (this.hoverTime = a),
          (this.hoverTimeout = -1),
          (this.restartTimeout = -1),
          (this.pending = null),
          (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
          (this.checkHover = this.checkHover.bind(this)),
          e.dom.addEventListener("mouseleave", (this.mouseleave = this.mouseleave.bind(this))),
          e.dom.addEventListener("mousemove", (this.mousemove = this.mousemove.bind(this)))
      }
      update() {
        this.pending &&
          ((this.pending = null),
          clearTimeout(this.restartTimeout),
          (this.restartTimeout = setTimeout(() => this.startHover(), 20)))
      }
      get active() {
        return this.view.state.field(this.field)
      }
      checkHover() {
        if (((this.hoverTimeout = -1), this.active.length)) return
        let e = Date.now() - this.lastMove.time
        e < this.hoverTime ? (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e)) : this.startHover()
      }
      startHover() {
        clearTimeout(this.restartTimeout)
        let { view: e, lastMove: t } = this,
          n = e.docView.nearest(t.target)
        if (!n) return
        let r,
          a = 1
        if (n instanceof T9) r = n.posAtStart
        else {
          if (((r = e.posAtCoords(t)), null == r)) return
          let n = e.coordsAtPos(r)
          if (
            !n ||
            t.y < n.top ||
            t.y > n.bottom ||
            t.x < n.left - e.defaultCharacterWidth ||
            t.x > n.right + e.defaultCharacterWidth
          )
            return
          let o = e.bidiSpans(e.state.doc.lineAt(r)).find((e) => e.from <= r && e.to >= r),
            i = o && o.dir == Y9.RTL ? -1 : 1
          a = t.x < n.left ? -i : i
        }
        let o = this.source(e, r, a)
        if (null == o ? void 0 : o.then) {
          let t = (this.pending = { pos: r })
          o.then(
            (n) => {
              this.pending == t &&
                ((this.pending = null),
                !n ||
                  (Array.isArray(n) && !n.length) ||
                  e.dispatch({ effects: this.setHover.of(Array.isArray(n) ? n : [n]) }))
            },
            (t) => Aee(e.state, t, "hover tooltip"),
          )
        } else
          !o || (Array.isArray(o) && !o.length) || e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) })
      }
      get tooltip() {
        let e = this.view.plugin(are),
          t = e ? e.manager.tooltips.findIndex((e) => e.create == cre.create) : -1
        return t > -1 ? e.manager.tooltipViews[t] : null
      }
      mousemove(e) {
        var t, n
        ;(this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }),
          this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime))
        let { active: r, tooltip: a } = this
        if (
          (r.length &&
            a &&
            !(function (e, t) {
              let n = e.getBoundingClientRect()
              return (
                t.clientX >= n.left - pre &&
                t.clientX <= n.right + pre &&
                t.clientY >= n.top - pre &&
                t.clientY <= n.bottom + pre
              )
            })(a.dom, e)) ||
          this.pending
        ) {
          let { pos: a } = r[0] || this.pending,
            o = null !== (n = null === (t = r[0]) || void 0 === t ? void 0 : t.end) && void 0 !== n ? n : a
          ;(a == o
            ? this.view.posAtCoords(this.lastMove) == a
            : (function (e, t, n, r, a, o) {
                let i = e.scrollDOM.getBoundingClientRect(),
                  s = e.documentTop + e.documentPadding.top + e.contentHeight
                if (i.left > r || i.right < r || i.top > a || Math.min(i.bottom, s) < a) return !1
                let l = e.posAtCoords({ x: r, y: a }, !1)
                return l >= t && l <= n
              })(this.view, a, o, e.clientX, e.clientY)) ||
            (this.view.dispatch({ effects: this.setHover.of([]) }), (this.pending = null))
        }
      }
      mouseleave(e) {
        clearTimeout(this.hoverTimeout), (this.hoverTimeout = -1)
        let { active: t } = this
        if (t.length) {
          let { tooltip: t } = this
          t && t.dom.contains(e.relatedTarget)
            ? this.watchTooltipLeave(t.dom)
            : this.view.dispatch({ effects: this.setHover.of([]) })
        }
      }
      watchTooltipLeave(e) {
        let t = (n) => {
          e.removeEventListener("mouseleave", t),
            this.active.length &&
              !this.view.dom.contains(n.relatedTarget) &&
              this.view.dispatch({ effects: this.setHover.of([]) })
        }
        e.addEventListener("mouseleave", t)
      }
      destroy() {
        clearTimeout(this.hoverTimeout),
          this.view.dom.removeEventListener("mouseleave", this.mouseleave),
          this.view.dom.removeEventListener("mousemove", this.mousemove)
      }
    }
    const pre = 4
    function hre(e, t) {
      let n = e.plugin(are)
      if (!n) return null
      let r = n.manager.tooltips.indexOf(t)
      return r < 0 ? null : n.manager.tooltipViews[r]
    }
    const fre = Y7.define(),
      mre = _7.define({
        combine(e) {
          let t, n
          for (let r of e) (t = t || r.topContainer), (n = n || r.bottomContainer)
          return { topContainer: t, bottomContainer: n }
        },
      }),
      gre = Ree.fromClass(
        class {
          constructor(e) {
            ;(this.input = e.state.facet(yre)),
              (this.specs = this.input.filter((e) => e)),
              (this.panels = this.specs.map((t) => t(e)))
            let t = e.state.facet(mre)
            ;(this.top = new bre(e, !0, t.topContainer)),
              (this.bottom = new bre(e, !1, t.bottomContainer)),
              this.top.sync(this.panels.filter((e) => e.top)),
              this.bottom.sync(this.panels.filter((e) => !e.top))
            for (let e of this.panels) e.dom.classList.add("cm-panel"), e.mount && e.mount()
          }
          update(e) {
            let t = e.state.facet(mre)
            this.top.container != t.topContainer &&
              (this.top.sync([]), (this.top = new bre(e.view, !0, t.topContainer))),
              this.bottom.container != t.bottomContainer &&
                (this.bottom.sync([]), (this.bottom = new bre(e.view, !1, t.bottomContainer))),
              this.top.syncClasses(),
              this.bottom.syncClasses()
            let n = e.state.facet(yre)
            if (n != this.input) {
              let t = n.filter((e) => e),
                r = [],
                a = [],
                o = [],
                i = []
              for (let n of t) {
                let t,
                  s = this.specs.indexOf(n)
                s < 0 ? ((t = n(e.view)), i.push(t)) : ((t = this.panels[s]), t.update && t.update(e)),
                  r.push(t),
                  (t.top ? a : o).push(t)
              }
              ;(this.specs = t), (this.panels = r), this.top.sync(a), this.bottom.sync(o)
              for (let e of i) e.dom.classList.add("cm-panel"), e.mount && e.mount()
            } else for (let t of this.panels) t.update && t.update(e)
          }
          destroy() {
            this.top.sync([]), this.bottom.sync([])
          }
        },
        {
          provide: (e) =>
            Tne.scrollMargins.of((t) => {
              let n = t.plugin(e)
              return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() }
            }),
        },
      )
    class bre {
      constructor(e, t, n) {
        ;(this.view = e),
          (this.top = t),
          (this.container = n),
          (this.dom = void 0),
          (this.classes = ""),
          (this.panels = []),
          this.syncClasses()
      }
      sync(e) {
        for (let t of this.panels) t.destroy && e.indexOf(t) < 0 && t.destroy()
        ;(this.panels = e), this.syncDOM()
      }
      syncDOM() {
        if (0 == this.panels.length) return void (this.dom && (this.dom.remove(), (this.dom = void 0)))
        if (!this.dom) {
          ;(this.dom = document.createElement("div")),
            (this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom"),
            (this.dom.style[this.top ? "top" : "bottom"] = "0")
          let e = this.container || this.view.dom
          e.insertBefore(this.dom, this.top ? e.firstChild : null)
        }
        let e = this.dom.firstChild
        for (let t of this.panels)
          if (t.dom.parentNode == this.dom) {
            for (; e != t.dom; ) e = vre(e)
            e = e.nextSibling
          } else this.dom.insertBefore(t.dom, e)
        for (; e; ) e = vre(e)
      }
      scrollMargin() {
        return !this.dom || this.container
          ? 0
          : Math.max(
              0,
              this.top
                ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
                : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) -
                    this.dom.getBoundingClientRect().top,
            )
      }
      syncClasses() {
        if (this.container && this.classes != this.view.themeClasses) {
          for (let e of this.classes.split(" ")) e && this.container.classList.remove(e)
          for (let e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e)
        }
      }
    }
    function vre(e) {
      let t = e.nextSibling
      return e.remove(), t
    }
    const yre = _7.define({ enables: gre })
    class Ore extends c6 {
      compare(e) {
        return this == e || (this.constructor == e.constructor && this.eq(e))
      }
      eq(e) {
        return !1
      }
      destroy(e) {}
    }
    ;(Ore.prototype.elementClass = ""),
      (Ore.prototype.toDOM = void 0),
      (Ore.prototype.mapMode = u7.TrackBefore),
      (Ore.prototype.startSide = Ore.prototype.endSide = -1),
      (Ore.prototype.point = !0)
    const wre = _7.define(),
      xre = _7.define(),
      kre = _7.define({ combine: (e) => e.some((e) => e) }),
      _re = Ree.fromClass(
        class {
          constructor(e) {
            ;(this.view = e),
              (this.prevViewport = e.viewport),
              (this.dom = document.createElement("div")),
              (this.dom.className = "cm-gutters"),
              this.dom.setAttribute("aria-hidden", "true"),
              (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
              (this.gutters = e.state.facet(xre).map((t) => new Are(e, t)))
            for (let e of this.gutters) this.dom.appendChild(e.dom)
            ;(this.fixed = !e.state.facet(kre)),
              this.fixed && (this.dom.style.position = "sticky"),
              this.syncGutters(!1),
              e.scrollDOM.insertBefore(this.dom, e.contentDOM)
          }
          update(e) {
            if (this.updateGutters(e)) {
              let t = this.prevViewport,
                n = e.view.viewport,
                r = Math.min(t.to, n.to) - Math.max(t.from, n.from)
              this.syncGutters(r < 0.8 * (n.to - n.from))
            }
            e.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
              this.view.state.facet(kre) != !this.fixed &&
                ((this.fixed = !this.fixed), (this.dom.style.position = this.fixed ? "sticky" : "")),
              (this.prevViewport = e.view.viewport)
          }
          syncGutters(e) {
            let t = this.dom.nextSibling
            e && this.dom.remove()
            let n = h6.iter(this.view.state.facet(wre), this.view.viewport.from),
              r = [],
              a = this.gutters.map((e) => new Tre(e, this.view.viewport, -this.view.documentPadding.top))
            for (let e of this.view.viewportLineBlocks)
              if ((r.length && (r = []), Array.isArray(e.type))) {
                let t = !0
                for (let o of e.type)
                  if (o.type == j9.Text && t) {
                    Ere(n, r, o.from)
                    for (let e of a) e.line(this.view, o, r)
                    t = !1
                  } else if (o.widget) for (let e of a) e.widget(this.view, o)
              } else if (e.type == j9.Text) {
                Ere(n, r, e.from)
                for (let t of a) t.line(this.view, e, r)
              } else if (e.widget) for (let t of a) t.widget(this.view, e)
            for (let e of a) e.finish()
            e && this.view.scrollDOM.insertBefore(this.dom, t)
          }
          updateGutters(e) {
            let t = e.startState.facet(xre),
              n = e.state.facet(xre),
              r =
                e.docChanged ||
                e.heightChanged ||
                e.viewportChanged ||
                !h6.eq(e.startState.facet(wre), e.state.facet(wre), e.view.viewport.from, e.view.viewport.to)
            if (t == n) for (let t of this.gutters) t.update(e) && (r = !0)
            else {
              r = !0
              let a = []
              for (let r of n) {
                let n = t.indexOf(r)
                n < 0 ? a.push(new Are(this.view, r)) : (this.gutters[n].update(e), a.push(this.gutters[n]))
              }
              for (let e of this.gutters) e.dom.remove(), a.indexOf(e) < 0 && e.destroy()
              for (let e of a) this.dom.appendChild(e.dom)
              this.gutters = a
            }
            return r
          }
          destroy() {
            for (let e of this.gutters) e.destroy()
            this.dom.remove()
          }
        },
        {
          provide: (e) =>
            Tne.scrollMargins.of((t) => {
              let n = t.plugin(e)
              return n && 0 != n.gutters.length && n.fixed
                ? t.textDirection == Y9.LTR
                  ? { left: n.dom.offsetWidth * t.scaleX }
                  : { right: n.dom.offsetWidth * t.scaleX }
                : null
            }),
        },
      )
    function Sre(e) {
      return Array.isArray(e) ? e : [e]
    }
    function Ere(e, t, n) {
      for (; e.value && e.from <= n; ) e.from == n && t.push(e.value), e.next()
    }
    class Tre {
      constructor(e, t, n) {
        ;(this.gutter = e), (this.height = n), (this.i = 0), (this.cursor = h6.iter(e.markers, t.from))
      }
      addElement(e, t, n) {
        let { gutter: r } = this,
          a = (t.top - this.height) / e.scaleY,
          o = t.height / e.scaleY
        if (this.i == r.elements.length) {
          let t = new Cre(e, o, a, n)
          r.elements.push(t), r.dom.appendChild(t.dom)
        } else r.elements[this.i].update(e, o, a, n)
        ;(this.height = t.bottom), this.i++
      }
      line(e, t, n) {
        let r = []
        Ere(this.cursor, r, t.from), n.length && (r = r.concat(n))
        let a = this.gutter.config.lineMarker(e, t, r)
        a && r.unshift(a)
        let o = this.gutter
        ;(0 != r.length || o.config.renderEmptyElements) && this.addElement(e, t, r)
      }
      widget(e, t) {
        let n = this.gutter.config.widgetMarker(e, t.widget, t)
        n && this.addElement(e, t, [n])
      }
      finish() {
        let e = this.gutter
        for (; e.elements.length > this.i; ) {
          let t = e.elements.pop()
          e.dom.removeChild(t.dom), t.destroy()
        }
      }
    }
    class Are {
      constructor(e, t) {
        ;(this.view = e),
          (this.config = t),
          (this.elements = []),
          (this.spacer = null),
          (this.dom = document.createElement("div")),
          (this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""))
        for (let n in t.domEventHandlers)
          this.dom.addEventListener(n, (r) => {
            let a,
              o = r.target
            if (o != this.dom && this.dom.contains(o)) {
              for (; o.parentNode != this.dom; ) o = o.parentNode
              let e = o.getBoundingClientRect()
              a = (e.top + e.bottom) / 2
            } else a = r.clientY
            let i = e.lineBlockAtHeight(a - e.documentTop)
            t.domEventHandlers[n](e, i, r) && r.preventDefault()
          })
        ;(this.markers = Sre(t.markers(e))),
          t.initialSpacer &&
            ((this.spacer = new Cre(e, 0, 0, [t.initialSpacer(e)])),
            this.dom.appendChild(this.spacer.dom),
            (this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none"))
      }
      update(e) {
        let t = this.markers
        if (((this.markers = Sre(this.config.markers(e.view))), this.spacer && this.config.updateSpacer)) {
          let t = this.config.updateSpacer(this.spacer.markers[0], e)
          t != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [t])
        }
        let n = e.view.viewport
        return (
          !h6.eq(this.markers, t, n.from, n.to) || (!!this.config.lineMarkerChange && this.config.lineMarkerChange(e))
        )
      }
      destroy() {
        for (let e of this.elements) e.destroy()
      }
    }
    class Cre {
      constructor(e, t, n, r) {
        ;(this.height = -1),
          (this.above = 0),
          (this.markers = []),
          (this.dom = document.createElement("div")),
          (this.dom.className = "cm-gutterElement"),
          this.update(e, t, n, r)
      }
      update(e, t, n, r) {
        this.height != t && ((this.height = t), (this.dom.style.height = t + "px")),
          this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""),
          (function (e, t) {
            if (e.length != t.length) return !1
            for (let n = 0; n < e.length; n++) if (!e[n].compare(t[n])) return !1
            return !0
          })(this.markers, r) || this.setMarkers(e, r)
      }
      setMarkers(e, t) {
        let n = "cm-gutterElement",
          r = this.dom.firstChild
        for (let a = 0, o = 0; ; ) {
          let i = o,
            s = a < t.length ? t[a++] : null,
            l = !1
          if (s) {
            let e = s.elementClass
            e && (n += " " + e)
            for (let e = o; e < this.markers.length; e++)
              if (this.markers[e].compare(s)) {
                ;(i = e), (l = !0)
                break
              }
          } else i = this.markers.length
          for (; o < i; ) {
            let e = this.markers[o++]
            if (e.toDOM) {
              e.destroy(r)
              let t = r.nextSibling
              r.remove(), (r = t)
            }
          }
          if (!s) break
          s.toDOM && (l ? (r = r.nextSibling) : this.dom.insertBefore(s.toDOM(e), r)), l && o++
        }
        ;(this.dom.className = n), (this.markers = t)
      }
      destroy() {
        this.setMarkers(null, [])
      }
    }
    const Pre = _7.define(),
      Dre = _7.define({
        combine: (e) =>
          l6(
            e,
            { formatNumber: String, domEventHandlers: {} },
            {
              domEventHandlers(e, t) {
                let n = Object.assign({}, e)
                for (let e in t) {
                  let r = n[e],
                    a = t[e]
                  n[e] = r ? (e, t, n) => r(e, t, n) || a(e, t, n) : a
                }
                return n
              },
            },
          ),
      })
    class Rre extends Ore {
      constructor(e) {
        super(), (this.number = e)
      }
      eq(e) {
        return this.number == e.number
      }
      toDOM() {
        return document.createTextNode(this.number)
      }
    }
    function Nre(e, t) {
      return e.state.facet(Dre).formatNumber(t, e.state)
    }
    const $re = xre.compute([Dre], (e) => ({
      class: "cm-lineNumbers",
      renderEmptyElements: !1,
      markers: (e) => e.state.facet(Pre),
      lineMarker: (e, t, n) => (n.some((e) => e.toDOM) ? null : new Rre(Nre(e, e.state.doc.lineAt(t.from).number))),
      widgetMarker: () => null,
      lineMarkerChange: (e) => e.startState.facet(Dre) != e.state.facet(Dre),
      initialSpacer: (e) => new Rre(Nre(e, Ire(e.state.doc.lines))),
      updateSpacer(e, t) {
        let n = Nre(t.view, Ire(t.view.state.doc.lines))
        return n == e.number ? e : new Rre(n)
      },
      domEventHandlers: e.facet(Dre).domEventHandlers,
    }))
    function Ire(e) {
      let t = 9
      for (; t < e; ) t = 10 * t + 9
      return t
    }
    const Mre = 1024
    let Lre = 0
    class Qre {
      constructor(e, t) {
        ;(this.from = e), (this.to = t)
      }
    }
    class Bre {
      constructor(e = {}) {
        ;(this.id = Lre++),
          (this.perNode = !!e.perNode),
          (this.deserialize =
            e.deserialize ||
            (() => {
              throw new Error("This node type doesn't define a deserialize function")
            }))
      }
      add(e) {
        if (this.perNode) throw new RangeError("Can't add per-node props to node types")
        return (
          "function" != typeof e && (e = Fre.match(e)),
          (t) => {
            let n = e(t)
            return void 0 === n ? null : [this, n]
          }
        )
      }
    }
    ;(Bre.closedBy = new Bre({ deserialize: (e) => e.split(" ") })),
      (Bre.openedBy = new Bre({ deserialize: (e) => e.split(" ") })),
      (Bre.group = new Bre({ deserialize: (e) => e.split(" ") })),
      (Bre.isolate = new Bre({
        deserialize: (e) => {
          if (e && "rtl" != e && "ltr" != e && "auto" != e) throw new RangeError("Invalid value for isolate: " + e)
          return e || "auto"
        },
      })),
      (Bre.contextHash = new Bre({ perNode: !0 })),
      (Bre.lookAhead = new Bre({ perNode: !0 })),
      (Bre.mounted = new Bre({ perNode: !0 }))
    class jre {
      constructor(e, t, n) {
        ;(this.tree = e), (this.overlay = t), (this.parser = n)
      }
      static get(e) {
        return e && e.props && e.props[Bre.mounted.id]
      }
    }
    const Ure = Object.create(null)
    class Fre {
      constructor(e, t, n, r = 0) {
        ;(this.name = e), (this.props = t), (this.id = n), (this.flags = r)
      }
      static define(e) {
        let t = e.props && e.props.length ? Object.create(null) : Ure,
          n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (null == e.name ? 8 : 0),
          r = new Fre(e.name || "", t, e.id, n)
        if (e.props)
          for (let n of e.props)
            if ((Array.isArray(n) || (n = n(r)), n)) {
              if (n[0].perNode) throw new RangeError("Can't store a per-node prop on a node type")
              t[n[0].id] = n[1]
            }
        return r
      }
      prop(e) {
        return this.props[e.id]
      }
      get isTop() {
        return (1 & this.flags) > 0
      }
      get isSkipped() {
        return (2 & this.flags) > 0
      }
      get isError() {
        return (4 & this.flags) > 0
      }
      get isAnonymous() {
        return (8 & this.flags) > 0
      }
      is(e) {
        if ("string" == typeof e) {
          if (this.name == e) return !0
          let t = this.prop(Bre.group)
          return !!t && t.indexOf(e) > -1
        }
        return this.id == e
      }
      static match(e) {
        let t = Object.create(null)
        for (let n in e) for (let r of n.split(" ")) t[r] = e[n]
        return (e) => {
          for (let n = e.prop(Bre.group), r = -1; r < (n ? n.length : 0); r++) {
            let a = t[r < 0 ? e.name : n[r]]
            if (a) return a
          }
        }
      }
    }
    Fre.none = new Fre("", Object.create(null), 0, 8)
    class zre {
      constructor(e) {
        this.types = e
        for (let t = 0; t < e.length; t++)
          if (e[t].id != t)
            throw new RangeError("Node type ids should correspond to array positions when creating a node set")
      }
      extend(...e) {
        let t = []
        for (let n of this.types) {
          let r = null
          for (let t of e) {
            let e = t(n)
            e && (r || (r = Object.assign({}, n.props)), (r[e[0].id] = e[1]))
          }
          t.push(r ? new Fre(n.name, r, n.id, n.flags) : n)
        }
        return new zre(t)
      }
    }
    const qre = new WeakMap(),
      Zre = new WeakMap()
    var Hre, Vre
    ;((Vre = Hre || (Hre = {}))[(Vre.ExcludeBuffers = 1)] = "ExcludeBuffers"),
      (Vre[(Vre.IncludeAnonymous = 2)] = "IncludeAnonymous"),
      (Vre[(Vre.IgnoreMounts = 4)] = "IgnoreMounts"),
      (Vre[(Vre.IgnoreOverlays = 8)] = "IgnoreOverlays")
    class Wre {
      constructor(e, t, n, r, a) {
        if (
          ((this.type = e),
          (this.children = t),
          (this.positions = n),
          (this.length = r),
          (this.props = null),
          a && a.length)
        ) {
          this.props = Object.create(null)
          for (let [e, t] of a) this.props["number" == typeof e ? e : e.id] = t
        }
      }
      toString() {
        let e = jre.get(this)
        if (e && !e.overlay) return e.tree.toString()
        let t = ""
        for (let e of this.children) {
          let n = e.toString()
          n && (t && (t += ","), (t += n))
        }
        return this.type.name
          ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
              (t.length ? "(" + t + ")" : "")
          : t
      }
      cursor(e = 0) {
        return new sae(this.topNode, e)
      }
      cursorAt(e, t = 0, n = 0) {
        let r = qre.get(this) || this.topNode,
          a = new sae(r)
        return a.moveTo(e, t), qre.set(this, a._tree), a
      }
      get topNode() {
        return new eae(this, 0, 0, null)
      }
      resolve(e, t = 0) {
        let n = Kre(qre.get(this) || this.topNode, e, t, !1)
        return qre.set(this, n), n
      }
      resolveInner(e, t = 0) {
        let n = Kre(Zre.get(this) || this.topNode, e, t, !0)
        return Zre.set(this, n), n
      }
      resolveStack(e, t = 0) {
        return (function (e, t, n) {
          let r = e.resolveInner(t, n),
            a = null
          for (let e = r instanceof eae ? r : r.context.parent; e; e = e.parent)
            if (e.index < 0) {
              let o = e.parent
              ;(a || (a = [r])).push(o.resolve(t, n)), (e = o)
            } else {
              let o = jre.get(e.tree)
              if (o && o.overlay && o.overlay[0].from <= t && o.overlay[o.overlay.length - 1].to >= t) {
                let i = new eae(o.tree, o.overlay[0].from + e.from, -1, e)
                ;(a || (a = [r])).push(Kre(i, t, n, !1))
              }
            }
          return a ? oae(a) : r
        })(this, e, t)
      }
      iterate(e) {
        let { enter: t, leave: n, from: r = 0, to: a = this.length } = e,
          o = e.mode || 0,
          i = (o & Hre.IncludeAnonymous) > 0
        for (let e = this.cursor(o | Hre.IncludeAnonymous); ; ) {
          let o = !1
          if (e.from <= a && e.to >= r && ((!i && e.type.isAnonymous) || !1 !== t(e))) {
            if (e.firstChild()) continue
            o = !0
          }
          for (; o && n && (i || !e.type.isAnonymous) && n(e), !e.nextSibling(); ) {
            if (!e.parent()) return
            o = !0
          }
        }
      }
      prop(e) {
        return e.perNode ? (this.props ? this.props[e.id] : void 0) : this.type.prop(e)
      }
      get propValues() {
        let e = []
        if (this.props) for (let t in this.props) e.push([+t, this.props[t]])
        return e
      }
      balance(e = {}) {
        return this.children.length <= 8
          ? this
          : uae(
              Fre.none,
              this.children,
              this.positions,
              0,
              this.children.length,
              0,
              this.length,
              (e, t, n) => new Wre(this.type, e, t, n, this.propValues),
              e.makeTree || ((e, t, n) => new Wre(Fre.none, e, t, n)),
            )
      }
      static build(e) {
        return (function (e) {
          var t
          let {
              buffer: n,
              nodeSet: r,
              maxBufferLength: a = Mre,
              reused: o = [],
              minRepeatType: i = r.types.length,
            } = e,
            s = Array.isArray(n) ? new Xre(n, n.length) : n,
            l = r.types,
            c = 0,
            d = 0
          function u(e, t, n, g, b, v) {
            let { id: y, start: O, end: w, size: x } = s,
              k = d
            for (; x < 0; ) {
              if ((s.next(), -1 == x)) {
                let t = o[y]
                return n.push(t), void g.push(O - e)
              }
              if (-3 == x) return void (c = y)
              if (-4 == x) return void (d = y)
              throw new RangeError(`Unrecognized record size: ${x}`)
            }
            let _,
              S,
              E = l[y],
              T = O - e
            if (
              w - O <= a &&
              (S = (function (e, t) {
                let n = s.fork(),
                  r = 0,
                  o = 0,
                  l = 0,
                  c = n.end - a,
                  d = { size: 0, start: 0, skip: 0 }
                e: for (let a = n.pos - e; n.pos > a; ) {
                  let e = n.size
                  if (n.id == t && e >= 0) {
                    ;(d.size = r), (d.start = o), (d.skip = l), (l += 4), (r += 4), n.next()
                    continue
                  }
                  let s = n.pos - e
                  if (e < 0 || s < a || n.start < c) break
                  let u = n.id >= i ? 4 : 0,
                    p = n.start
                  for (n.next(); n.pos > s; ) {
                    if (n.size < 0) {
                      if (-3 != n.size) break e
                      u += 4
                    } else n.id >= i && (u += 4)
                    n.next()
                  }
                  ;(o = p), (r += e), (l += u)
                }
                return (t < 0 || r == e) && ((d.size = r), (d.start = o), (d.skip = l)), d.size > 4 ? d : void 0
              })(s.pos - t, b))
            ) {
              let t = new Uint16Array(S.size - S.skip),
                n = s.pos - S.size,
                a = t.length
              for (; s.pos > n; ) a = m(S.start, t, a)
              ;(_ = new Yre(t, w - S.start, r)), (T = S.start - e)
            } else {
              let e = s.pos - x
              s.next()
              let t = [],
                n = [],
                r = y >= i ? y : -1,
                o = 0,
                l = w
              for (; s.pos > e; )
                r >= 0 && s.id == r && s.size >= 0
                  ? (s.end <= l - a && (h(t, n, O, o, s.end, l, r, k), (o = t.length), (l = s.end)), s.next())
                  : v > 2500
                    ? p(O, e, t, n)
                    : u(O, e, t, n, r, v + 1)
              if (
                (r >= 0 && o > 0 && o < t.length && h(t, n, O, o, O, l, r, k),
                t.reverse(),
                n.reverse(),
                r > -1 && o > 0)
              ) {
                let e = (function (e) {
                  return (t, n, r) => {
                    let a,
                      o,
                      i = 0,
                      s = t.length - 1
                    if (s >= 0 && (a = t[s]) instanceof Wre) {
                      if (!s && a.type == e && a.length == r) return a
                      ;(o = a.prop(Bre.lookAhead)) && (i = n[s] + a.length + o)
                    }
                    return f(e, t, n, r, i)
                  }
                })(E)
                _ = uae(E, t, n, 0, t.length, 0, w - O, e, e)
              } else _ = f(E, t, n, w - O, k - w)
            }
            n.push(_), g.push(T)
          }
          function p(e, t, n, o) {
            let i = [],
              l = 0,
              c = -1
            for (; s.pos > t; ) {
              let { id: e, start: t, end: n, size: r } = s
              if (r > 4) s.next()
              else {
                if (c > -1 && t < c) break
                c < 0 && (c = n - a), i.push(e, t, n), l++, s.next()
              }
            }
            if (l) {
              let t = new Uint16Array(4 * l),
                a = i[i.length - 2]
              for (let e = i.length - 3, n = 0; e >= 0; e -= 3)
                (t[n++] = i[e]), (t[n++] = i[e + 1] - a), (t[n++] = i[e + 2] - a), (t[n++] = n)
              n.push(new Yre(t, i[2] - a, r)), o.push(a - e)
            }
          }
          function h(e, t, n, a, o, i, s, l) {
            let c = [],
              d = []
            for (; e.length > a; ) c.push(e.pop()), d.push(t.pop() + n - o)
            e.push(f(r.types[s], c, d, i - o, l - i)), t.push(o - n)
          }
          function f(e, t, n, r, a = 0, o) {
            if (c) {
              let e = [Bre.contextHash, c]
              o = o ? [e].concat(o) : [e]
            }
            if (a > 25) {
              let e = [Bre.lookAhead, a]
              o = o ? [e].concat(o) : [e]
            }
            return new Wre(e, t, n, r, o)
          }
          function m(e, t, n) {
            let { id: r, start: a, end: o, size: l } = s
            if ((s.next(), l >= 0 && r < i)) {
              let i = n
              if (l > 4) {
                let r = s.pos - (l - 4)
                for (; s.pos > r; ) n = m(e, t, n)
              }
              ;(t[--n] = i), (t[--n] = o - e), (t[--n] = a - e), (t[--n] = r)
            } else -3 == l ? (c = r) : -4 == l && (d = r)
            return n
          }
          let g = [],
            b = []
          for (; s.pos > 0; ) u(e.start || 0, e.bufferStart || 0, g, b, -1, 0)
          let v = null !== (t = e.length) && void 0 !== t ? t : g.length ? b[0] + g[0].length : 0
          return new Wre(l[e.topID], g.reverse(), b.reverse(), v)
        })(e)
      }
    }
    Wre.empty = new Wre(Fre.none, [], [], 0)
    class Xre {
      constructor(e, t) {
        ;(this.buffer = e), (this.index = t)
      }
      get id() {
        return this.buffer[this.index - 4]
      }
      get start() {
        return this.buffer[this.index - 3]
      }
      get end() {
        return this.buffer[this.index - 2]
      }
      get size() {
        return this.buffer[this.index - 1]
      }
      get pos() {
        return this.index
      }
      next() {
        this.index -= 4
      }
      fork() {
        return new Xre(this.buffer, this.index)
      }
    }
    class Yre {
      constructor(e, t, n) {
        ;(this.buffer = e), (this.length = t), (this.set = n)
      }
      get type() {
        return Fre.none
      }
      toString() {
        let e = []
        for (let t = 0; t < this.buffer.length; ) e.push(this.childString(t)), (t = this.buffer[t + 3])
        return e.join(",")
      }
      childString(e) {
        let t = this.buffer[e],
          n = this.buffer[e + 3],
          r = this.set.types[t],
          a = r.name
        if ((/\W/.test(a) && !r.isError && (a = JSON.stringify(a)), n == (e += 4))) return a
        let o = []
        for (; e < n; ) o.push(this.childString(e)), (e = this.buffer[e + 3])
        return a + "(" + o.join(",") + ")"
      }
      findChild(e, t, n, r, a) {
        let { buffer: o } = this,
          i = -1
        for (let s = e; s != t && !(Gre(a, r, o[s + 1], o[s + 2]) && ((i = s), n > 0)); s = o[s + 3]);
        return i
      }
      slice(e, t, n) {
        let r = this.buffer,
          a = new Uint16Array(t - e),
          o = 0
        for (let i = e, s = 0; i < t; ) {
          ;(a[s++] = r[i++]), (a[s++] = r[i++] - n)
          let t = (a[s++] = r[i++] - n)
          ;(a[s++] = r[i++] - e), (o = Math.max(o, t))
        }
        return new Yre(a, o, this.set)
      }
    }
    function Gre(e, t, n, r) {
      switch (e) {
        case -2:
          return n < t
        case -1:
          return r >= t && n < t
        case 0:
          return n < t && r > t
        case 1:
          return n <= t && r > t
        case 2:
          return r > t
        case 4:
          return !0
      }
    }
    function Kre(e, t, n, r) {
      for (var a; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t); ) {
        let t = !r && e instanceof eae && e.index < 0 ? null : e.parent
        if (!t) return e
        e = t
      }
      let o = r ? 0 : Hre.IgnoreOverlays
      if (r)
        for (let r = e, i = r.parent; i; r = i, i = r.parent)
          r instanceof eae &&
            r.index < 0 &&
            (null === (a = i.enter(t, n, o)) || void 0 === a ? void 0 : a.from) != r.from &&
            (e = i)
      for (;;) {
        let r = e.enter(t, n, o)
        if (!r) return e
        e = r
      }
    }
    class Jre {
      cursor(e = 0) {
        return new sae(this, e)
      }
      getChild(e, t = null, n = null) {
        let r = tae(this, e, t, n)
        return r.length ? r[0] : null
      }
      getChildren(e, t = null, n = null) {
        return tae(this, e, t, n)
      }
      resolve(e, t = 0) {
        return Kre(this, e, t, !1)
      }
      resolveInner(e, t = 0) {
        return Kre(this, e, t, !0)
      }
      matchContext(e) {
        return nae(this, e)
      }
      enterUnfinishedNodesBefore(e) {
        let t = this.childBefore(e),
          n = this
        for (; t; ) {
          let e = t.lastChild
          if (!e || e.to != t.to) break
          e.type.isError && e.from == e.to ? ((n = t), (t = e.prevSibling)) : (t = e)
        }
        return n
      }
      get node() {
        return this
      }
      get next() {
        return this.parent
      }
    }
    class eae extends Jre {
      constructor(e, t, n, r) {
        super(), (this._tree = e), (this.from = t), (this.index = n), (this._parent = r)
      }
      get type() {
        return this._tree.type
      }
      get name() {
        return this._tree.type.name
      }
      get to() {
        return this.from + this._tree.length
      }
      nextChild(e, t, n, r, a = 0) {
        for (let o = this; ; ) {
          for (let { children: i, positions: s } = o._tree, l = t > 0 ? i.length : -1; e != l; e += t) {
            let l = i[e],
              c = s[e] + o.from
            if (Gre(r, n, c, c + l.length))
              if (l instanceof Yre) {
                if (a & Hre.ExcludeBuffers) continue
                let i = l.findChild(0, l.buffer.length, t, n - c, r)
                if (i > -1) return new aae(new rae(o, l, e, c), null, i)
              } else if (a & Hre.IncludeAnonymous || !l.type.isAnonymous || lae(l)) {
                let i
                if (!(a & Hre.IgnoreMounts) && (i = jre.get(l)) && !i.overlay) return new eae(i.tree, c, e, o)
                let s = new eae(l, c, e, o)
                return a & Hre.IncludeAnonymous || !s.type.isAnonymous
                  ? s
                  : s.nextChild(t < 0 ? l.children.length - 1 : 0, t, n, r)
              }
          }
          if (a & Hre.IncludeAnonymous || !o.type.isAnonymous) return null
          if (((e = o.index >= 0 ? o.index + t : t < 0 ? -1 : o._parent._tree.children.length), (o = o._parent), !o))
            return null
        }
      }
      get firstChild() {
        return this.nextChild(0, 1, 0, 4)
      }
      get lastChild() {
        return this.nextChild(this._tree.children.length - 1, -1, 0, 4)
      }
      childAfter(e) {
        return this.nextChild(0, 1, e, 2)
      }
      childBefore(e) {
        return this.nextChild(this._tree.children.length - 1, -1, e, -2)
      }
      enter(e, t, n = 0) {
        let r
        if (!(n & Hre.IgnoreOverlays) && (r = jre.get(this._tree)) && r.overlay) {
          let n = e - this.from
          for (let { from: e, to: a } of r.overlay)
            if ((t > 0 ? e <= n : e < n) && (t < 0 ? a >= n : a > n))
              return new eae(r.tree, r.overlay[0].from + this.from, -1, this)
        }
        return this.nextChild(0, 1, e, t, n)
      }
      nextSignificantParent() {
        let e = this
        for (; e.type.isAnonymous && e._parent; ) e = e._parent
        return e
      }
      get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null
      }
      get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null
      }
      get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null
      }
      get tree() {
        return this._tree
      }
      toTree() {
        return this._tree
      }
      toString() {
        return this._tree.toString()
      }
    }
    function tae(e, t, n, r) {
      let a = e.cursor(),
        o = []
      if (!a.firstChild()) return o
      if (null != n) for (let e = !1; !e; ) if (((e = a.type.is(n)), !a.nextSibling())) return o
      for (;;) {
        if (null != r && a.type.is(r)) return o
        if ((a.type.is(t) && o.push(a.node), !a.nextSibling())) return null == r ? o : []
      }
    }
    function nae(e, t, n = t.length - 1) {
      for (let r = e.parent; n >= 0; r = r.parent) {
        if (!r) return !1
        if (!r.type.isAnonymous) {
          if (t[n] && t[n] != r.name) return !1
          n--
        }
      }
      return !0
    }
    class rae {
      constructor(e, t, n, r) {
        ;(this.parent = e), (this.buffer = t), (this.index = n), (this.start = r)
      }
    }
    class aae extends Jre {
      get name() {
        return this.type.name
      }
      get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1]
      }
      get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2]
      }
      constructor(e, t, n) {
        super(),
          (this.context = e),
          (this._parent = t),
          (this.index = n),
          (this.type = e.buffer.set.types[e.buffer.buffer[n]])
      }
      child(e, t, n) {
        let { buffer: r } = this.context,
          a = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.context.start, n)
        return a < 0 ? null : new aae(this.context, this, a)
      }
      get firstChild() {
        return this.child(1, 0, 4)
      }
      get lastChild() {
        return this.child(-1, 0, 4)
      }
      childAfter(e) {
        return this.child(1, e, 2)
      }
      childBefore(e) {
        return this.child(-1, e, -2)
      }
      enter(e, t, n = 0) {
        if (n & Hre.ExcludeBuffers) return null
        let { buffer: r } = this.context,
          a = r.findChild(this.index + 4, r.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t)
        return a < 0 ? null : new aae(this.context, this, a)
      }
      get parent() {
        return this._parent || this.context.parent.nextSignificantParent()
      }
      externalSibling(e) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4)
      }
      get nextSibling() {
        let { buffer: e } = this.context,
          t = e.buffer[this.index + 3]
        return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
          ? new aae(this.context, this._parent, t)
          : this.externalSibling(1)
      }
      get prevSibling() {
        let { buffer: e } = this.context,
          t = this._parent ? this._parent.index + 4 : 0
        return this.index == t
          ? this.externalSibling(-1)
          : new aae(this.context, this._parent, e.findChild(t, this.index, -1, 0, 4))
      }
      get tree() {
        return null
      }
      toTree() {
        let e = [],
          t = [],
          { buffer: n } = this.context,
          r = this.index + 4,
          a = n.buffer[this.index + 3]
        if (a > r) {
          let o = n.buffer[this.index + 1]
          e.push(n.slice(r, a, o)), t.push(0)
        }
        return new Wre(this.type, e, t, this.to - this.from)
      }
      toString() {
        return this.context.buffer.childString(this.index)
      }
    }
    function oae(e) {
      if (!e.length) return null
      let t = 0,
        n = e[0]
      for (let r = 1; r < e.length; r++) {
        let a = e[r]
        ;(a.from > n.from || a.to < n.to) && ((n = a), (t = r))
      }
      let r = n instanceof eae && n.index < 0 ? null : n.parent,
        a = e.slice()
      return r ? (a[t] = r) : a.splice(t, 1), new iae(a, n)
    }
    class iae {
      constructor(e, t) {
        ;(this.heads = e), (this.node = t)
      }
      get next() {
        return oae(this.heads)
      }
    }
    class sae {
      get name() {
        return this.type.name
      }
      constructor(e, t = 0) {
        if (
          ((this.mode = t),
          (this.buffer = null),
          (this.stack = []),
          (this.index = 0),
          (this.bufferNode = null),
          e instanceof eae)
        )
          this.yieldNode(e)
        else {
          ;(this._tree = e.context.parent), (this.buffer = e.context)
          for (let t = e._parent; t; t = t._parent) this.stack.unshift(t.index)
          ;(this.bufferNode = e), this.yieldBuf(e.index)
        }
      }
      yieldNode(e) {
        return !!e && ((this._tree = e), (this.type = e.type), (this.from = e.from), (this.to = e.to), !0)
      }
      yieldBuf(e, t) {
        this.index = e
        let { start: n, buffer: r } = this.buffer
        return (
          (this.type = t || r.set.types[r.buffer[e]]),
          (this.from = n + r.buffer[e + 1]),
          (this.to = n + r.buffer[e + 2]),
          !0
        )
      }
      yield(e) {
        return (
          !!e &&
          (e instanceof eae
            ? ((this.buffer = null), this.yieldNode(e))
            : ((this.buffer = e.context), this.yieldBuf(e.index, e.type)))
        )
      }
      toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()
      }
      enterChild(e, t, n) {
        if (!this.buffer)
          return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, n, this.mode))
        let { buffer: r } = this.buffer,
          a = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.buffer.start, n)
        return !(a < 0) && (this.stack.push(this.index), this.yieldBuf(a))
      }
      firstChild() {
        return this.enterChild(1, 0, 4)
      }
      lastChild() {
        return this.enterChild(-1, 0, 4)
      }
      childAfter(e) {
        return this.enterChild(1, e, 2)
      }
      childBefore(e) {
        return this.enterChild(-1, e, -2)
      }
      enter(e, t, n = this.mode) {
        return this.buffer
          ? !(n & Hre.ExcludeBuffers) && this.enterChild(1, e, t)
          : this.yield(this._tree.enter(e, t, n))
      }
      parent() {
        if (!this.buffer)
          return this.yieldNode(this.mode & Hre.IncludeAnonymous ? this._tree._parent : this._tree.parent)
        if (this.stack.length) return this.yieldBuf(this.stack.pop())
        let e = this.mode & Hre.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent()
        return (this.buffer = null), this.yieldNode(e)
      }
      sibling(e) {
        if (!this.buffer)
          return (
            !!this._tree._parent &&
            this.yield(
              this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode),
            )
          )
        let { buffer: t } = this.buffer,
          n = this.stack.length - 1
        if (e < 0) {
          let e = n < 0 ? 0 : this.stack[n] + 4
          if (this.index != e) return this.yieldBuf(t.findChild(e, this.index, -1, 0, 4))
        } else {
          let e = t.buffer[this.index + 3]
          if (e < (n < 0 ? t.buffer.length : t.buffer[this.stack[n] + 3])) return this.yieldBuf(e)
        }
        return n < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode))
      }
      nextSibling() {
        return this.sibling(1)
      }
      prevSibling() {
        return this.sibling(-1)
      }
      atLastNode(e) {
        let t,
          n,
          { buffer: r } = this
        if (r) {
          if (e > 0) {
            if (this.index < r.buffer.buffer.length) return !1
          } else for (let e = 0; e < this.index; e++) if (r.buffer.buffer[e + 3] < this.index) return !1
          ;({ index: t, parent: n } = r)
        } else ({ index: t, _parent: n } = this._tree)
        for (; n; { index: t, _parent: n } = n)
          if (t > -1)
            for (let r = t + e, a = e < 0 ? -1 : n._tree.children.length; r != a; r += e) {
              let e = n._tree.children[r]
              if (this.mode & Hre.IncludeAnonymous || e instanceof Yre || !e.type.isAnonymous || lae(e)) return !1
            }
        return !0
      }
      move(e, t) {
        if (t && this.enterChild(e, 0, 4)) return !0
        for (;;) {
          if (this.sibling(e)) return !0
          if (this.atLastNode(e) || !this.parent()) return !1
        }
      }
      next(e = !0) {
        return this.move(1, e)
      }
      prev(e = !0) {
        return this.move(-1, e)
      }
      moveTo(e, t = 0) {
        for (
          ;
          (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) &&
          this.parent();

        );
        for (; this.enterChild(1, e, t); );
        return this
      }
      get node() {
        if (!this.buffer) return this._tree
        let e = this.bufferNode,
          t = null,
          n = 0
        if (e && e.context == this.buffer)
          e: for (let r = this.index, a = this.stack.length; a >= 0; ) {
            for (let o = e; o; o = o._parent)
              if (o.index == r) {
                if (r == this.index) return o
                ;(t = o), (n = a + 1)
                break e
              }
            r = this.stack[--a]
          }
        for (let e = n; e < this.stack.length; e++) t = new aae(this.buffer, t, this.stack[e])
        return (this.bufferNode = new aae(this.buffer, t, this.index))
      }
      get tree() {
        return this.buffer ? null : this._tree._tree
      }
      iterate(e, t) {
        for (let n = 0; ; ) {
          let r = !1
          if (this.type.isAnonymous || !1 !== e(this)) {
            if (this.firstChild()) {
              n++
              continue
            }
            this.type.isAnonymous || (r = !0)
          }
          for (; r && t && t(this), (r = this.type.isAnonymous), !this.nextSibling(); ) {
            if (!n) return
            this.parent(), n--, (r = !0)
          }
        }
      }
      matchContext(e) {
        if (!this.buffer) return nae(this.node, e)
        let { buffer: t } = this.buffer,
          { types: n } = t.set
        for (let r = e.length - 1, a = this.stack.length - 1; r >= 0; a--) {
          if (a < 0) return nae(this.node, e, r)
          let o = n[t.buffer[this.stack[a]]]
          if (!o.isAnonymous) {
            if (e[r] && e[r] != o.name) return !1
            r--
          }
        }
        return !0
      }
    }
    function lae(e) {
      return e.children.some((e) => e instanceof Yre || !e.type.isAnonymous || lae(e))
    }
    const cae = new WeakMap()
    function dae(e, t) {
      if (!e.isAnonymous || t instanceof Yre || t.type != e) return 1
      let n = cae.get(t)
      if (null == n) {
        n = 1
        for (let r of t.children) {
          if (r.type != e || !(r instanceof Wre)) {
            n = 1
            break
          }
          n += dae(e, r)
        }
        cae.set(t, n)
      }
      return n
    }
    function uae(e, t, n, r, a, o, i, s, l) {
      let c = 0
      for (let n = r; n < a; n++) c += dae(e, t[n])
      let d = Math.ceil((1.5 * c) / 8),
        u = [],
        p = []
      return (
        (function t(n, r, a, i, s) {
          for (let c = a; c < i; ) {
            let a = c,
              h = r[c],
              f = dae(e, n[c])
            for (c++; c < i; c++) {
              let t = dae(e, n[c])
              if (f + t >= d) break
              f += t
            }
            if (c == a + 1) {
              if (f > d) {
                let e = n[a]
                t(e.children, e.positions, 0, e.children.length, r[a] + s)
                continue
              }
              u.push(n[a])
            } else {
              let t = r[c - 1] + n[c - 1].length - h
              u.push(uae(e, n, r, a, c, h, t, null, l))
            }
            p.push(h + s - o)
          }
        })(t, n, r, a, 0),
        (s || l)(u, p, i)
      )
    }
    class pae {
      constructor() {
        this.map = new WeakMap()
      }
      setBuffer(e, t, n) {
        let r = this.map.get(e)
        r || this.map.set(e, (r = new Map())), r.set(t, n)
      }
      getBuffer(e, t) {
        let n = this.map.get(e)
        return n && n.get(t)
      }
      set(e, t) {
        e instanceof aae ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof eae && this.map.set(e.tree, t)
      }
      get(e) {
        return e instanceof aae
          ? this.getBuffer(e.context.buffer, e.index)
          : e instanceof eae
            ? this.map.get(e.tree)
            : void 0
      }
      cursorSet(e, t) {
        e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t)
      }
      cursorGet(e) {
        return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree)
      }
    }
    class hae {
      constructor(e, t, n, r, a = !1, o = !1) {
        ;(this.from = e), (this.to = t), (this.tree = n), (this.offset = r), (this.open = (a ? 1 : 0) | (o ? 2 : 0))
      }
      get openStart() {
        return (1 & this.open) > 0
      }
      get openEnd() {
        return (2 & this.open) > 0
      }
      static addTree(e, t = [], n = !1) {
        let r = [new hae(0, e.length, e, 0, !1, n)]
        for (let n of t) n.to > e.length && r.push(n)
        return r
      }
      static applyChanges(e, t, n = 128) {
        if (!t.length) return e
        let r = [],
          a = 1,
          o = e.length ? e[0] : null
        for (let i = 0, s = 0, l = 0; ; i++) {
          let c = i < t.length ? t[i] : null,
            d = c ? c.fromA : 1e9
          if (d - s >= n)
            for (; o && o.from < d; ) {
              let t = o
              if (s >= t.from || d <= t.to || l) {
                let e = Math.max(t.from, s) - l,
                  n = Math.min(t.to, d) - l
                t = e >= n ? null : new hae(e, n, t.tree, t.offset + l, i > 0, !!c)
              }
              if ((t && r.push(t), o.to > d)) break
              o = a < e.length ? e[a++] : null
            }
          if (!c) break
          ;(s = c.toA), (l = c.toA - c.toB)
        }
        return r
      }
    }
    class fae {
      startParse(e, t, n) {
        return (
          "string" == typeof e && (e = new mae(e)),
          (n = n ? (n.length ? n.map((e) => new Qre(e.from, e.to)) : [new Qre(0, 0)]) : [new Qre(0, e.length)]),
          this.createParse(e, t || [], n)
        )
      }
      parse(e, t, n) {
        let r = this.startParse(e, t, n)
        for (;;) {
          let e = r.advance()
          if (e) return e
        }
      }
    }
    class mae {
      constructor(e) {
        this.string = e
      }
      get length() {
        return this.string.length
      }
      chunk(e) {
        return this.string.slice(e)
      }
      get lineChunks() {
        return !1
      }
      read(e, t) {
        return this.string.slice(e, t)
      }
    }
    class gae {
      constructor(e, t, n, r, a) {
        ;(this.parser = e), (this.parse = t), (this.overlay = n), (this.target = r), (this.from = a)
      }
    }
    function bae(e) {
      if (!e.length || e.some((e) => e.from >= e.to))
        throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(e))
    }
    class vae {
      constructor(e, t, n, r, a, o, i) {
        ;(this.parser = e),
          (this.predicate = t),
          (this.mounts = n),
          (this.index = r),
          (this.start = a),
          (this.target = o),
          (this.prev = i),
          (this.depth = 0),
          (this.ranges = [])
      }
    }
    const yae = new Bre({ perNode: !0 })
    class Oae {
      constructor(e, t, n, r, a) {
        ;(this.nest = t),
          (this.input = n),
          (this.fragments = r),
          (this.ranges = a),
          (this.inner = []),
          (this.innerDone = 0),
          (this.baseTree = null),
          (this.stoppedAt = null),
          (this.baseParse = e)
      }
      advance() {
        if (this.baseParse) {
          let e = this.baseParse.advance()
          if (!e) return null
          if (((this.baseParse = null), (this.baseTree = e), this.startInner(), null != this.stoppedAt))
            for (let e of this.inner) e.parse.stopAt(this.stoppedAt)
        }
        if (this.innerDone == this.inner.length) {
          let e = this.baseTree
          return (
            null != this.stoppedAt &&
              (e = new Wre(e.type, e.children, e.positions, e.length, e.propValues.concat([[yae, this.stoppedAt]]))),
            e
          )
        }
        let e = this.inner[this.innerDone],
          t = e.parse.advance()
        if (t) {
          this.innerDone++
          let n = Object.assign(Object.create(null), e.target.props)
          ;(n[Bre.mounted.id] = new jre(t, e.overlay, e.parser)), (e.target.props = n)
        }
        return null
      }
      get parsedPos() {
        if (this.baseParse) return 0
        let e = this.input.length
        for (let t = this.innerDone; t < this.inner.length; t++)
          this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos))
        return e
      }
      stopAt(e) {
        if (((this.stoppedAt = e), this.baseParse)) this.baseParse.stopAt(e)
        else for (let t = this.innerDone; t < this.inner.length; t++) this.inner[t].parse.stopAt(e)
      }
      startInner() {
        let e = new Sae(this.fragments),
          t = null,
          n = null,
          r = new sae(new eae(this.baseTree, this.ranges[0].from, 0, null), Hre.IncludeAnonymous | Hre.IgnoreMounts)
        e: for (let a, o; ; ) {
          let i,
            s = !0
          if (null != this.stoppedAt && r.from >= this.stoppedAt) s = !1
          else if (e.hasNode(r)) {
            if (t) {
              let e = t.mounts.find((e) => e.frag.from <= r.from && e.frag.to >= r.to && e.mount.overlay)
              if (e)
                for (let n of e.mount.overlay) {
                  let a = n.from + e.pos,
                    o = n.to + e.pos
                  a >= r.from &&
                    o <= r.to &&
                    !t.ranges.some((e) => e.from < o && e.to > a) &&
                    t.ranges.push({ from: a, to: o })
                }
            }
            s = !1
          } else if (n && (o = wae(n.ranges, r.from, r.to))) s = 2 != o
          else if (!r.type.isAnonymous && (a = this.nest(r, this.input)) && (r.from < r.to || !a.overlay)) {
            r.tree || kae(r)
            let o = e.findMounts(r.from, a.parser)
            if ("function" == typeof a.overlay)
              t = new vae(a.parser, a.overlay, o, this.inner.length, r.from, r.tree, t)
            else {
              let e = Eae(this.ranges, a.overlay || (r.from < r.to ? [new Qre(r.from, r.to)] : []))
              e.length && bae(e),
                (!e.length && a.overlay) ||
                  this.inner.push(
                    new gae(
                      a.parser,
                      e.length ? a.parser.startParse(this.input, Aae(o, e), e) : a.parser.startParse(""),
                      a.overlay ? a.overlay.map((e) => new Qre(e.from - r.from, e.to - r.from)) : null,
                      r.tree,
                      e.length ? e[0].from : r.from,
                    ),
                  ),
                a.overlay ? e.length && (n = { ranges: e, depth: 0, prev: n }) : (s = !1)
            }
          } else
            t && (i = t.predicate(r)) && (!0 === i && (i = new Qre(r.from, r.to)), i.from < i.to && t.ranges.push(i))
          if (s && r.firstChild()) t && t.depth++, n && n.depth++
          else
            for (; !r.nextSibling(); ) {
              if (!r.parent()) break e
              if (t && !--t.depth) {
                let e = Eae(this.ranges, t.ranges)
                e.length &&
                  (bae(e),
                  this.inner.splice(
                    t.index,
                    0,
                    new gae(
                      t.parser,
                      t.parser.startParse(this.input, Aae(t.mounts, e), e),
                      t.ranges.map((e) => new Qre(e.from - t.start, e.to - t.start)),
                      t.target,
                      e[0].from,
                    ),
                  )),
                  (t = t.prev)
              }
              n && !--n.depth && (n = n.prev)
            }
        }
      }
    }
    function wae(e, t, n) {
      for (let r of e) {
        if (r.from >= n) break
        if (r.to > t) return r.from <= t && r.to >= n ? 2 : 1
      }
      return 0
    }
    function xae(e, t, n, r, a, o) {
      if (t < n) {
        let i = e.buffer[t + 1]
        r.push(e.slice(t, n, i)), a.push(i - o)
      }
    }
    function kae(e) {
      let { node: t } = e,
        n = [],
        r = t.context.buffer
      do {
        n.push(e.index), e.parent()
      } while (!e.tree)
      let a = e.tree,
        o = a.children.indexOf(r),
        i = a.children[o],
        s = i.buffer,
        l = [o]
      a.children[o] = (function e(r, a, o, c, d, u) {
        let p = n[u],
          h = [],
          f = []
        xae(i, r, p, h, f, c)
        let m = s[p + 1],
          g = s[p + 2]
        l.push(h.length)
        let b = u ? e(p + 4, s[p + 3], i.set.types[s[p]], m, g - m, u - 1) : t.toTree()
        return h.push(b), f.push(m - c), xae(i, s[p + 3], a, h, f, c), new Wre(o, h, f, d)
      })(0, s.length, Fre.none, 0, i.length, n.length - 1)
      for (let t of l) {
        let n = e.tree.children[t],
          r = e.tree.positions[t]
        e.yield(new eae(n, r + e.from, t, e._tree))
      }
    }
    class _ae {
      constructor(e, t) {
        ;(this.offset = t), (this.done = !1), (this.cursor = e.cursor(Hre.IncludeAnonymous | Hre.IgnoreMounts))
      }
      moveTo(e) {
        let { cursor: t } = this,
          n = e - this.offset
        for (; !this.done && t.from < n; )
          (t.to >= e && t.enter(n, 1, Hre.IgnoreOverlays | Hre.ExcludeBuffers)) || t.next(!1) || (this.done = !0)
      }
      hasNode(e) {
        if ((this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree))
          for (let t = this.cursor.tree; ; ) {
            if (t == e.tree) return !0
            if (!(t.children.length && 0 == t.positions[0] && t.children[0] instanceof Wre)) break
            t = t.children[0]
          }
        return !1
      }
    }
    let Sae = class {
      constructor(e) {
        var t
        if (((this.fragments = e), (this.curTo = 0), (this.fragI = 0), e.length)) {
          let n = (this.curFrag = e[0])
          ;(this.curTo = null !== (t = n.tree.prop(yae)) && void 0 !== t ? t : n.to),
            (this.inner = new _ae(n.tree, -n.offset))
        } else this.curFrag = this.inner = null
      }
      hasNode(e) {
        for (; this.curFrag && e.from >= this.curTo; ) this.nextFrag()
        return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e)
      }
      nextFrag() {
        var e
        if ((this.fragI++, this.fragI == this.fragments.length)) this.curFrag = this.inner = null
        else {
          let t = (this.curFrag = this.fragments[this.fragI])
          ;(this.curTo = null !== (e = t.tree.prop(yae)) && void 0 !== e ? e : t.to),
            (this.inner = new _ae(t.tree, -t.offset))
        }
      }
      findMounts(e, t) {
        var n
        let r = []
        if (this.inner) {
          this.inner.cursor.moveTo(e, 1)
          for (let e = this.inner.cursor.node; e; e = e.parent) {
            let a = null === (n = e.tree) || void 0 === n ? void 0 : n.prop(Bre.mounted)
            if (a && a.parser == t)
              for (let t = this.fragI; t < this.fragments.length; t++) {
                let n = this.fragments[t]
                if (n.from >= e.to) break
                n.tree == this.curFrag.tree && r.push({ frag: n, pos: e.from - n.offset, mount: a })
              }
          }
        }
        return r
      }
    }
    function Eae(e, t) {
      let n = null,
        r = t
      for (let a = 1, o = 0; a < e.length; a++) {
        let i = e[a - 1].to,
          s = e[a].from
        for (; o < r.length; o++) {
          let e = r[o]
          if (e.from >= s) break
          e.to <= i ||
            (n || (r = n = t.slice()),
            e.from < i
              ? ((n[o] = new Qre(e.from, i)), e.to > s && n.splice(o + 1, 0, new Qre(s, e.to)))
              : e.to > s
                ? (n[o--] = new Qre(s, e.to))
                : n.splice(o--, 1))
        }
      }
      return r
    }
    function Tae(e, t, n, r) {
      let a = 0,
        o = 0,
        i = !1,
        s = !1,
        l = -1e9,
        c = []
      for (;;) {
        let d = a == e.length ? 1e9 : i ? e[a].to : e[a].from,
          u = o == t.length ? 1e9 : s ? t[o].to : t[o].from
        if (i != s) {
          let e = Math.max(l, n),
            t = Math.min(d, u, r)
          e < t && c.push(new Qre(e, t))
        }
        if (((l = Math.min(d, u)), 1e9 == l)) break
        d == l && (i ? ((i = !1), a++) : (i = !0)), u == l && (s ? ((s = !1), o++) : (s = !0))
      }
      return c
    }
    function Aae(e, t) {
      let n = []
      for (let { pos: r, mount: a, frag: o } of e) {
        let e = r + (a.overlay ? a.overlay[0].from : 0),
          i = e + a.tree.length,
          s = Math.max(o.from, e),
          l = Math.min(o.to, i)
        if (a.overlay) {
          let i = a.overlay.map((e) => new Qre(e.from + r, e.to + r)),
            c = Tae(t, i, s, l)
          for (let t = 0, r = s; ; t++) {
            let i = t == c.length,
              s = i ? l : c[t].from
            if ((s > r && n.push(new hae(r, s, a.tree, -e, o.from >= r || o.openStart, o.to <= s || o.openEnd)), i))
              break
            r = c[t].to
          }
        } else n.push(new hae(s, l, a.tree, -e, o.from >= e || o.openStart, o.to <= i || o.openEnd))
      }
      return n
    }
    let Cae = 0,
      Pae = class e {
        constructor(e, t, n) {
          ;(this.set = e), (this.base = t), (this.modified = n), (this.id = Cae++)
        }
        static define(t) {
          if (null == t ? void 0 : t.base) throw new Error("Can not derive from a modified tag")
          let n = new e([], null, [])
          if ((n.set.push(n), t)) for (let e of t.set) n.set.push(e)
          return n
        }
        static defineModifier() {
          let e = new Rae()
          return (t) =>
            t.modified.indexOf(e) > -1
              ? t
              : Rae.get(
                  t.base || t,
                  t.modified.concat(e).sort((e, t) => e.id - t.id),
                )
        }
      },
      Dae = 0
    class Rae {
      constructor() {
        ;(this.instances = []), (this.id = Dae++)
      }
      static get(e, t) {
        if (!t.length) return e
        let n = t[0].instances.find((n) => {
          return n.base == e && ((r = t), (a = n.modified), r.length == a.length && r.every((e, t) => e == a[t]))
          var r, a
        })
        if (n) return n
        let r = [],
          a = new Pae(r, e, t)
        for (let e of t) e.instances.push(a)
        let o = (function (e) {
          let t = [[]]
          for (let n = 0; n < e.length; n++) for (let r = 0, a = t.length; r < a; r++) t.push(t[r].concat(e[n]))
          return t.sort((e, t) => t.length - e.length)
        })(t)
        for (let t of e.set) if (!t.modified.length) for (let e of o) r.push(Rae.get(t, e))
        return a
      }
    }
    function Nae(e) {
      let t = Object.create(null)
      for (let n in e) {
        let r = e[n]
        Array.isArray(r) || (r = [r])
        for (let e of n.split(" "))
          if (e) {
            let n = [],
              a = 2,
              o = e
            for (let t = 0; ; ) {
              if ("..." == o && t > 0 && t + 3 == e.length) {
                a = 1
                break
              }
              let r = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o)
              if (!r) throw new RangeError("Invalid path: " + e)
              if (
                (n.push("*" == r[0] ? "" : '"' == r[0][0] ? JSON.parse(r[0]) : r[0]), (t += r[0].length), t == e.length)
              )
                break
              let i = e[t++]
              if (t == e.length && "!" == i) {
                a = 0
                break
              }
              if ("/" != i) throw new RangeError("Invalid path: " + e)
              o = e.slice(t)
            }
            let i = n.length - 1,
              s = n[i]
            if (!s) throw new RangeError("Invalid path: " + e)
            let l = new Iae(r, a, i > 0 ? n.slice(0, i) : null)
            t[s] = l.sort(t[s])
          }
      }
      return $ae.add(t)
    }
    const $ae = new Bre()
    class Iae {
      constructor(e, t, n, r) {
        ;(this.tags = e), (this.mode = t), (this.context = n), (this.next = r)
      }
      get opaque() {
        return 0 == this.mode
      }
      get inherit() {
        return 1 == this.mode
      }
      sort(e) {
        return !e || e.depth < this.depth ? ((this.next = e), this) : ((e.next = this.sort(e.next)), e)
      }
      get depth() {
        return this.context ? this.context.length : 0
      }
    }
    function Mae(e, t) {
      let n = Object.create(null)
      for (let t of e)
        if (Array.isArray(t.tag)) for (let e of t.tag) n[e.id] = t.class
        else n[t.tag.id] = t.class
      let { scope: r, all: a = null } = t || {}
      return {
        style: (e) => {
          let t = a
          for (let r of e)
            for (let e of r.set) {
              let r = n[e.id]
              if (r) {
                t = t ? t + " " + r : r
                break
              }
            }
          return t
        },
        scope: r,
      }
    }
    function Lae(e, t, n, r = 0, a = e.length) {
      let o = new Qae(r, Array.isArray(t) ? t : [t], n)
      o.highlightRange(e.cursor(), r, a, "", o.highlighters), o.flush(a)
    }
    Iae.empty = new Iae([], 2, null)
    class Qae {
      constructor(e, t, n) {
        ;(this.at = e), (this.highlighters = t), (this.span = n), (this.class = "")
      }
      startSpan(e, t) {
        t != this.class && (this.flush(e), e > this.at && (this.at = e), (this.class = t))
      }
      flush(e) {
        e > this.at && this.class && this.span(this.at, e, this.class)
      }
      highlightRange(e, t, n, r, a) {
        let { type: o, from: i, to: s } = e
        if (i >= n || s <= t) return
        o.isTop && (a = this.highlighters.filter((e) => !e.scope || e.scope(o)))
        let l = r,
          c =
            (function (e) {
              let t = e.type.prop($ae)
              for (; t && t.context && !e.matchContext(t.context); ) t = t.next
              return t || null
            })(e) || Iae.empty,
          d = (function (e, t) {
            let n = null
            for (let r of e) {
              let e = r.style(t)
              e && (n = n ? n + " " + e : e)
            }
            return n
          })(a, c.tags)
        if (
          (d && (l && (l += " "), (l += d), 1 == c.mode && (r += (r ? " " : "") + d)),
          this.startSpan(Math.max(t, i), l),
          c.opaque)
        )
          return
        let u = e.tree && e.tree.prop(Bre.mounted)
        if (u && u.overlay) {
          let o = e.node.enter(u.overlay[0].from + i, 1),
            c = this.highlighters.filter((e) => !e.scope || e.scope(u.tree.type)),
            d = e.firstChild()
          for (let p = 0, h = i; ; p++) {
            let f = p < u.overlay.length ? u.overlay[p] : null,
              m = f ? f.from + i : s,
              g = Math.max(t, h),
              b = Math.min(n, m)
            if (g < b && d)
              for (
                ;
                e.from < b &&
                (this.highlightRange(e, g, b, r, a),
                this.startSpan(Math.min(b, e.to), l),
                !(e.to >= m) && e.nextSibling());

              );
            if (!f || m > n) break
            ;(h = f.to + i),
              h > t &&
                (this.highlightRange(o.cursor(), Math.max(t, f.from + i), Math.min(n, h), "", c),
                this.startSpan(Math.min(n, h), l))
          }
          d && e.parent()
        } else if (e.firstChild()) {
          u && (r = "")
          do {
            if (!(e.to <= t)) {
              if (e.from >= n) break
              this.highlightRange(e, t, n, r, a), this.startSpan(Math.min(n, e.to), l)
            }
          } while (e.nextSibling())
          e.parent()
        }
      }
    }
    const Bae = Pae.define,
      jae = Bae(),
      Uae = Bae(),
      Fae = Bae(Uae),
      zae = Bae(Uae),
      qae = Bae(),
      Zae = Bae(qae),
      Hae = Bae(qae),
      Vae = Bae(),
      Wae = Bae(Vae),
      Xae = Bae(),
      Yae = Bae(),
      Gae = Bae(),
      Kae = Bae(Gae),
      Jae = Bae(),
      eoe = {
        comment: jae,
        lineComment: Bae(jae),
        blockComment: Bae(jae),
        docComment: Bae(jae),
        name: Uae,
        variableName: Bae(Uae),
        typeName: Fae,
        tagName: Bae(Fae),
        propertyName: zae,
        attributeName: Bae(zae),
        className: Bae(Uae),
        labelName: Bae(Uae),
        namespace: Bae(Uae),
        macroName: Bae(Uae),
        literal: qae,
        string: Zae,
        docString: Bae(Zae),
        character: Bae(Zae),
        attributeValue: Bae(Zae),
        number: Hae,
        integer: Bae(Hae),
        float: Bae(Hae),
        bool: Bae(qae),
        regexp: Bae(qae),
        escape: Bae(qae),
        color: Bae(qae),
        url: Bae(qae),
        keyword: Xae,
        self: Bae(Xae),
        null: Bae(Xae),
        atom: Bae(Xae),
        unit: Bae(Xae),
        modifier: Bae(Xae),
        operatorKeyword: Bae(Xae),
        controlKeyword: Bae(Xae),
        definitionKeyword: Bae(Xae),
        moduleKeyword: Bae(Xae),
        operator: Yae,
        derefOperator: Bae(Yae),
        arithmeticOperator: Bae(Yae),
        logicOperator: Bae(Yae),
        bitwiseOperator: Bae(Yae),
        compareOperator: Bae(Yae),
        updateOperator: Bae(Yae),
        definitionOperator: Bae(Yae),
        typeOperator: Bae(Yae),
        controlOperator: Bae(Yae),
        punctuation: Gae,
        separator: Bae(Gae),
        bracket: Kae,
        angleBracket: Bae(Kae),
        squareBracket: Bae(Kae),
        paren: Bae(Kae),
        brace: Bae(Kae),
        content: Vae,
        heading: Wae,
        heading1: Bae(Wae),
        heading2: Bae(Wae),
        heading3: Bae(Wae),
        heading4: Bae(Wae),
        heading5: Bae(Wae),
        heading6: Bae(Wae),
        contentSeparator: Bae(Vae),
        list: Bae(Vae),
        quote: Bae(Vae),
        emphasis: Bae(Vae),
        strong: Bae(Vae),
        link: Bae(Vae),
        monospace: Bae(Vae),
        strikethrough: Bae(Vae),
        inserted: Bae(),
        deleted: Bae(),
        changed: Bae(),
        invalid: Bae(),
        meta: Jae,
        documentMeta: Bae(Jae),
        annotation: Bae(Jae),
        processingInstruction: Bae(Jae),
        definition: Pae.defineModifier(),
        constant: Pae.defineModifier(),
        function: Pae.defineModifier(),
        standard: Pae.defineModifier(),
        local: Pae.defineModifier(),
        special: Pae.defineModifier(),
      }
    var toe
    Mae([
      { tag: eoe.link, class: "tok-link" },
      { tag: eoe.heading, class: "tok-heading" },
      { tag: eoe.emphasis, class: "tok-emphasis" },
      { tag: eoe.strong, class: "tok-strong" },
      { tag: eoe.keyword, class: "tok-keyword" },
      { tag: eoe.atom, class: "tok-atom" },
      { tag: eoe.bool, class: "tok-bool" },
      { tag: eoe.url, class: "tok-url" },
      { tag: eoe.labelName, class: "tok-labelName" },
      { tag: eoe.inserted, class: "tok-inserted" },
      { tag: eoe.deleted, class: "tok-deleted" },
      { tag: eoe.literal, class: "tok-literal" },
      { tag: eoe.string, class: "tok-string" },
      { tag: eoe.number, class: "tok-number" },
      { tag: [eoe.regexp, eoe.escape, eoe.special(eoe.string)], class: "tok-string2" },
      { tag: eoe.variableName, class: "tok-variableName" },
      { tag: eoe.local(eoe.variableName), class: "tok-variableName tok-local" },
      { tag: eoe.definition(eoe.variableName), class: "tok-variableName tok-definition" },
      { tag: eoe.special(eoe.variableName), class: "tok-variableName2" },
      { tag: eoe.definition(eoe.propertyName), class: "tok-propertyName tok-definition" },
      { tag: eoe.typeName, class: "tok-typeName" },
      { tag: eoe.namespace, class: "tok-namespace" },
      { tag: eoe.className, class: "tok-className" },
      { tag: eoe.macroName, class: "tok-macroName" },
      { tag: eoe.propertyName, class: "tok-propertyName" },
      { tag: eoe.operator, class: "tok-operator" },
      { tag: eoe.comment, class: "tok-comment" },
      { tag: eoe.meta, class: "tok-meta" },
      { tag: eoe.invalid, class: "tok-invalid" },
      { tag: eoe.punctuation, class: "tok-punctuation" },
    ])
    const noe = new Bre()
    function roe(e) {
      return _7.define({ combine: e ? (t) => t.concat(e) : void 0 })
    }
    const aoe = new Bre()
    class ooe {
      constructor(e, t, n = [], r = "") {
        ;(this.data = e),
          (this.name = r),
          s6.prototype.hasOwnProperty("tree") ||
            Object.defineProperty(s6.prototype, "tree", {
              get() {
                return loe(this)
              },
            }),
          (this.parser = t),
          (this.extension = [
            boe.of(this),
            s6.languageData.of((e, t, n) => {
              let r = ioe(e, t, n),
                a = r.type.prop(noe)
              if (!a) return []
              let o = e.facet(a),
                i = r.type.prop(aoe)
              if (i) {
                let a = r.resolve(t - r.from, n)
                for (let t of i)
                  if (t.test(a, e)) {
                    let n = e.facet(t.facet)
                    return "replace" == t.type ? n : n.concat(o)
                  }
              }
              return o
            }),
          ].concat(n))
      }
      isActiveAt(e, t, n = -1) {
        return ioe(e, t, n).type.prop(noe) == this.data
      }
      findRegions(e) {
        let t = e.facet(boe)
        if ((null == t ? void 0 : t.data) == this.data) return [{ from: 0, to: e.doc.length }]
        if (!t || !t.allowsNesting) return []
        let n = [],
          r = (e, t) => {
            if (e.prop(noe) == this.data) return void n.push({ from: t, to: t + e.length })
            let a = e.prop(Bre.mounted)
            if (a) {
              if (a.tree.prop(noe) == this.data) {
                if (a.overlay) for (let e of a.overlay) n.push({ from: e.from + t, to: e.to + t })
                else n.push({ from: t, to: t + e.length })
                return
              }
              if (a.overlay) {
                let e = n.length
                if ((r(a.tree, a.overlay[0].from + t), n.length > e)) return
              }
            }
            for (let n = 0; n < e.children.length; n++) {
              let a = e.children[n]
              a instanceof Wre && r(a, e.positions[n] + t)
            }
          }
        return r(loe(e), 0), n
      }
      get allowsNesting() {
        return !0
      }
    }
    function ioe(e, t, n) {
      let r = e.facet(boe),
        a = loe(e).topNode
      if (!r || r.allowsNesting) for (let e = a; e; e = e.enter(t, n, Hre.ExcludeBuffers)) e.type.isTop && (a = e)
      return a
    }
    ooe.setState = Y7.define()
    class soe extends ooe {
      constructor(e, t, n) {
        super(e, t, [], n), (this.parser = t)
      }
      static define(e) {
        let t = roe(e.languageData)
        return new soe(t, e.parser.configure({ props: [noe.add((e) => (e.isTop ? t : void 0))] }), e.name)
      }
      configure(e, t) {
        return new soe(this.data, this.parser.configure(e), t || this.name)
      }
      get allowsNesting() {
        return this.parser.hasWrappers()
      }
    }
    function loe(e) {
      let t = e.field(ooe.state, !1)
      return t ? t.tree : Wre.empty
    }
    class coe {
      constructor(e) {
        ;(this.doc = e), (this.cursorPos = 0), (this.string = ""), (this.cursor = e.iter())
      }
      get length() {
        return this.doc.length
      }
      syncTo(e) {
        return (
          (this.string = this.cursor.next(e - this.cursorPos).value),
          (this.cursorPos = e + this.string.length),
          this.cursorPos - this.string.length
        )
      }
      chunk(e) {
        return this.syncTo(e), this.string
      }
      get lineChunks() {
        return !0
      }
      read(e, t) {
        let n = this.cursorPos - this.string.length
        return e < n || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - n, t - n)
      }
    }
    let doe = null
    class uoe {
      constructor(e, t, n = [], r, a, o, i, s) {
        ;(this.parser = e),
          (this.state = t),
          (this.fragments = n),
          (this.tree = r),
          (this.treeLen = a),
          (this.viewport = o),
          (this.skipped = i),
          (this.scheduleOn = s),
          (this.parse = null),
          (this.tempSkipped = [])
      }
      static create(e, t, n) {
        return new uoe(e, t, [], Wre.empty, 0, n, [], null)
      }
      startParse() {
        return this.parser.startParse(new coe(this.state.doc), this.fragments)
      }
      work(e, t) {
        return (
          null != t && t >= this.state.doc.length && (t = void 0),
          this.tree != Wre.empty && this.isDone(null != t ? t : this.state.doc.length)
            ? (this.takeTree(), !0)
            : this.withContext(() => {
                var n
                if ("number" == typeof e) {
                  let t = Date.now() + e
                  e = () => Date.now() > t
                }
                for (
                  this.parse || (this.parse = this.startParse()),
                    null != t &&
                      (null == this.parse.stoppedAt || this.parse.stoppedAt > t) &&
                      t < this.state.doc.length &&
                      this.parse.stopAt(t);
                  ;

                ) {
                  let r = this.parse.advance()
                  if (r) {
                    if (
                      ((this.fragments = this.withoutTempSkipped(
                        hae.addTree(r, this.fragments, null != this.parse.stoppedAt),
                      )),
                      (this.treeLen = null !== (n = this.parse.stoppedAt) && void 0 !== n ? n : this.state.doc.length),
                      (this.tree = r),
                      (this.parse = null),
                      !(this.treeLen < (null != t ? t : this.state.doc.length)))
                    )
                      return !0
                    this.parse = this.startParse()
                  }
                  if (e()) return !1
                }
              })
        )
      }
      takeTree() {
        let e, t
        this.parse &&
          (e = this.parse.parsedPos) >= this.treeLen &&
          ((null == this.parse.stoppedAt || this.parse.stoppedAt > e) && this.parse.stopAt(e),
          this.withContext(() => {
            for (; !(t = this.parse.advance()); );
          }),
          (this.treeLen = e),
          (this.tree = t),
          (this.fragments = this.withoutTempSkipped(hae.addTree(this.tree, this.fragments, !0))),
          (this.parse = null))
      }
      withContext(e) {
        let t = doe
        doe = this
        try {
          return e()
        } finally {
          doe = t
        }
      }
      withoutTempSkipped(e) {
        for (let t; (t = this.tempSkipped.pop()); ) e = poe(e, t.from, t.to)
        return e
      }
      changes(e, t) {
        let { fragments: n, tree: r, treeLen: a, viewport: o, skipped: i } = this
        if ((this.takeTree(), !e.empty)) {
          let t = []
          if (
            (e.iterChangedRanges((e, n, r, a) => t.push({ fromA: e, toA: n, fromB: r, toB: a })),
            (n = hae.applyChanges(n, t)),
            (r = Wre.empty),
            (a = 0),
            (o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }),
            this.skipped.length)
          ) {
            i = []
            for (let t of this.skipped) {
              let n = e.mapPos(t.from, 1),
                r = e.mapPos(t.to, -1)
              n < r && i.push({ from: n, to: r })
            }
          }
        }
        return new uoe(this.parser, t, n, r, a, o, i, this.scheduleOn)
      }
      updateViewport(e) {
        if (this.viewport.from == e.from && this.viewport.to == e.to) return !1
        this.viewport = e
        let t = this.skipped.length
        for (let t = 0; t < this.skipped.length; t++) {
          let { from: n, to: r } = this.skipped[t]
          n < e.to && r > e.from && ((this.fragments = poe(this.fragments, n, r)), this.skipped.splice(t--, 1))
        }
        return !(this.skipped.length >= t || (this.reset(), 0))
      }
      reset() {
        this.parse && (this.takeTree(), (this.parse = null))
      }
      skipUntilInView(e, t) {
        this.skipped.push({ from: e, to: t })
      }
      static getSkippingParser(e) {
        return new (class extends fae {
          createParse(t, n, r) {
            let a = r[0].from,
              o = r[r.length - 1].to,
              i = {
                parsedPos: a,
                advance() {
                  let t = doe
                  if (t) {
                    for (let e of r) t.tempSkipped.push(e)
                    e && (t.scheduleOn = t.scheduleOn ? Promise.all([t.scheduleOn, e]) : e)
                  }
                  return (this.parsedPos = o), new Wre(Fre.none, [], [], o - a)
                },
                stoppedAt: null,
                stopAt() {},
              }
            return i
          }
        })()
      }
      isDone(e) {
        e = Math.min(e, this.state.doc.length)
        let t = this.fragments
        return this.treeLen >= e && t.length && 0 == t[0].from && t[0].to >= e
      }
      static get() {
        return doe
      }
    }
    function poe(e, t, n) {
      return hae.applyChanges(e, [{ fromA: t, toA: n, fromB: t, toB: n }])
    }
    class hoe {
      constructor(e) {
        ;(this.context = e), (this.tree = e.tree)
      }
      apply(e) {
        if (!e.docChanged && this.tree == this.context.tree) return this
        let t = this.context.changes(e.changes, e.state),
          n =
            this.context.treeLen == e.startState.doc.length
              ? void 0
              : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to)
        return t.work(20, n) || t.takeTree(), new hoe(t)
      }
      static init(e) {
        let t = Math.min(3e3, e.doc.length),
          n = uoe.create(e.facet(boe).parser, e, { from: 0, to: t })
        return n.work(20, t) || n.takeTree(), new hoe(n)
      }
    }
    ooe.state = D7.define({
      create: hoe.init,
      update(e, t) {
        for (let e of t.effects) if (e.is(ooe.setState)) return e.value
        return t.startState.facet(boe) != t.state.facet(boe) ? hoe.init(t.state) : e.apply(t)
      },
    })
    let foe = (e) => {
      let t = setTimeout(() => e(), 500)
      return () => clearTimeout(t)
    }
    "undefined" != typeof requestIdleCallback &&
      (foe = (e) => {
        let t = -1,
          n = setTimeout(() => {
            t = requestIdleCallback(e, { timeout: 400 })
          }, 100)
        return () => (t < 0 ? clearTimeout(n) : cancelIdleCallback(t))
      })
    const moe =
        "undefined" != typeof navigator &&
        (null === (toe = navigator.scheduling) || void 0 === toe ? void 0 : toe.isInputPending)
          ? () => navigator.scheduling.isInputPending()
          : null,
      goe = Ree.fromClass(
        class {
          constructor(e) {
            ;(this.view = e),
              (this.working = null),
              (this.workScheduled = 0),
              (this.chunkEnd = -1),
              (this.chunkBudget = -1),
              (this.work = this.work.bind(this)),
              this.scheduleWork()
          }
          update(e) {
            let t = this.view.state.field(ooe.state).context
            ;(t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(),
              (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()),
              this.checkAsyncSchedule(t)
          }
          scheduleWork() {
            if (this.working) return
            let { state: e } = this.view,
              t = e.field(ooe.state)
            ;(t.tree == t.context.tree && t.context.isDone(e.doc.length)) || (this.working = foe(this.work))
          }
          work(e) {
            this.working = null
            let t = Date.now()
            if (
              (this.chunkEnd < t &&
                (this.chunkEnd < 0 || this.view.hasFocus) &&
                ((this.chunkEnd = t + 3e4), (this.chunkBudget = 3e3)),
              this.chunkBudget <= 0)
            )
              return
            let {
                state: n,
                viewport: { to: r },
              } = this.view,
              a = n.field(ooe.state)
            if (a.tree == a.context.tree && a.context.isDone(r + 1e5)) return
            let o = Date.now() + Math.min(this.chunkBudget, 100, e && !moe ? Math.max(25, e.timeRemaining() - 5) : 1e9),
              i = a.context.treeLen < r && n.doc.length > r + 1e3,
              s = a.context.work(() => (moe && moe()) || Date.now() > o, r + (i ? 0 : 1e5))
            ;(this.chunkBudget -= Date.now() - t),
              (s || this.chunkBudget <= 0) &&
                (a.context.takeTree(), this.view.dispatch({ effects: ooe.setState.of(new hoe(a.context)) })),
              this.chunkBudget > 0 && (!s || i) && this.scheduleWork(),
              this.checkAsyncSchedule(a.context)
          }
          checkAsyncSchedule(e) {
            e.scheduleOn &&
              (this.workScheduled++,
              e.scheduleOn
                .then(() => this.scheduleWork())
                .catch((e) => Aee(this.view.state, e))
                .then(() => this.workScheduled--),
              (e.scheduleOn = null))
          }
          destroy() {
            this.working && this.working()
          }
          isWorking() {
            return !!(this.working || this.workScheduled > 0)
          }
        },
        {
          eventHandlers: {
            focus() {
              this.scheduleWork()
            },
          },
        },
      ),
      boe = _7.define({
        combine: (e) => (e.length ? e[0] : null),
        enables: (e) => [
          ooe.state,
          goe,
          Tne.contentAttributes.compute([e], (t) => {
            let n = t.facet(e)
            return n && n.name ? { "data-language": n.name } : {}
          }),
        ],
      })
    class voe {
      constructor(e, t = []) {
        ;(this.language = e), (this.support = t), (this.extension = [e, t])
      }
    }
    const yoe = _7.define(),
      Ooe = _7.define({
        combine: (e) => {
          if (!e.length) return "  "
          let t = e[0]
          if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(e[0]))
          return t
        },
      })
    function woe(e) {
      let t = e.facet(Ooe)
      return 9 == t.charCodeAt(0) ? e.tabSize * t.length : t.length
    }
    function xoe(e, t) {
      let n = "",
        r = e.tabSize,
        a = e.facet(Ooe)[0]
      if ("\t" == a) {
        for (; t >= r; ) (n += "\t"), (t -= r)
        a = " "
      }
      for (let e = 0; e < t; e++) n += a
      return n
    }
    function koe(e, t) {
      e instanceof s6 && (e = new _oe(e))
      for (let n of e.state.facet(yoe)) {
        let r = n(e, t)
        if (void 0 !== r) return r
      }
      let n = loe(e.state)
      return n.length >= t
        ? (function (e, t, n) {
            let r = t.resolveStack(n),
              a = r.node.enterUnfinishedNodesBefore(n)
            if (a != r.node) {
              let e = []
              for (let t = a; t != r.node; t = t.parent) e.push(t)
              for (let t = e.length - 1; t >= 0; t--) r = { node: e[t], next: r }
            }
            return Eoe(r, e, n)
          })(e, n, t)
        : null
    }
    class _oe {
      constructor(e, t = {}) {
        ;(this.state = e), (this.options = t), (this.unit = woe(e))
      }
      lineAt(e, t = 1) {
        let n = this.state.doc.lineAt(e),
          { simulateBreak: r, simulateDoubleBreak: a } = this.options
        return null != r && r >= n.from && r <= n.to
          ? a && r == e
            ? { text: "", from: e }
            : (t < 0 ? r < e : r <= e)
              ? { text: n.text.slice(r - n.from), from: r }
              : { text: n.text.slice(0, r - n.from), from: n.from }
          : n
      }
      textAfterPos(e, t = 1) {
        if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return ""
        let { text: n, from: r } = this.lineAt(e, t)
        return n.slice(e - r, Math.min(n.length, e + 100 - r))
      }
      column(e, t = 1) {
        let { text: n, from: r } = this.lineAt(e, t),
          a = this.countColumn(n, e - r),
          o = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1
        return o > -1 && (a += o - this.countColumn(n, n.search(/\S|$/))), a
      }
      countColumn(e, t = e.length) {
        return S6(e, this.state.tabSize, t)
      }
      lineIndent(e, t = 1) {
        let { text: n, from: r } = this.lineAt(e, t),
          a = this.options.overrideIndentation
        if (a) {
          let e = a(r)
          if (e > -1) return e
        }
        return this.countColumn(n, n.search(/\S|$/))
      }
      get simulatedBreak() {
        return this.options.simulateBreak || null
      }
    }
    const Soe = new Bre()
    function Eoe(e, t, n) {
      for (let r = e; r; r = r.next) {
        let e = Toe(r.node)
        if (e) return e(Coe.create(t, n, r))
      }
      return 0
    }
    function Toe(e) {
      let t = e.type.prop(Soe)
      if (t) return t
      let n,
        r = e.firstChild
      if (r && (n = r.type.prop(Bre.closedBy))) {
        let t = e.lastChild,
          r = t && n.indexOf(t.name) > -1
        return (e) =>
          Roe(
            e,
            !0,
            1,
            void 0,
            r &&
              !(function (e) {
                return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak
              })(e)
              ? t.from
              : void 0,
          )
      }
      return null == e.parent ? Aoe : null
    }
    function Aoe() {
      return 0
    }
    class Coe extends _oe {
      constructor(e, t, n) {
        super(e.state, e.options), (this.base = e), (this.pos = t), (this.context = n)
      }
      get node() {
        return this.context.node
      }
      static create(e, t, n) {
        return new Coe(e, t, n)
      }
      get textAfter() {
        return this.textAfterPos(this.pos)
      }
      get baseIndent() {
        return this.baseIndentFor(this.node)
      }
      baseIndentFor(e) {
        let t = this.state.doc.lineAt(e.from)
        for (;;) {
          let n = e.resolve(t.from)
          for (; n.parent && n.parent.from == n.from; ) n = n.parent
          if (Poe(n, e)) break
          t = this.state.doc.lineAt(n.from)
        }
        return this.lineIndent(t.from)
      }
      continue() {
        return Eoe(this.context.next, this.base, this.pos)
      }
    }
    function Poe(e, t) {
      for (let n = t; n; n = n.parent) if (e == n) return !0
      return !1
    }
    function Doe({ closing: e, align: t = !0, units: n = 1 }) {
      return (r) => Roe(r, t, n, e)
    }
    function Roe(e, t, n, r, a) {
      let o = e.textAfter,
        i = o.match(/^\s*/)[0].length,
        s = (r && o.slice(i, i + r.length) == r) || a == e.pos + i,
        l = t
          ? (function (e) {
              let t = e.node,
                n = t.childAfter(t.from),
                r = t.lastChild
              if (!n) return null
              let a = e.options.simulateBreak,
                o = e.state.doc.lineAt(n.from),
                i = null == a || a <= o.from ? o.to : Math.min(o.to, a)
              for (let e = n.to; ; ) {
                let a = t.childAfter(e)
                if (!a || a == r) return null
                if (!a.type.isSkipped) return a.from < i ? n : null
                e = a.to
              }
            })(e)
          : null
      return l ? (s ? e.column(l.from) : e.column(l.to)) : e.baseIndent + (s ? 0 : e.unit * n)
    }
    function Noe({ except: e, units: t = 1 } = {}) {
      return (n) => {
        let r = e && e.test(n.textAfter)
        return n.baseIndent + (r ? 0 : t * n.unit)
      }
    }
    const $oe = new Bre()
    function Ioe(e) {
      let t = e.firstChild,
        n = e.lastChild
      return t && t.to < n.from ? { from: t.to, to: n.type.isError ? e.to : n.from } : null
    }
    class Moe {
      constructor(e, t) {
        let n
        function r(e) {
          let t = C6.newName()
          return ((n || (n = Object.create(null)))["." + t] = e), t
        }
        this.specs = e
        const a = "string" == typeof t.all ? t.all : t.all ? r(t.all) : void 0,
          o = t.scope
        ;(this.scope = o instanceof ooe ? (e) => e.prop(noe) == o.data : o ? (e) => e == o : void 0),
          (this.style = Mae(
            e.map((e) => ({ tag: e.tag, class: e.class || r(Object.assign({}, e, { tag: null })) })),
            { all: a },
          ).style),
          (this.module = n ? new C6(n) : null),
          (this.themeType = t.themeType)
      }
      static define(e, t) {
        return new Moe(e, t || {})
      }
    }
    const Loe = _7.define(),
      Qoe = _7.define({ combine: (e) => (e.length ? [e[0]] : null) })
    function Boe(e) {
      let t = e.facet(Loe)
      return t.length ? t : e.facet(Qoe)
    }
    function joe(e, t) {
      let n,
        r = [Uoe]
      return (
        e instanceof Moe && (e.module && r.push(Tne.styleModule.of(e.module)), (n = e.themeType)),
        (null == t ? void 0 : t.fallback)
          ? r.push(Qoe.of(e))
          : n
            ? r.push(Loe.computeN([Tne.darkTheme], (t) => (t.facet(Tne.darkTheme) == ("dark" == n) ? [e] : [])))
            : r.push(Loe.of(e)),
        r
      )
    }
    const Uoe = N7.high(
        Ree.fromClass(
          class {
            constructor(e) {
              ;(this.markCache = Object.create(null)),
                (this.tree = loe(e.state)),
                (this.decorations = this.buildDeco(e, Boe(e.state))),
                (this.decoratedTo = e.viewport.to)
            }
            update(e) {
              let t = loe(e.state),
                n = Boe(e.state),
                r = n != Boe(e.startState),
                { viewport: a } = e.view,
                o = e.changes.mapPos(this.decoratedTo, 1)
              t.length < a.to && !r && t.type == this.tree.type && o >= a.to
                ? ((this.decorations = this.decorations.map(e.changes)), (this.decoratedTo = o))
                : (t != this.tree || e.viewportChanged || r) &&
                  ((this.tree = t), (this.decorations = this.buildDeco(e.view, n)), (this.decoratedTo = a.to))
            }
            buildDeco(e, t) {
              if (!t || !this.tree.length) return U9.none
              let n = new f6()
              for (let { from: r, to: a } of e.visibleRanges)
                Lae(
                  this.tree,
                  t,
                  (e, t, r) => {
                    n.add(e, t, this.markCache[r] || (this.markCache[r] = U9.mark({ class: r })))
                  },
                  r,
                  a,
                )
              return n.finish()
            }
          },
          { decorations: (e) => e.decorations },
        ),
      ),
      Foe = Moe.define([
        { tag: eoe.meta, color: "#404740" },
        { tag: eoe.link, textDecoration: "underline" },
        { tag: eoe.heading, textDecoration: "underline", fontWeight: "bold" },
        { tag: eoe.emphasis, fontStyle: "italic" },
        { tag: eoe.strong, fontWeight: "bold" },
        { tag: eoe.strikethrough, textDecoration: "line-through" },
        { tag: eoe.keyword, color: "#708" },
        { tag: [eoe.atom, eoe.bool, eoe.url, eoe.contentSeparator, eoe.labelName], color: "#219" },
        { tag: [eoe.literal, eoe.inserted], color: "#164" },
        { tag: [eoe.string, eoe.deleted], color: "#a11" },
        { tag: [eoe.regexp, eoe.escape, eoe.special(eoe.string)], color: "#e40" },
        { tag: eoe.definition(eoe.variableName), color: "#00f" },
        { tag: eoe.local(eoe.variableName), color: "#30a" },
        { tag: [eoe.typeName, eoe.namespace], color: "#085" },
        { tag: eoe.className, color: "#167" },
        { tag: [eoe.special(eoe.variableName), eoe.macroName], color: "#256" },
        { tag: eoe.definition(eoe.propertyName), color: "#00c" },
        { tag: eoe.comment, color: "#940" },
        { tag: eoe.invalid, color: "#f00" },
      ]),
      zoe = Tne.baseTheme({
        "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
        "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" },
      }),
      qoe = "()[]{}",
      Zoe = _7.define({
        combine: (e) => l6(e, { afterCursor: !0, brackets: qoe, maxScanDistance: 1e4, renderMatch: Woe }),
      }),
      Hoe = U9.mark({ class: "cm-matchingBracket" }),
      Voe = U9.mark({ class: "cm-nonmatchingBracket" })
    function Woe(e) {
      let t = [],
        n = e.matched ? Hoe : Voe
      return t.push(n.range(e.start.from, e.start.to)), e.end && t.push(n.range(e.end.from, e.end.to)), t
    }
    const Xoe = [
      D7.define({
        create: () => U9.none,
        update(e, t) {
          if (!t.docChanged && !t.selection) return e
          let n = [],
            r = t.state.facet(Zoe)
          for (let e of t.state.selection.ranges) {
            if (!e.empty) continue
            let a =
              eie(t.state, e.head, -1, r) ||
              (e.head > 0 && eie(t.state, e.head - 1, 1, r)) ||
              (r.afterCursor &&
                (eie(t.state, e.head, 1, r) || (e.head < t.state.doc.length && eie(t.state, e.head + 1, -1, r))))
            a && (n = n.concat(r.renderMatch(a, t.state)))
          }
          return U9.set(n, !0)
        },
        provide: (e) => Tne.decorations.from(e),
      }),
      zoe,
    ]
    function Yoe(e = {}) {
      return [Zoe.of(e), Xoe]
    }
    const Goe = new Bre()
    function Koe(e, t, n) {
      let r = e.prop(t < 0 ? Bre.openedBy : Bre.closedBy)
      if (r) return r
      if (1 == e.name.length) {
        let r = n.indexOf(e.name)
        if (r > -1 && r % 2 == (t < 0 ? 1 : 0)) return [n[r + t]]
      }
      return null
    }
    function Joe(e) {
      let t = e.type.prop(Goe)
      return t ? t(e.node) : e
    }
    function eie(e, t, n, r = {}) {
      let a = r.maxScanDistance || 1e4,
        o = r.brackets || qoe,
        i = loe(e),
        s = i.resolveInner(t, n)
      for (let r = s; r; r = r.parent) {
        let a = Koe(r.type, n, o)
        if (a && r.from < r.to) {
          let i = Joe(r)
          if (i && (n > 0 ? t >= i.from && t < i.to : t > i.from && t <= i.to)) return tie(e, t, n, r, i, a, o)
        }
      }
      return (function (e, t, n, r, a, o, i) {
        let s = n < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1),
          l = i.indexOf(s)
        if (l < 0 || (l % 2 == 0) != n > 0) return null
        let c = { from: n < 0 ? t - 1 : t, to: n > 0 ? t + 1 : t },
          d = e.doc.iterRange(t, n > 0 ? e.doc.length : 0),
          u = 0
        for (let e = 0; !d.next().done && e <= o; ) {
          let o = d.value
          n < 0 && (e += o.length)
          let s = t + e * n
          for (let e = n > 0 ? 0 : o.length - 1, t = n > 0 ? o.length : -1; e != t; e += n) {
            let t = i.indexOf(o[e])
            if (!(t < 0 || r.resolveInner(s + e, 1).type != a))
              if ((t % 2 == 0) == n > 0) u++
              else {
                if (1 == u) return { start: c, end: { from: s + e, to: s + e + 1 }, matched: t >> 1 == l >> 1 }
                u--
              }
          }
          n > 0 && (e += o.length)
        }
        return d.done ? { start: c, matched: !1 } : null
      })(e, t, n, i, s.type, a, o)
    }
    function tie(e, t, n, r, a, o, i) {
      let s = r.parent,
        l = { from: a.from, to: a.to },
        c = 0,
        d = null == s ? void 0 : s.cursor()
      if (d && (n < 0 ? d.childBefore(r.from) : d.childAfter(r.to)))
        do {
          if (n < 0 ? d.to <= r.from : d.from >= r.to) {
            if (0 == c && o.indexOf(d.type.name) > -1 && d.from < d.to) {
              let e = Joe(d)
              return { start: l, end: e ? { from: e.from, to: e.to } : void 0, matched: !0 }
            }
            if (Koe(d.type, n, i)) c++
            else if (Koe(d.type, -n, i)) {
              if (0 == c) {
                let e = Joe(d)
                return { start: l, end: e && e.from < e.to ? { from: e.from, to: e.to } : void 0, matched: !1 }
              }
              c--
            }
          }
        } while (n < 0 ? d.prevSibling() : d.nextSibling())
      return { start: l, matched: !1 }
    }
    const nie = Object.create(null),
      rie = [Fre.none],
      aie = [],
      oie = Object.create(null),
      iie = Object.create(null)
    for (let [e, t] of [
      ["variable", "variableName"],
      ["variable-2", "variableName.special"],
      ["string-2", "string.special"],
      ["def", "variableName.definition"],
      ["tag", "tagName"],
      ["attribute", "attributeName"],
      ["type", "typeName"],
      ["builtin", "variableName.standard"],
      ["qualifier", "modifier"],
      ["error", "invalid"],
      ["header", "heading"],
      ["property", "propertyName"],
    ])
      iie[e] = lie(nie, t)
    function sie(e, t) {
      aie.indexOf(e) > -1 || (aie.push(e), console.warn(t))
    }
    function lie(e, t) {
      let n = []
      for (let r of t.split(" ")) {
        let t = []
        for (let n of r.split(".")) {
          let r = e[n] || eoe[n]
          r
            ? "function" == typeof r
              ? t.length
                ? (t = t.map(r))
                : sie(n, `Modifier ${n} used at start of tag`)
              : t.length
                ? sie(n, `Tag ${n} used as modifier`)
                : (t = Array.isArray(r) ? r : [r])
            : sie(n, `Unknown highlighting tag ${n}`)
        }
        for (let e of t) n.push(e)
      }
      if (!n.length) return 0
      let r = t.replace(/ /g, "_"),
        a = r + " " + n.map((e) => e.id),
        o = oie[a]
      if (o) return o.id
      let i = (oie[a] = Fre.define({ id: rie.length, name: r, props: [Nae({ [r]: n })] }))
      return rie.push(i), i.id
    }
    Y9.RTL, Y9.LTR
    const cie = new Map([
        ["aliceblue", "#f0f8ff"],
        ["antiquewhite", "#faebd7"],
        ["aqua", "#00ffff"],
        ["aquamarine", "#7fffd4"],
        ["azure", "#f0ffff"],
        ["beige", "#f5f5dc"],
        ["bisque", "#ffe4c4"],
        ["black", "#000000"],
        ["blanchedalmond", "#ffebcd"],
        ["blue", "#0000ff"],
        ["blueviolet", "#8a2be2"],
        ["brown", "#a52a2a"],
        ["burlywood", "#deb887"],
        ["cadetblue", "#5f9ea0"],
        ["chartreuse", "#7fff00"],
        ["chocolate", "#d2691e"],
        ["coral", "#ff7f50"],
        ["cornflowerblue", "#6495ed"],
        ["cornsilk", "#fff8dc"],
        ["crimson", "#dc143c"],
        ["cyan", "#00ffff"],
        ["darkblue", "#00008b"],
        ["darkcyan", "#008b8b"],
        ["darkgoldenrod", "#b8860b"],
        ["darkgray", "#a9a9a9"],
        ["darkgreen", "#006400"],
        ["darkgrey", "#a9a9a9"],
        ["darkkhaki", "#bdb76b"],
        ["darkmagenta", "#8b008b"],
        ["darkolivegreen", "#556b2f"],
        ["darkorange", "#ff8c00"],
        ["darkorchid", "#9932cc"],
        ["darkred", "#8b0000"],
        ["darksalmon", "#e9967a"],
        ["darkseagreen", "#8fbc8f"],
        ["darkslateblue", "#483d8b"],
        ["darkslategray", "#2f4f4f"],
        ["darkslategrey", "#2f4f4f"],
        ["darkturquoise", "#00ced1"],
        ["darkviolet", "#9400d3"],
        ["deeppink", "#ff1493"],
        ["deepskyblue", "#00bfff"],
        ["dimgray", "#696969"],
        ["dimgrey", "#696969"],
        ["dodgerblue", "#1e90ff"],
        ["firebrick", "#b22222"],
        ["floralwhite", "#fffaf0"],
        ["forestgreen", "#228b22"],
        ["fuchsia", "#ff00ff"],
        ["gainsboro", "#dcdcdc"],
        ["ghostwhite", "#f8f8ff"],
        ["goldenrod", "#daa520"],
        ["gold", "#ffd700"],
        ["gray", "#808080"],
        ["green", "#008000"],
        ["greenyellow", "#adff2f"],
        ["grey", "#808080"],
        ["honeydew", "#f0fff0"],
        ["hotpink", "#ff69b4"],
        ["indianred", "#cd5c5c"],
        ["indigo", "#4b0082"],
        ["ivory", "#fffff0"],
        ["khaki", "#f0e68c"],
        ["lavenderblush", "#fff0f5"],
        ["lavender", "#e6e6fa"],
        ["lawngreen", "#7cfc00"],
        ["lemonchiffon", "#fffacd"],
        ["lightblue", "#add8e6"],
        ["lightcoral", "#f08080"],
        ["lightcyan", "#e0ffff"],
        ["lightgoldenrodyellow", "#fafad2"],
        ["lightgray", "#d3d3d3"],
        ["lightgreen", "#90ee90"],
        ["lightgrey", "#d3d3d3"],
        ["lightpink", "#ffb6c1"],
        ["lightsalmon", "#ffa07a"],
        ["lightseagreen", "#20b2aa"],
        ["lightskyblue", "#87cefa"],
        ["lightslategray", "#778899"],
        ["lightslategrey", "#778899"],
        ["lightsteelblue", "#b0c4de"],
        ["lightyellow", "#ffffe0"],
        ["lime", "#00ff00"],
        ["limegreen", "#32cd32"],
        ["linen", "#faf0e6"],
        ["magenta", "#ff00ff"],
        ["maroon", "#800000"],
        ["mediumaquamarine", "#66cdaa"],
        ["mediumblue", "#0000cd"],
        ["mediumorchid", "#ba55d3"],
        ["mediumpurple", "#9370db"],
        ["mediumseagreen", "#3cb371"],
        ["mediumslateblue", "#7b68ee"],
        ["mediumspringgreen", "#00fa9a"],
        ["mediumturquoise", "#48d1cc"],
        ["mediumvioletred", "#c71585"],
        ["midnightblue", "#191970"],
        ["mintcream", "#f5fffa"],
        ["mistyrose", "#ffe4e1"],
        ["moccasin", "#ffe4b5"],
        ["navajowhite", "#ffdead"],
        ["navy", "#000080"],
        ["oldlace", "#fdf5e6"],
        ["olive", "#808000"],
        ["olivedrab", "#6b8e23"],
        ["orange", "#ffa500"],
        ["orangered", "#ff4500"],
        ["orchid", "#da70d6"],
        ["palegoldenrod", "#eee8aa"],
        ["palegreen", "#98fb98"],
        ["paleturquoise", "#afeeee"],
        ["palevioletred", "#db7093"],
        ["papayawhip", "#ffefd5"],
        ["peachpuff", "#ffdab9"],
        ["peru", "#cd853f"],
        ["pink", "#ffc0cb"],
        ["plum", "#dda0dd"],
        ["powderblue", "#b0e0e6"],
        ["purple", "#800080"],
        ["rebeccapurple", "#663399"],
        ["red", "#ff0000"],
        ["rosybrown", "#bc8f8f"],
        ["royalblue", "#4169e1"],
        ["saddlebrown", "#8b4513"],
        ["salmon", "#fa8072"],
        ["sandybrown", "#f4a460"],
        ["seagreen", "#2e8b57"],
        ["seashell", "#fff5ee"],
        ["sienna", "#a0522d"],
        ["silver", "#c0c0c0"],
        ["skyblue", "#87ceeb"],
        ["slateblue", "#6a5acd"],
        ["slategray", "#708090"],
        ["slategrey", "#708090"],
        ["snow", "#fffafa"],
        ["springgreen", "#00ff7f"],
        ["steelblue", "#4682b4"],
        ["tan", "#d2b48c"],
        ["teal", "#008080"],
        ["thistle", "#d8bfd8"],
        ["tomato", "#ff6347"],
        ["turquoise", "#40e0d0"],
        ["violet", "#ee82ee"],
        ["wheat", "#f5deb3"],
        ["white", "#ffffff"],
        ["whitesmoke", "#f5f5f5"],
        ["yellow", "#ffff00"],
        ["yellowgreen", "#9acd32"],
      ]),
      die = new WeakMap()
    var uie = (function (e) {
      return (e.rgb = "RGB"), (e.hex = "HEX"), (e.named = "NAMED"), (e.hsl = "HSL"), e
    })(uie || (uie = {}))
    const pie = /rgb(?:a)?\(\s*(\d{1,3}%?)\s*,?\s*(\d{1,3}%?)\s*,?\s*(\d{1,3}%?)\s*(,\s*0?\.\d+)?\)/,
      hie = /hsl\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*(,\s*0?\.\d+)?\)/
    function fie(e, t, n, r, a) {
      var o
      switch (r) {
        case "AttributeValue": {
          const n = e.resolveInner(t, 0).tree
          if (!n) return null
          const r = null === (o = n.prop(Bre.mounted)) || void 0 === o ? void 0 : o.tree
          if ("Styles" !== (null == r ? void 0 : r.type.name)) return null
          const i = []
          return (
            r.iterate({
              from: 0,
              to: r.length,
              enter: ({ type: n, from: r, to: o }) => {
                const s = fie(e, t + 1 + r, t + 1 + o, n.name, a)
                if (s) {
                  if (Array.isArray(s)) throw new Error("Unexpected nested overlays")
                  i.push(s)
                }
              },
            }),
            i
          )
        }
        case "CallExpression": {
          const e = a.sliceString(t, n)
          switch (e.slice(0, 3)) {
            case "rgb": {
              const r = pie.exec(e)
              if (!r) return null
              const [a, o, i, s, l] = r,
                c = (function (e, t, n) {
                  return `#${gie(e)}${gie(t)}${gie(n)}`
                })(o, i, s)
              return { colorType: uie.rgb, color: c, from: t, to: n, alpha: l || "" }
            }
            case "hsl": {
              const r = hie.exec(e)
              if (!r) return null
              const [a, o, i, s, l] = r,
                c = (function (e, t, n) {
                  const r = Number(t) / 100,
                    a = Number(n) / 100,
                    [o, i, s] = (function (e, t, n) {
                      if (0 === t) {
                        const e = Math.round(255 * n)
                        return [e, e, e]
                      }
                      let r
                      r = n < 0.5 ? n * (1 + t) : n + t - n * t
                      const a = 2 * n - r,
                        o = yie(0.333 + (e /= 360)),
                        i = e,
                        s = yie(e - 0.333),
                        l = Oie(r, a, o),
                        c = Oie(r, a, i),
                        d = Oie(r, a, s)
                      return [Math.round(255 * l), Math.round(255 * c), Math.round(255 * d)]
                    })(Number(e), r, a)
                  return `#${bie(o)}${bie(i)}${bie(s)}`
                })(o, i, s)
              return { colorType: uie.hsl, color: c, from: t, to: n, alpha: l || "" }
            }
            default:
              return null
          }
        }
        case "ColorLiteral": {
          const [e, r] = (function (e) {
            return 4 === e.length
              ? [`#${e[1].repeat(2)}${e[2].repeat(2)}${e[3].repeat(2)}`, ""]
              : 5 === e.length
                ? [`#${e[1].repeat(2)}${e[2].repeat(2)}${e[3].repeat(2)}`, e[4].repeat(2)]
                : 9 === e.length
                  ? [`#${e.slice(1, -2)}`, e.slice(-2)]
                  : [e, ""]
          })(a.sliceString(t, n))
          return { colorType: uie.hex, color: e, from: t, to: n, alpha: r }
        }
        case "ValueName": {
          const e = a.sliceString(t, n),
            r = cie.get(e)
          return r ? { colorType: uie.named, color: r, from: t, to: n, alpha: "" } : null
        }
        default:
          return null
      }
    }
    function mie(e) {
      const t = [],
        n = loe(e.state)
      for (const r of e.visibleRanges)
        n.iterate({
          from: r.from,
          to: r.to,
          enter: ({ type: r, from: a, to: o }) => {
            const i = fie(n, a, o, r.name, e.state.doc)
            if (i)
              if (Array.isArray(i)) for (const e of i) t.push(U9.widget({ widget: new xie(e), side: 1 }).range(e.from))
              else t.push(U9.widget({ widget: new xie(i), side: 1 }).range(i.from))
          },
        })
      return U9.set(t)
    }
    function gie(e) {
      let t
      if (e.endsWith("%")) {
        const n = Number(e.slice(0, -1))
        t = Math.round((n / 100) * 255)
      } else t = Number(e)
      return bie(t)
    }
    function bie(e) {
      const t = e.toString(16)
      return 1 == t.length ? "0" + t : t
    }
    function vie(e) {
      const t = e.slice(1, 3),
        n = e.slice(3, 5),
        r = e.slice(5, 7)
      return [parseInt(t, 16), parseInt(n, 16), parseInt(r, 16)]
    }
    function yie(e) {
      return e < 0 ? e + 1 : e > 1 ? e - 1 : e
    }
    function Oie(e, t, n) {
      return 6 * n < 1 ? t + 6 * (e - t) * n : 2 * n < 1 ? e : 3 * n < 2 ? t + (e - t) * (0.666 - n) * 6 : t
    }
    const wie = "cm-css-color-picker-wrapper"
    class xie extends B9 {
      constructor(e) {
        var { color: t } = e,
          n = (function (e, t) {
            var n = {}
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r])
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
              var a = 0
              for (r = Object.getOwnPropertySymbols(e); a < r.length; a++)
                t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]])
            }
            return n
          })(e, ["color"])
        super(), (this.state = n), (this.color = t)
      }
      eq(e) {
        return (
          e.state.colorType === this.state.colorType &&
          e.color === this.color &&
          e.state.from === this.state.from &&
          e.state.to === this.state.to &&
          e.state.alpha === this.state.alpha
        )
      }
      toDOM() {
        const e = document.createElement("input")
        die.set(e, this.state), (e.type = "color"), (e.value = this.color)
        const t = document.createElement("span")
        return t.appendChild(e), (t.className = wie), t
      }
      ignoreEvent() {
        return !1
      }
    }
    const kie = Tne.baseTheme({
        [`.${wie}`]: {
          display: "inline-block",
          outline: "1px solid #eee",
          marginRight: "0.6ch",
          height: "1em",
          width: "1em",
          transform: "translateY(1px)",
        },
        [`.${wie} input[type="color"]`]: {
          cursor: "pointer",
          height: "100%",
          width: "100%",
          padding: 0,
          border: "none",
          "&::-webkit-color-swatch-wrapper": { padding: 0 },
          "&::-webkit-color-swatch": { border: "none" },
          "&::-moz-color-swatch": { border: "none" },
        },
      }),
      _ie = Ree.fromClass(
        class {
          constructor(e) {
            this.decorations = mie(e)
          }
          update(e) {
            ;(e.docChanged || e.viewportChanged) && (this.decorations = mie(e.view))
          }
        },
        {
          decorations: (e) => e.decorations,
          eventHandlers: {
            change: (e, t) => {
              const n = e.target
              if ("INPUT" !== n.nodeName || !n.parentElement || !n.parentElement.classList.contains(wie)) return !1
              const r = die.get(n)
              let a = n.value + r.alpha
              if (r.colorType === uie.rgb) a = `rgb(${vie(n.value).join(", ")}${r.alpha})`
              else if (r.colorType === uie.named) for (const [e, t] of cie.entries()) t === n.value && (a = e)
              else if (r.colorType === uie.hsl) {
                const [e, t, o] = vie(n.value),
                  [i, s, l] = (function (e, t, n) {
                    const r = e / 255,
                      a = t / 255,
                      o = n / 255,
                      i = Math.min(r, a, o),
                      s = Math.max(r, a, o),
                      l = (s + i) / 2
                    if (s === i) return [0, 0, l]
                    let c, d
                    for (
                      c = l <= 0.5 ? (s - i) / (s + i) : (s - i) / (2 - s - i),
                        d = s === r ? (a - o) / (s - i) : a === s ? 2 + (o - r) / (s - i) : 4 + (r - a) / (s - i),
                        d = Math.round(60 * d);
                      d < 0;

                    )
                      d += 360
                    return [d, c, l]
                  })(e, t, o)
                a = `hsl(${i}, ${Math.round(100 * s)}%, ${Math.round(100 * l)}%${r.alpha})`
              }
              return t.dispatch({ changes: { from: r.from, to: r.to, insert: a } }), !0
            },
          },
        },
      ),
      Sie = [_ie, kie]
    class Eie {
      constructor(e, t, n) {
        ;(this.state = e), (this.pos = t), (this.explicit = n), (this.abortListeners = [])
      }
      tokenBefore(e) {
        let t = loe(this.state).resolveInner(this.pos, -1)
        for (; t && e.indexOf(t.name) < 0; ) t = t.parent
        return t ? { from: t.from, to: this.pos, text: this.state.sliceDoc(t.from, this.pos), type: t.type } : null
      }
      matchBefore(e) {
        let t = this.state.doc.lineAt(this.pos),
          n = Math.max(t.from, this.pos - 250),
          r = t.text.slice(n - t.from, this.pos - t.from),
          a = r.search(Die(e, !1))
        return a < 0 ? null : { from: n + a, to: this.pos, text: r.slice(a) }
      }
      get aborted() {
        return null == this.abortListeners
      }
      addEventListener(e, t) {
        "abort" == e && this.abortListeners && this.abortListeners.push(t)
      }
    }
    function Tie(e) {
      let t = Object.keys(e).join(""),
        n = /\w/.test(t)
      return n && (t = t.replace(/\w/g, "")), `[${n ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`
    }
    function Aie(e) {
      let t = e.map((e) => ("string" == typeof e ? { label: e } : e)),
        [n, r] = t.every((e) => /^\w+$/.test(e.label))
          ? [/\w*$/, /\w+$/]
          : (function (e) {
              let t = Object.create(null),
                n = Object.create(null)
              for (let { label: r } of e) {
                t[r[0]] = !0
                for (let e = 1; e < r.length; e++) n[r[e]] = !0
              }
              let r = Tie(t) + Tie(n) + "*$"
              return [new RegExp("^" + r), new RegExp(r)]
            })(t)
      return (e) => {
        let a = e.matchBefore(r)
        return a || e.explicit ? { from: a ? a.from : e.pos, options: t, validFor: n } : null
      }
    }
    class Cie {
      constructor(e, t, n, r) {
        ;(this.completion = e), (this.source = t), (this.match = n), (this.score = r)
      }
    }
    function Pie(e) {
      return e.selection.main.from
    }
    function Die(e, t) {
      var n
      let { source: r } = e,
        a = t && "^" != r[0],
        o = "$" != r[r.length - 1]
      return a || o
        ? new RegExp(
            `${a ? "^" : ""}(?:${r})${o ? "$" : ""}`,
            null !== (n = e.flags) && void 0 !== n ? n : e.ignoreCase ? "i" : "",
          )
        : e
    }
    const Rie = V7.define(),
      Nie = new WeakMap()
    function $ie(e) {
      if (!Array.isArray(e)) return e
      let t = Nie.get(e)
      return t || Nie.set(e, (t = Aie(e))), t
    }
    const Iie = Y7.define(),
      Mie = Y7.define()
    class Lie {
      constructor(e) {
        ;(this.pattern = e),
          (this.chars = []),
          (this.folded = []),
          (this.any = []),
          (this.precise = []),
          (this.byWord = []),
          (this.score = 0),
          (this.matched = [])
        for (let t = 0; t < e.length; ) {
          let n = s7(e, t),
            r = c7(n)
          this.chars.push(n)
          let a = e.slice(t, t + r),
            o = a.toUpperCase()
          this.folded.push(s7(o == a ? a.toLowerCase() : o, 0)), (t += r)
        }
        this.astral = e.length != this.chars.length
      }
      ret(e, t) {
        return (this.score = e), (this.matched = t), this
      }
      match(e) {
        if (0 == this.pattern.length) return this.ret(-100, [])
        if (e.length < this.pattern.length) return null
        let { chars: t, folded: n, any: r, precise: a, byWord: o } = this
        if (1 == t.length) {
          let r = s7(e, 0),
            a = c7(r),
            o = a == e.length ? 0 : -100
          if (r == t[0]);
          else {
            if (r != n[0]) return null
            o += -200
          }
          return this.ret(o, [0, a])
        }
        let i = e.indexOf(this.pattern)
        if (0 == i) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length])
        let s = t.length,
          l = 0
        if (i < 0) {
          for (let a = 0, o = Math.min(e.length, 200); a < o && l < s; ) {
            let o = s7(e, a)
            ;(o != t[l] && o != n[l]) || (r[l++] = a), (a += c7(o))
          }
          if (l < s) return null
        }
        let c = 0,
          d = 0,
          u = !1,
          p = 0,
          h = -1,
          f = -1,
          m = /[a-z]/.test(e),
          g = !0
        for (let r = 0, l = Math.min(e.length, 200), b = 0; r < l && d < s; ) {
          let l = s7(e, r)
          i < 0 &&
            (c < s && l == t[c] && (a[c++] = r),
            p < s && (l == t[p] || l == n[p] ? (0 == p && (h = r), (f = r + 1), p++) : (p = 0)))
          let v,
            y =
              l < 255
                ? (l >= 48 && l <= 57) || (l >= 97 && l <= 122)
                  ? 2
                  : l >= 65 && l <= 90
                    ? 1
                    : 0
                : (v = l7(l)) != v.toLowerCase()
                  ? 1
                  : v != v.toUpperCase()
                    ? 2
                    : 0
          ;(!r || (1 == y && m) || (0 == b && 0 != y)) &&
            (t[d] == l || (n[d] == l && (u = !0)) ? (o[d++] = r) : o.length && (g = !1)),
            (b = y),
            (r += c7(l))
        }
        return d == s && 0 == o[0] && g
          ? this.result((u ? -200 : 0) - 100, o, e)
          : p == s && 0 == h
            ? this.ret(-200 - e.length + (f == e.length ? 0 : -100), [0, f])
            : i > -1
              ? this.ret(-700 - e.length, [i, i + this.pattern.length])
              : p == s
                ? this.ret(-900 - e.length, [h, f])
                : d == s
                  ? this.result((u ? -200 : 0) - 100 - 700 + (g ? 0 : -1100), o, e)
                  : 2 == t.length
                    ? null
                    : this.result((r[0] ? -700 : 0) - 200 - 1100, r, e)
      }
      result(e, t, n) {
        let r = [],
          a = 0
        for (let e of t) {
          let t = e + (this.astral ? c7(s7(n, e)) : 1)
          a && r[a - 1] == e ? (r[a - 1] = t) : ((r[a++] = e), (r[a++] = t))
        }
        return this.ret(e - n.length, r)
      }
    }
    class Qie {
      constructor(e) {
        ;(this.pattern = e), (this.matched = []), (this.score = 0), (this.folded = e.toLowerCase())
      }
      match(e) {
        if (e.length < this.pattern.length) return null
        let t = e.slice(0, this.pattern.length),
          n = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null
        return null == n
          ? null
          : ((this.matched = [0, t.length]), (this.score = n + (e.length == this.pattern.length ? 0 : -100)), this)
      }
    }
    const Bie = _7.define({
      combine: (e) =>
        l6(
          e,
          {
            activateOnTyping: !0,
            activateOnCompletion: () => !1,
            activateOnTypingDelay: 100,
            selectOnOpen: !0,
            override: null,
            closeOnBlur: !0,
            maxRenderedOptions: 100,
            defaultKeymap: !0,
            tooltipClass: () => "",
            optionClass: () => "",
            aboveCursor: !1,
            icons: !0,
            addToOptions: [],
            positionInfo: Uie,
            filterStrict: !1,
            compareCompletions: (e, t) => e.label.localeCompare(t.label),
            interactionDelay: 75,
            updateSyncTime: 100,
          },
          {
            defaultKeymap: (e, t) => e && t,
            closeOnBlur: (e, t) => e && t,
            icons: (e, t) => e && t,
            tooltipClass: (e, t) => (n) => jie(e(n), t(n)),
            optionClass: (e, t) => (n) => jie(e(n), t(n)),
            addToOptions: (e, t) => e.concat(t),
            filterStrict: (e, t) => e || t,
          },
        ),
    })
    function jie(e, t) {
      return e ? (t ? e + " " + t : e) : t
    }
    function Uie(e, t, n, r, a, o) {
      let i,
        s,
        l = e.textDirection == Y9.RTL,
        c = l,
        d = !1,
        u = "top",
        p = t.left - a.left,
        h = a.right - t.right,
        f = r.right - r.left,
        m = r.bottom - r.top
      if ((c && p < Math.min(f, h) ? (c = !1) : !c && h < Math.min(f, p) && (c = !0), f <= (c ? p : h)))
        (i = Math.max(a.top, Math.min(n.top, a.bottom - m)) - t.top), (s = Math.min(400, c ? p : h))
      else {
        ;(d = !0), (s = Math.min(400, (l ? t.right : a.right - t.left) - 30))
        let e = a.bottom - t.bottom
        e >= m || e > t.top ? (i = n.bottom - t.top) : ((u = "bottom"), (i = t.bottom - n.top))
      }
      return {
        style: `${u}: ${i / ((t.bottom - t.top) / o.offsetHeight)}px; max-width: ${s / ((t.right - t.left) / o.offsetWidth)}px`,
        class: "cm-completionInfo-" + (d ? (l ? "left-narrow" : "right-narrow") : c ? "left" : "right"),
      }
    }
    function Fie(e, t, n) {
      if (e <= n) return { from: 0, to: e }
      if ((t < 0 && (t = 0), t <= e >> 1)) {
        let e = Math.floor(t / n)
        return { from: e * n, to: (e + 1) * n }
      }
      let r = Math.floor((e - t) / n)
      return { from: e - (r + 1) * n, to: e - r * n }
    }
    class zie {
      constructor(e, t, n) {
        ;(this.view = e),
          (this.stateField = t),
          (this.applyCompletion = n),
          (this.info = null),
          (this.infoDestroy = null),
          (this.placeInfoReq = { read: () => this.measureInfo(), write: (e) => this.placeInfo(e), key: this }),
          (this.space = null),
          (this.currentClass = "")
        let r = e.state.field(t),
          { options: a, selected: o } = r.open,
          i = e.state.facet(Bie)
        ;(this.optionContent = (function (e) {
          let t = e.addToOptions.slice()
          return (
            e.icons &&
              t.push({
                render(e) {
                  let t = document.createElement("div")
                  return (
                    t.classList.add("cm-completionIcon"),
                    e.type && t.classList.add(...e.type.split(/\s+/g).map((e) => "cm-completionIcon-" + e)),
                    t.setAttribute("aria-hidden", "true"),
                    t
                  )
                },
                position: 20,
              }),
            t.push(
              {
                render(e, t, n, r) {
                  let a = document.createElement("span")
                  a.className = "cm-completionLabel"
                  let o = e.displayLabel || e.label,
                    i = 0
                  for (let e = 0; e < r.length; ) {
                    let t = r[e++],
                      n = r[e++]
                    t > i && a.appendChild(document.createTextNode(o.slice(i, t)))
                    let s = a.appendChild(document.createElement("span"))
                    s.appendChild(document.createTextNode(o.slice(t, n))),
                      (s.className = "cm-completionMatchedText"),
                      (i = n)
                  }
                  return i < o.length && a.appendChild(document.createTextNode(o.slice(i))), a
                },
                position: 50,
              },
              {
                render(e) {
                  if (!e.detail) return null
                  let t = document.createElement("span")
                  return (t.className = "cm-completionDetail"), (t.textContent = e.detail), t
                },
                position: 80,
              },
            ),
            t.sort((e, t) => e.position - t.position).map((e) => e.render)
          )
        })(i)),
          (this.optionClass = i.optionClass),
          (this.tooltipClass = i.tooltipClass),
          (this.range = Fie(a.length, o, i.maxRenderedOptions)),
          (this.dom = document.createElement("div")),
          (this.dom.className = "cm-tooltip-autocomplete"),
          this.updateTooltipClass(e.state),
          this.dom.addEventListener("mousedown", (n) => {
            let { options: r } = e.state.field(t).open
            for (let t, a = n.target; a && a != this.dom; a = a.parentNode)
              if ("LI" == a.nodeName && (t = /-(\d+)$/.exec(a.id)) && +t[1] < r.length)
                return this.applyCompletion(e, r[+t[1]]), void n.preventDefault()
          }),
          this.dom.addEventListener("focusout", (t) => {
            let n = e.state.field(this.stateField, !1)
            n &&
              n.tooltip &&
              e.state.facet(Bie).closeOnBlur &&
              t.relatedTarget != e.contentDOM &&
              e.dispatch({ effects: Mie.of(null) })
          }),
          this.showOptions(a, r.id)
      }
      mount() {
        this.updateSel()
      }
      showOptions(e, t) {
        this.list && this.list.remove(),
          (this.list = this.dom.appendChild(this.createListBox(e, t, this.range))),
          this.list.addEventListener("scroll", () => {
            this.info && this.view.requestMeasure(this.placeInfoReq)
          })
      }
      update(e) {
        var t
        let n = e.state.field(this.stateField),
          r = e.startState.field(this.stateField)
        if ((this.updateTooltipClass(e.state), n != r)) {
          let { options: a, selected: o, disabled: i } = n.open
          ;(r.open && r.open.options == a) ||
            ((this.range = Fie(a.length, o, e.state.facet(Bie).maxRenderedOptions)), this.showOptions(a, n.id)),
            this.updateSel(),
            i != (null === (t = r.open) || void 0 === t ? void 0 : t.disabled) &&
              this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!i)
        }
      }
      updateTooltipClass(e) {
        let t = this.tooltipClass(e)
        if (t != this.currentClass) {
          for (let e of this.currentClass.split(" ")) e && this.dom.classList.remove(e)
          for (let e of t.split(" ")) e && this.dom.classList.add(e)
          this.currentClass = t
        }
      }
      positioned(e) {
        ;(this.space = e), this.info && this.view.requestMeasure(this.placeInfoReq)
      }
      updateSel() {
        let e = this.view.state.field(this.stateField),
          t = e.open
        if (
          (((t.selected > -1 && t.selected < this.range.from) || t.selected >= this.range.to) &&
            ((this.range = Fie(t.options.length, t.selected, this.view.state.facet(Bie).maxRenderedOptions)),
            this.showOptions(t.options, e.id)),
          this.updateSelectedOption(t.selected))
        ) {
          this.destroyInfo()
          let { completion: n } = t.options[t.selected],
            { info: r } = n
          if (!r) return
          let a = "string" == typeof r ? document.createTextNode(r) : r(n)
          if (!a) return
          "then" in a
            ? a
                .then((t) => {
                  t && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(t, n)
                })
                .catch((e) => Aee(this.view.state, e, "completion info"))
            : this.addInfoPane(a, n)
        }
      }
      addInfoPane(e, t) {
        this.destroyInfo()
        let n = (this.info = document.createElement("div"))
        if (((n.className = "cm-tooltip cm-completionInfo"), null != e.nodeType))
          n.appendChild(e), (this.infoDestroy = null)
        else {
          let { dom: t, destroy: r } = e
          n.appendChild(t), (this.infoDestroy = r || null)
        }
        this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq)
      }
      updateSelectedOption(e) {
        let t = null
        for (let n = this.list.firstChild, r = this.range.from; n; n = n.nextSibling, r++)
          "LI" == n.nodeName && n.id
            ? r == e
              ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), (t = n))
              : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected")
            : r--
        return (
          t &&
            (function (e, t) {
              let n = e.getBoundingClientRect(),
                r = t.getBoundingClientRect(),
                a = n.height / e.offsetHeight
              r.top < n.top
                ? (e.scrollTop -= (n.top - r.top) / a)
                : r.bottom > n.bottom && (e.scrollTop += (r.bottom - n.bottom) / a)
            })(this.list, t),
          t
        )
      }
      measureInfo() {
        let e = this.dom.querySelector("[aria-selected]")
        if (!e || !this.info) return null
        let t = this.dom.getBoundingClientRect(),
          n = this.info.getBoundingClientRect(),
          r = e.getBoundingClientRect(),
          a = this.space
        if (!a) {
          let e = this.dom.ownerDocument.defaultView || window
          a = { left: 0, top: 0, right: e.innerWidth, bottom: e.innerHeight }
        }
        return r.top > Math.min(a.bottom, t.bottom) - 10 || r.bottom < Math.max(a.top, t.top) + 10
          ? null
          : this.view.state.facet(Bie).positionInfo(this.view, t, r, n, a, this.dom)
      }
      placeInfo(e) {
        this.info &&
          (e
            ? (e.style && (this.info.style.cssText = e.style),
              (this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")))
            : (this.info.style.cssText = "top: -1e6px"))
      }
      createListBox(e, t, n) {
        const r = document.createElement("ul")
        ;(r.id = t),
          r.setAttribute("role", "listbox"),
          r.setAttribute("aria-expanded", "true"),
          r.setAttribute("aria-label", this.view.state.phrase("Completions"))
        let a = null
        for (let o = n.from; o < n.to; o++) {
          let { completion: i, match: s } = e[o],
            { section: l } = i
          if (l) {
            let e = "string" == typeof l ? l : l.name
            e != a &&
              (o > n.from || 0 == n.from) &&
              ((a = e),
              "string" != typeof l && l.header
                ? r.appendChild(l.header(l))
                : (r.appendChild(document.createElement("completion-section")).textContent = e))
          }
          const c = r.appendChild(document.createElement("li"))
          ;(c.id = t + "-" + o), c.setAttribute("role", "option")
          let d = this.optionClass(i)
          d && (c.className = d)
          for (let e of this.optionContent) {
            let t = e(i, this.view.state, this.view, s)
            t && c.appendChild(t)
          }
        }
        return (
          n.from && r.classList.add("cm-completionListIncompleteTop"),
          n.to < e.length && r.classList.add("cm-completionListIncompleteBottom"),
          r
        )
      }
      destroyInfo() {
        this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), (this.info = null))
      }
      destroy() {
        this.destroyInfo()
      }
    }
    function qie(e) {
      return 100 * (e.boost || 0) + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0)
    }
    class Zie {
      constructor(e, t, n, r, a, o) {
        ;(this.options = e),
          (this.attrs = t),
          (this.tooltip = n),
          (this.timestamp = r),
          (this.selected = a),
          (this.disabled = o)
      }
      setSelected(e, t) {
        return e == this.selected || e >= this.options.length
          ? this
          : new Zie(this.options, Wie(t, e), this.tooltip, this.timestamp, e, this.disabled)
      }
      static build(e, t, n, r, a) {
        let o = (function (e, t) {
          let n = [],
            r = null,
            a = (e) => {
              n.push(e)
              let { section: t } = e.completion
              if (t) {
                r || (r = [])
                let e = "string" == typeof t ? t : t.name
                r.some((t) => t.name == e) || r.push("string" == typeof t ? { name: e } : t)
              }
            },
            o = t.facet(Bie)
          for (let r of e)
            if (r.hasResult()) {
              let e = r.result.getMatch
              if (!1 === r.result.filter)
                for (let t of r.result.options) a(new Cie(t, r.source, e ? e(t) : [], 1e9 - n.length))
              else {
                let n,
                  i = t.sliceDoc(r.from, r.to),
                  s = o.filterStrict ? new Qie(i) : new Lie(i)
                for (let t of r.result.options)
                  if ((n = s.match(t.label))) {
                    let o = t.displayLabel ? (e ? e(t, n.matched) : []) : n.matched
                    a(new Cie(t, r.source, o, n.score + (t.boost || 0)))
                  }
              }
            }
          if (r) {
            let e = Object.create(null),
              t = 0,
              a = (e, t) => {
                var n, r
                return (
                  (null !== (n = e.rank) && void 0 !== n ? n : 1e9) -
                    (null !== (r = t.rank) && void 0 !== r ? r : 1e9) || (e.name < t.name ? -1 : 1)
                )
              }
            for (let n of r.sort(a)) (t -= 1e5), (e[n.name] = t)
            for (let t of n) {
              let { section: n } = t.completion
              n && (t.score += e["string" == typeof n ? n : n.name])
            }
          }
          let i = [],
            s = null,
            l = o.compareCompletions
          for (let e of n.sort((e, t) => t.score - e.score || l(e.completion, t.completion))) {
            let t = e.completion
            !s ||
            s.label != t.label ||
            s.detail != t.detail ||
            (null != s.type && null != t.type && s.type != t.type) ||
            s.apply != t.apply ||
            s.boost != t.boost
              ? i.push(e)
              : qie(e.completion) > qie(s) && (i[i.length - 1] = e),
              (s = e.completion)
          }
          return i
        })(e, t)
        if (!o.length)
          return r && e.some((e) => 1 == e.state)
            ? new Zie(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0)
            : null
        let i = t.facet(Bie).selectOnOpen ? 0 : -1
        if (r && r.selected != i && -1 != r.selected) {
          let e = r.options[r.selected].completion
          for (let t = 0; t < o.length; t++)
            if (o[t].completion == e) {
              i = t
              break
            }
        }
        return new Zie(
          o,
          Wie(n, i),
          {
            pos: e.reduce((e, t) => (t.hasResult() ? Math.min(e, t.from) : e), 1e8),
            create: rse,
            above: a.aboveCursor,
          },
          r ? r.timestamp : Date.now(),
          i,
          !1,
        )
      }
      map(e) {
        return new Zie(
          this.options,
          this.attrs,
          Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }),
          this.timestamp,
          this.selected,
          this.disabled,
        )
      }
    }
    class Hie {
      constructor(e, t, n) {
        ;(this.active = e), (this.id = t), (this.open = n)
      }
      static start() {
        return new Hie(Xie, "cm-ac-" + Math.floor(2e6 * Math.random()).toString(36), null)
      }
      update(e) {
        let { state: t } = e,
          n = t.facet(Bie),
          r = (n.override || t.languageDataAt("autocomplete", Pie(t)).map($ie)).map((t) => {
            let r = this.active.find((e) => e.source == t) || new Gie(t, this.active.some((e) => 0 != e.state) ? 1 : 0)
            return r.update(e, n)
          })
        r.length == this.active.length && r.every((e, t) => e == this.active[t]) && (r = this.active)
        let a = this.open
        a && e.docChanged && (a = a.map(e.changes)),
          e.selection ||
          r.some((t) => t.hasResult() && e.changes.touchesRange(t.from, t.to)) ||
          !(function (e, t) {
            if (e == t) return !0
            for (let n = 0, r = 0; ; ) {
              for (; n < e.length && !e[n].hasResult; ) n++
              for (; r < t.length && !t[r].hasResult; ) r++
              let a = n == e.length,
                o = r == t.length
              if (a || o) return a == o
              if (e[n++].result != t[r++].result) return !1
            }
          })(r, this.active)
            ? (a = Zie.build(r, t, this.id, a, n))
            : a && a.disabled && !r.some((e) => 1 == e.state) && (a = null),
          !a &&
            r.every((e) => 1 != e.state) &&
            r.some((e) => e.hasResult()) &&
            (r = r.map((e) => (e.hasResult() ? new Gie(e.source, 0) : e)))
        for (let t of e.effects) t.is(ese) && (a = a && a.setSelected(t.value, this.id))
        return r == this.active && a == this.open ? this : new Hie(r, this.id, a)
      }
      get tooltip() {
        return this.open ? this.open.tooltip : null
      }
      get attrs() {
        return this.open ? this.open.attrs : Vie
      }
    }
    const Vie = { "aria-autocomplete": "list" }
    function Wie(e, t) {
      let n = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": e }
      return t > -1 && (n["aria-activedescendant"] = e + "-" + t), n
    }
    const Xie = []
    function Yie(e, t) {
      if (e.isUserEvent("input.complete")) {
        let n = e.annotation(Rie)
        if (n && t.activateOnCompletion(n)) return "input"
      }
      return e.isUserEvent("input.type") ? "input" : e.isUserEvent("delete.backward") ? "delete" : null
    }
    class Gie {
      constructor(e, t, n = -1) {
        ;(this.source = e), (this.state = t), (this.explicitPos = n)
      }
      hasResult() {
        return !1
      }
      update(e, t) {
        let n = Yie(e, t),
          r = this
        n
          ? (r = r.handleUserEvent(e, n, t))
          : e.docChanged
            ? (r = r.handleChange(e))
            : e.selection && 0 != r.state && (r = new Gie(r.source, 0))
        for (let t of e.effects)
          if (t.is(Iie)) r = new Gie(r.source, 1, t.value ? Pie(e.state) : -1)
          else if (t.is(Mie)) r = new Gie(r.source, 0)
          else if (t.is(Jie)) for (let e of t.value) e.source == r.source && (r = e)
        return r
      }
      handleUserEvent(e, t, n) {
        return "delete" != t && n.activateOnTyping ? new Gie(this.source, 1) : this.map(e.changes)
      }
      handleChange(e) {
        return e.changes.touchesRange(Pie(e.startState)) ? new Gie(this.source, 0) : this.map(e.changes)
      }
      map(e) {
        return e.empty || this.explicitPos < 0 ? this : new Gie(this.source, this.state, e.mapPos(this.explicitPos))
      }
    }
    class Kie extends Gie {
      constructor(e, t, n, r, a) {
        super(e, 2, t), (this.result = n), (this.from = r), (this.to = a)
      }
      hasResult() {
        return !0
      }
      handleUserEvent(e, t, n) {
        var r
        let a = this.result
        a.map && !e.changes.empty && (a = a.map(a, e.changes))
        let o = e.changes.mapPos(this.from),
          i = e.changes.mapPos(this.to, 1),
          s = Pie(e.state)
        if (
          (this.explicitPos < 0 ? s <= o : s < this.from) ||
          s > i ||
          !a ||
          ("delete" == t && Pie(e.startState) == this.from)
        )
          return new Gie(this.source, "input" == t && n.activateOnTyping ? 1 : 0)
        let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos)
        return (function (e, t, n, r) {
          if (!e) return !1
          let a = t.sliceDoc(n, r)
          return "function" == typeof e ? e(a, n, r, t) : Die(e, !0).test(a)
        })(a.validFor, e.state, o, i)
          ? new Kie(this.source, l, a, o, i)
          : a.update && (a = a.update(a, o, i, new Eie(e.state, s, l >= 0)))
            ? new Kie(this.source, l, a, a.from, null !== (r = a.to) && void 0 !== r ? r : Pie(e.state))
            : new Gie(this.source, 1, l)
      }
      handleChange(e) {
        return e.changes.touchesRange(this.from, this.to) ? new Gie(this.source, 0) : this.map(e.changes)
      }
      map(e) {
        return e.empty
          ? this
          : (this.result.map ? this.result.map(this.result, e) : this.result)
            ? new Kie(
                this.source,
                this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos),
                this.result,
                e.mapPos(this.from),
                e.mapPos(this.to, 1),
              )
            : new Gie(this.source, 0)
      }
    }
    const Jie = Y7.define({ map: (e, t) => e.map((e) => e.map(t)) }),
      ese = Y7.define(),
      tse = D7.define({
        create: () => Hie.start(),
        update: (e, t) => e.update(t),
        provide: (e) => [sre.from(e, (e) => e.tooltip), Tne.contentAttributes.from(e, (e) => e.attrs)],
      })
    function nse(e, t) {
      const n = t.completion.apply || t.completion.label
      let r = e.state.field(tse).active.find((e) => e.source == t.source)
      return (
        r instanceof Kie &&
        ("string" == typeof n
          ? e.dispatch(
              Object.assign(
                Object.assign(
                  {},
                  (function (e, t, n, r) {
                    let { main: a } = e.selection,
                      o = n - a.from,
                      i = r - a.from
                    return Object.assign(
                      Object.assign(
                        {},
                        e.changeByRange((s) =>
                          s != a && n != r && e.sliceDoc(s.from + o, s.from + i) != e.sliceDoc(n, r)
                            ? { range: s }
                            : {
                                changes: { from: s.from + o, to: r == a.from ? s.to : s.from + i, insert: t },
                                range: w7.cursor(s.from + o + t.length),
                              },
                        ),
                      ),
                      { scrollIntoView: !0, userEvent: "input.complete" },
                    )
                  })(e.state, n, r.from, r.to),
                ),
                { annotations: Rie.of(t.completion) },
              ),
            )
          : n(e, t.completion, r.from, r.to),
        !0)
      )
    }
    const rse = (function (e, t) {
      return (n) => new zie(n, e, t)
    })(tse, nse)
    function ase(e, t = "option") {
      return (n) => {
        let r = n.state.field(tse, !1)
        if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Bie).interactionDelay)
          return !1
        let a,
          o = 1
        "page" == t &&
          (a = hre(n, r.open.tooltip)) &&
          (o = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector("li").offsetHeight) - 1))
        let { length: i } = r.open.options,
          s = r.open.selected > -1 ? r.open.selected + o * (e ? 1 : -1) : e ? 0 : i - 1
        return (
          s < 0 ? (s = "page" == t ? 0 : i - 1) : s >= i && (s = "page" == t ? i - 1 : 0),
          n.dispatch({ effects: ese.of(s) }),
          !0
        )
      }
    }
    class ose {
      constructor(e, t) {
        ;(this.active = e), (this.context = t), (this.time = Date.now()), (this.updates = []), (this.done = void 0)
      }
    }
    const ise = Ree.fromClass(
        class {
          constructor(e) {
            ;(this.view = e),
              (this.debounceUpdate = -1),
              (this.running = []),
              (this.debounceAccept = -1),
              (this.pendingStart = !1),
              (this.composing = 0)
            for (let t of e.state.field(tse).active) 1 == t.state && this.startQuery(t)
          }
          update(e) {
            let t = e.state.field(tse),
              n = e.state.facet(Bie)
            if (!e.selectionSet && !e.docChanged && e.startState.field(tse) == t) return
            let r = e.transactions.some((e) => (e.selection || e.docChanged) && !Yie(e, n))
            for (let t = 0; t < this.running.length; t++) {
              let n = this.running[t]
              if (r || (n.updates.length + e.transactions.length > 50 && Date.now() - n.time > 1e3)) {
                for (let e of n.context.abortListeners)
                  try {
                    e()
                  } catch (e) {
                    Aee(this.view.state, e)
                  }
                ;(n.context.abortListeners = null), this.running.splice(t--, 1)
              } else n.updates.push(...e.transactions)
            }
            this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
              e.transactions.some((e) => e.effects.some((e) => e.is(Iie))) && (this.pendingStart = !0)
            let a = this.pendingStart ? 50 : n.activateOnTypingDelay
            if (
              ((this.debounceUpdate = t.active.some(
                (e) => 1 == e.state && !this.running.some((t) => t.active.source == e.source),
              )
                ? setTimeout(() => this.startUpdate(), a)
                : -1),
              0 != this.composing)
            )
              for (let t of e.transactions)
                "input" == Yie(t, n) ? (this.composing = 2) : 2 == this.composing && t.selection && (this.composing = 3)
          }
          startUpdate() {
            ;(this.debounceUpdate = -1), (this.pendingStart = !1)
            let { state: e } = this.view,
              t = e.field(tse)
            for (let e of t.active)
              1 != e.state || this.running.some((t) => t.active.source == e.source) || this.startQuery(e)
          }
          startQuery(e) {
            let { state: t } = this.view,
              n = Pie(t),
              r = new Eie(t, n, e.explicitPos == n),
              a = new ose(e, r)
            this.running.push(a),
              Promise.resolve(e.source(r)).then(
                (e) => {
                  a.context.aborted || ((a.done = e || null), this.scheduleAccept())
                },
                (e) => {
                  this.view.dispatch({ effects: Mie.of(null) }), Aee(this.view.state, e)
                },
              )
          }
          scheduleAccept() {
            this.running.every((e) => void 0 !== e.done)
              ? this.accept()
              : this.debounceAccept < 0 &&
                (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Bie).updateSyncTime))
          }
          accept() {
            var e
            this.debounceAccept > -1 && clearTimeout(this.debounceAccept), (this.debounceAccept = -1)
            let t = [],
              n = this.view.state.facet(Bie)
            for (let r = 0; r < this.running.length; r++) {
              let a = this.running[r]
              if (void 0 === a.done) continue
              if ((this.running.splice(r--, 1), a.done)) {
                let r = new Kie(
                  a.active.source,
                  a.active.explicitPos,
                  a.done,
                  a.done.from,
                  null !== (e = a.done.to) && void 0 !== e
                    ? e
                    : Pie(a.updates.length ? a.updates[0].startState : this.view.state),
                )
                for (let e of a.updates) r = r.update(e, n)
                if (r.hasResult()) {
                  t.push(r)
                  continue
                }
              }
              let o = this.view.state.field(tse).active.find((e) => e.source == a.active.source)
              if (o && 1 == o.state)
                if (null == a.done) {
                  let e = new Gie(a.active.source, 0)
                  for (let t of a.updates) e = e.update(t, n)
                  1 != e.state && t.push(e)
                } else this.startQuery(o)
            }
            t.length && this.view.dispatch({ effects: Jie.of(t) })
          }
        },
        {
          eventHandlers: {
            blur(e) {
              let t = this.view.state.field(tse, !1)
              if (t && t.tooltip && this.view.state.facet(Bie).closeOnBlur) {
                let n = t.open && hre(this.view, t.open.tooltip)
                ;(n && n.dom.contains(e.relatedTarget)) ||
                  setTimeout(() => this.view.dispatch({ effects: Mie.of(null) }), 10)
              }
            },
            compositionstart() {
              this.composing = 1
            },
            compositionend() {
              3 == this.composing && setTimeout(() => this.view.dispatch({ effects: Iie.of(!1) }), 20),
                (this.composing = 0)
            },
          },
        },
      ),
      sse = "object" == typeof navigator && /Win/.test(navigator.platform),
      lse = N7.highest(
        Tne.domEventHandlers({
          keydown(e, t) {
            let n = t.state.field(tse, !1)
            if (
              !n ||
              !n.open ||
              n.open.disabled ||
              n.open.selected < 0 ||
              e.key.length > 1 ||
              (e.ctrlKey && (!sse || !e.altKey)) ||
              e.metaKey
            )
              return !1
            let r = n.open.options[n.open.selected],
              a = n.active.find((e) => e.source == r.source),
              o = r.completion.commitCharacters || a.result.commitCharacters
            return o && o.indexOf(e.key) > -1 && nse(t, r), !1
          },
        }),
      ),
      cse = Tne.baseTheme({
        ".cm-tooltip.cm-tooltip-autocomplete": {
          "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            height: "100%",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 },
            "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" },
            "& > completion-section": {
              display: "list-item",
              borderBottom: "1px solid silver",
              paddingLeft: "0.5em",
              opacity: 0.7,
            },
          },
        },
        "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" },
        "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" },
        "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" },
        "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" },
        ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
          content: '""',
          opacity: 0.5,
          display: "block",
          textAlign: "center",
        },
        ".cm-tooltip.cm-completionInfo": {
          position: "absolute",
          padding: "3px 9px",
          width: "max-content",
          maxWidth: "400px",
          boxSizing: "border-box",
        },
        ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
        ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
        ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
        ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
        "&light .cm-snippetField": { backgroundColor: "#00000022" },
        "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
        ".cm-snippetFieldPosition": {
          verticalAlign: "text-top",
          width: 0,
          height: "1.15em",
          display: "inline-block",
          margin: "0 -0.7px -.7em",
          borderLeft: "1.4px dotted #888",
        },
        ".cm-completionMatchedText": { textDecoration: "underline" },
        ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" },
        ".cm-completionIcon": {
          fontSize: "90%",
          width: ".8em",
          display: "inline-block",
          textAlign: "center",
          paddingRight: ".6em",
          opacity: "0.6",
          boxSizing: "content-box",
        },
        ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "''" } },
        ".cm-completionIcon-class": { "&:after": { content: "''" } },
        ".cm-completionIcon-interface": { "&:after": { content: "''" } },
        ".cm-completionIcon-variable": { "&:after": { content: "''" } },
        ".cm-completionIcon-constant": { "&:after": { content: "''" } },
        ".cm-completionIcon-type": { "&:after": { content: "''" } },
        ".cm-completionIcon-enum": { "&:after": { content: "''" } },
        ".cm-completionIcon-property": { "&:after": { content: "''" } },
        ".cm-completionIcon-keyword": { "&:after": { content: "''" } },
        ".cm-completionIcon-namespace": { "&:after": { content: "''" } },
        ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } },
      })
    class dse {
      constructor(e, t, n, r) {
        ;(this.field = e), (this.line = t), (this.from = n), (this.to = r)
      }
    }
    class use {
      constructor(e, t, n) {
        ;(this.field = e), (this.from = t), (this.to = n)
      }
      map(e) {
        let t = e.mapPos(this.from, -1, u7.TrackDel),
          n = e.mapPos(this.to, 1, u7.TrackDel)
        return null == t || null == n ? null : new use(this.field, t, n)
      }
    }
    class pse {
      constructor(e, t) {
        ;(this.lines = e), (this.fieldPositions = t)
      }
      instantiate(e, t) {
        let n = [],
          r = [t],
          a = e.doc.lineAt(t),
          o = /^\s*/.exec(a.text)[0]
        for (let a of this.lines) {
          if (n.length) {
            let n = o,
              i = /^\t*/.exec(a)[0].length
            for (let t = 0; t < i; t++) n += e.facet(Ooe)
            r.push(t + n.length - i), (a = n + a.slice(i))
          }
          n.push(a), (t += a.length + 1)
        }
        return {
          text: n,
          ranges: this.fieldPositions.map((e) => new use(e.field, r[e.line] + e.from, r[e.line] + e.to)),
        }
      }
      static parse(e) {
        let t,
          n = [],
          r = [],
          a = []
        for (let o of e.split(/\r\n?|\n/)) {
          for (; (t = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o)); ) {
            let e = t[1] ? +t[1] : null,
              i = t[2] || t[3] || "",
              s = -1,
              l = i.replace(/\\[{}]/g, (e) => e[1])
            for (let t = 0; t < n.length; t++) (null != e ? n[t].seq == e : l && n[t].name == l) && (s = t)
            if (s < 0) {
              let t = 0
              for (; t < n.length && (null == e || (null != n[t].seq && n[t].seq < e)); ) t++
              n.splice(t, 0, { seq: e, name: l }), (s = t)
              for (let e of a) e.field >= s && e.field++
            }
            a.push(new dse(s, r.length, t.index, t.index + l.length)),
              (o = o.slice(0, t.index) + i + o.slice(t.index + t[0].length))
          }
          ;(o = o.replace(/\\([{}])/g, (e, t, n) => {
            for (let e of a) e.line == r.length && e.from > n && (e.from--, e.to--)
            return t
          })),
            r.push(o)
        }
        return new pse(r, a)
      }
    }
    let hse = U9.widget({
        widget: new (class extends B9 {
          toDOM() {
            let e = document.createElement("span")
            return (e.className = "cm-snippetFieldPosition"), e
          }
          ignoreEvent() {
            return !1
          }
        })(),
      }),
      fse = U9.mark({ class: "cm-snippetField" })
    class mse {
      constructor(e, t) {
        ;(this.ranges = e),
          (this.active = t),
          (this.deco = U9.set(e.map((e) => (e.from == e.to ? hse : fse).range(e.from, e.to))))
      }
      map(e) {
        let t = []
        for (let n of this.ranges) {
          let r = n.map(e)
          if (!r) return null
          t.push(r)
        }
        return new mse(t, this.active)
      }
      selectionInsideField(e) {
        return e.ranges.every((e) =>
          this.ranges.some((t) => t.field == this.active && t.from <= e.from && t.to >= e.to),
        )
      }
    }
    const gse = Y7.define({ map: (e, t) => e && e.map(t) }),
      bse = Y7.define(),
      vse = D7.define({
        create: () => null,
        update(e, t) {
          for (let n of t.effects) {
            if (n.is(gse)) return n.value
            if (n.is(bse) && e) return new mse(e.ranges, n.value)
          }
          return (
            e && t.docChanged && (e = e.map(t.changes)),
            e && t.selection && !e.selectionInsideField(t.selection) && (e = null),
            e
          )
        },
        provide: (e) => Tne.decorations.from(e, (e) => (e ? e.deco : U9.none)),
      })
    function yse(e, t) {
      return w7.create(e.filter((e) => e.field == t).map((e) => w7.range(e.from, e.to)))
    }
    function Ose(e) {
      let t = pse.parse(e)
      return (e, n, r, a) => {
        let { text: o, ranges: i } = t.instantiate(e.state, r),
          s = {
            changes: { from: r, to: a, insert: F8.of(o) },
            scrollIntoView: !0,
            annotations: n ? [Rie.of(n), G7.userEvent.of("input.complete")] : void 0,
          }
        if ((i.length && (s.selection = yse(i, 0)), i.some((e) => e.field > 0))) {
          let t = new mse(i, 0),
            n = (s.effects = [gse.of(t)])
          void 0 === e.state.field(vse, !1) && n.push(Y7.appendConfig.of([vse, _se, Ese, cse]))
        }
        e.dispatch(e.state.update(s))
      }
    }
    function wse(e) {
      return ({ state: t, dispatch: n }) => {
        let r = t.field(vse, !1)
        if (!r || (e < 0 && 0 == r.active)) return !1
        let a = r.active + e,
          o = e > 0 && !r.ranges.some((t) => t.field == a + e)
        return (
          n(
            t.update({
              selection: yse(r.ranges, a),
              effects: gse.of(o ? null : new mse(r.ranges, a)),
              scrollIntoView: !0,
            }),
          ),
          !0
        )
      }
    }
    const xse = [
        { key: "Tab", run: wse(1), shift: wse(-1) },
        {
          key: "Escape",
          run: ({ state: e, dispatch: t }) => !!e.field(vse, !1) && (t(e.update({ effects: gse.of(null) })), !0),
        },
      ],
      kse = _7.define({ combine: (e) => (e.length ? e[0] : xse) }),
      _se = N7.highest(Ine.compute([kse], (e) => e.facet(kse)))
    function Sse(e, t) {
      return Object.assign(Object.assign({}, t), { apply: Ose(e) })
    }
    const Ese = Tne.domEventHandlers({
        mousedown(e, t) {
          let n,
            r = t.state.field(vse, !1)
          if (!r || null == (n = t.posAtCoords({ x: e.clientX, y: e.clientY }))) return !1
          let a = r.ranges.find((e) => e.from <= n && e.to >= n)
          return !(
            !a ||
            a.field == r.active ||
            (t.dispatch({
              selection: yse(r.ranges, a.field),
              effects: gse.of(r.ranges.some((e) => e.field > a.field) ? new mse(r.ranges, a.field) : null),
              scrollIntoView: !0,
            }),
            0)
          )
        },
      }),
      Tse = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] },
      Ase = Y7.define({
        map(e, t) {
          let n = t.mapPos(e, -1, u7.TrackAfter)
          return null == n ? void 0 : n
        },
      }),
      Cse = new (class extends c6 {})()
    ;(Cse.startSide = 1), (Cse.endSide = -1)
    const Pse = D7.define({
        create: () => h6.empty,
        update(e, t) {
          if (((e = e.map(t.changes)), t.selection)) {
            let n = t.state.doc.lineAt(t.selection.main.head)
            e = e.update({ filter: (e) => e >= n.from && e <= n.to })
          }
          for (let n of t.effects) n.is(Ase) && (e = e.update({ add: [Cse.range(n.value, n.value + 1)] }))
          return e
        },
      }),
      Dse = "()[]{}<>"
    function Rse(e) {
      for (let t = 0; t < 8; t += 2) if (Dse.charCodeAt(t) == e) return Dse.charAt(t + 1)
      return l7(e < 128 ? e : e + 1)
    }
    function Nse(e, t) {
      return e.languageDataAt("closeBrackets", t)[0] || Tse
    }
    const $se = "object" == typeof navigator && /Android\b/.test(navigator.userAgent),
      Ise = Tne.inputHandler.of((e, t, n, r) => {
        if (($se ? e.composing : e.compositionStarted) || e.state.readOnly) return !1
        let a = e.state.selection.main
        if (r.length > 2 || (2 == r.length && 1 == c7(s7(r, 0))) || t != a.from || n != a.to) return !1
        let o = (function (e, t) {
          let n = Nse(e, e.selection.main.head),
            r = n.brackets || Tse.brackets
          for (let a of r) {
            let o = Rse(s7(a, 0))
            if (t == a) return o == a ? Use(e, a, r.indexOf(a + a + a) > -1, n) : Bse(e, a, o, n.before || Tse.before)
            if (t == o && Lse(e, e.selection.main.from)) return jse(e, a, o)
          }
          return null
        })(e.state, r)
        return !!o && (e.dispatch(o), !0)
      }),
      Mse = [
        {
          key: "Backspace",
          run: ({ state: e, dispatch: t }) => {
            if (e.readOnly) return !1
            let n = Nse(e, e.selection.main.head).brackets || Tse.brackets,
              r = null,
              a = e.changeByRange((t) => {
                if (t.empty) {
                  let r = (function (e, t) {
                    let n = e.sliceString(t - 2, t)
                    return c7(s7(n, 0)) == n.length ? n : n.slice(1)
                  })(e.doc, t.head)
                  for (let a of n)
                    if (a == r && Qse(e.doc, t.head) == Rse(s7(a, 0)))
                      return {
                        changes: { from: t.head - a.length, to: t.head + a.length },
                        range: w7.cursor(t.head - a.length),
                      }
                }
                return { range: (r = t) }
              })
            return r || t(e.update(a, { scrollIntoView: !0, userEvent: "delete.backward" })), !r
          },
        },
      ]
    function Lse(e, t) {
      let n = !1
      return (
        e.field(Pse).between(0, e.doc.length, (e) => {
          e == t && (n = !0)
        }),
        n
      )
    }
    function Qse(e, t) {
      let n = e.sliceString(t, t + 2)
      return n.slice(0, c7(s7(n, 0)))
    }
    function Bse(e, t, n, r) {
      let a = null,
        o = e.changeByRange((o) => {
          if (!o.empty)
            return {
              changes: [
                { insert: t, from: o.from },
                { insert: n, from: o.to },
              ],
              effects: Ase.of(o.to + t.length),
              range: w7.range(o.anchor + t.length, o.head + t.length),
            }
          let i = Qse(e.doc, o.head)
          return !i || /\s/.test(i) || r.indexOf(i) > -1
            ? {
                changes: { insert: t + n, from: o.head },
                effects: Ase.of(o.head + t.length),
                range: w7.cursor(o.head + t.length),
              }
            : { range: (a = o) }
        })
      return a ? null : e.update(o, { scrollIntoView: !0, userEvent: "input.type" })
    }
    function jse(e, t, n) {
      let r = null,
        a = e.changeByRange((t) =>
          t.empty && Qse(e.doc, t.head) == n
            ? { changes: { from: t.head, to: t.head + n.length, insert: n }, range: w7.cursor(t.head + n.length) }
            : (r = { range: t }),
        )
      return r ? null : e.update(a, { scrollIntoView: !0, userEvent: "input.type" })
    }
    function Use(e, t, n, r) {
      let a = r.stringPrefixes || Tse.stringPrefixes,
        o = null,
        i = e.changeByRange((r) => {
          if (!r.empty)
            return {
              changes: [
                { insert: t, from: r.from },
                { insert: t, from: r.to },
              ],
              effects: Ase.of(r.to + t.length),
              range: w7.range(r.anchor + t.length, r.head + t.length),
            }
          let i,
            s = r.head,
            l = Qse(e.doc, s)
          if (l == t) {
            if (Fse(e, s))
              return {
                changes: { insert: t + t, from: s },
                effects: Ase.of(s + t.length),
                range: w7.cursor(s + t.length),
              }
            if (Lse(e, s)) {
              let r = n && e.sliceDoc(s, s + 3 * t.length) == t + t + t ? t + t + t : t
              return { changes: { from: s, to: s + r.length, insert: r }, range: w7.cursor(s + r.length) }
            }
          } else {
            if (n && e.sliceDoc(s - 2 * t.length, s) == t + t && (i = zse(e, s - 2 * t.length, a)) > -1 && Fse(e, i))
              return {
                changes: { insert: t + t + t + t, from: s },
                effects: Ase.of(s + t.length),
                range: w7.cursor(s + t.length),
              }
            if (
              e.charCategorizer(s)(l) != a6.Word &&
              zse(e, s, a) > -1 &&
              !(function (e, t, n, r) {
                let a = loe(e).resolveInner(t, -1),
                  o = r.reduce((e, t) => Math.max(e, t.length), 0)
                for (let i = 0; i < 5; i++) {
                  let i = e.sliceDoc(a.from, Math.min(a.to, a.from + n.length + o)),
                    s = i.indexOf(n)
                  if (!s || (s > -1 && r.indexOf(i.slice(0, s)) > -1)) {
                    let t = a.firstChild
                    for (; t && t.from == a.from && t.to - t.from > n.length + s; ) {
                      if (e.sliceDoc(t.to - n.length, t.to) == n) return !1
                      t = t.firstChild
                    }
                    return !0
                  }
                  let l = a.to == t && a.parent
                  if (!l) break
                  a = l
                }
                return !1
              })(e, s, t, a)
            )
              return {
                changes: { insert: t + t, from: s },
                effects: Ase.of(s + t.length),
                range: w7.cursor(s + t.length),
              }
          }
          return { range: (o = r) }
        })
      return o ? null : e.update(i, { scrollIntoView: !0, userEvent: "input.type" })
    }
    function Fse(e, t) {
      let n = loe(e).resolveInner(t + 1)
      return n.parent && n.from == t
    }
    function zse(e, t, n) {
      let r = e.charCategorizer(t)
      if (r(e.sliceDoc(t - 1, t)) != a6.Word) return t
      for (let a of n) {
        let n = t - a.length
        if (e.sliceDoc(n, t) == a && r(e.sliceDoc(n - 1, n)) != a6.Word) return n
      }
      return -1
    }
    const qse = [
        { key: "Ctrl-Space", run: (e) => !!e.state.field(tse, !1) && (e.dispatch({ effects: Iie.of(!0) }), !0) },
        {
          key: "Escape",
          run: (e) => {
            let t = e.state.field(tse, !1)
            return !(!t || !t.active.some((e) => 0 != e.state) || (e.dispatch({ effects: Mie.of(null) }), 0))
          },
        },
        { key: "ArrowDown", run: ase(!0) },
        { key: "ArrowUp", run: ase(!1) },
        { key: "PageDown", run: ase(!0, "page") },
        { key: "PageUp", run: ase(!1, "page") },
        {
          key: "Enter",
          run: (e) => {
            let t = e.state.field(tse, !1)
            return (
              !(
                e.state.readOnly ||
                !t ||
                !t.open ||
                t.open.selected < 0 ||
                t.open.disabled ||
                Date.now() - t.open.timestamp < e.state.facet(Bie).interactionDelay
              ) && nse(e, t.open.options[t.open.selected])
            )
          },
        },
      ],
      Zse = N7.highest(Ine.computeN([Bie], (e) => (e.facet(Bie).defaultKeymap ? [qse] : []))),
      Hse = ({ state: e, dispatch: t }) => (
        t(e.update(e.replaceSelection(e.lineBreak), { scrollIntoView: !0, userEvent: "input" })), !0
      )
    function Vse(e, t) {
      let n = -1
      return e.changeByRange((r) => {
        let a = []
        for (let o = r.from; o <= r.to; ) {
          let i = e.doc.lineAt(o)
          i.number > n && (r.empty || r.to > i.from) && (t(i, a, r), (n = i.number)), (o = i.to + 1)
        }
        let o = e.changes(a)
        return { changes: a, range: w7.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1)) }
      })
    }
    const Wse = {
      key: "Tab",
      run: ({ state: e, dispatch: t }) =>
        !e.readOnly &&
        (t(
          e.update(
            Vse(e, (t, n) => {
              n.push({ from: t.from, insert: e.facet(Ooe) })
            }),
            { userEvent: "input.indent" },
          ),
        ),
        !0),
      shift: ({ state: e, dispatch: t }) =>
        !e.readOnly &&
        (t(
          e.update(
            Vse(e, (t, n) => {
              let r = /^\s*/.exec(t.text)[0]
              if (!r) return
              let a = S6(r, e.tabSize),
                o = 0,
                i = xoe(e, Math.max(0, a - woe(e)))
              for (; o < r.length && o < i.length && r.charCodeAt(o) == i.charCodeAt(o); ) o++
              n.push({ from: t.from + o, to: t.from + r.length, insert: i.slice(o) })
            }),
            { userEvent: "delete.dedent" },
          ),
        ),
        !0),
    }
    class Xse {
      constructor(e, t, n, r, a, o, i, s, l, c = 0, d) {
        ;(this.p = e),
          (this.stack = t),
          (this.state = n),
          (this.reducePos = r),
          (this.pos = a),
          (this.score = o),
          (this.buffer = i),
          (this.bufferBase = s),
          (this.curContext = l),
          (this.lookAhead = c),
          (this.parent = d)
      }
      toString() {
        return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`
      }
      static start(e, t, n = 0) {
        let r = e.parser.context
        return new Xse(e, [], t, n, n, 0, [], 0, r ? new Yse(r, r.start) : null, 0, null)
      }
      get context() {
        return this.curContext ? this.curContext.context : null
      }
      pushState(e, t) {
        this.stack.push(this.state, t, this.bufferBase + this.buffer.length), (this.state = e)
      }
      reduce(e) {
        var t
        let n = e >> 19,
          r = 65535 & e,
          { parser: a } = this.p
        this.reducePos < this.pos - 25 && this.setLookAhead(this.pos)
        let o = a.dynamicPrecedence(r)
        if ((o && (this.score += o), 0 == n))
          return (
            this.pushState(a.getGoto(this.state, r, !0), this.reducePos),
            r < a.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, 4, !0),
            void this.reduceContext(r, this.reducePos)
          )
        let i = this.stack.length - 3 * (n - 1) - (262144 & e ? 6 : 0),
          s = i ? this.stack[i - 2] : this.p.ranges[0].from,
          l = this.reducePos - s
        l >= 2e3 &&
          !(null === (t = this.p.parser.nodeSet.types[r]) || void 0 === t ? void 0 : t.isAnonymous) &&
          (s == this.p.lastBigReductionStart
            ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = l))
            : this.p.lastBigReductionSize < l &&
              ((this.p.bigReductionCount = 1), (this.p.lastBigReductionStart = s), (this.p.lastBigReductionSize = l)))
        let c = i ? this.stack[i - 1] : 0,
          d = this.bufferBase + this.buffer.length - c
        if (r < a.minRepeatTerm || 131072 & e) {
          let e = a.stateFlag(this.state, 1) ? this.pos : this.reducePos
          this.storeNode(r, s, e, d + 4, !0)
        }
        if (262144 & e) this.state = this.stack[i]
        else {
          let e = this.stack[i - 3]
          this.state = a.getGoto(e, r, !0)
        }
        for (; this.stack.length > i; ) this.stack.pop()
        this.reduceContext(r, s)
      }
      storeNode(e, t, n, r = 4, a = !1) {
        if (
          0 == e &&
          (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)
        ) {
          let e = this,
            r = this.buffer.length
          if (
            (0 == r && e.parent && ((r = e.bufferBase - e.parent.bufferBase), (e = e.parent)),
            r > 0 && 0 == e.buffer[r - 4] && e.buffer[r - 1] > -1)
          ) {
            if (t == n) return
            if (e.buffer[r - 2] >= t) return void (e.buffer[r - 2] = n)
          }
        }
        if (a && this.pos != n) {
          let a = this.buffer.length
          if (a > 0 && 0 != this.buffer[a - 4])
            for (; a > 0 && this.buffer[a - 2] > n; )
              (this.buffer[a] = this.buffer[a - 4]),
                (this.buffer[a + 1] = this.buffer[a - 3]),
                (this.buffer[a + 2] = this.buffer[a - 2]),
                (this.buffer[a + 3] = this.buffer[a - 1]),
                (a -= 4),
                r > 4 && (r -= 4)
          ;(this.buffer[a] = e), (this.buffer[a + 1] = t), (this.buffer[a + 2] = n), (this.buffer[a + 3] = r)
        } else this.buffer.push(e, t, n, r)
      }
      shift(e, t, n, r) {
        if (131072 & e) this.pushState(65535 & e, this.pos)
        else if (262144 & e)
          (this.pos = r), this.shiftContext(t, n), t <= this.p.parser.maxNode && this.buffer.push(t, n, r, 4)
        else {
          let a = e,
            { parser: o } = this.p
          ;(r > this.pos || t <= o.maxNode) && ((this.pos = r), o.stateFlag(a, 1) || (this.reducePos = r)),
            this.pushState(a, n),
            this.shiftContext(t, n),
            t <= o.maxNode && this.buffer.push(t, n, r, 4)
        }
      }
      apply(e, t, n, r) {
        65536 & e ? this.reduce(e) : this.shift(e, t, n, r)
      }
      useNode(e, t) {
        let n = this.p.reused.length - 1
        ;(n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++)
        let r = this.pos
        ;(this.reducePos = this.pos = r + e.length),
          this.pushState(t, r),
          this.buffer.push(n, r, this.reducePos, -1),
          this.curContext &&
            this.updateContext(
              this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)),
            )
      }
      split() {
        let e = this,
          t = e.buffer.length
        for (; t > 0 && e.buffer[t - 2] > e.reducePos; ) t -= 4
        let n = e.buffer.slice(t),
          r = e.bufferBase + t
        for (; e && r == e.bufferBase; ) e = e.parent
        return new Xse(
          this.p,
          this.stack.slice(),
          this.state,
          this.reducePos,
          this.pos,
          this.score,
          n,
          r,
          this.curContext,
          this.lookAhead,
          e,
        )
      }
      recoverByDelete(e, t) {
        let n = e <= this.p.parser.maxNode
        n && this.storeNode(e, this.pos, t, 4),
          this.storeNode(0, this.pos, t, n ? 8 : 4),
          (this.pos = this.reducePos = t),
          (this.score -= 190)
      }
      canShift(e) {
        for (let t = new Gse(this); ; ) {
          let n = this.p.parser.stateSlot(t.state, 4) || this.p.parser.hasAction(t.state, e)
          if (0 == n) return !1
          if (!(65536 & n)) return !0
          t.reduce(n)
        }
      }
      recoverByInsert(e) {
        if (this.stack.length >= 300) return []
        let t = this.p.parser.nextStates(this.state)
        if (t.length > 8 || this.stack.length >= 120) {
          let n = []
          for (let r, a = 0; a < t.length; a += 2)
            (r = t[a + 1]) != this.state && this.p.parser.hasAction(r, e) && n.push(t[a], r)
          if (this.stack.length < 120)
            for (let e = 0; n.length < 8 && e < t.length; e += 2) {
              let r = t[e + 1]
              n.some((e, t) => 1 & t && e == r) || n.push(t[e], r)
            }
          t = n
        }
        let n = []
        for (let e = 0; e < t.length && n.length < 4; e += 2) {
          let r = t[e + 1]
          if (r == this.state) continue
          let a = this.split()
          a.pushState(r, this.pos),
            a.storeNode(0, a.pos, a.pos, 4, !0),
            a.shiftContext(t[e], this.pos),
            (a.reducePos = this.pos),
            (a.score -= 200),
            n.push(a)
        }
        return n
      }
      forceReduce() {
        let { parser: e } = this.p,
          t = e.stateSlot(this.state, 5)
        if (!(65536 & t)) return !1
        if (!e.validAction(this.state, t)) {
          let n = t >> 19,
            r = 65535 & t,
            a = this.stack.length - 3 * n
          if (a < 0 || e.getGoto(this.stack[a], r, !1) < 0) {
            let e = this.findForcedReduction()
            if (null == e) return !1
            t = e
          }
          this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100)
        }
        return (this.reducePos = this.pos), this.reduce(t), !0
      }
      findForcedReduction() {
        let { parser: e } = this.p,
          t = [],
          n = (r, a) => {
            if (!t.includes(r))
              return (
                t.push(r),
                e.allActions(r, (t) => {
                  if (393216 & t);
                  else if (65536 & t) {
                    let n = (t >> 19) - a
                    if (n > 1) {
                      let r = 65535 & t,
                        a = this.stack.length - 3 * n
                      if (a >= 0 && e.getGoto(this.stack[a], r, !1) >= 0) return (n << 19) | 65536 | r
                    }
                  } else {
                    let e = n(t, a + 1)
                    if (null != e) return e
                  }
                })
              )
          }
        return n(this.state, 0)
      }
      forceAll() {
        for (; !this.p.parser.stateFlag(this.state, 2); )
          if (!this.forceReduce()) {
            this.storeNode(0, this.pos, this.pos, 4, !0)
            break
          }
        return this
      }
      get deadEnd() {
        if (3 != this.stack.length) return !1
        let { parser: e } = this.p
        return 65535 == e.data[e.stateSlot(this.state, 1)] && !e.stateSlot(this.state, 4)
      }
      restart() {
        this.storeNode(0, this.pos, this.pos, 4, !0), (this.state = this.stack[0]), (this.stack.length = 0)
      }
      sameState(e) {
        if (this.state != e.state || this.stack.length != e.stack.length) return !1
        for (let t = 0; t < this.stack.length; t += 3) if (this.stack[t] != e.stack[t]) return !1
        return !0
      }
      get parser() {
        return this.p.parser
      }
      dialectEnabled(e) {
        return this.p.parser.dialect.flags[e]
      }
      shiftContext(e, t) {
        this.curContext &&
          this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)))
      }
      reduceContext(e, t) {
        this.curContext &&
          this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)))
      }
      emitContext() {
        let e = this.buffer.length - 1
        ;(e < 0 || -3 != this.buffer[e]) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3)
      }
      emitLookAhead() {
        let e = this.buffer.length - 1
        ;(e < 0 || -4 != this.buffer[e]) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4)
      }
      updateContext(e) {
        if (e != this.curContext.context) {
          let t = new Yse(this.curContext.tracker, e)
          t.hash != this.curContext.hash && this.emitContext(), (this.curContext = t)
        }
      }
      setLookAhead(e) {
        e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e))
      }
      close() {
        this.curContext && this.curContext.tracker.strict && this.emitContext(),
          this.lookAhead > 0 && this.emitLookAhead()
      }
    }
    class Yse {
      constructor(e, t) {
        ;(this.tracker = e), (this.context = t), (this.hash = e.strict ? e.hash(t) : 0)
      }
    }
    class Gse {
      constructor(e) {
        ;(this.start = e), (this.state = e.state), (this.stack = e.stack), (this.base = this.stack.length)
      }
      reduce(e) {
        let t = 65535 & e,
          n = e >> 19
        0 == n
          ? (this.stack == this.start.stack && (this.stack = this.stack.slice()),
            this.stack.push(this.state, 0, 0),
            (this.base += 3))
          : (this.base -= 3 * (n - 1))
        let r = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0)
        this.state = r
      }
    }
    class Kse {
      constructor(e, t, n) {
        ;(this.stack = e),
          (this.pos = t),
          (this.index = n),
          (this.buffer = e.buffer),
          0 == this.index && this.maybeNext()
      }
      static create(e, t = e.bufferBase + e.buffer.length) {
        return new Kse(e, t, t - e.bufferBase)
      }
      maybeNext() {
        let e = this.stack.parent
        null != e && ((this.index = this.stack.bufferBase - e.bufferBase), (this.stack = e), (this.buffer = e.buffer))
      }
      get id() {
        return this.buffer[this.index - 4]
      }
      get start() {
        return this.buffer[this.index - 3]
      }
      get end() {
        return this.buffer[this.index - 2]
      }
      get size() {
        return this.buffer[this.index - 1]
      }
      next() {
        ;(this.index -= 4), (this.pos -= 4), 0 == this.index && this.maybeNext()
      }
      fork() {
        return new Kse(this.stack, this.pos, this.index)
      }
    }
    function Jse(e, t = Uint16Array) {
      if ("string" != typeof e) return e
      let n = null
      for (let r = 0, a = 0; r < e.length; ) {
        let o = 0
        for (;;) {
          let t = e.charCodeAt(r++),
            n = !1
          if (126 == t) {
            o = 65535
            break
          }
          t >= 92 && t--, t >= 34 && t--
          let a = t - 32
          if ((a >= 46 && ((a -= 46), (n = !0)), (o += a), n)) break
          o *= 46
        }
        n ? (n[a++] = o) : (n = new t(o))
      }
      return n
    }
    class ele {
      constructor() {
        ;(this.start = -1),
          (this.value = -1),
          (this.end = -1),
          (this.extended = -1),
          (this.lookAhead = 0),
          (this.mask = 0),
          (this.context = 0)
      }
    }
    const tle = new ele()
    class nle {
      constructor(e, t) {
        ;(this.input = e),
          (this.ranges = t),
          (this.chunk = ""),
          (this.chunkOff = 0),
          (this.chunk2 = ""),
          (this.chunk2Pos = 0),
          (this.next = -1),
          (this.token = tle),
          (this.rangeIndex = 0),
          (this.pos = this.chunkPos = t[0].from),
          (this.range = t[0]),
          (this.end = t[t.length - 1].to),
          this.readNext()
      }
      resolveOffset(e, t) {
        let n = this.range,
          r = this.rangeIndex,
          a = this.pos + e
        for (; a < n.from; ) {
          if (!r) return null
          let e = this.ranges[--r]
          ;(a -= n.from - e.to), (n = e)
        }
        for (; t < 0 ? a > n.to : a >= n.to; ) {
          if (r == this.ranges.length - 1) return null
          let e = this.ranges[++r]
          ;(a += e.from - n.to), (n = e)
        }
        return a
      }
      clipPos(e) {
        if (e >= this.range.from && e < this.range.to) return e
        for (let t of this.ranges) if (t.to > e) return Math.max(e, t.from)
        return this.end
      }
      peek(e) {
        let t,
          n,
          r = this.chunkOff + e
        if (r >= 0 && r < this.chunk.length) (t = this.pos + e), (n = this.chunk.charCodeAt(r))
        else {
          let r = this.resolveOffset(e, 1)
          if (null == r) return -1
          if (((t = r), t >= this.chunk2Pos && t < this.chunk2Pos + this.chunk2.length))
            n = this.chunk2.charCodeAt(t - this.chunk2Pos)
          else {
            let e = this.rangeIndex,
              r = this.range
            for (; r.to <= t; ) r = this.ranges[++e]
            ;(this.chunk2 = this.input.chunk((this.chunk2Pos = t))),
              t + this.chunk2.length > r.to && (this.chunk2 = this.chunk2.slice(0, r.to - t)),
              (n = this.chunk2.charCodeAt(0))
          }
        }
        return t >= this.token.lookAhead && (this.token.lookAhead = t + 1), n
      }
      acceptToken(e, t = 0) {
        let n = t ? this.resolveOffset(t, -1) : this.pos
        if (null == n || n < this.token.start) throw new RangeError("Token end out of bounds")
        ;(this.token.value = e), (this.token.end = n)
      }
      acceptTokenTo(e, t) {
        ;(this.token.value = e), (this.token.end = t)
      }
      getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
          let { chunk: e, chunkPos: t } = this
          ;(this.chunk = this.chunk2),
            (this.chunkPos = this.chunk2Pos),
            (this.chunk2 = e),
            (this.chunk2Pos = t),
            (this.chunkOff = this.pos - this.chunkPos)
        } else {
          ;(this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos)
          let e = this.input.chunk(this.pos),
            t = this.pos + e.length
          ;(this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e),
            (this.chunkPos = this.pos),
            (this.chunkOff = 0)
        }
      }
      readNext() {
        return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length)
          ? (this.next = -1)
          : (this.next = this.chunk.charCodeAt(this.chunkOff))
      }
      advance(e = 1) {
        for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
          if (this.rangeIndex == this.ranges.length - 1) return this.setDone()
          ;(e -= this.range.to - this.pos), (this.range = this.ranges[++this.rangeIndex]), (this.pos = this.range.from)
        }
        return (
          (this.pos += e), this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext()
        )
      }
      setDone() {
        return (
          (this.pos = this.chunkPos = this.end),
          (this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
          (this.chunk = ""),
          (this.next = -1)
        )
      }
      reset(e, t) {
        if (
          (t
            ? ((this.token = t), (t.start = e), (t.lookAhead = e + 1), (t.value = t.extended = -1))
            : (this.token = tle),
          this.pos != e)
        ) {
          if (((this.pos = e), e == this.end)) return this.setDone(), this
          for (; e < this.range.from; ) this.range = this.ranges[--this.rangeIndex]
          for (; e >= this.range.to; ) this.range = this.ranges[++this.rangeIndex]
          e >= this.chunkPos && e < this.chunkPos + this.chunk.length
            ? (this.chunkOff = e - this.chunkPos)
            : ((this.chunk = ""), (this.chunkOff = 0)),
            this.readNext()
        }
        return this
      }
      read(e, t) {
        if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
          return this.chunk.slice(e - this.chunkPos, t - this.chunkPos)
        if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
          return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos)
        if (e >= this.range.from && t <= this.range.to) return this.input.read(e, t)
        let n = ""
        for (let r of this.ranges) {
          if (r.from >= t) break
          r.to > e && (n += this.input.read(Math.max(r.from, e), Math.min(r.to, t)))
        }
        return n
      }
    }
    class rle {
      constructor(e, t) {
        ;(this.data = e), (this.id = t)
      }
      token(e, t) {
        let { parser: n } = t.p
        ile(this.data, e, t, this.id, n.data, n.tokenPrecTable)
      }
    }
    rle.prototype.contextual = rle.prototype.fallback = rle.prototype.extend = !1
    class ale {
      constructor(e, t, n) {
        ;(this.precTable = t), (this.elseToken = n), (this.data = "string" == typeof e ? Jse(e) : e)
      }
      token(e, t) {
        let n = e.pos,
          r = 0
        for (;;) {
          let n = e.next < 0,
            a = e.resolveOffset(1, 1)
          if ((ile(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)) break
          if (null == this.elseToken) return
          if ((n || r++, null == a)) break
          e.reset(a, e.token)
        }
        r && (e.reset(n, e.token), e.acceptToken(this.elseToken, r))
      }
    }
    ale.prototype.contextual = rle.prototype.fallback = rle.prototype.extend = !1
    class ole {
      constructor(e, t = {}) {
        ;(this.token = e),
          (this.contextual = !!t.contextual),
          (this.fallback = !!t.fallback),
          (this.extend = !!t.extend)
      }
    }
    function ile(e, t, n, r, a, o) {
      let i = 0,
        s = 1 << r,
        { dialect: l } = n.p.parser
      e: for (; s & e[i]; ) {
        let n = e[i + 1]
        for (let r = i + 3; r < n; r += 2)
          if ((e[r + 1] & s) > 0) {
            let n = e[r]
            if (l.allows(n) && (-1 == t.token.value || t.token.value == n || lle(n, t.token.value, a, o))) {
              t.acceptToken(n)
              break
            }
          }
        let r = t.next,
          c = 0,
          d = e[i + 2]
        if (!(t.next < 0 && d > c && 65535 == e[n + 3 * d - 3])) {
          for (; c < d; ) {
            let a = (c + d) >> 1,
              o = n + a + (a << 1),
              s = e[o],
              l = e[o + 1] || 65536
            if (r < s) d = a
            else {
              if (!(r >= l)) {
                ;(i = e[o + 2]), t.advance()
                continue e
              }
              c = a + 1
            }
          }
          break
        }
        i = e[n + 3 * d - 1]
      }
    }
    function sle(e, t, n) {
      for (let r, a = t; 65535 != (r = e[a]); a++) if (r == n) return a - t
      return -1
    }
    function lle(e, t, n, r) {
      let a = sle(n, r, t)
      return a < 0 || sle(n, r, e) < a
    }
    const cle = "undefined" != typeof process && process.env && /\bparse\b/.test(process.env.LOG)
    let dle = null
    function ule(e, t, n) {
      let r = e.cursor(Hre.IncludeAnonymous)
      for (r.moveTo(t); ; )
        if (!(n < 0 ? r.childBefore(t) : r.childAfter(t)))
          for (;;) {
            if ((n < 0 ? r.to < t : r.from > t) && !r.type.isError)
              return n < 0 ? Math.max(0, Math.min(r.to - 1, t - 25)) : Math.min(e.length, Math.max(r.from + 1, t + 25))
            if (n < 0 ? r.prevSibling() : r.nextSibling()) break
            if (!r.parent()) return n < 0 ? 0 : e.length
          }
    }
    class ple {
      constructor(e, t) {
        ;(this.fragments = e),
          (this.nodeSet = t),
          (this.i = 0),
          (this.fragment = null),
          (this.safeFrom = -1),
          (this.safeTo = -1),
          (this.trees = []),
          (this.start = []),
          (this.index = []),
          this.nextFragment()
      }
      nextFragment() {
        let e = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++])
        if (e) {
          for (
            this.safeFrom = e.openStart ? ule(e.tree, e.from + e.offset, 1) - e.offset : e.from,
              this.safeTo = e.openEnd ? ule(e.tree, e.to + e.offset, -1) - e.offset : e.to;
            this.trees.length;

          )
            this.trees.pop(), this.start.pop(), this.index.pop()
          this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), (this.nextStart = this.safeFrom)
        } else this.nextStart = 1e9
      }
      nodeAt(e) {
        if (e < this.nextStart) return null
        for (; this.fragment && this.safeTo <= e; ) this.nextFragment()
        if (!this.fragment) return null
        for (;;) {
          let t = this.trees.length - 1
          if (t < 0) return this.nextFragment(), null
          let n = this.trees[t],
            r = this.index[t]
          if (r == n.children.length) {
            this.trees.pop(), this.start.pop(), this.index.pop()
            continue
          }
          let a = n.children[r],
            o = this.start[t] + n.positions[r]
          if (o > e) return (this.nextStart = o), null
          if (a instanceof Wre) {
            if (o == e) {
              if (o < this.safeFrom) return null
              let e = o + a.length
              if (e <= this.safeTo) {
                let t = a.prop(Bre.lookAhead)
                if (!t || e + t < this.fragment.to) return a
              }
            }
            this.index[t]++,
              o + a.length >= Math.max(this.safeFrom, e) && (this.trees.push(a), this.start.push(o), this.index.push(0))
          } else this.index[t]++, (this.nextStart = o + a.length)
        }
      }
    }
    class hle {
      constructor(e, t) {
        ;(this.stream = t),
          (this.tokens = []),
          (this.mainToken = null),
          (this.actions = []),
          (this.tokens = e.tokenizers.map((e) => new ele()))
      }
      getActions(e) {
        let t = 0,
          n = null,
          { parser: r } = e.p,
          { tokenizers: a } = r,
          o = r.stateSlot(e.state, 3),
          i = e.curContext ? e.curContext.hash : 0,
          s = 0
        for (let r = 0; r < a.length; r++) {
          if (!((1 << r) & o)) continue
          let l = a[r],
            c = this.tokens[r]
          if (
            (!n || l.fallback) &&
            ((l.contextual || c.start != e.pos || c.mask != o || c.context != i) &&
              (this.updateCachedToken(c, l, e), (c.mask = o), (c.context = i)),
            c.lookAhead > c.end + 25 && (s = Math.max(c.lookAhead, s)),
            0 != c.value)
          ) {
            let r = t
            if (
              (c.extended > -1 && (t = this.addActions(e, c.extended, c.end, t)),
              (t = this.addActions(e, c.value, c.end, t)),
              !l.extend && ((n = c), t > r))
            )
              break
          }
        }
        for (; this.actions.length > t; ) this.actions.pop()
        return (
          s && e.setLookAhead(s),
          n ||
            e.pos != this.stream.end ||
            ((n = new ele()),
            (n.value = e.p.parser.eofTerm),
            (n.start = n.end = e.pos),
            (t = this.addActions(e, n.value, n.end, t))),
          (this.mainToken = n),
          this.actions
        )
      }
      getMainToken(e) {
        if (this.mainToken) return this.mainToken
        let t = new ele(),
          { pos: n, p: r } = e
        return (
          (t.start = n),
          (t.end = Math.min(n + 1, r.stream.end)),
          (t.value = n == r.stream.end ? r.parser.eofTerm : 0),
          t
        )
      }
      updateCachedToken(e, t, n) {
        let r = this.stream.clipPos(n.pos)
        if ((t.token(this.stream.reset(r, e), n), e.value > -1)) {
          let { parser: t } = n.p
          for (let r = 0; r < t.specialized.length; r++)
            if (t.specialized[r] == e.value) {
              let a = t.specializers[r](this.stream.read(e.start, e.end), n)
              if (a >= 0 && n.p.parser.dialect.allows(a >> 1)) {
                1 & a ? (e.extended = a >> 1) : (e.value = a >> 1)
                break
              }
            }
        } else (e.value = 0), (e.end = this.stream.clipPos(r + 1))
      }
      putAction(e, t, n, r) {
        for (let t = 0; t < r; t += 3) if (this.actions[t] == e) return r
        return (this.actions[r++] = e), (this.actions[r++] = t), (this.actions[r++] = n), r
      }
      addActions(e, t, n, r) {
        let { state: a } = e,
          { parser: o } = e.p,
          { data: i } = o
        for (let e = 0; e < 2; e++)
          for (let s = o.stateSlot(a, e ? 2 : 1); ; s += 3) {
            if (65535 == i[s]) {
              if (1 != i[s + 1]) {
                0 == r && 2 == i[s + 1] && (r = this.putAction(Ole(i, s + 2), t, n, r))
                break
              }
              s = Ole(i, s + 2)
            }
            i[s] == t && (r = this.putAction(Ole(i, s + 1), t, n, r))
          }
        return r
      }
    }
    class fle {
      constructor(e, t, n, r) {
        ;(this.parser = e),
          (this.input = t),
          (this.ranges = r),
          (this.recovering = 0),
          (this.nextStackID = 9812),
          (this.minStackPos = 0),
          (this.reused = []),
          (this.stoppedAt = null),
          (this.lastBigReductionStart = -1),
          (this.lastBigReductionSize = 0),
          (this.bigReductionCount = 0),
          (this.stream = new nle(t, r)),
          (this.tokens = new hle(e, this.stream)),
          (this.topTerm = e.top[1])
        let { from: a } = r[0]
        ;(this.stacks = [Xse.start(this, e.top[0], a)]),
          (this.fragments = n.length && this.stream.end - a > 4 * e.bufferLength ? new ple(n, e.nodeSet) : null)
      }
      get parsedPos() {
        return this.minStackPos
      }
      advance() {
        let e,
          t,
          n = this.stacks,
          r = this.minStackPos,
          a = (this.stacks = [])
        if (this.bigReductionCount > 300 && 1 == n.length) {
          let [e] = n
          for (; e.forceReduce() && e.stack.length && e.stack[e.stack.length - 2] >= this.lastBigReductionStart; );
          this.bigReductionCount = this.lastBigReductionSize = 0
        }
        for (let o = 0; o < n.length; o++) {
          let i = n[o]
          for (;;) {
            if (((this.tokens.mainToken = null), i.pos > r)) a.push(i)
            else {
              if (this.advanceStack(i, a, n)) continue
              {
                e || ((e = []), (t = [])), e.push(i)
                let n = this.tokens.getMainToken(i)
                t.push(n.value, n.end)
              }
            }
            break
          }
        }
        if (!a.length) {
          let t =
            e &&
            (function (e) {
              let t = null
              for (let n of e) {
                let e = n.p.stoppedAt
                ;(n.pos == n.p.stream.end || (null != e && n.pos > e)) &&
                  n.p.parser.stateFlag(n.state, 2) &&
                  (!t || t.score < n.score) &&
                  (t = n)
              }
              return t
            })(e)
          if (t) return cle && console.log("Finish with " + this.stackID(t)), this.stackToTree(t)
          if (this.parser.strict)
            throw (
              (cle &&
                e &&
                console.log(
                  "Stuck with token " +
                    (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"),
                ),
              new SyntaxError("No parse at " + r))
            )
          this.recovering || (this.recovering = 5)
        }
        if (this.recovering && e) {
          let n = null != this.stoppedAt && e[0].pos > this.stoppedAt ? e[0] : this.runRecovery(e, t, a)
          if (n) return cle && console.log("Force-finish " + this.stackID(n)), this.stackToTree(n.forceAll())
        }
        if (this.recovering) {
          let e = 1 == this.recovering ? 1 : 3 * this.recovering
          if (a.length > e) for (a.sort((e, t) => t.score - e.score); a.length > e; ) a.pop()
          a.some((e) => e.reducePos > r) && this.recovering--
        } else if (a.length > 1) {
          e: for (let e = 0; e < a.length - 1; e++) {
            let t = a[e]
            for (let n = e + 1; n < a.length; n++) {
              let r = a[n]
              if (t.sameState(r) || (t.buffer.length > 500 && r.buffer.length > 500)) {
                if (!((t.score - r.score || t.buffer.length - r.buffer.length) > 0)) {
                  a.splice(e--, 1)
                  continue e
                }
                a.splice(n--, 1)
              }
            }
          }
          a.length > 12 && a.splice(12, a.length - 12)
        }
        this.minStackPos = a[0].pos
        for (let e = 1; e < a.length; e++) a[e].pos < this.minStackPos && (this.minStackPos = a[e].pos)
        return null
      }
      stopAt(e) {
        if (null != this.stoppedAt && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward")
        this.stoppedAt = e
      }
      advanceStack(e, t, n) {
        let r = e.pos,
          { parser: a } = this,
          o = cle ? this.stackID(e) + " -> " : ""
        if (null != this.stoppedAt && r > this.stoppedAt) return e.forceReduce() ? e : null
        if (this.fragments) {
          let t = e.curContext && e.curContext.tracker.strict,
            n = t ? e.curContext.hash : 0
          for (let i = this.fragments.nodeAt(r); i; ) {
            let r = this.parser.nodeSet.types[i.type.id] == i.type ? a.getGoto(e.state, i.type.id) : -1
            if (r > -1 && i.length && (!t || (i.prop(Bre.contextHash) || 0) == n))
              return (
                e.useNode(i, r), cle && console.log(o + this.stackID(e) + ` (via reuse of ${a.getName(i.type.id)})`), !0
              )
            if (!(i instanceof Wre) || 0 == i.children.length || i.positions[0] > 0) break
            let s = i.children[0]
            if (!(s instanceof Wre && 0 == i.positions[0])) break
            i = s
          }
        }
        let i = a.stateSlot(e.state, 4)
        if (i > 0)
          return (
            e.reduce(i), cle && console.log(o + this.stackID(e) + ` (via always-reduce ${a.getName(65535 & i)})`), !0
          )
        if (e.stack.length >= 8400) for (; e.stack.length > 6e3 && e.forceReduce(); );
        let s = this.tokens.getActions(e)
        for (let i = 0; i < s.length; ) {
          let l = s[i++],
            c = s[i++],
            d = s[i++],
            u = i == s.length || !n,
            p = u ? e : e.split(),
            h = this.tokens.mainToken
          if (
            (p.apply(l, c, h ? h.start : p.pos, d),
            cle &&
              console.log(
                o +
                  this.stackID(p) +
                  ` (via ${65536 & l ? `reduce of ${a.getName(65535 & l)}` : "shift"} for ${a.getName(c)} @ ${r}${p == e ? "" : ", split"})`,
              ),
            u)
          )
            return !0
          p.pos > r ? t.push(p) : n.push(p)
        }
        return !1
      }
      advanceFully(e, t) {
        let n = e.pos
        for (;;) {
          if (!this.advanceStack(e, null, null)) return !1
          if (e.pos > n) return mle(e, t), !0
        }
      }
      runRecovery(e, t, n) {
        let r = null,
          a = !1
        for (let o = 0; o < e.length; o++) {
          let i = e[o],
            s = t[o << 1],
            l = t[1 + (o << 1)],
            c = cle ? this.stackID(i) + " -> " : ""
          if (i.deadEnd) {
            if (a) continue
            if (
              ((a = !0), i.restart(), cle && console.log(c + this.stackID(i) + " (restarted)"), this.advanceFully(i, n))
            )
              continue
          }
          let d = i.split(),
            u = c
          for (
            let e = 0;
            d.forceReduce() &&
            e < 10 &&
            (cle && console.log(u + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, n));
            e++
          )
            cle && (u = this.stackID(d) + " -> ")
          for (let e of i.recoverByInsert(s))
            cle && console.log(c + this.stackID(e) + " (via recover-insert)"), this.advanceFully(e, n)
          this.stream.end > i.pos
            ? (l == i.pos && (l++, (s = 0)),
              i.recoverByDelete(s, l),
              cle && console.log(c + this.stackID(i) + ` (via recover-delete ${this.parser.getName(s)})`),
              mle(i, n))
            : (!r || r.score < i.score) && (r = i)
        }
        return r
      }
      stackToTree(e) {
        return (
          e.close(),
          Wre.build({
            buffer: Kse.create(e),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: e.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm,
          })
        )
      }
      stackID(e) {
        let t = (dle || (dle = new WeakMap())).get(e)
        return t || dle.set(e, (t = String.fromCodePoint(this.nextStackID++))), t + e
      }
    }
    function mle(e, t) {
      for (let n = 0; n < t.length; n++) {
        let r = t[n]
        if (r.pos == e.pos && r.sameState(e)) return void (t[n].score < e.score && (t[n] = e))
      }
      t.push(e)
    }
    class gle {
      constructor(e, t, n) {
        ;(this.source = e), (this.flags = t), (this.disabled = n)
      }
      allows(e) {
        return !this.disabled || 0 == this.disabled[e]
      }
    }
    const ble = (e) => e
    class vle {
      constructor(e) {
        ;(this.start = e.start),
          (this.shift = e.shift || ble),
          (this.reduce = e.reduce || ble),
          (this.reuse = e.reuse || ble),
          (this.hash = e.hash || (() => 0)),
          (this.strict = !1 !== e.strict)
      }
    }
    class yle extends fae {
      constructor(e) {
        if ((super(), (this.wrappers = []), 14 != e.version))
          throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`)
        let t = e.nodeNames.split(" ")
        this.minRepeatTerm = t.length
        for (let n = 0; n < e.repeatNodeCount; n++) t.push("")
        let n = Object.keys(e.topRules).map((t) => e.topRules[t][1]),
          r = []
        for (let e = 0; e < t.length; e++) r.push([])
        function a(e, t, n) {
          r[e].push([t, t.deserialize(String(n))])
        }
        if (e.nodeProps)
          for (let t of e.nodeProps) {
            let e = t[0]
            "string" == typeof e && (e = Bre[e])
            for (let n = 1; n < t.length; ) {
              let r = t[n++]
              if (r >= 0) a(r, e, t[n++])
              else {
                let o = t[n + -r]
                for (let i = -r; i > 0; i--) a(t[n++], e, o)
                n++
              }
            }
          }
        ;(this.nodeSet = new zre(
          t.map((t, a) =>
            Fre.define({
              name: a >= this.minRepeatTerm ? void 0 : t,
              id: a,
              props: r[a],
              top: n.indexOf(a) > -1,
              error: 0 == a,
              skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1,
            }),
          ),
        )),
          e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
          (this.strict = !1),
          (this.bufferLength = Mre)
        let o = Jse(e.tokenData)
        ;(this.context = e.context),
          (this.specializerSpecs = e.specialized || []),
          (this.specialized = new Uint16Array(this.specializerSpecs.length))
        for (let e = 0; e < this.specializerSpecs.length; e++) this.specialized[e] = this.specializerSpecs[e].term
        ;(this.specializers = this.specializerSpecs.map(wle)),
          (this.states = Jse(e.states, Uint32Array)),
          (this.data = Jse(e.stateData)),
          (this.goto = Jse(e.goto)),
          (this.maxTerm = e.maxTerm),
          (this.tokenizers = e.tokenizers.map((e) => ("number" == typeof e ? new rle(o, e) : e))),
          (this.topRules = e.topRules),
          (this.dialects = e.dialects || {}),
          (this.dynamicPrecedences = e.dynamicPrecedences || null),
          (this.tokenPrecTable = e.tokenPrec),
          (this.termNames = e.termNames || null),
          (this.maxNode = this.nodeSet.types.length - 1),
          (this.dialect = this.parseDialect()),
          (this.top = this.topRules[Object.keys(this.topRules)[0]])
      }
      createParse(e, t, n) {
        let r = new fle(this, e, t, n)
        for (let a of this.wrappers) r = a(r, e, t, n)
        return r
      }
      getGoto(e, t, n = !1) {
        let r = this.goto
        if (t >= r[0]) return -1
        for (let a = r[t + 1]; ; ) {
          let t = r[a++],
            o = 1 & t,
            i = r[a++]
          if (o && n) return i
          for (let n = a + (t >> 1); a < n; a++) if (r[a] == e) return i
          if (o) return -1
        }
      }
      hasAction(e, t) {
        let n = this.data
        for (let r = 0; r < 2; r++)
          for (let a, o = this.stateSlot(e, r ? 2 : 1); ; o += 3) {
            if (65535 == (a = n[o])) {
              if (1 != n[o + 1]) {
                if (2 == n[o + 1]) return Ole(n, o + 2)
                break
              }
              a = n[(o = Ole(n, o + 2))]
            }
            if (a == t || 0 == a) return Ole(n, o + 1)
          }
        return 0
      }
      stateSlot(e, t) {
        return this.states[6 * e + t]
      }
      stateFlag(e, t) {
        return (this.stateSlot(e, 0) & t) > 0
      }
      validAction(e, t) {
        return !!this.allActions(e, (e) => e == t || null)
      }
      allActions(e, t) {
        let n = this.stateSlot(e, 4),
          r = n ? t(n) : void 0
        for (let n = this.stateSlot(e, 1); null == r; n += 3) {
          if (65535 == this.data[n]) {
            if (1 != this.data[n + 1]) break
            n = Ole(this.data, n + 2)
          }
          r = t(Ole(this.data, n + 1))
        }
        return r
      }
      nextStates(e) {
        let t = []
        for (let n = this.stateSlot(e, 1); ; n += 3) {
          if (65535 == this.data[n]) {
            if (1 != this.data[n + 1]) break
            n = Ole(this.data, n + 2)
          }
          if (!(1 & this.data[n + 2])) {
            let e = this.data[n + 1]
            t.some((t, n) => 1 & n && t == e) || t.push(this.data[n], e)
          }
        }
        return t
      }
      configure(e) {
        let t = Object.assign(Object.create(yle.prototype), this)
        if ((e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top)) {
          let n = this.topRules[e.top]
          if (!n) throw new RangeError(`Invalid top rule name ${e.top}`)
          t.top = n
        }
        return (
          e.tokenizers &&
            (t.tokenizers = this.tokenizers.map((t) => {
              let n = e.tokenizers.find((e) => e.from == t)
              return n ? n.to : t
            })),
          e.specializers &&
            ((t.specializers = this.specializers.slice()),
            (t.specializerSpecs = this.specializerSpecs.map((n, r) => {
              let a = e.specializers.find((e) => e.from == n.external)
              if (!a) return n
              let o = Object.assign(Object.assign({}, n), { external: a.to })
              return (t.specializers[r] = wle(o)), o
            }))),
          e.contextTracker && (t.context = e.contextTracker),
          e.dialect && (t.dialect = this.parseDialect(e.dialect)),
          null != e.strict && (t.strict = e.strict),
          e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)),
          null != e.bufferLength && (t.bufferLength = e.bufferLength),
          t
        )
      }
      hasWrappers() {
        return this.wrappers.length > 0
      }
      getName(e) {
        return this.termNames ? this.termNames[e] : String((e <= this.maxNode && this.nodeSet.types[e].name) || e)
      }
      get eofTerm() {
        return this.maxNode + 1
      }
      get topNode() {
        return this.nodeSet.types[this.top[1]]
      }
      dynamicPrecedence(e) {
        let t = this.dynamicPrecedences
        return null == t ? 0 : t[e] || 0
      }
      parseDialect(e) {
        let t = Object.keys(this.dialects),
          n = t.map(() => !1)
        if (e)
          for (let r of e.split(" ")) {
            let e = t.indexOf(r)
            e >= 0 && (n[e] = !0)
          }
        let r = null
        for (let e = 0; e < t.length; e++)
          if (!n[e])
            for (let n, a = this.dialects[t[e]]; 65535 != (n = this.data[a++]); )
              (r || (r = new Uint8Array(this.maxTerm + 1)))[n] = 1
        return new gle(e, n, r)
      }
      static deserialize(e) {
        return new yle(e)
      }
    }
    function Ole(e, t) {
      return e[t] | (e[t + 1] << 16)
    }
    function wle(e) {
      if (e.external) {
        let t = e.extend ? 1 : 0
        return (n, r) => (e.external(n, r) << 1) | t
      }
      return e.get
    }
    const xle = [
      9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232,
      8233, 8239, 8287, 12288,
    ]
    function kle(e) {
      return (e >= 65 && e <= 90) || (e >= 97 && e <= 122) || e >= 161
    }
    function _le(e) {
      return e >= 48 && e <= 57
    }
    const Sle = new ole((e, t) => {
        for (let n = !1, r = 0, a = 0; ; a++) {
          let { next: o } = e
          if (kle(o) || 45 == o || 95 == o || (n && _le(o)))
            !n && (45 != o || a > 0) && (n = !0), r === a && 45 == o && r++, e.advance()
          else {
            if (92 != o || 10 == e.peek(1)) {
              n && e.acceptToken(40 == o ? 100 : 2 == r && t.canShift(2) ? 2 : 101)
              break
            }
            e.advance(), e.next > -1 && e.advance(), (n = !0)
          }
        }
      }),
      Ele = new ole((e) => {
        if (xle.includes(e.peek(-1))) {
          let { next: t } = e
          ;(kle(t) || 95 == t || 35 == t || 46 == t || 91 == t || (58 == t && kle(e.peek(1))) || 45 == t || 38 == t) &&
            e.acceptToken(99)
        }
      }),
      Tle = new ole((e) => {
        if (!xle.includes(e.peek(-1))) {
          let { next: t } = e
          if ((37 == t && (e.advance(), e.acceptToken(1)), kle(t))) {
            do {
              e.advance()
            } while (kle(e.next) || _le(e.next))
            e.acceptToken(1)
          }
        }
      }),
      Ale = Nae({
        "AtKeyword import charset namespace keyframes media supports": eoe.definitionKeyword,
        "from to selector": eoe.keyword,
        NamespaceName: eoe.namespace,
        KeyframeName: eoe.labelName,
        KeyframeRangeName: eoe.operatorKeyword,
        TagName: eoe.tagName,
        ClassName: eoe.className,
        PseudoClassName: eoe.constant(eoe.className),
        IdName: eoe.labelName,
        "FeatureName PropertyName": eoe.propertyName,
        AttributeName: eoe.attributeName,
        NumberLiteral: eoe.number,
        KeywordQuery: eoe.keyword,
        UnaryQueryOp: eoe.operatorKeyword,
        "CallTag ValueName": eoe.atom,
        VariableName: eoe.variableName,
        Callee: eoe.operatorKeyword,
        Unit: eoe.unit,
        "UniversalSelector NestingSelector": eoe.definitionOperator,
        MatchOp: eoe.compareOperator,
        "ChildOp SiblingOp, LogicOp": eoe.logicOperator,
        BinOp: eoe.arithmeticOperator,
        Important: eoe.modifier,
        Comment: eoe.blockComment,
        ColorLiteral: eoe.color,
        "ParenthesizedContent StringLiteral": eoe.string,
        ":": eoe.punctuation,
        "PseudoOp #": eoe.derefOperator,
        "; ,": eoe.separator,
        "( )": eoe.paren,
        "[ ]": eoe.squareBracket,
        "{ }": eoe.brace,
      }),
      Cle = {
        __proto__: null,
        lang: 32,
        "nth-child": 32,
        "nth-last-child": 32,
        "nth-of-type": 32,
        "nth-last-of-type": 32,
        dir: 32,
        "host-context": 32,
        url: 60,
        "url-prefix": 60,
        domain: 60,
        regexp: 60,
        selector: 138,
      },
      Ple = {
        __proto__: null,
        "@import": 118,
        "@media": 142,
        "@charset": 146,
        "@namespace": 150,
        "@keyframes": 156,
        "@supports": 168,
      },
      Dle = { __proto__: null, not: 132, only: 132 },
      Rle = yle.deserialize({
        version: 14,
        states:
          ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
        stateData:
          ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
        goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
        nodeNames:
          " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
        maxTerm: 117,
        nodeProps: [
          ["isolate", -2, 3, 24, ""],
          ["openedBy", 17, "(", 32, "[", 50, "{"],
          ["closedBy", 18, ")", 33, "]", 51, "}"],
        ],
        propSources: [Ale],
        skippedNodes: [0, 3, 87],
        repeatNodeCount: 11,
        tokenData:
          "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
        tokenizers: [Ele, Tle, Sle, 1, 2, 3, 4, new ale("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
        topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
        specialized: [
          { term: 100, get: (e) => Cle[e] || -1 },
          { term: 58, get: (e) => Ple[e] || -1 },
          { term: 101, get: (e) => Dle[e] || -1 },
        ],
        tokenPrec: 1200,
      })
    let Nle = null
    function $le() {
      if (!Nle && "object" == typeof document && document.body) {
        let { style: e } = document.body,
          t = [],
          n = new Set()
        for (let r in e)
          "cssText" != r &&
            "cssFloat" != r &&
            "string" == typeof e[r] &&
            (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase())),
            n.has(r) || (t.push(r), n.add(r)))
        Nle = t.sort().map((e) => ({ type: "property", label: e }))
      }
      return Nle || []
    }
    const Ile = [
        "active",
        "after",
        "any-link",
        "autofill",
        "backdrop",
        "before",
        "checked",
        "cue",
        "default",
        "defined",
        "disabled",
        "empty",
        "enabled",
        "file-selector-button",
        "first",
        "first-child",
        "first-letter",
        "first-line",
        "first-of-type",
        "focus",
        "focus-visible",
        "focus-within",
        "fullscreen",
        "has",
        "host",
        "host-context",
        "hover",
        "in-range",
        "indeterminate",
        "invalid",
        "is",
        "lang",
        "last-child",
        "last-of-type",
        "left",
        "link",
        "marker",
        "modal",
        "not",
        "nth-child",
        "nth-last-child",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "part",
        "placeholder",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "selection",
        "slotted",
        "target",
        "target-text",
        "valid",
        "visited",
        "where",
      ].map((e) => ({ type: "class", label: e })),
      Mle = [
        "above",
        "absolute",
        "activeborder",
        "additive",
        "activecaption",
        "after-white-space",
        "ahead",
        "alias",
        "all",
        "all-scroll",
        "alphabetic",
        "alternate",
        "always",
        "antialiased",
        "appworkspace",
        "asterisks",
        "attr",
        "auto",
        "auto-flow",
        "avoid",
        "avoid-column",
        "avoid-page",
        "avoid-region",
        "axis-pan",
        "background",
        "backwards",
        "baseline",
        "below",
        "bidi-override",
        "blink",
        "block",
        "block-axis",
        "bold",
        "bolder",
        "border",
        "border-box",
        "both",
        "bottom",
        "break",
        "break-all",
        "break-word",
        "bullets",
        "button",
        "button-bevel",
        "buttonface",
        "buttonhighlight",
        "buttonshadow",
        "buttontext",
        "calc",
        "capitalize",
        "caps-lock-indicator",
        "caption",
        "captiontext",
        "caret",
        "cell",
        "center",
        "checkbox",
        "circle",
        "cjk-decimal",
        "clear",
        "clip",
        "close-quote",
        "col-resize",
        "collapse",
        "color",
        "color-burn",
        "color-dodge",
        "column",
        "column-reverse",
        "compact",
        "condensed",
        "contain",
        "content",
        "contents",
        "content-box",
        "context-menu",
        "continuous",
        "copy",
        "counter",
        "counters",
        "cover",
        "crop",
        "cross",
        "crosshair",
        "currentcolor",
        "cursive",
        "cyclic",
        "darken",
        "dashed",
        "decimal",
        "decimal-leading-zero",
        "default",
        "default-button",
        "dense",
        "destination-atop",
        "destination-in",
        "destination-out",
        "destination-over",
        "difference",
        "disc",
        "discard",
        "disclosure-closed",
        "disclosure-open",
        "document",
        "dot-dash",
        "dot-dot-dash",
        "dotted",
        "double",
        "down",
        "e-resize",
        "ease",
        "ease-in",
        "ease-in-out",
        "ease-out",
        "element",
        "ellipse",
        "ellipsis",
        "embed",
        "end",
        "ethiopic-abegede-gez",
        "ethiopic-halehame-aa-er",
        "ethiopic-halehame-gez",
        "ew-resize",
        "exclusion",
        "expanded",
        "extends",
        "extra-condensed",
        "extra-expanded",
        "fantasy",
        "fast",
        "fill",
        "fill-box",
        "fixed",
        "flat",
        "flex",
        "flex-end",
        "flex-start",
        "footnotes",
        "forwards",
        "from",
        "geometricPrecision",
        "graytext",
        "grid",
        "groove",
        "hand",
        "hard-light",
        "help",
        "hidden",
        "hide",
        "higher",
        "highlight",
        "highlighttext",
        "horizontal",
        "hsl",
        "hsla",
        "hue",
        "icon",
        "ignore",
        "inactiveborder",
        "inactivecaption",
        "inactivecaptiontext",
        "infinite",
        "infobackground",
        "infotext",
        "inherit",
        "initial",
        "inline",
        "inline-axis",
        "inline-block",
        "inline-flex",
        "inline-grid",
        "inline-table",
        "inset",
        "inside",
        "intrinsic",
        "invert",
        "italic",
        "justify",
        "keep-all",
        "landscape",
        "large",
        "larger",
        "left",
        "level",
        "lighter",
        "lighten",
        "line-through",
        "linear",
        "linear-gradient",
        "lines",
        "list-item",
        "listbox",
        "listitem",
        "local",
        "logical",
        "loud",
        "lower",
        "lower-hexadecimal",
        "lower-latin",
        "lower-norwegian",
        "lowercase",
        "ltr",
        "luminosity",
        "manipulation",
        "match",
        "matrix",
        "matrix3d",
        "medium",
        "menu",
        "menutext",
        "message-box",
        "middle",
        "min-intrinsic",
        "mix",
        "monospace",
        "move",
        "multiple",
        "multiple_mask_images",
        "multiply",
        "n-resize",
        "narrower",
        "ne-resize",
        "nesw-resize",
        "no-close-quote",
        "no-drop",
        "no-open-quote",
        "no-repeat",
        "none",
        "normal",
        "not-allowed",
        "nowrap",
        "ns-resize",
        "numbers",
        "numeric",
        "nw-resize",
        "nwse-resize",
        "oblique",
        "opacity",
        "open-quote",
        "optimizeLegibility",
        "optimizeSpeed",
        "outset",
        "outside",
        "outside-shape",
        "overlay",
        "overline",
        "padding",
        "padding-box",
        "painted",
        "page",
        "paused",
        "perspective",
        "pinch-zoom",
        "plus-darker",
        "plus-lighter",
        "pointer",
        "polygon",
        "portrait",
        "pre",
        "pre-line",
        "pre-wrap",
        "preserve-3d",
        "progress",
        "push-button",
        "radial-gradient",
        "radio",
        "read-only",
        "read-write",
        "read-write-plaintext-only",
        "rectangle",
        "region",
        "relative",
        "repeat",
        "repeating-linear-gradient",
        "repeating-radial-gradient",
        "repeat-x",
        "repeat-y",
        "reset",
        "reverse",
        "rgb",
        "rgba",
        "ridge",
        "right",
        "rotate",
        "rotate3d",
        "rotateX",
        "rotateY",
        "rotateZ",
        "round",
        "row",
        "row-resize",
        "row-reverse",
        "rtl",
        "run-in",
        "running",
        "s-resize",
        "sans-serif",
        "saturation",
        "scale",
        "scale3d",
        "scaleX",
        "scaleY",
        "scaleZ",
        "screen",
        "scroll",
        "scrollbar",
        "scroll-position",
        "se-resize",
        "self-start",
        "self-end",
        "semi-condensed",
        "semi-expanded",
        "separate",
        "serif",
        "show",
        "single",
        "skew",
        "skewX",
        "skewY",
        "skip-white-space",
        "slide",
        "slider-horizontal",
        "slider-vertical",
        "sliderthumb-horizontal",
        "sliderthumb-vertical",
        "slow",
        "small",
        "small-caps",
        "small-caption",
        "smaller",
        "soft-light",
        "solid",
        "source-atop",
        "source-in",
        "source-out",
        "source-over",
        "space",
        "space-around",
        "space-between",
        "space-evenly",
        "spell-out",
        "square",
        "start",
        "static",
        "status-bar",
        "stretch",
        "stroke",
        "stroke-box",
        "sub",
        "subpixel-antialiased",
        "svg_masks",
        "super",
        "sw-resize",
        "symbolic",
        "symbols",
        "system-ui",
        "table",
        "table-caption",
        "table-cell",
        "table-column",
        "table-column-group",
        "table-footer-group",
        "table-header-group",
        "table-row",
        "table-row-group",
        "text",
        "text-bottom",
        "text-top",
        "textarea",
        "textfield",
        "thick",
        "thin",
        "threeddarkshadow",
        "threedface",
        "threedhighlight",
        "threedlightshadow",
        "threedshadow",
        "to",
        "top",
        "transform",
        "translate",
        "translate3d",
        "translateX",
        "translateY",
        "translateZ",
        "transparent",
        "ultra-condensed",
        "ultra-expanded",
        "underline",
        "unidirectional-pan",
        "unset",
        "up",
        "upper-latin",
        "uppercase",
        "url",
        "var",
        "vertical",
        "vertical-text",
        "view-box",
        "visible",
        "visibleFill",
        "visiblePainted",
        "visibleStroke",
        "visual",
        "w-resize",
        "wait",
        "wave",
        "wider",
        "window",
        "windowframe",
        "windowtext",
        "words",
        "wrap",
        "wrap-reverse",
        "x-large",
        "x-small",
        "xor",
        "xx-large",
        "xx-small",
      ]
        .map((e) => ({ type: "keyword", label: e }))
        .concat(
          [
            "aliceblue",
            "antiquewhite",
            "aqua",
            "aquamarine",
            "azure",
            "beige",
            "bisque",
            "black",
            "blanchedalmond",
            "blue",
            "blueviolet",
            "brown",
            "burlywood",
            "cadetblue",
            "chartreuse",
            "chocolate",
            "coral",
            "cornflowerblue",
            "cornsilk",
            "crimson",
            "cyan",
            "darkblue",
            "darkcyan",
            "darkgoldenrod",
            "darkgray",
            "darkgreen",
            "darkkhaki",
            "darkmagenta",
            "darkolivegreen",
            "darkorange",
            "darkorchid",
            "darkred",
            "darksalmon",
            "darkseagreen",
            "darkslateblue",
            "darkslategray",
            "darkturquoise",
            "darkviolet",
            "deeppink",
            "deepskyblue",
            "dimgray",
            "dodgerblue",
            "firebrick",
            "floralwhite",
            "forestgreen",
            "fuchsia",
            "gainsboro",
            "ghostwhite",
            "gold",
            "goldenrod",
            "gray",
            "grey",
            "green",
            "greenyellow",
            "honeydew",
            "hotpink",
            "indianred",
            "indigo",
            "ivory",
            "khaki",
            "lavender",
            "lavenderblush",
            "lawngreen",
            "lemonchiffon",
            "lightblue",
            "lightcoral",
            "lightcyan",
            "lightgoldenrodyellow",
            "lightgray",
            "lightgreen",
            "lightpink",
            "lightsalmon",
            "lightseagreen",
            "lightskyblue",
            "lightslategray",
            "lightsteelblue",
            "lightyellow",
            "lime",
            "limegreen",
            "linen",
            "magenta",
            "maroon",
            "mediumaquamarine",
            "mediumblue",
            "mediumorchid",
            "mediumpurple",
            "mediumseagreen",
            "mediumslateblue",
            "mediumspringgreen",
            "mediumturquoise",
            "mediumvioletred",
            "midnightblue",
            "mintcream",
            "mistyrose",
            "moccasin",
            "navajowhite",
            "navy",
            "oldlace",
            "olive",
            "olivedrab",
            "orange",
            "orangered",
            "orchid",
            "palegoldenrod",
            "palegreen",
            "paleturquoise",
            "palevioletred",
            "papayawhip",
            "peachpuff",
            "peru",
            "pink",
            "plum",
            "powderblue",
            "purple",
            "rebeccapurple",
            "red",
            "rosybrown",
            "royalblue",
            "saddlebrown",
            "salmon",
            "sandybrown",
            "seagreen",
            "seashell",
            "sienna",
            "silver",
            "skyblue",
            "slateblue",
            "slategray",
            "snow",
            "springgreen",
            "steelblue",
            "tan",
            "teal",
            "thistle",
            "tomato",
            "turquoise",
            "violet",
            "wheat",
            "white",
            "whitesmoke",
            "yellow",
            "yellowgreen",
          ].map((e) => ({ type: "constant", label: e })),
        ),
      Lle = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "b",
        "bdi",
        "bdo",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "dd",
        "del",
        "details",
        "dfn",
        "dialog",
        "div",
        "dl",
        "dt",
        "em",
        "figcaption",
        "figure",
        "footer",
        "form",
        "header",
        "hgroup",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "meter",
        "nav",
        "ol",
        "output",
        "p",
        "pre",
        "ruby",
        "section",
        "select",
        "small",
        "source",
        "span",
        "strong",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "tr",
        "u",
        "ul",
      ].map((e) => ({ type: "type", label: e })),
      Qle = /^(\w[\w-]*|-\w[\w-]*|)$/,
      Ble = /^-(-[\w-]*)?$/,
      jle = new pae(),
      Ule = ["Declaration"]
    function Fle(e) {
      for (let t = e; ; ) {
        if (t.type.isTop) return t
        if (!(t = t.parent)) return e
      }
    }
    function zle(e, t, n) {
      if (t.to - t.from > 4096) {
        let r = jle.get(t)
        if (r) return r
        let a = [],
          o = new Set(),
          i = t.cursor(Hre.IncludeAnonymous)
        if (i.firstChild())
          do {
            for (let t of zle(e, i.node, n)) o.has(t.label) || (o.add(t.label), a.push(t))
          } while (i.nextSibling())
        return jle.set(t, a), a
      }
      {
        let r = [],
          a = new Set()
        return (
          t.cursor().iterate((t) => {
            var o
            if (
              n(t) &&
              t.matchContext(Ule) &&
              ":" == (null === (o = t.node.nextSibling) || void 0 === o ? void 0 : o.name)
            ) {
              let n = e.sliceString(t.from, t.to)
              a.has(n) || (a.add(n), r.push({ label: n, type: "variable" }))
            }
          }),
          r
        )
      }
    }
    const qle = ((e) => (t) => {
        let { state: n, pos: r } = t,
          a = loe(n).resolveInner(r, -1),
          o = a.type.isError && a.from == a.to - 1 && "-" == n.doc.sliceString(a.from, a.to)
        if ("PropertyName" == a.name || ((o || "TagName" == a.name) && /^(Block|Styles)$/.test(a.resolve(a.to).name)))
          return { from: a.from, options: $le(), validFor: Qle }
        if ("ValueName" == a.name) return { from: a.from, options: Mle, validFor: Qle }
        if ("PseudoClassName" == a.name) return { from: a.from, options: Ile, validFor: Qle }
        if (
          e(a) ||
          ((t.explicit || o) &&
            (function (e, t) {
              var n
              if ((("(" == e.name || e.type.isError) && (e = e.parent || e), "ArgList" != e.name)) return !1
              let r = null === (n = e.parent) || void 0 === n ? void 0 : n.firstChild
              return "Callee" == (null == r ? void 0 : r.name) && "var" == t.sliceString(r.from, r.to)
            })(a, n.doc))
        )
          return { from: e(a) || o ? a.from : r, options: zle(n.doc, Fle(a), e), validFor: Ble }
        if ("TagName" == a.name) {
          for (let { parent: e } = a; e; e = e.parent)
            if ("Block" == e.name) return { from: a.from, options: $le(), validFor: Qle }
          return { from: a.from, options: Lle, validFor: Qle }
        }
        if (!t.explicit) return null
        let i = a.resolve(r),
          s = i.childBefore(r)
        return s && ":" == s.name && "PseudoClassSelector" == i.name
          ? { from: r, options: Ile, validFor: Qle }
          : (s && ":" == s.name && "Declaration" == i.name) || "ArgList" == i.name
            ? { from: r, options: Mle, validFor: Qle }
            : "Block" == i.name || "Styles" == i.name
              ? { from: r, options: $le(), validFor: Qle }
              : null
      })((e) => "VariableName" == e.name),
      Zle = soe.define({
        name: "css",
        parser: Rle.configure({ props: [Soe.add({ Declaration: Noe() }), $oe.add({ "Block KeyframeList": Ioe })] }),
        languageData: {
          commentTokens: { block: { open: "/*", close: "*/" } },
          indentOnInput: /^\s*\}$/,
          wordChars: "-",
        },
      })
    function Hle() {
      return new voe(Zle, Zle.data.of({ autocomplete: qle }))
    }
    const Vle = 22,
      Wle = 23,
      Xle = 24,
      Yle = 26,
      Gle = 27,
      Kle = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0,
        menuitem: !0,
      },
      Jle = {
        dd: !0,
        li: !0,
        optgroup: !0,
        option: !0,
        p: !0,
        rp: !0,
        rt: !0,
        tbody: !0,
        td: !0,
        tfoot: !0,
        th: !0,
        tr: !0,
      },
      ece = {
        dd: { dd: !0, dt: !0 },
        dt: { dd: !0, dt: !0 },
        li: { li: !0 },
        option: { option: !0, optgroup: !0 },
        optgroup: { optgroup: !0 },
        p: {
          address: !0,
          article: !0,
          aside: !0,
          blockquote: !0,
          dir: !0,
          div: !0,
          dl: !0,
          fieldset: !0,
          footer: !0,
          form: !0,
          h1: !0,
          h2: !0,
          h3: !0,
          h4: !0,
          h5: !0,
          h6: !0,
          header: !0,
          hgroup: !0,
          hr: !0,
          menu: !0,
          nav: !0,
          ol: !0,
          p: !0,
          pre: !0,
          section: !0,
          table: !0,
          ul: !0,
        },
        rp: { rp: !0, rt: !0 },
        rt: { rp: !0, rt: !0 },
        tbody: { tbody: !0, tfoot: !0 },
        td: { td: !0, th: !0 },
        tfoot: { tbody: !0 },
        th: { td: !0, th: !0 },
        thead: { tbody: !0, tfoot: !0 },
        tr: { tr: !0 },
      }
    function tce(e) {
      return 9 == e || 10 == e || 13 == e || 32 == e
    }
    let nce = null,
      rce = null,
      ace = 0
    function oce(e, t) {
      let n = e.pos + t
      if (ace == n && rce == e) return nce
      let r = e.peek(t)
      for (; tce(r); ) r = e.peek(++t)
      let a = ""
      for (
        ;
        45 == (o = r) || 46 == o || 58 == o || (o >= 65 && o <= 90) || 95 == o || (o >= 97 && o <= 122) || o >= 161;

      )
        (a += String.fromCharCode(r)), (r = e.peek(++t))
      var o
      return (rce = e), (ace = n), (nce = a ? a.toLowerCase() : r == ice || r == sce ? void 0 : null)
    }
    const ice = 63,
      sce = 33
    function lce(e, t) {
      ;(this.name = e), (this.parent = t)
    }
    const cce = [6, 10, 7, 8, 9],
      dce = new vle({
        start: null,
        shift: (e, t, n, r) => (cce.indexOf(t) > -1 ? new lce(oce(r, 1) || "", e) : e),
        reduce: (e, t) => (20 == t && e ? e.parent : e),
        reuse(e, t, n, r) {
          let a = t.type.id
          return 6 == a || 36 == a ? new lce(oce(r, 1) || "", e) : e
        },
        strict: !1,
      }),
      uce = new ole(
        (e, t) => {
          if (60 != e.next) return void (e.next < 0 && t.context && e.acceptToken(57))
          e.advance()
          let n = 47 == e.next
          n && e.advance()
          let r = oce(e, 0)
          if (void 0 === r) return
          if (!r) return e.acceptToken(n ? 14 : 6)
          let a = t.context ? t.context.name : null
          if (n) {
            if (r == a) return e.acceptToken(11)
            if (a && Jle[a]) return e.acceptToken(57, -2)
            if (t.dialectEnabled(0)) return e.acceptToken(12)
            for (let e = t.context; e; e = e.parent) if (e.name == r) return
            e.acceptToken(13)
          } else {
            if ("script" == r) return e.acceptToken(7)
            if ("style" == r) return e.acceptToken(8)
            if ("textarea" == r) return e.acceptToken(9)
            if (Kle.hasOwnProperty(r)) return e.acceptToken(10)
            a && ece[a] && ece[a][r] ? e.acceptToken(57, -1) : e.acceptToken(6)
          }
        },
        { contextual: !0 },
      ),
      pce = new ole((e) => {
        for (let t = 0, n = 0; ; n++) {
          if (e.next < 0) {
            n && e.acceptToken(58)
            break
          }
          if (45 == e.next) t++
          else {
            if (62 == e.next && t >= 2) {
              n >= 3 && e.acceptToken(58, -2)
              break
            }
            t = 0
          }
          e.advance()
        }
      }),
      hce = new ole((e, t) => {
        if (47 == e.next && 62 == e.peek(1)) {
          let n =
            t.dialectEnabled(1) ||
            (function (e) {
              for (; e; e = e.parent) if ("svg" == e.name || "math" == e.name) return !0
              return !1
            })(t.context)
          e.acceptToken(n ? 5 : 4, 2)
        } else 62 == e.next && e.acceptToken(4, 1)
      })
    function fce(e, t, n) {
      let r = 2 + e.length
      return new ole((a) => {
        for (let o = 0, i = 0, s = 0; ; s++) {
          if (a.next < 0) {
            s && a.acceptToken(t)
            break
          }
          if (
            (0 == o && 60 == a.next) ||
            (1 == o && 47 == a.next) ||
            (o >= 2 && o < r && a.next == e.charCodeAt(o - 2))
          )
            o++, i++
          else if ((2 != o && o != r) || !tce(a.next)) {
            if (o == r && 62 == a.next) {
              s > i ? a.acceptToken(t, -i) : a.acceptToken(n, -(i - 2))
              break
            }
            if ((10 == a.next || 13 == a.next) && s) {
              a.acceptToken(t, 1)
              break
            }
            o = i = 0
          } else i++
          a.advance()
        }
      })
    }
    const mce = fce("script", 54, 1),
      gce = fce("style", 55, 2),
      bce = fce("textarea", 56, 3),
      vce = Nae({
        "Text RawText": eoe.content,
        "StartTag StartCloseTag SelfClosingEndTag EndTag": eoe.angleBracket,
        TagName: eoe.tagName,
        "MismatchedCloseTag/TagName": [eoe.tagName, eoe.invalid],
        AttributeName: eoe.attributeName,
        "AttributeValue UnquotedAttributeValue": eoe.attributeValue,
        Is: eoe.definitionOperator,
        "EntityReference CharacterReference": eoe.character,
        Comment: eoe.blockComment,
        ProcessingInst: eoe.processingInstruction,
        DoctypeDecl: eoe.documentMeta,
      }),
      yce = yle.deserialize({
        version: 14,
        states:
          ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
        stateData:
          ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
        goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
        nodeNames:
          " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
        maxTerm: 67,
        context: dce,
        nodeProps: [
          [
            "closedBy",
            -10,
            1,
            2,
            3,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            "EndTag",
            6,
            "EndTag SelfClosingEndTag",
            -4,
            21,
            30,
            33,
            36,
            "CloseTag",
          ],
          ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
          [
            "group",
            -9,
            14,
            17,
            18,
            19,
            20,
            39,
            40,
            41,
            42,
            "Entity",
            16,
            "Entity TextContent",
            -3,
            28,
            31,
            34,
            "TextContent Entity",
          ],
          ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""],
        ],
        propSources: [vce],
        skippedNodes: [0],
        repeatNodeCount: 9,
        tokenData:
          "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
        tokenizers: [mce, gce, bce, hce, uce, pce, 0, 1, 2, 3, 4, 5],
        topRules: { Document: [0, 15] },
        dialects: { noMatch: 0, selfClosing: 509 },
        tokenPrec: 511,
      })
    function Oce(e, t) {
      let n = Object.create(null)
      for (let r of e.getChildren(Wle)) {
        let e = r.getChild(Xle),
          a = r.getChild(Yle) || r.getChild(Gle)
        e &&
          (n[t.read(e.from, e.to)] = a ? (a.type.id == Yle ? t.read(a.from + 1, a.to - 1) : t.read(a.from, a.to)) : "")
      }
      return n
    }
    function wce(e, t) {
      let n = e.getChild(Vle)
      return n ? t.read(n.from, n.to) : " "
    }
    function xce(e, t, n) {
      let r
      for (let a of n) if (!a.attrs || a.attrs(r || (r = Oce(e.node.parent.firstChild, t)))) return { parser: a.parser }
      return null
    }
    function kce(e = [], t = []) {
      let n = [],
        r = [],
        a = [],
        o = []
      for (let t of e) ("script" == t.tag ? n : "style" == t.tag ? r : "textarea" == t.tag ? a : o).push(t)
      let i = t.length ? Object.create(null) : null
      for (let e of t) (i[e.name] || (i[e.name] = [])).push(e)
      return (
        (s = (e, t) => {
          let s = e.type.id
          if (28 == s) return xce(e, t, n)
          if (31 == s) return xce(e, t, r)
          if (34 == s) return xce(e, t, a)
          if (20 == s && o.length) {
            let n,
              r = e.node,
              a = r.firstChild,
              i = a && wce(a, t)
            if (i)
              for (let e of o)
                if (e.tag == i && (!e.attrs || e.attrs(n || (n = Oce(a, t))))) {
                  let t = r.lastChild,
                    n = 37 == t.type.id ? t.from : r.to
                  if (n > a.to) return { parser: e.parser, overlay: [{ from: a.to, to: n }] }
                }
          }
          if (i && s == Wle) {
            let n,
              r = e.node
            if ((n = r.firstChild)) {
              let e = i[t.read(n.from, n.to)]
              if (e)
                for (let n of e) {
                  if (n.tagName && n.tagName != wce(r.parent, t)) continue
                  let e = r.lastChild
                  if (e.type.id == Yle) {
                    let t = e.from + 1,
                      r = e.lastChild,
                      a = e.to - (r && r.isError ? 0 : 1)
                    if (a > t) return { parser: n.parser, overlay: [{ from: t, to: a }] }
                  } else if (e.type.id == Gle) return { parser: n.parser, overlay: [{ from: e.from, to: e.to }] }
                }
            }
          }
          return null
        }),
        (e, t, n, r) => new Oae(e, s, t, n, r)
      )
      var s
    }
    const _ce = [
        9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232,
        8233, 8239, 8287, 12288,
      ],
      Sce = new vle({ start: !1, shift: (e, t) => (5 == t || 6 == t || 315 == t ? e : 316 == t), strict: !1 }),
      Ece = new ole(
        (e, t) => {
          let { next: n } = e
          ;(125 == n || -1 == n || t.context) && e.acceptToken(313)
        },
        { contextual: !0, fallback: !0 },
      ),
      Tce = new ole(
        (e, t) => {
          let n,
            { next: r } = e
          _ce.indexOf(r) > -1 ||
            ((47 != r || (47 != (n = e.peek(1)) && 42 != n)) &&
              (125 == r || 59 == r || -1 == r || t.context || e.acceptToken(312)))
        },
        { contextual: !0 },
      ),
      Ace = new ole(
        (e, t) => {
          let { next: n } = e
          if (43 == n || 45 == n) {
            if ((e.advance(), n == e.next)) {
              e.advance()
              let n = !t.context && t.canShift(1)
              e.acceptToken(n ? 1 : 2)
            }
          } else
            63 == n && 46 == e.peek(1) && (e.advance(), e.advance(), (e.next < 48 || e.next > 57) && e.acceptToken(3))
        },
        { contextual: !0 },
      )
    function Cce(e, t) {
      return (e >= 65 && e <= 90) || (e >= 97 && e <= 122) || 95 == e || e >= 192 || (!t && e >= 48 && e <= 57)
    }
    const Pce = new ole((e, t) => {
        if (60 != e.next || !t.dialectEnabled(0)) return
        if ((e.advance(), 47 == e.next)) return
        let n = 0
        for (; _ce.indexOf(e.next) > -1; ) e.advance(), n++
        if (Cce(e.next, !0)) {
          for (e.advance(), n++; Cce(e.next, !1); ) e.advance(), n++
          for (; _ce.indexOf(e.next) > -1; ) e.advance(), n++
          if (44 == e.next) return
          for (let t = 0; ; t++) {
            if (7 == t) {
              if (!Cce(e.next, !0)) return
              break
            }
            if (e.next != "extends".charCodeAt(t)) break
            e.advance(), n++
          }
        }
        e.acceptToken(4, -n)
      }),
      Dce = Nae({
        "get set async static": eoe.modifier,
        "for while do if else switch try catch finally return throw break continue default case": eoe.controlKeyword,
        "in of await yield void typeof delete instanceof": eoe.operatorKeyword,
        "let var const using function class extends": eoe.definitionKeyword,
        "import export from": eoe.moduleKeyword,
        "with debugger as new": eoe.keyword,
        TemplateString: eoe.special(eoe.string),
        super: eoe.atom,
        BooleanLiteral: eoe.bool,
        this: eoe.self,
        null: eoe.null,
        Star: eoe.modifier,
        VariableName: eoe.variableName,
        "CallExpression/VariableName TaggedTemplateExpression/VariableName": eoe.function(eoe.variableName),
        VariableDefinition: eoe.definition(eoe.variableName),
        Label: eoe.labelName,
        PropertyName: eoe.propertyName,
        PrivatePropertyName: eoe.special(eoe.propertyName),
        "CallExpression/MemberExpression/PropertyName": eoe.function(eoe.propertyName),
        "FunctionDeclaration/VariableDefinition": eoe.function(eoe.definition(eoe.variableName)),
        "ClassDeclaration/VariableDefinition": eoe.definition(eoe.className),
        PropertyDefinition: eoe.definition(eoe.propertyName),
        PrivatePropertyDefinition: eoe.definition(eoe.special(eoe.propertyName)),
        UpdateOp: eoe.updateOperator,
        "LineComment Hashbang": eoe.lineComment,
        BlockComment: eoe.blockComment,
        Number: eoe.number,
        String: eoe.string,
        Escape: eoe.escape,
        ArithOp: eoe.arithmeticOperator,
        LogicOp: eoe.logicOperator,
        BitOp: eoe.bitwiseOperator,
        CompareOp: eoe.compareOperator,
        RegExp: eoe.regexp,
        Equals: eoe.definitionOperator,
        Arrow: eoe.function(eoe.punctuation),
        ": Spread": eoe.punctuation,
        "( )": eoe.paren,
        "[ ]": eoe.squareBracket,
        "{ }": eoe.brace,
        "InterpolationStart InterpolationEnd": eoe.special(eoe.brace),
        ".": eoe.derefOperator,
        ", ;": eoe.separator,
        "@": eoe.meta,
        TypeName: eoe.typeName,
        TypeDefinition: eoe.definition(eoe.typeName),
        "type enum interface implements namespace module declare": eoe.definitionKeyword,
        "abstract global Privacy readonly override": eoe.modifier,
        "is keyof unique infer": eoe.operatorKeyword,
        JSXAttributeValue: eoe.attributeValue,
        JSXText: eoe.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": eoe.angleBracket,
        "JSXIdentifier JSXNameSpacedName": eoe.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": eoe.attributeName,
        "JSXBuiltin/JSXIdentifier": eoe.standard(eoe.tagName),
      }),
      Rce = {
        __proto__: null,
        export: 20,
        as: 25,
        from: 33,
        default: 36,
        async: 41,
        function: 42,
        extends: 54,
        this: 58,
        true: 66,
        false: 66,
        null: 78,
        void: 82,
        typeof: 86,
        super: 102,
        new: 136,
        delete: 148,
        yield: 157,
        await: 161,
        class: 166,
        public: 229,
        private: 229,
        protected: 229,
        readonly: 231,
        instanceof: 250,
        satisfies: 253,
        in: 254,
        const: 256,
        import: 290,
        keyof: 345,
        unique: 349,
        infer: 355,
        is: 391,
        abstract: 411,
        implements: 413,
        type: 415,
        let: 418,
        var: 420,
        using: 423,
        interface: 429,
        enum: 433,
        namespace: 439,
        module: 441,
        declare: 445,
        global: 449,
        for: 468,
        of: 477,
        while: 480,
        with: 484,
        do: 488,
        if: 492,
        else: 494,
        switch: 498,
        case: 504,
        try: 510,
        catch: 514,
        finally: 518,
        return: 522,
        throw: 526,
        break: 530,
        continue: 534,
        debugger: 538,
      },
      Nce = {
        __proto__: null,
        async: 123,
        get: 125,
        set: 127,
        declare: 189,
        public: 191,
        private: 191,
        protected: 191,
        static: 193,
        abstract: 195,
        override: 197,
        readonly: 203,
        accessor: 205,
        new: 395,
      },
      $ce = { __proto__: null, "<": 187 },
      Ice = yle.deserialize({
        version: 14,
        states:
          "$@QO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#CiO+RO!bO'#CjO+aO#tO'#CjO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DwO0fQ^O'#EPOOQ?Mr'#EX'#EXO1PQWO'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQWO'#GpO1dQWO'#ElO1iQWO'#ElO3hQ?NdO'#JmO6[Q?NdO'#JnO6uQWO'#F[O6zQ&jO'#FsOOQ?Mr'#Fe'#FeO7VO,YO'#FeO7eQ7[O'#FzO9RQWO'#FyOOQ?Mr'#Jn'#JnOOQ?Mp'#Jm'#JmO9WQWO'#GtOOQU'#KZ'#KZO9cQWO'#IUO9hQ?MxO'#IVOOQU'#JZ'#JZOOQU'#IZ'#IZQ`Q^OOO`Q^OOO9pQMnO'#DsO9wQ^O'#D{O:OQ^O'#D}O9^QWO'#GpO:VQ7[O'#CoO:eQWO'#EkO:pQWO'#EvO:uQ7[O'#FdO;dQWO'#GpOOQO'#K['#K[O;iQWO'#K[O;wQWO'#GxO;wQWO'#GyO;wQWO'#G{O9^QWO'#HOO<nQWO'#HRO>VQWO'#CeO>gQWO'#H_O>oQWO'#HeO>oQWO'#HgO`Q^O'#HiO>oQWO'#HkO>oQWO'#HnO>tQWO'#HtO>yQ?MyO'#HzO%[Q^O'#H|O?UQ?MyO'#IOO?aQ?MyO'#IQO9hQ?MxO'#ISO?lQ?NdO'#CiO@nQ`O'#DiQOQWOOO%[Q^O'#D}OAUQWO'#EQO:VQ7[O'#EkOAaQWO'#EkOAlQpO'#FdOOQU'#Cg'#CgOOQ?Mp'#Dn'#DnOOQ?Mp'#Jq'#JqO%[Q^O'#JqOOQO'#Jt'#JtOOQO'#Id'#IdOBlQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Jx'#JxOChQ?NQO'#EdOCrQ`O'#ETOOQO'#Js'#JsODWQ`O'#JtOEeQ`O'#ETOCrQ`O'#EdPErO#@ItO'#CbPOOO)CDx)CDxOOOO'#I['#I[OE}O!bO,59UOOQ?Mr,59U,59UOOOO'#I]'#I]OF]O#tO,59UO%[Q^O'#D`OOOO'#I_'#I_OFkO!0LbO,59xOOQ?Mr,59x,59xOFyQ^O'#I`OG^QWO'#JoOI]QrO'#JoO+}Q^O'#JoOIdQWO,5:OOIzQWO'#EmOJXQWO'#KOOJdQWO'#J}OJdQWO'#J}OJlQWO,5;ZOJqQWO'#J|OOQ?Mv,5:Z,5:ZOJxQ^O,5:ZOLvQ?NdO,5:cOMgQWO,5:kONQQ?MxO'#J{ONXQWO'#JzO9WQWO'#JzONmQWO'#JzONuQWO,5;YONzQWO'#JzO!#PQrO'#JnOOQ?Mr'#Ci'#CiO%[Q^O'#EPO!#oQrO,5:pOOQQ'#Ju'#JuOOQO-E<f-E<fO9^QWO,5=[O!$VQWO,5=[O!$[Q^O,5;WO!&_Q7[O'#EhO!'xQWO,5;WO!'}Q^O'#DvO!(XQ`O,5;aO!(aQ`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!(oQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yOOQ?Mr,5;{,5;{O%[Q^O'#IlO!*rQ?MxO,5<gO%[Q^O,5;bO!&_Q7[O,5;bO!+aQ7[O,5;bO!-RQ7[O'#EZO%[Q^O,5;vOOQ?Mr,5;z,5;zO!-YQ&jO'#FiO!.VQ&jO'#KSO!-qQ&jO'#KSO!.^Q&jO'#KSOOQO'#KS'#KSO!.rQ&jO,5<ROOOS,5<_,5<_O!/TQ^O'#FuOOOS'#Ik'#IkO7VO,YO,5<PO!/[Q&jO'#FwOOQ?Mr,5<P,5<PO!/{Q!LQO'#CvOOQ?Mr'#Cz'#CzO!0`O!0LbO'#DOO!0|Q7[O,5<dO!1TQWO,5<fO!2pQ$ISO'#GVO!2}QWO'#GWO!3SQWO'#GWO!4rQ$ISO'#G[O!5nQ`O'#G`OOQO'#Gk'#GkO!+hQ7[O'#GjOOQO'#Gm'#GmO!+hQ7[O'#GlO!6aQ!LQO'#JgOOQ?Mr'#Jg'#JgO!6kQWO'#JfO!6yQWO'#JeO!7RQWO'#CuOOQ?Mr'#Cx'#CxO!7ZQWO'#CzOOQ?Mr'#DS'#DSOOQ?Mr'#DU'#DUO1SQWO'#DWO!+hQ7[O'#F}O!+hQ7[O'#GPO!7`QWO'#GRO!7eQWO'#GSO!3SQWO'#GYO!+hQ7[O'#G_O!7jQWO'#EnO!8XQWO,5<eOOQ?Mp'#Cr'#CrO!8aQWO'#EoO!9ZQ`O'#EpOOQ?Mp'#J|'#J|O!9bQ?MxO'#K]O9hQ?MxO,5=`O`Q^O,5>pOOQU'#Jc'#JcOOQU,5>q,5>qOOQU-E<X-E<XO!;aQ?NdO,5:_O!9UQ`O,5:]O!=zQ?NdO,5:gO%[Q^O,5:gO!@bQ?NdO,5:iOOQO,5@v,5@vO!ARQ7[O,5=[O!AaQ?MxO'#JdO9RQWO'#JdO!ArQ?MxO,59ZO!A}Q`O,59ZO!BVQ7[O,59ZO:VQ7[O,59ZO!BbQWO,5;WO!BjQWO'#H^O!COQWO'#K`O%[Q^O,5;|O!9UQ`O,5<OO!CWQWO,5=wO!C]QWO,5=wO!CbQWO,5=wO9hQ?MxO,5=wO;wQWO,5=gOOQO'#Cv'#CvO!CpQ`O,5=dO!CxQ7[O,5=eO!DTQWO,5=gO!DYQpO,5=jO!DbQWO'#K[O>tQWO'#HTO9^QWO'#HVO!DgQWO'#HVO:VQ7[O'#HXO!DlQWO'#HXOOQU,5=m,5=mO!DqQWO'#HYO!ESQWO'#CoO!EXQWO,59PO!EcQWO,59PO!GhQ^O,59POOQU,59P,59PO!GxQ?MxO,59PO%[Q^O,59PO!JTQ^O'#HaOOQU'#Hb'#HbOOQU'#Hc'#HcO`Q^O,5=yO!JkQWO,5=yO`Q^O,5>PO`Q^O,5>RO!JpQWO,5>TO`Q^O,5>VO!JuQWO,5>YO!JzQ^O,5>`OOQU,5>f,5>fO%[Q^O,5>fO9hQ?MxO,5>hOOQU,5>j,5>jO# UQWO,5>jOOQU,5>l,5>lO# UQWO,5>lOOQU,5>n,5>nO# rQ`O'#D[O%[Q^O'#JqO# |Q`O'#JqO#!kQ`O'#DjO#!|Q`O'#DjO#%_Q^O'#DjO#%fQWO'#JpO#%nQWO,5:TO#%sQWO'#EqO#&RQWO'#KPO#&ZQWO,5;[O#&`Q`O'#DjO#&mQ`O'#ESOOQ?Mr,5:l,5:lO%[Q^O,5:lO#&tQWO,5:lO>tQWO,5;VO!A}Q`O,5;VO!BVQ7[O,5;VO:VQ7[O,5;VO#&|QWO,5@]O#'RQ(CYO,5:pOOQO-E<b-E<bO#(XQ?NQO,5;OOCrQ`O,5:oO#(cQ`O,5:oOCrQ`O,5;OO!ArQ?MxO,5:oOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#(pQ?MxO,5;OO#({Q?MxO,5;OO!A}Q`O,5:oOOQO,5;U,5;UO#)ZQ?MxO,5;OPOOO'#IY'#IYP#)oO#@ItO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ?Mr1G.p1G.pOOOO-E<Z-E<ZO#)zQpO,59zOOOO-E<]-E<]OOQ?Mr1G/d1G/dO#*PQrO,5>zO+}Q^O,5>zOOQO,5?Q,5?QO#*ZQ^O'#I`OOQO-E<^-E<^O#*hQWO,5@ZO#*pQrO,5@ZO#*wQWO,5@iOOQ?Mr1G/j1G/jO%[Q^O,5@jO#+PQWO'#IfOOQO-E<d-E<dO#*wQWO,5@iOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0V1G0VO%[Q^O,5@gO#+eQ?MxO,5@gO#+vQ?MxO,5@gO#+}QWO,5@fO9WQWO,5@fO#,VQWO,5@fO#,eQWO'#IiO#+}QWO,5@fOOQ?Mp1G0t1G0tO!(XQ`O,5:rO!(dQ`O,5:rOOQQ,5:t,5:tO#-VQYO,5:tO#-_Q7[O1G2vO9^QWO1G2vOOQ?Mr1G0r1G0rO#-mQ?NdO1G0rO#.rQ?NbO,5;SOOQ?Mr'#GU'#GUO#/`Q?NdO'#JgO!$[Q^O1G0rO#1hQrO'#JrO%[Q^O'#JrO#1rQWO,5:bOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#1wQWO1G0{O#4]Q?NdO1G0|O#4dQ?NdO1G0|O#6zQ?NdO1G0|O#7RQ?NdO1G0|O#9iQ?NdO1G0|O#<PQ?NdO1G0|O#<WQ?NdO1G0|O#<_Q?NdO1G0|O#>uQ?NdO1G0|O#>|Q?NdO1G0|O#AZQ07bO'#CiO#CUQ07bO1G1_O#C]Q07bO'#JnO#CpQ?NdO,5?WOOQ?Mp-E<j-E<jO#E}Q?NdO1G0|O#FzQ?NdO1G0|OOQ?Mr1G0|1G0|O#GzQ7[O'#JwO#HUQWO,5:uO#HZQ?NdO1G1bO#H}Q&jO,5<VO#IVQ&jO,5<WO#I_Q&jO'#FnO#IvQWO'#FmOOQO'#KT'#KTOOQO'#Ij'#IjO#I{Q&jO1G1mOOQ?Mr1G1m1G1mOOOS1G1x1G1xO#J^Q07bO'#JmO#JhQWO,5<aO!(oQ^O,5<aOOOS-E<i-E<iOOQ?Mr1G1k1G1kO#JmQ`O'#KSOOQ?Mr,5<c,5<cO#JuQ`O,5<cO!&_Q7[O'#DQOOOO'#I^'#I^O#JzO!0LbO,59jOOQ?Mr,59j,59jO%[Q^O1G2OO!7eQWO'#InO#KVQ7[O,5<xOOQ?Mr,5<u,5<uO!+hQ7[O'#IqO#KuQ7[O,5=UO!+hQ7[O'#IsO#LhQ7[O,5=WO!&_Q7[O,5=YOOQO1G2Q1G2QO#LrQpO'#CrO#MVQ$ISO'#EoO#NUQ`O'#G`O#NrQpO,5<qO#NyQWO'#KWO9WQWO'#KWO$ XQWO,5<sO!+hQ7[O,5<rO$ ^QWO'#GXO$ oQWO,5<rO$ tQpO'#GUO$!RQpO'#KXO$!]QWO'#KXO!&_Q7[O'#KXO$!bQWO,5<vO$!gQ`O'#GaO!5iQ`O'#GaO$!xQWO'#GcO$!}QWO'#GeO!3SQWO'#GhO$#SQ?MxO'#IpO$#_Q`O,5<zOOQ?Mv,5<z,5<zO$#fQ`O'#GaO$#tQ`O'#GbO$#|Q`O'#GbO$$RQ7[O,5=UO$$cQ7[O,5=WOOQ?Mr,5=Z,5=ZO!+hQ7[O,5@QO!+hQ7[O,5@QO$$sQWO'#IuO$%OQWO,5@PO$%WQWO,59aOOQ?Mr,59f,59fO$%zQ!LSO,59rOOQ?Mr'#Jk'#JkO$&mQ7[O,5<iO$'`Q7[O,5<kO@fQWO,5<mOOQ?Mr,5<n,5<nO$'jQWO,5<tO$'oQ7[O,5<yO$(PQWO'#JzO!$[Q^O1G2PO$(UQWO1G2PO9WQWO'#J}O9WQWO'#EqO%[Q^O'#EqO9WQWO'#IwO$(ZQ?MxO,5@wOOQU1G2z1G2zOOQU1G4[1G4[OOQ?Mr1G/y1G/yOOQ?Mr1G/w1G/wO$*]Q?NdO1G0ROOQU1G2v1G2vO!&_Q7[O1G2vO%[Q^O1G2vO#-bQWO1G2vO$,aQ7[O'#EhOOQ?Mp,5@O,5@OO$,kQ?MxO,5@OOOQU1G.u1G.uO!ArQ?MxO1G.uO!A}Q`O1G.uO!BVQ7[O1G.uO$,|QWO1G0rO$-RQWO'#CiO$-^QWO'#KaO$-fQWO,5=xO$-kQWO'#KaO$-pQWO'#KaO$.OQWO'#I}O$.^QWO,5@zO$.fQrO1G1hOOQ?Mr1G1j1G1jO9^QWO1G3cO@fQWO1G3cO$.mQWO1G3cO$.rQWO1G3cOOQU1G3c1G3cO!DTQWO1G3RO!&_Q7[O1G3OO$.wQWO1G3OOOQU1G3P1G3PO!&_Q7[O1G3PO$.|QWO1G3PO$/UQ`O'#G}OOQU1G3R1G3RO!5iQ`O'#IyO!DYQpO1G3UOOQU1G3U1G3UOOQU,5=o,5=oO$/^Q7[O,5=qO9^QWO,5=qO$!}QWO,5=sO9RQWO,5=sO!A}Q`O,5=sO!BVQ7[O,5=sO:VQ7[O,5=sO$/lQWO'#K_O$/wQWO,5=tOOQU1G.k1G.kO$/|Q?MxO1G.kO@fQWO1G.kO$0XQWO1G.kO9hQ?MxO1G.kO$2aQrO,5@|O$2nQWO,5@|O9WQWO,5@|O$2yQ^O,5={O$3QQWO,5={OOQU1G3e1G3eO`Q^O1G3eOOQU1G3k1G3kOOQU1G3m1G3mO>oQWO1G3oO$3VQ^O1G3qO$7ZQ^O'#HpOOQU1G3t1G3tO$7hQWO'#HvO>tQWO'#HxOOQU1G3z1G3zO$7pQ^O1G3zO9hQ?MxO1G4QOOQU1G4S1G4SOOQ?Mp'#G]'#G]O9hQ?MxO1G4UO9hQ?MxO1G4WO$;wQWO,5@]O!(oQ^O,5;]O9WQWO,5;]O>tQWO,5:UO!(oQ^O,5:UO!A}Q`O,5:UO$;|Q07bO,5:UOOQO,5;],5;]O$<WQ`O'#IaO$<nQWO,5@[OOQ?Mr1G/o1G/oO$<vQ`O'#IgO$=QQWO,5@kOOQ?Mp1G0v1G0vO#!|Q`O,5:UOOQO'#Ic'#IcO$=YQ`O,5:nOOQ?Mv,5:n,5:nO#&wQWO1G0WOOQ?Mr1G0W1G0WO%[Q^O1G0WOOQ?Mr1G0q1G0qO>tQWO1G0qO!A}Q`O1G0qO!BVQ7[O1G0qOOQ?Mp1G5w1G5wO!ArQ?MxO1G0ZOOQO1G0j1G0jO%[Q^O1G0jO$=aQ?MxO1G0jO$=lQ?MxO1G0jO!A}Q`O1G0ZOCrQ`O1G0ZO$=zQ?MxO1G0jOOQO1G0Z1G0ZO$>`Q?NdO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$>jQpO,5<gO$>rQrO1G4fOOQO1G4l1G4lO%[Q^O,5>zO$>|QWO1G5uO$?UQWO1G6TO$?^QrO1G6UO9WQWO,5?QO$?hQ?NdO1G6RO%[Q^O1G6RO$?xQ?MxO1G6RO$@ZQWO1G6QO$@ZQWO1G6QO9WQWO1G6QO$@cQWO,5?TO9WQWO,5?TOOQO,5?T,5?TO$@wQWO,5?TO$(PQWO,5?TOOQO-E<g-E<gOOQQ1G0^1G0^OOQQ1G0`1G0`O#-YQWO1G0`OOQU7+(b7+(bO!&_Q7[O7+(bO%[Q^O7+(bO$AVQWO7+(bO$AbQ7[O7+(bO$ApQ?NdO,5=UO$CxQ?NdO,5=WO$FQQ?NdO,5=UO$H`Q?NdO,5=WO$JnQ?NdO,59rO$LsQ?NdO,5<iO$N{Q?NdO,5<kO%#TQ?NdO,5<yOOQ?Mr7+&^7+&^O%%cQ?NdO7+&^O%&VQ^O'#IbO%&dQWO,5@^O%&lQrO,5@^OOQ?Mr1G/|1G/|O%&vQWO7+&gOOQ?Mr7+&g7+&gO%&{Q07bO,5:cO%[Q^O7+&yO%'VQ07bO,5:_O%'dQ07bO,5:gO%'nQ07bO,5:iO%'xQ7[O'#IeO%(SQWO,5@cOOQ?Mr1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%([QtO,5<YO!(oQ^O,5<XOOQO-E<h-E<hOOQ?Mr7+'X7+'XOOOS7+'d7+'dOOOS1G1{1G1{O%(gQWO1G1{OOQ?Mr1G1}1G1}O%(lQpO,59lOOOO-E<[-E<[OOQ?Mr1G/U1G/UO%(sQ?NdO7+'jOOQ?Mr,5?Y,5?YO%)gQpO,5?YOOQ?Mr1G2d1G2dP!&_Q7[O'#InPOQ?Mr-E<l-E<lO%*VQ7[O,5?]OOQ?Mr-E<o-E<oO%*xQ7[O,5?_OOQ?Mr-E<q-E<qO%+SQpO1G2tO%+ZQpO'#CrO%+qQ7[O'#J}O%+xQ^O'#EqOOQ?Mr1G2]1G2]O%,SQWO'#ImO%,hQWO,5@rO%,hQWO,5@rO%,pQWO,5@rO%,{QWO,5@rOOQO1G2_1G2_O%-ZQ7[O1G2^O!+hQ7[O1G2^O%-kQ$ISO'#IoO%-xQWO,5@sO!&_Q7[O,5@sO%.QQpO,5@sOOQ?Mr1G2b1G2bOOQ?Mp,5<{,5<{OOQ?Mp,5<|,5<|O$(PQWO,5<|OCcQWO,5<|O!A}Q`O,5<{OOQO'#Gd'#GdO%.[QWO,5<}OOQ?Mp,5=P,5=PO$(PQWO,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ?Mv1G2f1G2fO!5iQ`O,5<{O%.dQWO,5<|O$!xQWO,5<}O%.oQ`O,5<|O!+hQ7[O'#IqO%/`Q7[O1G2pO!+hQ7[O'#IsO%0RQ7[O1G2rO%0]Q7[O1G5lO%0gQ7[O1G5lOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9UQ`O,59tO%[Q^O,59tOOQ?Mr,5<h,5<hO%0tQWO1G2XO!+hQ7[O1G2`O%0yQ?NdO7+'kOOQ?Mr7+'k7+'kO!$[Q^O7+'kO%1mQWO,5;]OOQ?Mp,5?c,5?cOOQ?Mp-E<u-E<uO%1rQpO'#KYO#&wQWO7+(bO4UQrO7+(bO$AYQWO7+(bO%1|Q?NbO'#CiO%2aQ?NbO,5=QO%3RQWO,5=QOOQ?Mp1G5j1G5jOOQU7+$a7+$aO!ArQ?MxO7+$aO!A}Q`O7+$aO!$[Q^O7+&^O%3WQWO'#I|O%3oQWO,5@{OOQO1G3d1G3dO9^QWO,5@{O%3oQWO,5@{O%3wQWO,5@{OOQO,5?i,5?iOOQO-E<{-E<{OOQ?Mr7+'S7+'SO%3|QWO7+(}O9hQ?MxO7+(}O9^QWO7+(}O@fQWO7+(}OOQU7+(m7+(mO%4RQ?NbO7+(jO!&_Q7[O7+(jO%4]QpO7+(kOOQU7+(k7+(kO!&_Q7[O7+(kO%4dQWO'#K^O%4oQWO,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQU7+(p7+(pO%6RQ`O'#HWOOQU1G3]1G3]O!&_Q7[O1G3]O%[Q^O1G3]O%6YQWO1G3]O%6eQ7[O1G3]O9hQ?MxO1G3_O$!}QWO1G3_O9RQWO1G3_O!A}Q`O1G3_O!BVQ7[O1G3_O%6sQWO'#I{O%7XQWO,5@yO%7aQ`O,5@yOOQ?Mp1G3`1G3`OOQU7+$V7+$VO@fQWO7+$VO9hQ?MxO7+$VO%7lQWO7+$VO%[Q^O1G6hO%[Q^O1G6iO%7qQ?MxO1G6hO%7{Q^O1G3gO%8SQWO1G3gO%8XQ^O1G3gOOQU7+)P7+)PO9hQ?MxO7+)ZO`Q^O7+)]OOQU'#Kd'#KdOOQU'#JO'#JOO%8`Q^O,5>[OOQU,5>[,5>[O%[Q^O'#HqO%8mQWO'#HsOOQU,5>b,5>bO9WQWO,5>bOOQU,5>d,5>dOOQU7+)f7+)fOOQU7+)l7+)lOOQU7+)p7+)pOOQU7+)r7+)rO%8rQ`O1G5wO%9WQ07bO1G0wO%9bQWO1G0wOOQO1G/p1G/pO%9mQ07bO1G/pO>tQWO1G/pO!(oQ^O'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!A}Q`O1G/pOOQO-E<a-E<aOOQ?Mv1G0Y1G0YOOQ?Mr7+%r7+%rO#&wQWO7+%rOOQ?Mr7+&]7+&]O>tQWO7+&]O!A}Q`O7+&]OOQO7+%u7+%uO$>`Q?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%9wQ?MxO7+&UO!ArQ?MxO7+%uO!A}Q`O7+%uO%:SQ?MxO7+&UO%:bQ?NdO7++mO%[Q^O7++mO%:rQWO7++lO%:rQWO7++lOOQO1G4o1G4oO9WQWO1G4oO%:zQWO1G4oOOQQ7+%z7+%zO#&wQWO<<K|O4UQrO<<K|O%;YQWO<<K|OOQU<<K|<<K|O!&_Q7[O<<K|O%[Q^O<<K|O%;bQWO<<K|O%;mQ?NdO,5?]O%=uQ?NdO,5?_O%?}Q?NdO1G2^O%B]Q?NdO1G2pO%DeQ?NdO1G2rO%FmQrO,5>|O%[Q^O,5>|OOQO-E<`-E<`O%FwQWO1G5xOOQ?Mr<<JR<<JRO%GPQ07bO1G0rO%IWQ07bO1G0|O%I_Q07bO1G0|O%K`Q07bO1G0|O%KgQ07bO1G0|O%MhQ07bO1G0|O& iQ07bO1G0|O& pQ07bO1G0|O& wQ07bO1G0|O&#xQ07bO1G0|O&$PQ07bO1G0|O&$WQ?NdO<<JeO&&OQ07bO1G0|O&&{Q07bO1G0|O&'{Q07bO'#JgO&*OQ07bO1G1bO&*]Q07bO1G0RO&*gQ7[O,5?POOQO-E<c-E<cO!(oQ^O'#FpOOQO'#KU'#KUOOQO1G1t1G1tO&*qQWO1G1sO&*vQ07bO,5?WOOOS7+'g7+'gOOOO1G/W1G/WOOQ?Mr1G4t1G4tO!+hQ7[O7+(`O&-WQrO'#CiO&-bQWO,5?XO9WQWO,5?XOOQO-E<k-E<kO&-pQWO1G6^O&-pQWO1G6^O&-xQWO1G6^O&.TQ7[O7+'xO&.eQpO,5?ZO&.oQWO,5?ZO!&_Q7[O,5?ZOOQO-E<m-E<mO&.tQpO1G6_O&/OQWO1G6_OOQ?Mp1G2h1G2hO$(PQWO1G2hOOQ?Mp1G2g1G2gO&/WQWO1G2iO!&_Q7[O1G2iOOQ?Mp1G2n1G2nO!A}Q`O1G2gOCcQWO1G2hO&/]QWO1G2iO&/eQWO1G2hO$!xQWO1G2iO&0XQ7[O,5?]OOQ?Mr-E<p-E<pO&0zQ7[O,5?_OOQ?Mr-E<r-E<rO!+hQ7[O7++WOOQ?Mr1G/`1G/`O&1UQWO1G/`OOQ?Mr7+'s7+'sO&1ZQ7[O7+'zO&1kQ?NdO<<KVOOQ?Mr<<KV<<KVO&2_QWO1G0wO!&_Q7[O'#IvO&2dQWO,5@tO&4fQrO<<K|O!&_Q7[O1G2lOOQU<<G{<<G{O!ArQ?MxO<<G{O&4mQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?h,5?hO&5aQWO,5?hO&5fQWO,5?hOOQO-E<z-E<zO&5tQWO1G6gO&5tQWO1G6gO9^QWO1G6gO@fQWO<<LiOOQU<<Li<<LiO&5|QWO<<LiO9hQ?MxO<<LiOOQU<<LU<<LUO%4RQ?NbO<<LUOOQU<<LV<<LVO%4]QpO<<LVO&6RQ`O'#IxO&6^QWO,5@xO!(oQ^O,5@xOOQU1G3T1G3TO%+xQ^O'#JqOOQO'#Iz'#IzO9hQ?MxO'#IzO&6fQ`O,5=rOOQU,5=r,5=rO&6mQ`O'#EdO&7RQ`O'#GcO&7WQWO7+(wO&7]QWO7+(wOOQU7+(w7+(wO!&_Q7[O7+(wO%[Q^O7+(wO&7eQWO7+(wOOQU7+(y7+(yO9hQ?MxO7+(yO$!}QWO7+(yO9RQWO7+(yO!A}Q`O7+(yO&7pQWO,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&7{QWO1G6eO9hQ?MxO<<GqOOQU<<Gq<<GqO@fQWO<<GqO&8TQWO7+,SO&8YQWO7+,TO%[Q^O7+,SO%[Q^O7+,TOOQU7+)R7+)RO&8_QWO7+)RO&8dQ^O7+)RO&8kQWO7+)ROOQU<<Lu<<LuOOQU<<Lw<<LwOOQU-E<|-E<|OOQU1G3v1G3vO&8pQWO,5>]OOQU,5>_,5>_O&8uQWO1G3|O9WQWO7+&cO!(oQ^O7+&cOOQO7+%[7+%[O&8zQ07bO1G6UO>tQWO7+%[OOQ?Mr<<I^<<I^OOQ?Mr<<Iw<<IwO>tQWO<<IwOOQO<<Ip<<IpO$>`Q?NdO<<IpO%[Q^O<<IpOOQO<<Ia<<IaO!ArQ?MxO<<IaO&9UQ?MxO<<IpO&9aQ?NdO<= XO&9qQWO<= WOOQO7+*Z7+*ZO9WQWO7+*ZOOQUANAhANAhO&9yQrOANAhO!&_Q7[OANAhO#&wQWOANAhO4UQrOANAhO&:QQWOANAhO%[Q^OANAhO&:YQ?NdO7+'xO&<hQ?NdO,5?]O&>pQ?NdO,5?_O&@xQ?NdO7+'zO&CWQrO1G4hO&CbQ07bO7+&^O&EcQ07bO,5=UO&GgQ07bO,5=WO&GwQ07bO,5=UO&HXQ07bO,5=WO&HiQ07bO,59rO&JlQ07bO,5<iO&LlQ07bO,5<kO&N}Q07bO,5<yO'!pQ07bO7+'jO'!}Q07bO7+'kO'#[QWO,5<[OOQO7+'_7+'_O'#aQ7[O<<KzOOQO1G4s1G4sO'#hQWO1G4sO'#sQWO1G4sO'$RQWO7++xO'$RQWO7++xO!&_Q7[O1G4uO'$ZQpO1G4uO'$eQWO7++yOOQ?Mp7+(S7+(SO'$mQWO7+(TO'$xQpO7+(TOOQ?Mp7+(R7+(RO$(PQWO7+(SO'%PQWO7+(TO!&_Q7[O7+(TOCcQWO7+(SO'%UQWO7+(TO'%^Q7[O<<NrOOQ?Mr7+$z7+$zO'%hQpO,5?bOOQO-E<t-E<tO'%rQ?NbO7+(WOOQUAN=gAN=gO9^QWO1G5SOOQO1G5S1G5SO'&SQWO1G5SO'&XQWO7+,RO'&XQWO7+,RO9hQ?MxOANBTO@fQWOANBTOOQUANBTANBTOOQUANApANApOOQUANAqANAqO'&aQWO,5?dOOQO-E<v-E<vO'&lQ07bO1G6dOOQO,5?f,5?fOOQO-E<x-E<xOOQU1G3^1G3^O%+xQ^O,5<}O'&vQWO,5<}OOQU<<Lc<<LcO!&_Q7[O<<LcO&7WQWO<<LcO'&{QWO<<LcO%[Q^O<<LcOOQU<<Le<<LeO9hQ?MxO<<LeO$!}QWO<<LeO9RQWO<<LeO''TQ`O1G5RO''`QWO7+,POOQUAN=]AN=]O9hQ?MxOAN=]OOQU<= n<= nOOQU<= o<= oO''hQWO<= nO''mQWO<= oOOQU<<Lm<<LmO''rQWO<<LmO''wQ^O<<LmOOQU1G3w1G3wO>tQWO7+)hO'(OQWO<<I}O'(ZQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$>`Q?NdOAN?[OOQOAN>{AN>{O%[Q^OAN?[OOQO<<Mu<<MuOOQUG27SG27SO!&_Q7[OG27SO#&wQWOG27SO'(eQrOG27SO4UQrOG27SO'(lQWOG27SO'(tQ07bO<<JeO')RQ07bO1G2^O'*tQ07bO,5?]O',tQ07bO,5?_O'.tQ07bO1G2pO'0tQ07bO1G2rO'2tQ07bO<<KVO'3RQ07bO<<IxOOQO1G1v1G1vO!+hQ7[OANAfOOQO7+*_7+*_O'3`QWO7+*_O'3kQWO<= dO'3sQpO7+*aOOQ?Mp<<Ko<<KoO$(PQWO<<KoOCcQWO<<KoO'3}QWO<<KoOOQ?Mp<<Kn<<KnO'4YQpO<<KoO$(PQWO<<KnO'4aQWO<<KoO!&_Q7[O<<KoOOQO7+*n7+*nO9^QWO7+*nO'4fQWO<= mOOQUG27oG27oO9hQ?MxOG27oO!(oQ^O1G5OO'4nQWO7+,OO&7WQWOANA}OOQUANA}ANA}O!&_Q7[OANA}O'4vQWOANA}OOQUANBPANBPO9hQ?MxOANBPO$!}QWOANBPOOQO'#H['#H[OOQO7+*m7+*mOOQUG22wG22wOOQUANEYANEYOOQUANEZANEZOOQUANBXANBXO'5OQWOANBXOOQU<<MS<<MSO!(oQ^OAN?iOOQOG24vG24vO$>`Q?NdOG24vO#&wQWOLD,nOOQULD,nLD,nO!&_Q7[OLD,nO'5TQrOLD,nO'5[Q07bO7+'xO'6}Q07bO,5?]O'8}Q07bO,5?_O':}Q07bO7+'zO'<pQ7[OG27QOOQO<<My<<MyOOQ?MpANAZANAZO$(PQWOANAZOCcQWOANAZO'=QQWOANAZOOQ?MpANAYANAYO'=]QpOANAZOOQO<<NY<<NYOOQULD-ZLD-ZO'=dQ07bO7+*jOOQUG27iG27iO&7WQWOG27iO!&_Q7[OG27iOOQUG27kG27kO9hQ?MxOG27kOOQUG27sG27sO'=nQ07bOG25TOOQOLD*bLD*bOOQU!$(!Y!$(!YO#&wQWO!$(!YO!&_Q7[O!$(!YO'=xQ?NdOG27QOOQ?MpG26uG26uO$(PQWOG26uOCcQWOG26uO'@WQWOG26uOOQULD-TLD-TO&7WQWOLD-TOOQULD-VLD-VOOQU!)9Et!)9EtO#&wQWO!)9EtOOQ?MpLD,aLD,aO$(PQWOLD,aOCcQWOLD,aOOQU!$(!o!$(!oOOQU!.K;`!.K;`O'@cQ07bOG27QOOQ?Mp!$( {!$( {O$(PQWO!$( {OOQ?Mp!)9Eg!)9EgO!(oQ^O'#DwO1PQWO'#EUO'BUQrO'#JmO'B]QMnO'#DsO'BdQ^O'#D{O'BkQrO'#CiO'ERQrO'#CiO!(oQ^O'#D}O'EcQ^O,5;WO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O'#IlO'GfQWO,5<gO!(oQ^O,5;bO'GnQ7[O,5;bO'IXQ7[O,5;bO!(oQ^O,5;vO!&_Q7[O'#GjO'GnQ7[O'#GjO!&_Q7[O'#GlO'GnQ7[O'#GlO1SQWO'#DWO1SQWO'#DWO!&_Q7[O'#F}O'GnQ7[O'#F}O!&_Q7[O'#GPO'GnQ7[O'#GPO!&_Q7[O'#G_O'GnQ7[O'#G_O!(oQ^O,5:gO'I`Q`O'#D[O!(oQ^O,5@jO'EcQ^O1G0rO'IjQ07bO'#CiO!(oQ^O1G2OO!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO'ItQpO'#CrO!&_Q7[O,5<rO'GnQ7[O,5<rO'EcQ^O1G2PO!(oQ^O7+&yO!&_Q7[O1G2^O'GnQ7[O1G2^O!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO!&_Q7[O1G2`O'GnQ7[O1G2`O'EcQ^O7+'kO'EcQ^O7+&^O!&_Q7[OANAfO'GnQ7[OANAfO'JXQWO'#ElO'J^QWO'#ElO'JfQWO'#F[O'JkQWO'#EvO'JpQWO'#KOO'J{QWO'#J|O'KWQWO,5;WO'K]Q7[O,5<dO'KdQWO'#GWO'KiQWO'#GWO'KnQWO,5<eO'KvQWO,5;WO'LOQ07bO1G1_O'LVQWO,5<rO'L[QWO,5<rO'LaQWO,5<tO'LfQWO,5<tO'LkQWO1G2PO'LpQWO1G0rO'LuQ7[O<<KzO'L|Q7[O<<KzO7eQ7[O'#FzO9RQWO'#FyOAaQWO'#EkO!(oQ^O,5;sO!3SQWO'#GWO!3SQWO'#GWO!3SQWO'#GYO!3SQWO'#GYO!+hQ7[O7+(`O!+hQ7[O7+(`O%+SQpO1G2tO%+SQpO1G2tO!&_Q7[O,5=YO!&_Q7[O,5=Y",
        stateData:
          "'NQ~O'wOS'xOSTOS'yRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(OSO(QTO(TUO([VO(j[O(yiO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O'y!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'u]X([]X(m]X(t]X(u]X~O!d%PX~P(qO_!}O(Q#PO(R!}O(S#PO~O_#QO(S#PO(T#PO(U#QO~Ou#SO!R#TO(]#TO(^#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O;UO(QTO(TUO([VO(j[O(yiO~O!X#ZO!Y#WO!V(cP!V(qP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(QTO(TUO([VO(j[O(yiO~Om#mO!X#iO!y]O#f#lO#g#iO(O;VO!h(nP~P.iO!i#oO(O#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa(aX'u(aX's(aX!h(aX!V(aX![(aX%f(aX!d(aX~P1qO#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX![(bX%f(bX~Oa(bX'u(bX's(bX!V(bX!h(bXs(bX!d(bX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O$sO(QTO(TUO([$uO(t$}O(u%POg(XP~O!i%cO~O!P%fO![%gO(O%eO~O!d%kO~Oa%lO'u%lO~O}%pO~P%[O(P!lO~P%[O%k%tO~P%[Oh%VO!i%cO(O%eO(P!lO~Oe%{O!i%cO(O%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(O%eO(P!lO(QTO(TUO`)SP~O!u#sO~O%p&VO!P)OX![)OX(O)OX~O(O&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(P!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'u%lO~Oa%lO't&{O'u%lO~Oa%lO't&}O'u%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(P!lO(QTO(TUO~Op'RO!P'QO!X'UO(`'PO!Z(dP!Z(sP~P@YOk'_O![']O(O%eO~Oe'dO!i%cO(O%eO~O}&QO!i&PO~Op!nO!P!oO!y;QO#Q!pO#R!pO#T!pO#U!pO(P!lO(QTO(TUO(`!mO(j!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'u%lO(m'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(QTO(TUO(`!mO(j!sO~O![XOp(hX!P(hX!_(hX!`(hX!a(hX!y(hX#Q(hX#R(hX#S(hX#T(hX#U(hX#X(hX#Y(hX(P(hX(Q(hX(T(hX(`(hX(j(hX~O!`'iO!a'iO(P!lO~PCrO'z'uO'{'uO'|'wO~O_!}O(Q'yO(R!}O(S'yO~O_#QO(S'yO(T'yO(U#QO~Ou#SO!R#TO(]#TO(^'}O~O!X(PO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(RO!V(cX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(RO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~O!V(cX~PGfO!V(WO~O!V(pX!Y(pX!d(pX!h(pX(m(pX~O#](pX#h#aX!Z(pX~PIiO#](XO!V(rX!Y(rX~O!Y(YO!V(qX~O!V(]O~O#]$eO~PIiO!Z(^O~P`OR#zO}#yO!P#{O!i#xO([VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(m!ka(t!ka(u!ka~Oa!ka'u!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKPO!h(_O~O!d#vO#](`O(m'mO!Y(oXa(oX'u(oX~O!h(oX~PMlO!P%fO![%gO!y]O#f(eO#g(dO(O%eO~O!Y(fO!h(nX~O!h(hO~O!P%fO![%gO#g(dO(O%eO~OP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O!d#vO!h(bX~P! YOR(jO}(iO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(O!xa~P!#ZO!u(nO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#h(tO~O!X(vO!h(fP~P%[O(`(xO(j[O~O!P(zO!i#xO(`(xO(j[O~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y$_Oa$oa'u$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)`O~P!&_Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~Og(kP~P!+hO})eO!d)dO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)dO![(vX$Y(vX$[(vX$^(vX$e(vX~O})eO~P!-qO})eO![(vX$Y(vX$[(vX$^(vX$e(vX~O![)gO$Y)kO$[)fO$^)fO$e)lO~O!X)oO~P!(oO$[$hO$^$gO$e)sO~Ok$xX}$xX!P$xX#P$xX(t$xX(u$xX~OgjXg$xXkjX!YjX#]jX~P!/gOu)uO(])vO(^)xO~Ok*RO})zO!P){O(t$}O(u%PO~Og)yO~P!0kOg*SO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P*UO![*VO!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~O!X*YO(O*TO!h(zP~P!1YO#h*[O~O!i*]O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O*_O(QTO(TUO([$uO(t$}O(u%PO~O!X*bO!V({P~P!3XOo*nO!P*fO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO(`!mO~O!Z*kO~P!4|O#P$dOk(ZX}(ZX!P(ZX(t(ZX(u(ZX!Y(ZX#](ZX~Og(ZX#}(ZX~P!5uOk*sO#]*rOg(YX!Y(YX~O!Y*tOg(XX~O(O&WOg(XP~Op*wO~O!i*|O~O(O(rO~Om+QO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(O%eO!h(nP~O!d#vO#h+RO~O!P%fO!X+TO!Y(YO![%gO(O%eO!V(qP~Op'XO!P+VO!X+UO(QTO(TUO(`(xO~O!Z(sP~P!8uO!Y+WOa)PX'u)PX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa!ga!Y!ga'u!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9mOR#zO}#yO!P#{O!i#xO([VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(m!oa(t!oa(u!oa~Oa!oa'u!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<TOR#zO}#yO!P#{O!i#xO([VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(m!qa(t!qa(u!qa~Oa!qa'u!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>kOh%VOk+aO![']O%f+`O~O!d+cOa(WX![(WX'u(WX!Y(WX~Oa%lO![XO'u%lO~Oh%VO!i%cO~Oh%VO!i%cO(O%eO~O!d#vO#h(tO~Ob+nO%g+oO(O+kO(QTO(TUO!Z)TP~O!Y+pO`)SX~O[+tO~O`+uO~O![%}O(O%eO(P!lO`)SP~Oh%VO#]+zO~Oh%VOk+}O![$|O~O![,PO~O},RO![XO~O%k%tO~O!u,WO~Oe,]O~Ob,^O(O#nO(QTO(TUO!Z)RP~Oe%{O~O%g!QO(O&WO~P=RO[,cO`,bO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(QTO(TUO([VO(j[O(yiO~O![!eO!r!gO$V!kO(O!dO~P!EkO`,bOa%lO'u%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa,hO!rwO#t!OO%i!OO%j!OO%k!OO~P!HTO!i&lO~O&Y,nO~O![,pO~O&k,rO&m,sOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(O&ha(Q&ha(T&ha([&ha(j&ha(y&ha!Z&ha&a&hab&ha&f&ha~O(O,xO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# ZO!d,}O#],|Oh(eX!Y#eX!Y(eX!Z#eX!Z(eX!d(eX!i(eX~Oh%VO!d-PO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(QTO(TUO(`!mO~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(QTO(TUO([VO(j[O(y<xO~O(O;zO~P##_O!Y-TO!Z(dX~O!Z-VO~O!d,}O#],|O!Y#eX!Z#eX~O!Y-WO!Z(sX~O!Z-YO~O!`-ZO!a-ZO(P!lO~P#!|O!Z-^O~P'_Ok-aO![']O~O!V-fO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(P!xa(Q!xa(T!xa(`!xa(j!xa~P!#ZO!m-kO#]-iO~PCSO!`-mO!a-mO(P!lO~PCrOa%lO#]-iO'u%lO~Oa%lO!d#vO#]-iO'u%lO~Oa%lO!d#vO!m-kO#]-iO'u%lO(m'mO~O'z'uO'{'uO'|-rO~Os-sO~O!V'Sa!Y'Sa~P!9mO!X-wO!V'SX!Y'SX~P%[O!Y(RO!V(ca~O!V(ca~PGfO!Y(YO!V(qa~O!P%fO!X-{O![%gO(O%eO!V'YX!Y'YX~O#]-}O!Y(oa!h(oaa(oa'u(oa~O!d#vO~P#+eO!Y(fO!h(na~O!P%fO![%gO#g.RO(O%eO~Om.WO!P%fO!X.TO![%gO!y]O#f.VO#g.TO(O%eO!Y']X!h']X~OR.[O!i#xO~Oh%VOk._O![']O%f.^O~Oa#`i!Y#`i'u#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9mOk=UO})zO!P){O(t$}O(u%PO~O#h#[aa#[a#]#[a'u#[a!Y#[a!h#[a![#[a!V#[a~P#.aO#h(ZXP(ZXR(ZX[(ZXa(ZXo(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX'u(ZX([(ZX(m(ZX!h(ZX!V(ZX's(ZXs(ZX![(ZX%f(ZX!d(ZX~P!5uO!Y.lO!h(fX~P!9mO!h.oO~O!V.qO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#1|O#k$OO~P#1|OP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#4kO#o$QO~P#4kOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO([VOa#ji!Y#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO([VO(u#}Oa#ji!Y#ji#y#ji#z#ji'u#ji(m#ji(t#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#9pO#w#ji~P#9pO#u$SO~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO([VO(t#|O(u#}Oa#ji!Y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<fO#y$WO~P#<fOP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X!Y]X!Z]X~O#}]X~P#?TOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O#y;bO#z;cO([VO(m$YO(t#|O(u#}O~O#}.sO~P#AbO#P$dO#];iO$P;iO#}(bX!Z(bX~P! YOa'`a!Y'`a'u'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9mO[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO(t#ji(u#ji~P#DdOk=UO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P#DdO!Y.wOg(kX~P!0kOg.yO~Oa$Oi!Y$Oi'u$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9mO$[.zO$^.zO~O$[.{O$^.{O~O!d)dO#].|O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X.}O~O![)gO$Y/PO$[)fO$^)fO$e/QO~O!Y;dO!Z(aX~P#AbO!Z/RO~O!d)dO$e(vX~O$e/TO~Ou)uO(])vO(^/WO~O!V/[O~P!&_O(t$}Ok%^a}%^a!P%^a(u%^a!Y%^a#]%^a~Og%^a#}%^a~P#K^O(u%POk%`a}%`a!P%`a(t%`a!Y%`a#]%`a~Og%`a#}%`a~P#LPO!YfX!dfX!hfX!h$xX(mfX~P!/gO!X/eO!Y(YO(O/dO!V(qP!V({P~P!1YOo*nO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO~Op'XO!P/fO!X+UO!Z*kO(QTO(TUO(`;wO!Z(sP~P#MjO!h/gO~P#.aO!Y/hO!d#vO(m'mO!h(zX~O!h/mO~O!P%fO!X*YO![%gO(O%eO!h(zP~O#h/oO~O!V$xX!Y$xX!d%PX~P!/gO!Y/pO!V({X~P#.aO!d/rO~O!V/tO~Oh%VOo/xO!d#vO!i%cO(m'mO~O(O/zO~O!d+cO~Oa%lO!Y0OO'u%lO~O!Z0QO~P!4|O!`0RO!a0RO(P!lO(`!mO~O!P0TO(`!mO~O#X0UO~Og%^a!Y%^a#]%^a#}%^a~P!0kOg%`a!Y%`a#]%`a#}%`a~P!0kO(O&WOg'iX!Y'iX~O!Y*tOg(Xa~Og0_O~OR0`O}0`O!P0aO#P$dOkza(tza(uza!Yza#]za~Ogza#}za~P$%]O})zO!P){Ok$qa(t$qa(u$qa!Y$qa#]$qa~Og$qa#}$qa~P$&UO})zO!P){Ok$sa(t$sa(u$sa!Y$sa#]$sa~Og$sa#}$sa~P$&wO#h0dO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0kO!d#vO~O#h0gO~O!Y+WOa)Pa'u)Pa~OR#zO}#yO!P#{O!i#xO([VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(m!oi(t!oi(u!oi~Oa!oi'u!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$(fOh%VOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~Om0pO(O0oO~P$*|O!d+cOa(Wa![(Wa'u(Wa!Y(Wa~O#h0vO~O[]X!YfX!ZfX~O!Y0wO!Z)TX~O!Z0yO~O[0zO~Ob0|O(O+kO(QTO(TUO~O![%}O(O%eO`'qX!Y'qX~O!Y+pO`)Sa~O!h1PO~P!9mO[1SO~O`1TO~O#]1WO~Ok1ZO![$|O~O(`(xO!Z)QP~Oh%VOk1dO![1aO%f1cO~O[1nO!Y1lO!Z)RX~O!Z1oO~O`1qOa%lO'u%lO~O(O#nO(QTO(TUO~O#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O#s1tO&W1uOa(bX~P$0dO#]$eO#s1tO&W1uO~Oa1wO~P%[Oa1yO~O&a1|OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(O&_i(Q&_i(T&_i([&_i(j&_i(y&_i!Z&_ib&_i&f&_i~Ob2SO!Z2QO&f2RO~P`O![XO!i2UO~O&m,sOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(O&hi(Q&hi(T&hi([&hi(j&hi(y&hi!Z&hi&a&hib&hi&f&hi~O!V2[O~O!Y!^a!Z!^a~P#AbOp!nO!P!oO!X2bO(`!mO!Y'TX!Z'TX~P@YO!Y-TO!Z(da~O!Y'ZX!Z'ZX~P!8uO!Y-WO!Z(sa~O!Z2iO~P'_Oa%lO#]2rO'u%lO~Oa%lO!d#vO#]2rO'u%lO~Oa%lO!d#vO!m2vO#]2rO'u%lO(m'mO~Oa%lO'u%lO~P!9mO!Y$_Os$oa~O!V'Si!Y'Si~P!9mO!Y(RO!V(ci~O!Y(YO!V(qi~O!V(ri!Y(ri~P!9mO!Y(oi!h(oia(oi'u(oi~P!9mO#]2xO!Y(oi!h(oia(oi'u(oi~O!Y(fO!h(ni~O!P%fO![%gO!y]O#f2}O#g2|O(O%eO~O!P%fO![%gO#g2|O(O%eO~Ok3UO![']O%f3TO~Oh%VOk3UO![']O%f3TO~O#h%^aP%^aR%^a[%^aa%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K^O#h%`aP%`aR%`a[%`aa%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LPO#h%^aP%^aR%^a[%^aa%^ao%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.aO#h%`aP%`aR%`a[%`aa%`ao%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.aO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'uza([za(mza!hza!Vza'szasza![za%fza!dza~P$%]O#h$qaP$qaR$qa[$qaa$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'u$qa([$qa(m$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$&UO#h$saP$saR$sa[$saa$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'u$sa([$sa(m$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$&wO#h%RaP%RaR%Ra[%Raa%Rao%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'u%Ra([%Ra(m%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.aOa#`q!Y#`q'u#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9mO!X3^O!Y'UX!h'UX~P%[O!Y.lO!h(fa~O!Y.lO!h(fa~P!9mO!V3aO~O#}!ka!Z!ka~PKPO#}!ga!Y!ga!Z!ga~P#AbO#}!oa!Z!oa~P!<TO#}!qa!Z!qa~P!>kOg'XX!Y'XX~P!+hO!Y.wOg(ka~OSfO![3uO$c3vO~O!Z3zO~Os3{O~P#.aOa$lq!Y$lq'u$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9mO!V3|O~P#.aO})zO!P){O(u%POk'ea(t'ea!Y'ea#]'ea~Og'ea#}'ea~P%)nO})zO!P){Ok'ga(t'ga(u'ga!Y'ga#]'ga~Og'ga#}'ga~P%*aO(m$YO~P#.aO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/gO(O<QO~P!1YOmkO(O4OO~P.iO!P%fO!X4QO![%gO(O%eO!Y'aX!h'aX~O!Y/hO!h(za~O!Y/hO!d#vO!h(za~O!Y/hO!d#vO(m'mO!h(za~Og$zi!Y$zi#]$zi#}$zi~P!0kO!X4YO!V'cX!Y'cX~P!3XO!Y/pO!V({a~O!Y/pO!V({a~P#.aO!d#vO#s4bO~Oo4eO!d#vO(m'mO~O!P4hO(`!mO~O(t$}Ok%^i}%^i!P%^i(u%^i!Y%^i#]%^i~Og%^i#}%^i~P%.wO(u%POk%`i}%`i!P%`i(t%`i!Y%`i#]%`i~Og%`i#}%`i~P%/jOg(Yi!Y(Yi~P!0kO#]4mOg(Yi!Y(Yi~P!0kO!h4pO~Oa$mq!Y$mq'u$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9mO!V4tO~O!Y4uO![(|X~P#.aOa$xX![$xX%Z]X'u$xX!Y$xX~P!/gO%Z4xOalXklX}lX!PlX![lX'ulX(tlX(ulX!YlX~O%Z4xO~Ob5OO%g5PO(O+kO(QTO(TUO!Y'pX!Z'pX~O!Y0wO!Z)Ta~O[5TO~O`5UO~Oa%lO'u%lO~P#.aO![$|O~P#.aO!Y5^O#]5`O!Z)QX~O!Z5aO~Oo5hOp!nO!P5bO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5gO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O!Z5fO~P%4tOk5mO![1aO%f5lO~Oh%VOk5mO![1aO%f5lO~Ob5tO(O#nO(QTO(TUO!Y'oX!Z'oX~O!Y1lO!Z)Ra~O(QTO(TUO(`5vO~O`5zO~O#s5}O&W6OO~PMlO!h6PO~P%[Oa6RO~Oa6RO~P%[Ob2SO!Z6WO&f2RO~P`O!d6YO~O!d6[Oh(ei!Y(ei!Z(ei!d(ei!i(ei~O!Y#ei!Z#ei~P#AbO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AbOa%lO#]6fO'u%lO~Oa%lO!d#vO#]6fO'u%lO~O!Y(oq!h(oqa(oq'u(oq~P!9mO!Y(fO!h(nq~O!P%fO![%gO#g6mO(O%eO~O![']O%f6pO~Ok6tO![']O%f6pO~O#h'eaP'eaR'ea['eaa'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'u'ea(['ea(m'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%)nO#h'gaP'gaR'ga['gaa'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'u'ga(['ga(m'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%*aO#h$ziP$ziR$zi[$zia$zio$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'u$zi([$zi(m$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.aO#h%^iP%^iR%^i[%^ia%^io%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'u%^i([%^i(m%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%.wO#h%`iP%`iR%`i[%`ia%`io%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'u%`i([%`i(m%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%/jO!Y'Ua!h'Ua~P!9mO!Y.lO!h(fi~O#}#`i!Y#`i!Z#`i~P#AbOP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#k#ji~P%G^O#k;YO~P%G^OP$[OR#zOo;fO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#o#ji~P%IfO#o;[O~P%IfOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O([VO#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#u#ji~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O([VO(u#}O#y#ji#z#ji#}#ji(m#ji(t#ji!Y#ji!Z#ji~O#w;`O~P%MoO#w#ji~P%MoO#u;^O~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O([VO(t#|O(u#}O#z#ji#}#ji(m#ji!Y#ji!Z#ji~O#y#ji~P&!OO#y;bO~P&!OOa#{y!Y#{y'u#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9mO[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO(t#ji(u#ji~P&$zOk=VO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P&$zO#P$dOP(ZXR(ZX[(ZXk(ZXo(ZX}(ZX!P(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX#}(ZX([(ZX(m(ZX(t(ZX(u(ZX!Y(ZX!Z(ZX~O#}$Oi!Y$Oi!Z$Oi~P#AbO#}!oi!Z!oi~P$(fOg'Xa!Y'Xa~P!0kO!Z7WO~O!Y'`a!Z'`a~P#AbOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!d%WX#s%WX~P&+QO!d#vO(m'mO!Y'aa!h'aa~O!Y/hO!h(zi~O!Y/hO!d#vO!h(zi~Og$zq!Y$zq#]$zq#}$zq~P!0kO!V'ca!Y'ca~P#.aO!d7_O~O!Y/pO!V({i~P#.aO!Y/pO!V({i~O!V7cO~O!d#vO#s7hO~Oo7iO!d#vO(m'mO~O})zO!P){O(u%POk'fa(t'fa!Y'fa#]'fa~Og'fa#}'fa~P&/pO})zO!P){Ok'ha(t'ha(u'ha!Y'ha#]'ha~Og'ha#}'ha~P&0cO!V7lO~Og$|q!Y$|q#]$|q#}$|q~P!0kOa$my!Y$my'u$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9mO!d6[O~O!Y4uO![(|a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa([$Sa(m$Sa(t$Sa(u$Sa~O%f6pO~P&2lOa#`y!Y#`y'u#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9mO[7qO~Ob7sO(O+kO(QTO(TUO~O!Y0wO!Z)Ti~O`7wO~O(`(xO!Y'lX!Z'lX~O!Y5^O!Z)Qa~O!Z8QO~P%4tOp!nO!P8RO(QTO(TUO(`!mO(j!sO~O#X8SO~O![1aO~O![1aO%f8UO~Ok8XO![1aO%f8UO~O[8^O!Y'oa!Z'oa~O!Y1lO!Z)Ri~O!h8bO~O!h8cO~O!h8fO~O!h8fO~P%[Oa8hO~O!d8iO~O!h8jO~O!Y(ri!Z(ri~P#AbOa%lO#]8rO'u%lO~O!Y(oy!h(oya(oy'u(oy~P!9mO!Y(fO!h(ny~O%f8uO~P&2lO![']O%f8uO~O#h$zqP$zqR$zq[$zqa$zqo$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'u$zq([$zq(m$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.aO#h'faP'faR'fa['faa'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'u'fa(['fa(m'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&/pO#h'haP'haR'ha['haa'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'u'ha(['ha(m'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&0cO#h$|qP$|qR$|q[$|qa$|qo$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'u$|q([$|q(m$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.aO!Y'Ui!h'Ui~P!9mO#}#`q!Y#`q!Z#`q~P#AbO(t$}OP%^aR%^a[%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a([%^a(m%^a!Y%^a!Z%^a~Ok%^a}%^a!P%^a(u%^a~P&CoO(u%POP%`aR%`a[%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a([%`a(m%`a!Y%`a!Z%`a~Ok%`a}%`a!P%`a(t%`a~P&EsOk=VO})zO!P){O(u%PO~P&CoOk=VO})zO!P){O(t$}O~P&EsOR0`O}0`O!P0aO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za([za(mza(tza(uza!Yza!Zza~O})zO!P){OP$qaR$qa[$qak$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa([$qa(m$qa(t$qa(u$qa!Y$qa!Z$qa~O})zO!P){OP$saR$sa[$sak$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa([$sa(m$sa(t$sa(u$sa!Y$sa!Z$sa~Ok=VO})zO!P){O(t$}O(u%PO~OP%RaR%Ra[%Rao%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra([%Ra(m%Ra!Y%Ra!Z%Ra~P&NlO#}$lq!Y$lq!Z$lq~P#AbO#}$mq!Y$mq!Z$mq~P#AbO!Z9SO~O#}9TO~P!0kO!d#vO!Y'ai!h'ai~O!d#vO(m'mO!Y'ai!h'ai~O!Y/hO!h(zq~O!V'ci!Y'ci~P#.aO!Y/pO!V({q~Oo9[O!d#vO(m'mO~O!V9]O~P#.aO!V9]O~O!d#vO#s9bO~Og(Yy!Y(Yy~P!0kO!Y'ja!['ja~P#.aOa%Yq![%Yq'u%Yq!Y%Yq~P#.aO[9dO~O!Y0wO!Z)Tq~O#]9hO!Y'la!Z'la~O!Y5^O!Z)Qi~P#AbO!P4hO~O![1aO%f9lO~O(QTO(TUO(`9qO~O!Y1lO!Z)Rq~O!h9tO~O!h9uO~O!h9vO~O!h9vO~P%[O#]9yO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AbO%f:OO~P&2lO![']O%f:OO~O#}#{y!Y#{y!Z#{y~P#AbOP$ziR$zi[$zio$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi([$zi(m$zi!Y$zi!Z$zi~P&NlO})zO!P){O(u%POP'eaR'ea['eak'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(['ea(m'ea(t'ea!Y'ea!Z'ea~O})zO!P){OP'gaR'ga['gak'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(['ga(m'ga(t'ga(u'ga!Y'ga!Z'ga~O(t$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i([%^i(m%^i(u%^i!Y%^i!Z%^i~O(u%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i([%`i(m%`i(t%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AbO#}#`y!Y#`y!Z#`y~P#AbO!d#vO!Y'aq!h'aq~O!Y/hO!h(zy~O!V'cq!Y'cq~P#.aOo:YO!d#vO(m'mO~O!V:ZO~P#.aO!V:ZO~O!Y0wO!Z)Ty~O!Y5^O!Z)Qq~O![1aO%f:cO~O!h:fO~O%f:kO~P&2lOP$zqR$zq[$zqo$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq([$zq(m$zq!Y$zq!Z$zq~P&NlO})zO!P){O(u%POP'faR'fa['fak'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(['fa(m'fa(t'fa!Y'fa!Z'fa~O})zO!P){OP'haR'ha['hak'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(['ha(m'ha(t'ha(u'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q([$|q(m$|q!Y$|q!Z$|q~P&NlOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0kOo:oO!d#vO(m'mO~O!V:pO~P#.aO!Y'lq!Z'lq~P#AbO!Y#e!Z!Z#e!Z~P#AbO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'u%b!Z([%b!Z(m%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.aOo:xO!d#vO(m'mO~OP%b!ZR%b!Z[%b!Zo%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z([%b!Z(m%b!Z!Y%b!Z!Z%b!Z~P&NlOs(aX~P1qO}%pO~P!(oO(P!lO~P!(oO!VfX!YfX#]fX~P&+QOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!dfX!h]X!hfX(mfX~P'BxOP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![XO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y;dO!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;oO!P${O![$|O!f=PO!i$xO#g;uO$V%_O$r;qO$t;sO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#t)`O~P'GnOo!bX(m!bX~P# ZO!Z]X!ZfX~P'BxO!VfX!V$xX!YfX!Y$xX#]fX~P!/gO#h;XO~O!d#vO#h;XO~O#];iO~O#s;]O~O#];xO!Y(rX!Z(rX~O#];iO!Y(pX!Z(pX~O#h;yO~Og;{O~P!0kO#h<RO~O#h<SO~O!d#vO#h<TO~O!d#vO#h;yO~O#}<UO~P#AbO#h<VO~O#h<WO~O#h<]O~O#h<^O~O#h<_O~O#h<`O~O#}<aO~P!0kO#}<bO~P!0kO#P#Q#R#T#U#X#f#g#r(y$r$t$w%Z%e%f%g%n%p%s%t%v%x~'yT#l!U'w(P#mp#k#no}'x$['x(O$^(`~",
        goto: "$4Q)XPPPPPP)YPP)]P)nP+O/PPPPP5xPP6`PP<V?mP@QP@QPPP@QPBRP@QP@QP@QPBVPB[PByPGrPPPGvPPPPGvJxPPPKOKzPGvPGvPPNYGvPPPGvPGvP!!aGvP!%v!&{!'UP!'x!'|!'x!+YPPPPPPP!+y!&{PP!,Z!-gP!0jGvGv!0o!3z!8b!8b!<`PPP!<hGvPPPPPPPPPPP!?vP!ATPPGv!BfPGvPGvGvGvGvGvPGv!CxP!GRP!JWP!J[!Jf!Jj!JjP!GOP!Jn!JnP!MsP!MwGvGv!M}##RBV@QP@QP@Q@QP#$_@Q@Q#&j@Q#)Z@Q#+`@Q@Q#,O#.]#.]#.b#.k#.]#.wP#.]P@Q#/a@Q#3S@Q@Q5xPPP#6{PPP#7f#7fP#7fP#7|#7fPP#8SP#7yP#7y#8g#7y#9R#9X5u)]#9[)]P#9c#9c#9cP)]P)]P)]P)]PP)]P#9i#9lP#9l)]P#9pP#9sP)]P)]P)]P)]P)]P)])]PP#9y#:P#:[#:b#:h#:n#:t#;S#;Y#;d#;j#;t#;z#<[#<b#=S#=f#=l#=r#>Q#>g#@V#@e#@l#BR#Ba#C|#D[#Db#Dh#Dn#Dx#EO#EU#E`#Er#ExPPPPPPPPPP#FOPPPPPPP#Fs#Iz#KZ#Kb#KjPPP$!sP$!|$%t$,^$,a$,d$-P$-S$-Z$-cP$-i$-lP$.Y$.^$/U$0d$0i$1PPP$1U$1[$1`P$1c$1g$1k$2a$2x$3a$3e$3h$3k$3q$3t$3x$3|R!|RoqOXst!Z#d%k&o&q&r&t,k,p1|2PY!vQ']-]1a5eQ%rvQ%zyQ&R|Q&g!VS'T!e-TQ'c!iS'i!r!yU*e$|*V*jQ+i%{Q+v&TQ,[&aQ-Z'[Q-e'dQ-m'jQ0R*lQ1k,]R;v;T%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8rS#q];Q!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U*y%[;n;oQ+n%}Q,^&dQ,e&lQ0m+aQ0q+cQ0|+oQ1s,cQ3Q._Q5O0wQ5t1lQ6r3UQ7s5PR8x6t'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{t!nQ!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5g$|$ti#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ&U|Q'R!eU'X%g*V-WQ+n%}Q,^&dQ0c*|Q0|+oQ1R+uQ1r,bQ1s,cQ5O0wQ5X1TQ5t1lQ5w1nQ5x1qQ7s5PQ7v5UQ8a5zQ9g7wR9r8^rnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR,`&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<z<{[#]WZ#W#Z'U(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+h%z%{Q+l%}Q,V&_Q,Z&aS-d'c'dQ.a(nQ0u+iQ0{+oQ0}+pQ1Q+tQ1f,WS1j,[,]Q2n-eQ4}0wQ5R0zQ5W1SQ5s1kQ7r5PQ7u5TQ9c7qR:^9d!O$zi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R!S%wy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dQ+b%uQ+{&XQ,O&YQ,Y&aQ.`(mQ1e,VU1i,Z,[,]Q3V.aQ5n1fS5r1j1kQ8]5s#^<|#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo<};g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bW%Ti%V*t<xS&X!Q&fQ&Y!RQ&Z!SR+y&V$}%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VT)v$u)wV*y%[;n;oW'X!e%g*V-WS(y#y#zQ+]%pQ+s&QS.Y(i(jQ1[,PQ4n0`R7{5^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{$i$^c#Y#e%o%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.t.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q'V!eR2c-Tv!nQ!e!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5gU*d$|*V*jS/y*e*lQ0S*mQ1^,RQ4d0RR4g0UnqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&v!^Q's!xS(o#u;XQ+f%xQ,T&[Q,U&^Q-b'aQ-o'lS.j(t;yS0f+R<TQ0s+gQ1`,SQ2T,rQ2V,sQ2_-OQ2l-cQ2o-gS4s0g<_Q4y0tS4|0v<`Q6^2aQ6b2mQ6g2tQ7p4zQ8m6`Q8n6cQ8q6hR9x8j$d$]c#Y#e%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oS(k#p'fQ({#zS+[%o.tS.Z(j(lR3O.['OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S#q];QQ&q!XQ&r!YQ&t![Q&u!]R1{,nQ'^!hQ+_%uQ-`'`S.](m+bQ2j-_W3S.`.a0l0nQ6a2kW6n3P3R3V4wU8t6o6q6sU9}8v8w8yS:i9|:PQ:t:jR:z:uU!wQ']-]T5c1a5e!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,k,p.S1|2P]!pQ!r']-]1a5eT#q];Q%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS(y#y#zS.Y(i(j!s<f$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U$fd)Z,eS(l#p'fU*q%R(s3pU0b*x.f7PQ4w0mQ6o3QQ8w6rR:P8xm!tQ!r!v!y!z']'i'j'k-]-m1a5e5gQ'q!uS(b#g1vS-k'h'tQ/k*XQ/w*dQ2v-nQ4U/lS4_/x0SQ7Z4PS7f4e4gQ9V7[Q9Z7cQ9`7iS:X9[9]S:n:Y:ZS:w:o:pR:}:xQ#wbQ'p!uS(a#g1vS(c#m+QQ+S%dQ+d%vQ+j%|U-j'h'q'tQ.O(bQ/j*XQ/v*dQ/|*gQ0r+eQ1g,XS2s-k-nQ2{.WS4T/k/lS4^/w0SQ4a/{Q4c/}Q5p1hQ6i2vQ7Y4PQ7^4US7b4_4gQ7g4fQ8Z5qS9U7Z7[Q9Y7cQ9^7fQ9a7jQ9o8[Q:V9VS:W9Z9]Q:[9`Q:e9pS:m:X:ZS:v:n:pQ:|:wQ;O:}Q<i<dQ<t<mR<u<nV!wQ']-]%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS#wz!j!r<c$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<i<z%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dS%|z!jQ+e%wQ,X&aW1h,Y,Z,[,]U5q1i1j1kS8[5r5sQ9p8]!r<d$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q<m<yR<n<z%OeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rY#bWZ#W#Z(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ,f&l!p<e$Z$n)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<h'UU'Y!e%g*VR2e-W%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8r!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q,e&lQ0m+aQ3Q._Q6r3UR8x6t!b$Tc#Y%o(O(U(p(u)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!P;_)Y)m-R.t2]2`3b3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!f$Vc#Y%o(O(U(p(u)S)T)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!T;a)Y)m-R.t2]2`3b3h3i3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!^$Zc#Y%o(O(U(p(u)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;RQ3}/cz<{)Y)m-R.t2]2`3b3q3y6_6z7T7U7}8l8z9Q9R:`:g<oQ=Q=SR=R=T'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S$oh$pR3v.|'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$kf$qQ$ifS)f$l)jR)r$qT$jf$qT)h$l)j'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$oh$pQ$rhR)q$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8r!s<y$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{#elOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_(z)o+V+a,h,k,p-a._.}/f0a1d1t1u1w1y1|2P2R3U3u5b5m5}6O6R6t8R8X8h!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=VQ*}%`Q/Y)zo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!O$yi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=RQ*^$zU*g$|*V*jQ+O%aQ/}*h#^<k#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn<l;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bQ<p<|Q<q<}Q<r=OR<s=P!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bnoOXst!Z#d%k&o&q&r&t,k,p1|2PS*a${*UQ,y&{Q,z&}R4X/p$|%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ+|&YQ1Y,OQ5[1XR7z5]V*i$|*V*jU*i$|*V*jT5d1a5eU/{*f/f5bS4f0T8RR7j4hQ+d%vQ/|*gQ0r+eQ1g,XQ5p1hQ8Z5qQ9o8[R:e9p!O%Oi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rr)}$v)a*O*p+P/n0Z0[3s4V4q7X7k:U<j<v<wS0V*o0W#^;j#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;k;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!`;|(q)_*W*`.b.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=T`;}3o6{7O7S8{:Q:T:{S<X.d3ZT<Y6}9O!O%Qi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rv*P$v)a*Q*o+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<wS0X*p0Y#^;l#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;m;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!d<O(q)_*W*`.c.d.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=Td<P3o6|6}7S8{8|:Q:R:T:{S<Z.e3[T<[7O9PrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ&c!UR,h&lrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR&c!UQ,Q&ZR1U+ysnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ1b,VS5k1e1fU8T5i5j5nS9k8V8WS:a9j9mQ:q:bR:y:rQ&j!VR,a&fR5w1nS&O|&TR0}+pQ&o!WR,k&pR,q&uT1},p2PR,u&vQ,t&vR2W,uQ'v!{R-q'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)w$uR/V)wQ#UVR'|#UQ#XWU(S#X(T-xQ(T#YR-x(UQ-U'VR2d-UQ.m(uS3_.m3`R3`.nQ-]']R2h-]Y!rQ']-]1a5eR'g!rQ.x)aR3t.xU#_W%f*UU(Z#_([-yQ([#`R-y(VQ-X'YR2f-Xt`OXst!V!Z#d%k&f&h&o&q&r&t,k,p1|2PS#hZ%cU#r`#h.SR.S(fQ(g#jQ.P(cW.X(g.P2y6kQ2y.QR6k2zQ)j$lR/O)jQ$phR)p$pQ$`cU)]$`-t;eQ-t;RR;e)mQ/i*XW4R/i4S7]9WU4S/j/k/lS7]4T4UR9W7^$Z)|$v(q)_)a*W*`*o*p*z*{+P.d.e.g.h.i/U/Z/_/a/c/n/s0Z0[0k1V1X3W3X3Y3o3s4V4W4[4i4k4q5Z5]6u6v6w6x6}7O7Q7R7S7X7`7d7k7m7o8{8|8}9X9_:Q:R:S:T:U:]:l:{<j<v<w=S=TQ/q*`U4Z/q4]7aQ4]/sR7a4[S*j$|*VR0P*jr*O$v)a*o*p+P/n0Z0[3s4V4q7X7k:U<j<v<w!`.b(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=TU/`*O.b6{a6{3o6}7O7S8{:Q:T:{Q0W*oQ3Z.dU4j0W3Z9OR9O6}v*Q$v)a*o*p+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<w!d.c(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=TU/b*Q.c6|e6|3o6}7O7S8{8|:Q:R:T:{Q0Y*pQ3[.eU4l0Y3[9PR9P7OQ*u%UR0^*uQ4v0kR7n4vQ+X%iR0j+XQ5_1[S7|5_9iR9i7}Q,S&[R1_,SQ5e1aR8P5eQ1m,^S5u1m8_R8_5wQ0x+lW5Q0x5S7t9eQ5S0{Q7t5RR9e7uQ+q&OR1O+qQ2P,pR6V2PYrOXst#dQ&s!ZQ+Z%kQ,j&oQ,l&qQ,m&rQ,o&tQ1z,kS1},p2PR6U1|Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Y%jQ+f%xQ+x&UQ,`&jQ,w&yW-h'h'p'q'tQ-o'lQ0O*iQ0s+gS1p,a,dQ2X,vQ2Y,yQ2Z,zQ2o-gW2q-j-k-n-pQ4y0tQ5V1RQ5Y1VQ5o1gQ5y1rQ6T1{U6d2p2s2vQ6g2tQ7p4zQ7x5XQ7y5ZQ8O5dQ8Y5pQ8`5xS8o6e6iQ8q6hQ9f7vQ9n8ZQ9s8aQ9z8pQ:_9gQ:d9oQ:h9{R:s:eQ%xyQ'a!iQ'l!uU+g%y%z%{Q-O'SU-c'b'c'dS-g'h'rQ/u*dS0t+h+iQ2a-QS2m-d-eQ2t-lQ4`/yQ4z0uQ6`2gQ6c2nQ6h2uR7e4dS$wi<xR*v%VU%Ui%V<xR0]*tQ$viS(q#v+cS)_$b$cQ)a$dQ*W$xS*`${*UQ*o%OQ*p%QQ*z%]Q*{%^Q+P%bQ.d;jQ.e;lQ.g;pQ.h;rQ.i;tQ/U)uS/Z){/]Q/_)}Q/a*PQ/c*RQ/n*[S/s*b/eQ0Z*rQ0[*sh0k+`.^1c3T5l6p8U8u9l:O:c:kQ1V+zQ1X+}Q3W;|Q3X<OQ3Y<RS3o;g;hQ3s.wQ4V/oQ4W/pQ4[/rQ4i0VQ4k0XQ4q0dQ5Z1WQ5]1ZQ6u<VQ6v<XQ6w<ZQ6x<]Q6};kQ7O;mQ7Q;qQ7R;sQ7S;uQ7X3}Q7`4YQ7d4bQ7k4mQ7m4uQ7o4xQ8{<SQ8|;}Q8}<PQ9X7_Q9_7hQ:Q<WQ:R<YQ:S<[Q:T<^Q:U9TQ:]9bQ:l<aQ:{<bQ<j<xQ<v=QQ<w=RQ=S=UR=T=VQ*x%[Q.f;nR7P;onpOXst!Z#d%k&o&q&r&t,k,p1|2PQ!fPS#fZ#oQ&y!`U'e!o5b8RQ'{#SQ(|#{Q)n$nS,d&h&kQ,i&lQ,v&xQ,{'QQ-_'_Q.p(zQ/S)oS0h+V/fQ0n+aQ1x,hQ2k-aQ3R._Q3x.}Q4o0aQ5j1dQ5{1tQ5|1uQ6Q1wQ6S1yQ6X2RQ6s3UQ7V3uQ8W5mQ8d5}Q8e6OQ8g6RQ8y6tQ9m8XR9w8h#YcOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_(z+V+a,h,k,p-a._/f0a1d1t1u1w1y1|2P2R3U5b5m5}6O6R6t8R8X8hQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)Y$ZQ)[$_Q)^$aQ)c$eW)m$n)o.}3uQ+^%rQ+r&PS-R'U2bQ-p'oS-u(P-wQ-z(XQ-|(`Q.k(tQ.n(vQ.r;PQ.t;SQ.u;TQ.v;WQ/X)yQ0e+RQ2],|Q2`-PQ2p-iQ2w-}Q3].lQ3b;XQ3c;YQ3d;ZQ3e;[Q3f;]Q3g;^Q3h;_Q3i;`Q3j;aQ3k;bQ3l;cQ3m.sQ3n;fQ3q;iQ3r;vQ3y;dQ4r0gQ4{0vQ6_;xQ6e2rQ6j2xQ6y3^Q6z;yQ7T;{Q7U<TQ7}5`Q8l6]Q8p6fQ8z<UQ9Q<_Q9R<`Q9{8rQ:`9hQ:g9yQ;R#SR<o<{R#[WR'W!el!tQ!r!v!y!z']'i'j'k-]-m1a5e5gS'S!e-TS-Q'T'[R2g-ZR(w#xQ!fQT-[']-]]!qQ!r']-]1a5eQ#p]R'f;QR)b$dY!uQ']-]1a5eQ'h!rS'r!v!yS't!z5gS-l'i'jQ-n'kR2u-mT#kZ%cS#jZ%cS%im,gU(c#h#i#lS.Q(d(eQ.U(fQ0i+WQ2z.RU2{.S.T.VS6l2|2}R8s6md#^W#W#Z%f(P(Y*U+T-{/er#gZm#h#i#l%c(d(e(f+W.R.S.T.V2|2}6mS*X$x*]Q/l*YQ1v,gQ2^,}Q4P/hQ6Z2UQ7[4QQ8k6[T<g'U+UV#aW%f*UU#`W%f*US(Q#W(YU(V#Z+T/eS-S'U+UT-v(P-{V'Z!e%g*VQ$lfR)t$qT)i$l)jR3w.|T*Z$x*]T*c${*UQ0l+`Q3P.^Q5i1cQ6q3TQ8V5lQ8v6pQ9j8UQ9|8uQ:b9lQ:j:OQ:r:cR:u:knqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&i!VR,`&ftmOXst!U!V!Z#d%k&f&o&q&r&t,k,p1|2PR,g&lT%jm,gR1],PR,_&dQ&S|R+w&TR+m%}T&m!W&pT&n!W&pT2O,p2P",
        nodeNames:
          " ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
        maxTerm: 376,
        context: Sce,
        nodeProps: [
          ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
          [
            "group",
            -26,
            9,
            17,
            19,
            65,
            204,
            208,
            212,
            213,
            215,
            218,
            221,
            231,
            233,
            239,
            241,
            243,
            245,
            248,
            254,
            260,
            262,
            264,
            266,
            268,
            270,
            271,
            "Statement",
            -34,
            13,
            14,
            29,
            32,
            33,
            39,
            48,
            51,
            52,
            54,
            59,
            67,
            69,
            73,
            77,
            79,
            81,
            82,
            107,
            108,
            117,
            118,
            135,
            138,
            140,
            141,
            142,
            143,
            144,
            146,
            147,
            166,
            167,
            169,
            "Expression",
            -23,
            28,
            30,
            34,
            38,
            40,
            42,
            171,
            173,
            175,
            176,
            178,
            179,
            180,
            182,
            183,
            184,
            186,
            187,
            188,
            198,
            200,
            202,
            203,
            "Type",
            -3,
            85,
            100,
            106,
            "ClassItem",
          ],
          ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
          ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"],
        ],
        propSources: [Dce],
        skippedNodes: [0, 5, 6, 274],
        repeatNodeCount: 37,
        tokenData:
          "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Rp(U!b'w0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(S#S$h&j'x0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Rp(U!b'x0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(Q':f$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(U!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Rp(U!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Rp(U!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(U!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(U!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(RpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(RpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Rp(U!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(j%1l(Rp(U!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Rp(U!b$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Rp(U!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Rp(U!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(u+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(T';W$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(RpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Rp(U!b(P%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Rp(U!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Rp(U!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Rp(U!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Rp(U!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(U!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(U!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(U!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(U!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(U!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(U!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Rp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Rp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Rp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Rp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(RpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(RpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Rp(U!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Rp(U!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Rp(U!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Rp(U!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Rp(U!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Rp(U!b'y0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Rp(U!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(U!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(U!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(RpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(RpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Rp(U!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Rp(U!b(y7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(m(Ct$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Rp(U!b([+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Rp(U!b(O,2j$^#t(`$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Rp(U!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(t+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z(Kd$?V_!Z(Cds`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Rp(U!b'w0/l$[#t(O,2j(`$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Rp(U!b'x0/l$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
        tokenizers: [
          Tce,
          Ace,
          Pce,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          Ece,
          new ale(
            "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(^~~",
            141,
            335,
          ),
          new ale("j~RQYZXz{^~^O'{~~aP!P!Qd~iO'|~~", 25, 318),
        ],
        topRules: { Script: [0, 7], SingleExpression: [1, 272], SingleClassItem: [2, 273] },
        dialects: { jsx: 0, ts: 14725 },
        dynamicPrecedences: { 77: 1, 79: 1, 91: 1, 167: 1, 196: 1 },
        specialized: [
          { term: 322, get: (e) => Rce[e] || -1 },
          { term: 338, get: (e) => Nce[e] || -1 },
          { term: 92, get: (e) => $ce[e] || -1 },
        ],
        tokenPrec: 14749,
      }),
      Mce = [
        Sse("function ${name}(${params}) {\n\t${}\n}", { label: "function", detail: "definition", type: "keyword" }),
        Sse("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
          label: "for",
          detail: "loop",
          type: "keyword",
        }),
        Sse("for (let ${name} of ${collection}) {\n\t${}\n}", { label: "for", detail: "of loop", type: "keyword" }),
        Sse("do {\n\t${}\n} while (${})", { label: "do", detail: "loop", type: "keyword" }),
        Sse("while (${}) {\n\t${}\n}", { label: "while", detail: "loop", type: "keyword" }),
        Sse("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", { label: "try", detail: "/ catch block", type: "keyword" }),
        Sse("if (${}) {\n\t${}\n}", { label: "if", detail: "block", type: "keyword" }),
        Sse("if (${}) {\n\t${}\n} else {\n\t${}\n}", { label: "if", detail: "/ else block", type: "keyword" }),
        Sse("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
          label: "class",
          detail: "definition",
          type: "keyword",
        }),
        Sse('import {${names}} from "${module}"\n${}', { label: "import", detail: "named", type: "keyword" }),
        Sse('import ${name} from "${module}"\n${}', { label: "import", detail: "default", type: "keyword" }),
      ],
      Lce = Mce.concat([
        Sse("interface ${name} {\n\t${}\n}", { label: "interface", detail: "definition", type: "keyword" }),
        Sse("type ${name} = ${type}", { label: "type", detail: "definition", type: "keyword" }),
        Sse("enum ${name} {\n\t${}\n}", { label: "enum", detail: "definition", type: "keyword" }),
      ]),
      Qce = new pae(),
      Bce = new Set([
        "Script",
        "Block",
        "FunctionExpression",
        "FunctionDeclaration",
        "ArrowFunction",
        "MethodDeclaration",
        "ForStatement",
      ])
    function jce(e) {
      return (t, n) => {
        let r = t.node.getChild("VariableDefinition")
        return r && n(r, e), !0
      }
    }
    const Uce = ["FunctionDeclaration"],
      Fce = {
        FunctionDeclaration: jce("function"),
        ClassDeclaration: jce("class"),
        ClassExpression: () => !0,
        EnumDeclaration: jce("constant"),
        TypeAliasDeclaration: jce("type"),
        NamespaceDeclaration: jce("namespace"),
        VariableDefinition(e, t) {
          e.matchContext(Uce) || t(e, "variable")
        },
        TypeDefinition(e, t) {
          t(e, "type")
        },
        __proto__: null,
      }
    function zce(e, t) {
      let n = Qce.get(t)
      if (n) return n
      let r = [],
        a = !0
      function o(t, n) {
        let a = e.sliceString(t.from, t.to)
        r.push({ label: a, type: n })
      }
      return (
        t.cursor(Hre.IncludeAnonymous).iterate((t) => {
          if (a) a = !1
          else if (t.name) {
            let e = Fce[t.name]
            if ((e && e(t, o)) || Bce.has(t.name)) return !1
          } else if (t.to - t.from > 8192) {
            for (let n of zce(e, t.node)) r.push(n)
            return !1
          }
        }),
        Qce.set(t, r),
        r
      )
    }
    const qce = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,
      Zce = [
        "TemplateString",
        "String",
        "RegExp",
        "LineComment",
        "BlockComment",
        "VariableDefinition",
        "TypeDefinition",
        "Label",
        "PropertyDefinition",
        "PropertyName",
        "PrivatePropertyDefinition",
        "PrivatePropertyName",
        ".",
        "?.",
      ]
    function Hce(e) {
      let t = loe(e.state).resolveInner(e.pos, -1)
      if (Zce.indexOf(t.name) > -1) return null
      let n = "VariableName" == t.name || (t.to - t.from < 20 && qce.test(e.state.sliceDoc(t.from, t.to)))
      if (!n && !e.explicit) return null
      let r = []
      for (let n = t; n; n = n.parent) Bce.has(n.name) && (r = r.concat(zce(e.state.doc, n)))
      return { options: r, from: n ? t.from : e.pos, validFor: qce }
    }
    const Vce = soe.define({
        name: "javascript",
        parser: Ice.configure({
          props: [
            Soe.add({
              IfStatement: Noe({ except: /^\s*({|else\b)/ }),
              TryStatement: Noe({ except: /^\s*({|catch\b|finally\b)/ }),
              LabeledStatement: (e) => e.baseIndent,
              SwitchBody: (e) => {
                let t = e.textAfter,
                  n = /^\s*\}/.test(t),
                  r = /^\s*(case|default)\b/.test(t)
                return e.baseIndent + (n ? 0 : r ? 1 : 2) * e.unit
              },
              Block: Doe({ closing: "}" }),
              ArrowFunction: (e) => e.baseIndent + e.unit,
              "TemplateString BlockComment": () => null,
              "Statement Property": Noe({ except: /^{/ }),
              JSXElement(e) {
                let t = /^\s*<\//.test(e.textAfter)
                return e.lineIndent(e.node.from) + (t ? 0 : e.unit)
              },
              JSXEscape(e) {
                let t = /\s*\}/.test(e.textAfter)
                return e.lineIndent(e.node.from) + (t ? 0 : e.unit)
              },
              "JSXOpenTag JSXSelfClosingTag": (e) => e.column(e.node.from) + e.unit,
            }),
            $oe.add({
              "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Ioe,
              BlockComment: (e) => ({ from: e.from + 2, to: e.to - 2 }),
            }),
          ],
        }),
        languageData: {
          closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
          commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
          indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
          wordChars: "$",
        },
      }),
      Wce = {
        test: (e) => /^JSX/.test(e.name),
        facet: roe({ commentTokens: { block: { open: "{/*", close: "*/}" } } }),
      },
      Xce = Vce.configure({ dialect: "ts" }, "typescript"),
      Yce = Vce.configure({ dialect: "jsx", props: [aoe.add((e) => (e.isTop ? [Wce] : void 0))] }),
      Gce = Vce.configure({ dialect: "jsx ts", props: [aoe.add((e) => (e.isTop ? [Wce] : void 0))] }, "typescript")
    let Kce = (e) => ({ label: e, type: "keyword" })
    const Jce =
        "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield"
          .split(" ")
          .map(Kce),
      ede = Jce.concat(["declare", "implements", "private", "protected", "public"].map(Kce))
    function tde(e = {}) {
      let t = e.jsx ? (e.typescript ? Gce : Yce) : e.typescript ? Xce : Vce,
        n = e.typescript ? Lce.concat(ede) : Mce.concat(Jce)
      return new voe(t, [
        Vce.data.of({
          autocomplete:
            ((r = Zce),
            (a = Aie(n)),
            (e) => {
              for (let t = loe(e.state).resolveInner(e.pos, -1); t; t = t.parent) {
                if (r.indexOf(t.name) > -1) return null
                if (t.type.isTop) break
              }
              return a(e)
            }),
        }),
        Vce.data.of({ autocomplete: Hce }),
        e.jsx ? ade : [],
      ])
      var r, a
    }
    function nde(e, t, n = e.length) {
      for (let r = null == t ? void 0 : t.firstChild; r; r = r.nextSibling)
        if (
          "JSXIdentifier" == r.name ||
          "JSXBuiltin" == r.name ||
          "JSXNamespacedName" == r.name ||
          "JSXMemberExpression" == r.name
        )
          return e.sliceString(r.from, Math.min(r.to, n))
      return ""
    }
    const rde = "object" == typeof navigator && /Android\b/.test(navigator.userAgent),
      ade = Tne.inputHandler.of((e, t, n, r, a) => {
        if (
          (rde ? e.composing : e.compositionStarted) ||
          e.state.readOnly ||
          t != n ||
          (">" != r && "/" != r) ||
          !Vce.isActiveAt(e.state, t, -1)
        )
          return !1
        let o = a(),
          { state: i } = o,
          s = i.changeByRange((e) => {
            var t
            let n,
              { head: a } = e,
              o = loe(i).resolveInner(a - 1, -1)
            if (
              ("JSXStartTag" == o.name && (o = o.parent),
              i.doc.sliceString(a - 1, a) != r || ("JSXAttributeValue" == o.name && o.to > a))
            );
            else {
              if (">" == r && "JSXFragmentTag" == o.name) return { range: e, changes: { from: a, insert: "</>" } }
              if ("/" == r && "JSXStartCloseTag" == o.name) {
                let e = o.parent,
                  r = e.parent
                if (
                  r &&
                  e.from == a - 2 &&
                  ((n = nde(i.doc, r.firstChild, a)) ||
                    "JSXFragmentTag" == (null === (t = r.firstChild) || void 0 === t ? void 0 : t.name))
                ) {
                  let e = `${n}>`
                  return { range: w7.cursor(a + e.length, -1), changes: { from: a, insert: e } }
                }
              } else if (">" == r) {
                let t = (function (e) {
                  for (;;) {
                    if ("JSXOpenTag" == e.name || "JSXSelfClosingTag" == e.name || "JSXFragmentTag" == e.name) return e
                    if ("JSXEscape" == e.name || !e.parent) return null
                    e = e.parent
                  }
                })(o)
                if (
                  t &&
                  "JSXOpenTag" == t.name &&
                  !/^\/?>|^<\//.test(i.doc.sliceString(a, a + 2)) &&
                  (n = nde(i.doc, t, a))
                )
                  return { range: e, changes: { from: a, insert: `</${n}>` } }
              }
            }
            return { range: e }
          })
        return (
          !s.changes.empty && (e.dispatch([o, i.update(s, { userEvent: "input.complete", scrollIntoView: !0 })]), !0)
        )
      }),
      ode = ["_blank", "_self", "_top", "_parent"],
      ide = ["ascii", "utf-8", "utf-16", "latin1", "latin1"],
      sde = ["get", "post", "put", "delete"],
      lde = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
      cde = ["true", "false"],
      dde = {},
      ude = {
        a: { attrs: { href: null, ping: null, type: null, media: null, target: ode, hreflang: null } },
        abbr: dde,
        address: dde,
        area: {
          attrs: {
            alt: null,
            coords: null,
            href: null,
            target: null,
            ping: null,
            media: null,
            hreflang: null,
            type: null,
            shape: ["default", "rect", "circle", "poly"],
          },
        },
        article: dde,
        aside: dde,
        audio: {
          attrs: {
            src: null,
            mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"],
          },
        },
        b: dde,
        base: { attrs: { href: null, target: ode } },
        bdi: dde,
        bdo: dde,
        blockquote: { attrs: { cite: null } },
        body: dde,
        br: dde,
        button: {
          attrs: {
            form: null,
            formaction: null,
            name: null,
            value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: lde,
            formmethod: sde,
            formnovalidate: ["novalidate"],
            formtarget: ode,
            type: ["submit", "reset", "button"],
          },
        },
        canvas: { attrs: { width: null, height: null } },
        caption: dde,
        center: dde,
        cite: dde,
        code: dde,
        col: { attrs: { span: null } },
        colgroup: { attrs: { span: null } },
        command: {
          attrs: {
            type: ["command", "checkbox", "radio"],
            label: null,
            icon: null,
            radiogroup: null,
            command: null,
            title: null,
            disabled: ["disabled"],
            checked: ["checked"],
          },
        },
        data: { attrs: { value: null } },
        datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
        datalist: { attrs: { data: null } },
        dd: dde,
        del: { attrs: { cite: null, datetime: null } },
        details: { attrs: { open: ["open"] } },
        dfn: dde,
        div: dde,
        dl: dde,
        dt: dde,
        em: dde,
        embed: { attrs: { src: null, type: null, width: null, height: null } },
        eventsource: { attrs: { src: null } },
        fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
        figcaption: dde,
        figure: dde,
        footer: dde,
        form: {
          attrs: {
            action: null,
            name: null,
            "accept-charset": ide,
            autocomplete: ["on", "off"],
            enctype: lde,
            method: sde,
            novalidate: ["novalidate"],
            target: ode,
          },
        },
        h1: dde,
        h2: dde,
        h3: dde,
        h4: dde,
        h5: dde,
        h6: dde,
        head: { children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"] },
        header: dde,
        hgroup: dde,
        hr: dde,
        html: { attrs: { manifest: null } },
        i: dde,
        iframe: {
          attrs: {
            src: null,
            srcdoc: null,
            name: null,
            width: null,
            height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"],
          },
        },
        img: {
          attrs: {
            alt: null,
            src: null,
            ismap: null,
            usemap: null,
            width: null,
            height: null,
            crossorigin: ["anonymous", "use-credentials"],
          },
        },
        input: {
          attrs: {
            alt: null,
            dirname: null,
            form: null,
            formaction: null,
            height: null,
            list: null,
            max: null,
            maxlength: null,
            min: null,
            name: null,
            pattern: null,
            placeholder: null,
            size: null,
            src: null,
            step: null,
            value: null,
            width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: lde,
            formmethod: sde,
            formnovalidate: ["novalidate"],
            formtarget: ode,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: [
              "hidden",
              "text",
              "search",
              "tel",
              "url",
              "email",
              "password",
              "datetime",
              "date",
              "month",
              "week",
              "time",
              "datetime-local",
              "number",
              "range",
              "color",
              "checkbox",
              "radio",
              "file",
              "submit",
              "image",
              "reset",
              "button",
            ],
          },
        },
        ins: { attrs: { cite: null, datetime: null } },
        kbd: dde,
        keygen: {
          attrs: {
            challenge: null,
            form: null,
            name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"],
          },
        },
        label: { attrs: { for: null, form: null } },
        legend: dde,
        li: { attrs: { value: null } },
        link: {
          attrs: {
            href: null,
            type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"],
          },
        },
        map: { attrs: { name: null } },
        mark: dde,
        menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
        meta: {
          attrs: {
            content: null,
            charset: ide,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"],
          },
        },
        meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
        nav: dde,
        noscript: dde,
        object: {
          attrs: {
            data: null,
            type: null,
            name: null,
            usemap: null,
            form: null,
            width: null,
            height: null,
            typemustmatch: ["typemustmatch"],
          },
        },
        ol: {
          attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
          children: ["li", "script", "template", "ul", "ol"],
        },
        optgroup: { attrs: { disabled: ["disabled"], label: null } },
        option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
        output: { attrs: { for: null, form: null, name: null } },
        p: dde,
        param: { attrs: { name: null, value: null } },
        pre: dde,
        progress: { attrs: { value: null, max: null } },
        q: { attrs: { cite: null } },
        rp: dde,
        rt: dde,
        ruby: dde,
        samp: dde,
        script: { attrs: { type: ["text/javascript"], src: null, async: ["async"], defer: ["defer"], charset: ide } },
        section: dde,
        select: {
          attrs: {
            form: null,
            name: null,
            size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"],
          },
        },
        slot: { attrs: { name: null } },
        small: dde,
        source: { attrs: { src: null, type: null, media: null } },
        span: dde,
        strong: dde,
        style: { attrs: { type: ["text/css"], media: null, scoped: null } },
        sub: dde,
        summary: dde,
        sup: dde,
        table: dde,
        tbody: dde,
        td: { attrs: { colspan: null, rowspan: null, headers: null } },
        template: dde,
        textarea: {
          attrs: {
            dirname: null,
            form: null,
            maxlength: null,
            name: null,
            placeholder: null,
            rows: null,
            cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"],
          },
        },
        tfoot: dde,
        th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
        thead: dde,
        time: { attrs: { datetime: null } },
        title: dde,
        tr: dde,
        track: {
          attrs: {
            src: null,
            label: null,
            default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null,
          },
        },
        ul: { children: ["li", "script", "template", "ul", "ol"] },
        var: dde,
        video: {
          attrs: {
            src: null,
            poster: null,
            width: null,
            height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"],
          },
        },
        wbr: dde,
      },
      pde = {
        accesskey: null,
        class: null,
        contenteditable: cde,
        contextmenu: null,
        dir: ["ltr", "rtl", "auto"],
        draggable: ["true", "false", "auto"],
        dropzone: ["copy", "move", "link", "string:", "file:"],
        hidden: ["hidden"],
        id: null,
        inert: ["inert"],
        itemid: null,
        itemprop: null,
        itemref: null,
        itemscope: ["itemscope"],
        itemtype: null,
        lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
        spellcheck: cde,
        autocorrect: cde,
        autocapitalize: cde,
        style: null,
        tabindex: null,
        title: null,
        translate: ["yes", "no"],
        rel: [
          "stylesheet",
          "alternate",
          "author",
          "bookmark",
          "help",
          "license",
          "next",
          "nofollow",
          "noreferrer",
          "prefetch",
          "prev",
          "search",
          "tag",
        ],
        role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(
          " ",
        ),
        "aria-activedescendant": null,
        "aria-atomic": cde,
        "aria-autocomplete": ["inline", "list", "both", "none"],
        "aria-busy": cde,
        "aria-checked": ["true", "false", "mixed", "undefined"],
        "aria-controls": null,
        "aria-describedby": null,
        "aria-disabled": cde,
        "aria-dropeffect": null,
        "aria-expanded": ["true", "false", "undefined"],
        "aria-flowto": null,
        "aria-grabbed": ["true", "false", "undefined"],
        "aria-haspopup": cde,
        "aria-hidden": cde,
        "aria-invalid": ["true", "false", "grammar", "spelling"],
        "aria-label": null,
        "aria-labelledby": null,
        "aria-level": null,
        "aria-live": ["off", "polite", "assertive"],
        "aria-multiline": cde,
        "aria-multiselectable": cde,
        "aria-owns": null,
        "aria-posinset": null,
        "aria-pressed": ["true", "false", "mixed", "undefined"],
        "aria-readonly": cde,
        "aria-relevant": null,
        "aria-required": cde,
        "aria-selected": ["true", "false", "undefined"],
        "aria-setsize": null,
        "aria-sort": ["ascending", "descending", "none", "other"],
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null,
        "aria-valuetext": null,
      },
      hde =
        "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload"
          .split(" ")
          .map((e) => "on" + e)
    for (let e of hde) pde[e] = null
    class fde {
      constructor(e, t) {
        ;(this.tags = Object.assign(Object.assign({}, ude), e)),
          (this.globalAttrs = Object.assign(Object.assign({}, pde), t)),
          (this.allTags = Object.keys(this.tags)),
          (this.globalAttrNames = Object.keys(this.globalAttrs))
      }
    }
    function mde(e, t, n = e.length) {
      if (!t) return ""
      let r = t.firstChild,
        a = r && r.getChild("TagName")
      return a ? e.sliceString(a.from, Math.min(a.to, n)) : ""
    }
    function gde(e, t = !1) {
      for (; e; e = e.parent)
        if ("Element" == e.name) {
          if (!t) return e
          t = !1
        }
      return null
    }
    function bde(e, t, n) {
      let r = n.tags[mde(e, gde(t))]
      return (null == r ? void 0 : r.children) || n.allTags
    }
    function vde(e, t) {
      let n = []
      for (let r = gde(t); r && !r.type.isTop; r = gde(r.parent)) {
        let a = mde(e, r)
        if (a && "CloseTag" == r.lastChild.name) break
        a && n.indexOf(a) < 0 && ("EndTag" == t.name || t.from >= r.firstChild.to) && n.push(a)
      }
      return n
    }
    fde.default = new fde()
    const yde = /^[:\-\.\w\u00b7-\uffff]*$/
    function Ode(e, t, n, r, a) {
      let o = /\s*>/.test(e.sliceDoc(a, a + 5)) ? "" : ">",
        i = gde(n, !0)
      return {
        from: r,
        to: a,
        options: bde(e.doc, i, t)
          .map((e) => ({ label: e, type: "type" }))
          .concat(vde(e.doc, n).map((e, t) => ({ label: "/" + e, apply: "/" + e + o, type: "type", boost: 99 - t }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/,
      }
    }
    function wde(e, t, n, r) {
      let a = /\s*>/.test(e.sliceDoc(r, r + 5)) ? "" : ">"
      return {
        from: n,
        to: r,
        options: vde(e.doc, t).map((e, t) => ({ label: e, apply: e + a, type: "type", boost: 99 - t })),
        validFor: yde,
      }
    }
    function xde(e) {
      let { extraTags: t, extraGlobalAttributes: n } = e,
        r = n || t ? new fde(t, n) : fde.default
      return (e) =>
        (function (e, t) {
          let { state: n, pos: r } = t,
            a = loe(n).resolveInner(r, -1),
            o = a.resolve(r)
          for (let e, t = r; o == a && (e = a.childBefore(t)); ) {
            let n = e.lastChild
            if (!n || !n.type.isError || n.from < n.to) break
            ;(o = a = e), (t = n.from)
          }
          return "TagName" == a.name
            ? a.parent && /CloseTag$/.test(a.parent.name)
              ? wde(n, a, a.from, r)
              : Ode(n, e, a, a.from, r)
            : "StartTag" == a.name
              ? Ode(n, e, a, r, r)
              : "StartCloseTag" == a.name || "IncompleteCloseTag" == a.name
                ? wde(n, a, r, r)
                : "OpenTag" == a.name || "SelfClosingTag" == a.name || "AttributeName" == a.name
                  ? (function (e, t, n, r, a) {
                      let o = gde(n),
                        i = o ? t.tags[mde(e.doc, o)] : null,
                        s = i && i.attrs ? Object.keys(i.attrs) : []
                      return {
                        from: r,
                        to: a,
                        options: (i && !1 === i.globalAttrs
                          ? s
                          : s.length
                            ? s.concat(t.globalAttrNames)
                            : t.globalAttrNames
                        ).map((e) => ({ label: e, type: "property" })),
                        validFor: yde,
                      }
                    })(n, e, a, "AttributeName" == a.name ? a.from : r, r)
                  : "Is" == a.name || "AttributeValue" == a.name || "UnquotedAttributeValue" == a.name
                    ? (function (e, t, n, r, a) {
                        var o
                        let i,
                          s = null === (o = n.parent) || void 0 === o ? void 0 : o.getChild("AttributeName"),
                          l = []
                        if (s) {
                          let o = e.sliceDoc(s.from, s.to),
                            c = t.globalAttrs[o]
                          if (!c) {
                            let r = gde(n),
                              a = r ? t.tags[mde(e.doc, r)] : null
                            c = (null == a ? void 0 : a.attrs) && a.attrs[o]
                          }
                          if (c) {
                            let t = e.sliceDoc(r, a).toLowerCase(),
                              n = '"',
                              o = '"'
                            ;/^['"]/.test(t)
                              ? ((i = '"' == t[0] ? /^[^"]*$/ : /^[^']*$/),
                                (n = ""),
                                (o = e.sliceDoc(a, a + 1) == t[0] ? "" : t[0]),
                                (t = t.slice(1)),
                                r++)
                              : (i = /^[^\s<>='"]*$/)
                            for (let e of c) l.push({ label: e, apply: n + e + o, type: "constant" })
                          }
                        }
                        return { from: r, to: a, options: l, validFor: i }
                      })(n, e, a, "Is" == a.name ? r : a.from, r)
                    : !t.explicit || ("Element" != o.name && "Text" != o.name && "Document" != o.name)
                      ? null
                      : (function (e, t, n, r) {
                          let a = [],
                            o = 0
                          for (let r of bde(e.doc, n, t)) a.push({ label: "<" + r, type: "type" })
                          for (let t of vde(e.doc, n)) a.push({ label: "</" + t + ">", type: "type", boost: 99 - o++ })
                          return { from: r, to: r, options: a, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ }
                        })(n, e, a, r)
        })(r, e)
    }
    const kde = Vce.parser.configure({ top: "SingleExpression" }),
      _de = [
        { tag: "script", attrs: (e) => "text/typescript" == e.type || "ts" == e.lang, parser: Xce.parser },
        { tag: "script", attrs: (e) => "text/babel" == e.type || "text/jsx" == e.type, parser: Yce.parser },
        { tag: "script", attrs: (e) => "text/typescript-jsx" == e.type, parser: Gce.parser },
        {
          tag: "script",
          attrs: (e) => /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(e.type),
          parser: kde,
        },
        {
          tag: "script",
          attrs: (e) => !e.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(e.type),
          parser: Vce.parser,
        },
        {
          tag: "style",
          attrs: (e) => (!e.lang || "css" == e.lang) && (!e.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(e.type)),
          parser: Zle.parser,
        },
      ],
      Sde = [{ name: "style", parser: Zle.parser.configure({ top: "Styles" }) }].concat(
        hde.map((e) => ({ name: e, parser: Vce.parser })),
      ),
      Ede = soe.define({
        name: "html",
        parser: yce.configure({
          props: [
            Soe.add({
              Element(e) {
                let t = /^(\s*)(<\/)?/.exec(e.textAfter)
                return e.node.to <= e.pos + t[0].length ? e.continue() : e.lineIndent(e.node.from) + (t[2] ? 0 : e.unit)
              },
              "OpenTag CloseTag SelfClosingTag": (e) => e.column(e.node.from) + e.unit,
              Document(e) {
                if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to) return e.continue()
                let t,
                  n = null
                for (let t = e.node; ; ) {
                  let e = t.lastChild
                  if (!e || "Element" != e.name || e.to != t.to) break
                  n = t = e
                }
                return n && (!(t = n.lastChild) || ("CloseTag" != t.name && "SelfClosingTag" != t.name))
                  ? e.lineIndent(n.from) + e.unit
                  : null
              },
            }),
            $oe.add({
              Element(e) {
                let t = e.firstChild,
                  n = e.lastChild
                return t && "OpenTag" == t.name ? { from: t.to, to: "CloseTag" == n.name ? n.from : e.to } : null
              },
            }),
            Goe.add({ "OpenTag CloseTag": (e) => e.getChild("TagName") }),
          ],
        }),
        languageData: {
          commentTokens: { block: { open: "\x3c!--", close: "--\x3e" } },
          indentOnInput: /^\s*<\/\w+\W$/,
          wordChars: "-._",
        },
      }),
      Tde = Ede.configure({ wrap: kce(_de, Sde) }),
      Ade = new Set(
        "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "),
      ),
      Cde = Tne.inputHandler.of((e, t, n, r, a) => {
        if (e.composing || e.state.readOnly || t != n || (">" != r && "/" != r) || !Tde.isActiveAt(e.state, t, -1))
          return !1
        let o = a(),
          { state: i } = o,
          s = i.changeByRange((e) => {
            var t, n, a
            let o,
              s = i.doc.sliceString(e.from - 1, e.to) == r,
              { head: l } = e,
              c = loe(i).resolveInner(l, -1)
            if (s && ">" == r && "EndTag" == c.name) {
              let r = c.parent
              if (
                "CloseTag" !=
                  (null === (n = null === (t = r.parent) || void 0 === t ? void 0 : t.lastChild) || void 0 === n
                    ? void 0
                    : n.name) &&
                (o = mde(i.doc, r.parent, l)) &&
                !Ade.has(o)
              )
                return {
                  range: e,
                  changes: { from: l, to: l + (">" === i.doc.sliceString(l, l + 1) ? 1 : 0), insert: `</${o}>` },
                }
            } else if (s && "/" == r && "IncompleteCloseTag" == c.name) {
              let e = c.parent
              if (
                c.from == l - 2 &&
                "CloseTag" != (null === (a = e.lastChild) || void 0 === a ? void 0 : a.name) &&
                (o = mde(i.doc, e, l)) &&
                !Ade.has(o)
              ) {
                let e = l + (">" === i.doc.sliceString(l, l + 1) ? 1 : 0),
                  t = `${o}>`
                return { range: w7.cursor(l + t.length, -1), changes: { from: l, to: e, insert: t } }
              }
            }
            return { range: e }
          })
        return (
          !s.changes.empty && (e.dispatch([o, i.update(s, { userEvent: "input.complete", scrollIntoView: !0 })]), !0)
        )
      }),
      Pde = Nae({
        String: eoe.string,
        Number: eoe.number,
        "True False": eoe.bool,
        PropertyName: eoe.propertyName,
        Null: eoe.null,
        ",": eoe.separator,
        "[ ]": eoe.squareBracket,
        "{ }": eoe.brace,
      }),
      Dde = yle.deserialize({
        version: 14,
        states:
          "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
        stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
        goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
        nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
        maxTerm: 25,
        nodeProps: [
          ["isolate", -2, 6, 11, ""],
          ["openedBy", 7, "{", 12, "["],
          ["closedBy", 8, "}", 13, "]"],
        ],
        propSources: [Pde],
        skippedNodes: [0],
        repeatNodeCount: 2,
        tokenData:
          "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
        tokenizers: [0],
        topRules: { JsonText: [0, 1] },
        tokenPrec: 0,
      }),
      Rde = soe.define({
        name: "json",
        parser: Dde.configure({
          props: [
            Soe.add({ Object: Noe({ except: /^\s*\}/ }), Array: Noe({ except: /^\s*\]/ }) }),
            $oe.add({ "Object Array": Ioe }),
          ],
        }),
        languageData: { closeBrackets: { brackets: ["[", "{", '"'] }, indentOnInput: /^\s*[\}\]]$/ },
      }),
      Nde = 63
    class $de {
      constructor(e, t, n) {
        ;(this.parent = e),
          (this.depth = t),
          (this.type = n),
          (this.hash = (e ? (e.hash + e.hash) << 8 : 0) + t + (t << 4) + n)
      }
    }
    function Ide(e, t) {
      for (let n = 0, r = t - e.pos - 1; ; r--, n++) {
        let t = e.peek(r)
        if (Lde(t) || -1 == t) return n
      }
    }
    function Mde(e) {
      return 32 == e || 9 == e
    }
    function Lde(e) {
      return 10 == e || 13 == e
    }
    function Qde(e) {
      return Mde(e) || Lde(e)
    }
    function Bde(e) {
      return e < 0 || Qde(e)
    }
    $de.top = new $de(null, -1, 0)
    const jde = new vle({
      start: $de.top,
      reduce: (e, t) => (3 != e.type || (20 != t && 34 != t) ? e : e.parent),
      shift(e, t, n, r) {
        if (3 == t) return new $de(e, Ide(r, r.pos), 1)
        if (65 == t || 5 == t) return new $de(e, Ide(r, r.pos), 2)
        if (t == Nde) return e.parent
        if (19 == t || 33 == t) return new $de(e, 0, 3)
        if (13 == t && 4 == e.type) return e.parent
        if (47 == t) {
          let t = /[1-9]/.exec(r.read(r.pos, n.pos))
          if (t) return new $de(e, e.depth + +t[0], 4)
        }
        return e
      },
      hash: (e) => e.hash,
    })
    function Ude(e, t, n = 0) {
      return e.peek(n) == t && e.peek(n + 1) == t && e.peek(n + 2) == t && Bde(e.peek(n + 3))
    }
    const Fde = new ole(
        (e, t) => {
          if (-1 == e.next && t.canShift(64)) return e.acceptToken(64)
          let n = e.peek(-1)
          if ((Lde(n) || n < 0) && 3 != t.context.type) {
            if (Ude(e, 45)) {
              if (!t.canShift(Nde)) return e.acceptToken(1, 3)
              e.acceptToken(Nde)
            }
            if (Ude(e, 46)) {
              if (!t.canShift(Nde)) return e.acceptToken(2, 3)
              e.acceptToken(Nde)
            }
            let n = 0
            for (; 32 == e.next; ) n++, e.advance()
            ;(!(n < t.context.depth) &&
              (n != t.context.depth || 1 != t.context.type || (45 == e.next && Bde(e.peek(1))))) ||
              -1 == e.next ||
              Lde(e.next) ||
              35 == e.next ||
              e.acceptToken(Nde, -n)
          }
        },
        { contextual: !0 },
      ),
      zde = new ole(
        (e, t) => {
          if (3 != t.context.type)
            if (45 == e.next)
              e.advance(),
                Bde(e.next) && e.acceptToken(1 == t.context.type && t.context.depth == Ide(e, e.pos - 1) ? 4 : 3)
            else if (63 == e.next)
              e.advance(),
                Bde(e.next) && e.acceptToken(2 == t.context.type && t.context.depth == Ide(e, e.pos - 1) ? 6 : 5)
            else {
              let n = e.pos
              for (;;)
                if (Mde(e.next)) {
                  if (e.pos == n) return
                  e.advance()
                } else if (33 == e.next) Hde(e)
                else {
                  if (38 != e.next) {
                    if (42 == e.next) {
                      Vde(e)
                      break
                    }
                    if (39 == e.next || 34 == e.next) {
                      if (Wde(e, !0)) break
                      return
                    }
                    if (91 == e.next || 123 == e.next) {
                      if (!Xde(e)) return
                      break
                    }
                    Jde(e, !0, !1, 0)
                    break
                  }
                  Vde(e)
                }
              for (; Mde(e.next); ) e.advance()
              if (58 == e.next) {
                if (e.pos == n && t.canShift(29)) return
                Bde(e.peek(1)) && e.acceptTokenTo(2 == t.context.type && t.context.depth == Ide(e, n) ? 66 : 65, n)
              }
            }
          else 63 == e.next && (e.advance(), Bde(e.next) && e.acceptToken(7))
        },
        { contextual: !0 },
      )
    function qde(e) {
      return (e >= 48 && e <= 57) || (e >= 97 && e <= 102) || (e >= 65 && e <= 70)
    }
    function Zde(e, t) {
      return 37 == e.next
        ? (e.advance(), qde(e.next) && e.advance(), qde(e.next) && e.advance(), !0)
        : !!(
            ((n = e.next) > 32 &&
              n < 127 &&
              34 != n &&
              37 != n &&
              44 != n &&
              60 != n &&
              62 != n &&
              92 != n &&
              94 != n &&
              96 != n &&
              123 != n &&
              124 != n &&
              125 != n) ||
            (t && 44 == e.next)
          ) && (e.advance(), !0)
      var n
    }
    function Hde(e) {
      if ((e.advance(), 60 == e.next)) {
        for (e.advance(); ; )
          if (!Zde(e, !0)) {
            62 == e.next && e.advance()
            break
          }
      } else for (; Zde(e, !1); );
    }
    function Vde(e) {
      for (e.advance(); !Bde(e.next) && "f" != Gde(e.tag); ) e.advance()
    }
    function Wde(e, t) {
      let n = e.next,
        r = !1,
        a = e.pos
      for (e.advance(); ; ) {
        let o = e.next
        if (o < 0) break
        if ((e.advance(), o == n)) {
          if (39 != o) break
          if (39 != e.next) break
          e.advance()
        } else if (92 == o && 34 == n) e.next >= 0 && e.advance()
        else if (Lde(o)) {
          if (t) return !1
          r = !0
        } else if (t && e.pos >= a + 1024) return !1
      }
      return !r
    }
    function Xde(e) {
      for (let t = [], n = e.pos + 1024; ; )
        if (91 == e.next || 123 == e.next) t.push(e.next), e.advance()
        else if (39 == e.next || 34 == e.next) {
          if (!Wde(e, !0)) return !1
        } else if (93 == e.next || 125 == e.next) {
          if (t[t.length - 1] != e.next - 2) return !1
          if ((t.pop(), e.advance(), !t.length)) return !0
        } else {
          if (e.next < 0 || e.pos > n || Lde(e.next)) return !1
          e.advance()
        }
    }
    const Yde = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif"
    function Gde(e) {
      return e < 33 ? "u" : e > 125 ? "s" : Yde[e - 33]
    }
    function Kde(e, t) {
      let n = Gde(e)
      return "u" != n && !(t && "f" == n)
    }
    function Jde(e, t, n, r) {
      if ("s" != Gde(e.next) && ((63 != e.next && 58 != e.next && 45 != e.next) || !Kde(e.peek(1), n))) return !1
      e.advance()
      let a = e.pos
      for (;;) {
        let o = e.next,
          i = 0,
          s = r + 1
        for (; Qde(o); ) {
          if (Lde(o)) {
            if (t) return !1
            s = 0
          } else s++
          o = e.peek(++i)
        }
        if (
          !(o >= 0 && (58 == o ? Kde(e.peek(i + 1), n) : 35 == o ? 32 != e.peek(i - 1) : Kde(o, n))) ||
          (!n && s <= r) ||
          (0 == s && !n && (Ude(e, 45, i) || Ude(e, 46, i)))
        )
          break
        if (t && "f" == Gde(o)) return !1
        for (let t = i; t >= 0; t--) e.advance()
        if (t && e.pos > a + 1024) return !1
      }
      return !0
    }
    const eue = new ole((e, t) => {
        if (33 == e.next) Hde(e), e.acceptToken(12)
        else if (38 == e.next || 42 == e.next) {
          let t = 38 == e.next ? 10 : 11
          Vde(e), e.acceptToken(t)
        } else
          39 == e.next || 34 == e.next
            ? (Wde(e, !1), e.acceptToken(9))
            : Jde(e, !1, 3 == t.context.type, t.context.depth) && e.acceptToken(8)
      }),
      tue = new ole((e, t) => {
        let n = 4 == t.context.type ? t.context.depth : -1,
          r = e.pos
        e: for (;;) {
          let a = 0,
            o = e.next
          for (; 32 == o; ) o = e.peek(++a)
          if (!a && (Ude(e, 45, a) || Ude(e, 46, a))) break
          if (!Lde(o) && (n < 0 && (n = Math.max(t.context.depth + 1, a)), a < n)) break
          for (;;) {
            if (e.next < 0) break e
            let t = Lde(e.next)
            if ((e.advance(), t)) continue e
            r = e.pos
          }
        }
        e.acceptTokenTo(13, r)
      }),
      nue = Nae({
        DirectiveName: eoe.keyword,
        DirectiveContent: eoe.attributeValue,
        "DirectiveEnd DocEnd": eoe.meta,
        QuotedLiteral: eoe.string,
        BlockLiteralHeader: eoe.special(eoe.string),
        BlockLiteralContent: eoe.content,
        Literal: eoe.content,
        "Key/Literal Key/QuotedLiteral": eoe.definition(eoe.propertyName),
        "Anchor Alias": eoe.labelName,
        Tag: eoe.typeName,
        Comment: eoe.lineComment,
        ": , -": eoe.separator,
        "?": eoe.punctuation,
        "[ ]": eoe.squareBracket,
        "{ }": eoe.brace,
      }),
      rue = yle.deserialize({
        version: 14,
        states:
          "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
        stateData:
          ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
        goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
        nodeNames:
          " DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
        maxTerm: 74,
        context: jde,
        nodeProps: [
          ["isolate", -3, 8, 9, 14, ""],
          ["openedBy", 18, "[", 32, "{"],
          ["closedBy", 19, "]", 33, "}"],
        ],
        propSources: [nue],
        skippedNodes: [0],
        repeatNodeCount: 6,
        tokenData:
          "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
        tokenizers: [Fde, zde, eue, tue, 0, 1],
        topRules: { Stream: [0, 15] },
        tokenPrec: 0,
      }),
      aue = soe.define({
        name: "yaml",
        parser: rue.configure({
          props: [
            Soe.add({
              Stream: (e) => {
                for (let t = e.node.resolve(e.pos, -1); t && t.to >= e.pos; t = t.parent) {
                  if ("BlockLiteralContent" == t.name && t.from < t.to) return e.baseIndentFor(t)
                  if ("BlockLiteral" == t.name) return e.baseIndentFor(t) + e.unit
                  if ("BlockSequence" == t.name || "BlockMapping" == t.name) return e.column(t.from, 1)
                  if ("QuotedLiteral" == t.name) return null
                  if ("Literal" == t.name) {
                    let n = e.column(t.from, 1)
                    if (n == e.lineIndent(t.from, 1)) return n
                    if (t.to > e.pos) return null
                  }
                }
                return null
              },
              FlowMapping: Doe({ closing: "}" }),
              FlowSequence: Doe({ closing: "]" }),
            }),
            $oe.add({
              "FlowMapping FlowSequence": Ioe,
              "BlockSequence Pair BlockLiteral": (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to }),
            }),
          ],
        }),
        languageData: { commentTokens: { line: "#" }, indentOnInput: /^\s*[\]\}]$/ },
      })
    function oue() {
      var e = arguments[0]
      "string" == typeof e && (e = document.createElement(e))
      var t = 1,
        n = arguments[1]
      if (n && "object" == typeof n && null == n.nodeType && !Array.isArray(n)) {
        for (var r in n)
          if (Object.prototype.hasOwnProperty.call(n, r)) {
            var a = n[r]
            "string" == typeof a ? e.setAttribute(r, a) : null != a && (e[r] = a)
          }
        t++
      }
      for (; t < arguments.length; t++) iue(e, arguments[t])
      return e
    }
    function iue(e, t) {
      if ("string" == typeof t) e.appendChild(document.createTextNode(t))
      else if (null == t);
      else if (null != t.nodeType) e.appendChild(t)
      else {
        if (!Array.isArray(t)) throw new RangeError("Unsupported child node: " + t)
        for (var n = 0; n < t.length; n++) iue(e, t[n])
      }
    }
    class sue {
      constructor(e, t, n) {
        ;(this.from = e), (this.to = t), (this.diagnostic = n)
      }
    }
    class lue {
      constructor(e, t, n) {
        ;(this.diagnostics = e), (this.panel = t), (this.selected = n)
      }
      static init(e, t, n) {
        let r = e,
          a = n.facet(yue).markerFilter
        a && (r = a(r, n))
        let o = U9.set(
          r.map((e) =>
            e.from == e.to || (e.from == e.to - 1 && n.doc.lineAt(e.from).to == e.from)
              ? U9.widget({ widget: new xue(e), diagnostic: e }).range(e.from)
              : U9.mark({
                  attributes: {
                    class: "cm-lintRange cm-lintRange-" + e.severity + (e.markClass ? " " + e.markClass : ""),
                  },
                  diagnostic: e,
                }).range(e.from, e.to),
          ),
          !0,
        )
        return new lue(o, t, cue(o))
      }
    }
    function cue(e, t = null, n = 0) {
      let r = null
      return (
        e.between(n, 1e9, (e, n, { spec: a }) => {
          if (!t || a.diagnostic == t) return (r = new sue(e, n, a.diagnostic)), !1
        }),
        r
      )
    }
    function due(e, t) {
      return e.field(fue, !1) ? t : t.concat(Y7.appendConfig.of(Tue))
    }
    const uue = Y7.define(),
      pue = Y7.define(),
      hue = Y7.define(),
      fue = D7.define({
        create: () => new lue(U9.none, null, null),
        update(e, t) {
          if (t.docChanged && e.diagnostics.size) {
            let n = e.diagnostics.map(t.changes),
              r = null,
              a = e.panel
            if (e.selected) {
              let a = t.changes.mapPos(e.selected.from, 1)
              r = cue(n, e.selected.diagnostic, a) || cue(n, null, a)
            }
            !n.size && a && t.state.facet(yue).autoPanel && (a = null), (e = new lue(n, a, r))
          }
          for (let n of t.effects)
            if (n.is(uue)) {
              let r = t.state.facet(yue).autoPanel ? (n.value.length ? _ue.open : null) : e.panel
              e = lue.init(n.value, r, t.state)
            } else
              n.is(pue)
                ? (e = new lue(e.diagnostics, n.value ? _ue.open : null, e.selected))
                : n.is(hue) && (e = new lue(e.diagnostics, e.panel, n.value))
          return e
        },
        provide: (e) => [yre.from(e, (e) => e.panel), Tne.decorations.from(e, (e) => e.diagnostics)],
      }),
      mue = U9.mark({ class: "cm-lintRange cm-lintRange-active" })
    function gue(e, t) {
      return oue(
        "ul",
        { class: "cm-tooltip-lint" },
        t.map((t) => wue(e, t, !1)),
      )
    }
    const bue = (e) => {
        let t = e.state.field(fue, !1)
        return !(!t || !t.panel || (e.dispatch({ effects: pue.of(!1) }), 0))
      },
      vue = Ree.fromClass(
        class {
          constructor(e) {
            ;(this.view = e), (this.timeout = -1), (this.set = !0)
            let { delay: t } = e.state.facet(yue)
            ;(this.lintTime = Date.now() + t),
              (this.run = this.run.bind(this)),
              (this.timeout = setTimeout(this.run, t))
          }
          run() {
            clearTimeout(this.timeout)
            let e = Date.now()
            if (e < this.lintTime - 10) this.timeout = setTimeout(this.run, this.lintTime - e)
            else {
              this.set = !1
              let { state: e } = this.view,
                { sources: t } = e.facet(yue)
              t.length &&
                Promise.all(t.map((e) => Promise.resolve(e(this.view)))).then(
                  (t) => {
                    let n = t.reduce((e, t) => e.concat(t))
                    this.view.state.doc == e.doc &&
                      this.view.dispatch(
                        (function (e, t) {
                          return { effects: due(e, [uue.of(t)]) }
                        })(this.view.state, n),
                      )
                  },
                  (e) => {
                    Aee(this.view.state, e)
                  },
                )
            }
          }
          update(e) {
            let t = e.state.facet(yue)
            ;(e.docChanged || t != e.startState.facet(yue) || (t.needsRefresh && t.needsRefresh(e))) &&
              ((this.lintTime = Date.now() + t.delay),
              this.set || ((this.set = !0), (this.timeout = setTimeout(this.run, t.delay))))
          }
          force() {
            this.set && ((this.lintTime = Date.now()), this.run())
          }
          destroy() {
            clearTimeout(this.timeout)
          }
        },
      ),
      yue = _7.define({
        combine: (e) =>
          Object.assign(
            { sources: e.map((e) => e.source).filter((e) => null != e) },
            l6(
              e.map((e) => e.config),
              { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null, hideOn: () => null },
              { needsRefresh: (e, t) => (e ? (t ? (n) => e(n) || t(n) : e) : t) },
            ),
          ),
      })
    function Oue(e) {
      let t = []
      if (e)
        e: for (let { name: n } of e) {
          for (let e = 0; e < n.length; e++) {
            let r = n[e]
            if (/[a-zA-Z]/.test(r) && !t.some((e) => e.toLowerCase() == r.toLowerCase())) {
              t.push(r)
              continue e
            }
          }
          t.push("")
        }
      return t
    }
    function wue(e, t, n) {
      var r
      let a = n ? Oue(t.actions) : []
      return oue(
        "li",
        { class: "cm-diagnostic cm-diagnostic-" + t.severity },
        oue("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage(e) : t.message),
        null === (r = t.actions) || void 0 === r
          ? void 0
          : r.map((n, r) => {
              let o = !1,
                i = (r) => {
                  if ((r.preventDefault(), o)) return
                  o = !0
                  let a = cue(e.state.field(fue).diagnostics, t)
                  a && n.apply(e, a.from, a.to)
                },
                { name: s } = n,
                l = a[r] ? s.indexOf(a[r]) : -1,
                c = l < 0 ? s : [s.slice(0, l), oue("u", s.slice(l, l + 1)), s.slice(l + 1)]
              return oue(
                "button",
                {
                  type: "button",
                  class: "cm-diagnosticAction",
                  onclick: i,
                  onmousedown: i,
                  "aria-label": ` Action: ${s}${l < 0 ? "" : ` (access key "${a[r]})"`}.`,
                },
                c,
              )
            }),
        t.source && oue("div", { class: "cm-diagnosticSource" }, t.source),
      )
    }
    class xue extends B9 {
      constructor(e) {
        super(), (this.diagnostic = e)
      }
      eq(e) {
        return e.diagnostic == this.diagnostic
      }
      toDOM() {
        return oue("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity })
      }
    }
    class kue {
      constructor(e, t) {
        ;(this.diagnostic = t),
          (this.id = "item_" + Math.floor(4294967295 * Math.random()).toString(16)),
          (this.dom = wue(e, t, !0)),
          (this.dom.id = this.id),
          this.dom.setAttribute("role", "option")
      }
    }
    class _ue {
      constructor(e) {
        ;(this.view = e),
          (this.items = []),
          (this.list = oue("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown: (t) => {
              if (27 == t.keyCode) bue(this.view), this.view.focus()
              else if (38 == t.keyCode || 33 == t.keyCode)
                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length)
              else if (40 == t.keyCode || 34 == t.keyCode)
                this.moveSelection((this.selectedIndex + 1) % this.items.length)
              else if (36 == t.keyCode) this.moveSelection(0)
              else if (35 == t.keyCode) this.moveSelection(this.items.length - 1)
              else if (13 == t.keyCode) this.view.focus()
              else {
                if (!(t.keyCode >= 65 && t.keyCode <= 90 && this.selectedIndex >= 0)) return
                {
                  let { diagnostic: n } = this.items[this.selectedIndex],
                    r = Oue(n.actions)
                  for (let a = 0; a < r.length; a++)
                    if (r[a].toUpperCase().charCodeAt(0) == t.keyCode) {
                      let t = cue(this.view.state.field(fue).diagnostics, n)
                      t && n.actions[a].apply(e, t.from, t.to)
                    }
                }
              }
              t.preventDefault()
            },
            onclick: (e) => {
              for (let t = 0; t < this.items.length; t++) this.items[t].dom.contains(e.target) && this.moveSelection(t)
            },
          })),
          (this.dom = oue(
            "div",
            { class: "cm-panel-lint" },
            this.list,
            oue(
              "button",
              {
                type: "button",
                name: "close",
                "aria-label": this.view.state.phrase("close"),
                onclick: () => bue(this.view),
              },
              "",
            ),
          )),
          this.update()
      }
      get selectedIndex() {
        let e = this.view.state.field(fue).selected
        if (!e) return -1
        for (let t = 0; t < this.items.length; t++) if (this.items[t].diagnostic == e.diagnostic) return t
        return -1
      }
      update() {
        let { diagnostics: e, selected: t } = this.view.state.field(fue),
          n = 0,
          r = !1,
          a = null
        for (
          e.between(0, this.view.state.doc.length, (e, o, { spec: i }) => {
            let s,
              l = -1
            for (let e = n; e < this.items.length; e++)
              if (this.items[e].diagnostic == i.diagnostic) {
                l = e
                break
              }
            l < 0
              ? ((s = new kue(this.view, i.diagnostic)), this.items.splice(n, 0, s), (r = !0))
              : ((s = this.items[l]), l > n && (this.items.splice(n, l - n), (r = !0))),
              t && s.diagnostic == t.diagnostic
                ? s.dom.hasAttribute("aria-selected") || (s.dom.setAttribute("aria-selected", "true"), (a = s))
                : s.dom.hasAttribute("aria-selected") && s.dom.removeAttribute("aria-selected"),
              n++
          });
          n < this.items.length && !(1 == this.items.length && this.items[0].diagnostic.from < 0);

        )
          (r = !0), this.items.pop()
        0 == this.items.length &&
          (this.items.push(
            new kue(this.view, {
              from: -1,
              to: -1,
              severity: "info",
              message: this.view.state.phrase("No diagnostics"),
            }),
          ),
          (r = !0)),
          a
            ? (this.list.setAttribute("aria-activedescendant", a.id),
              this.view.requestMeasure({
                key: this,
                read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
                write: ({ sel: e, panel: t }) => {
                  let n = t.height / this.list.offsetHeight
                  e.top < t.top
                    ? (this.list.scrollTop -= (t.top - e.top) / n)
                    : e.bottom > t.bottom && (this.list.scrollTop += (e.bottom - t.bottom) / n)
                },
              }))
            : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"),
          r && this.sync()
      }
      sync() {
        let e = this.list.firstChild
        function t() {
          let t = e
          ;(e = t.nextSibling), t.remove()
        }
        for (let n of this.items)
          if (n.dom.parentNode == this.list) {
            for (; e != n.dom; ) t()
            e = n.dom.nextSibling
          } else this.list.insertBefore(n.dom, e)
        for (; e; ) t()
      }
      moveSelection(e) {
        if (this.selectedIndex < 0) return
        let t = cue(this.view.state.field(fue).diagnostics, this.items[e].diagnostic)
        t && this.view.dispatch({ selection: { anchor: t.from, head: t.to }, scrollIntoView: !0, effects: hue.of(t) })
      }
      static open(e) {
        return new _ue(e)
      }
    }
    function Sue(e) {
      return (function (e, t = 'viewBox="0 0 40 40"') {
        return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`
      })(
        `<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`,
        'width="6" height="3"',
      )
    }
    const Eue = Tne.baseTheme({
        ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" },
        ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
        ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
        ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
        ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
        ".cm-diagnosticAction": {
          font: "inherit",
          border: "none",
          padding: "2px 4px",
          backgroundColor: "#444",
          color: "white",
          borderRadius: "3px",
          marginLeft: "8px",
          cursor: "pointer",
        },
        ".cm-diagnosticSource": { fontSize: "70%", opacity: 0.7 },
        ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" },
        ".cm-lintRange-error": { backgroundImage: Sue("#d11") },
        ".cm-lintRange-warning": { backgroundImage: Sue("orange") },
        ".cm-lintRange-info": { backgroundImage: Sue("#999") },
        ".cm-lintRange-hint": { backgroundImage: Sue("#66d") },
        ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
        ".cm-tooltip-lint": { padding: 0, margin: 0 },
        ".cm-lintPoint": {
          position: "relative",
          "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11",
          },
        },
        ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } },
        ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } },
        ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } },
        ".cm-panel.cm-panel-lint": {
          position: "relative",
          "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } },
            "&:focus [aria-selected]": {
              background_fallback: "#bdf",
              backgroundColor: "Highlight",
              color_fallback: "white",
              color: "HighlightText",
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0,
          },
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0,
          },
        },
      }),
      Tue = [
        fue,
        Tne.decorations.compute([fue], (e) => {
          let { selected: t, panel: n } = e.field(fue)
          return t && n && t.from != t.to ? U9.set([mue.range(t.from, t.to)]) : U9.none
        }),
        (function (e, t = {}) {
          let n = Y7.define(),
            r = D7.define({
              create: () => [],
              update(e, r) {
                if (
                  e.length &&
                  (t.hideOnChange && (r.docChanged || r.selection)
                    ? (e = [])
                    : t.hideOn && (e = e.filter((e) => !t.hideOn(r, e))),
                  r.docChanged)
                ) {
                  let t = []
                  for (let n of e) {
                    let e = r.changes.mapPos(n.pos, -1, u7.TrackDel)
                    if (null != e) {
                      let a = Object.assign(Object.create(null), n)
                      ;(a.pos = e), null != a.end && (a.end = r.changes.mapPos(a.end)), t.push(a)
                    }
                  }
                  e = t
                }
                for (let t of r.effects) t.is(n) && (e = t.value), t.is(fre) && (e = [])
                return e
              },
              provide: (e) => lre.from(e),
            })
          return [r, Ree.define((a) => new ure(a, e, r, n, t.hoverTime || 300)), dre]
        })(
          function (e, t, n) {
            let { diagnostics: r } = e.state.field(fue),
              a = [],
              o = 2e8,
              i = 0
            r.between(t - (n < 0 ? 1 : 0), t + (n > 0 ? 1 : 0), (e, r, { spec: s }) => {
              t >= e &&
                t <= r &&
                (e == r || ((t > e || n > 0) && (t < r || n < 0))) &&
                (a.push(s.diagnostic), (o = Math.min(e, o)), (i = Math.max(r, i)))
            })
            let s = e.state.facet(yue).tooltipFilter
            return (
              s && (a = s(a, e.state)),
              a.length
                ? { pos: o, end: i, above: e.state.doc.lineAt(o).to < i, create: () => ({ dom: gue(e, a) }) }
                : null
            )
          },
          {
            hideOn: function (e, t) {
              let n = t.pos,
                r = t.end || n,
                a = e.state.facet(yue).hideOn(e, n, r)
              if (null != a) return a
              let o = e.startState.doc.lineAt(t.pos)
              return !(!e.effects.some((e) => e.is(uue)) && !e.changes.touchesRange(o.from, Math.max(o.to, r)))
            },
          },
        ),
        Eue,
      ],
      Aue = ((e) => {
        var { theme: t, settings: n = {}, styles: r = [] } = e,
          a = { ".cm-gutters": {} },
          o = {}
        n.background && (o.backgroundColor = n.background),
          n.backgroundImage && (o.backgroundImage = n.backgroundImage),
          n.foreground && (o.color = n.foreground),
          n.fontSize && (o.fontSize = n.fontSize),
          (n.background || n.foreground) && (a["&"] = o),
          n.fontFamily && (a["&.cm-editor .cm-scroller"] = { fontFamily: n.fontFamily }),
          n.gutterBackground && (a[".cm-gutters"].backgroundColor = n.gutterBackground),
          n.gutterForeground && (a[".cm-gutters"].color = n.gutterForeground),
          n.gutterBorder && (a[".cm-gutters"].borderRightColor = n.gutterBorder),
          n.caret &&
            ((a[".cm-content"] = { caretColor: n.caret }),
            (a[".cm-cursor, .cm-dropCursor"] = { borderLeftColor: n.caret }))
        var i = {}
        return (
          n.gutterActiveForeground && (i.color = n.gutterActiveForeground),
          n.lineHighlight &&
            ((a[".cm-activeLine"] = { backgroundColor: n.lineHighlight }), (i.backgroundColor = n.lineHighlight)),
          (a[".cm-activeLineGutter"] = i),
          n.selection &&
            (a[
              "&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"
            ] = { background: n.selection + " !important" }),
          n.selectionMatch && (a["& .cm-selectionMatch"] = { backgroundColor: n.selectionMatch }),
          [Tne.theme(a, { dark: "dark" === t }), joe(Moe.define(r))]
        )
      })({
        theme: "light",
        settings: {
          background: "var(--scalar-background-2)",
          foreground: "var(--scalar-color-1)",
          caret: "var(--scalar-color-1)",
          selection: "rgba(151, 183, 205, 0.2)",
          selectionMatch: "#e3dcce",
          gutterBackground: "var(--scalar-background-2)",
          gutterForeground: "var(--scalar-color-3)",
          gutterBorder: "transparent",
          lineHighlight: "var(--scalar-background-3)",
          fontFamily: "var(--scalar-font-code)",
        },
        styles: [
          { tag: [eoe.standard(eoe.tagName), eoe.tagName], color: "var(--scalar-color-purple)" },
          { tag: [eoe.comment], color: "var(--scalar-color-3)" },
          { tag: [eoe.className], color: "var(--scalar-color-orange)" },
          { tag: [eoe.variableName, eoe.propertyName, eoe.attributeName], color: "var(--scalar-color-1)" },
          { tag: [eoe.operator], color: "var(--scalar-color-2)" },
          { tag: [eoe.keyword, eoe.typeName, eoe.typeOperator], color: "var(--scalar-color-green)" },
          { tag: [eoe.string], color: "var(--scalar-color-blue)" },
          { tag: [eoe.bracket, eoe.regexp, eoe.meta], color: "var(--scalar-color-3)" },
          { tag: [eoe.number], color: "var(--scalar-color-blue)" },
          { tag: [eoe.name, eoe.quote], color: "var(--scalar-color-3)" },
          { tag: [eoe.heading], color: "var(--scalar-color-3)", fontWeight: "bold" },
          { tag: [eoe.emphasis], color: "var(--scalar-color-3)", fontStyle: "italic" },
          { tag: [eoe.deleted], color: "var(--scalar-color-3)", backgroundColor: "transparent" },
          { tag: [eoe.atom, eoe.bool, eoe.special(eoe.variableName)], color: "var(--scalar-color-3)" },
          { tag: [eoe.url, eoe.escape, eoe.regexp, eoe.link], color: "var(--scalar-color-1)" },
          { tag: eoe.link, textDecoration: "underline" },
          { tag: eoe.strikethrough, textDecoration: "line-through" },
          { tag: eoe.invalid, color: "var(--scalar-color-3)" },
        ],
      })
    var Cue = Object.defineProperty
    const Pue = new Fne({
        regexp: /(\{[^}]+\})/g,
        decoration: () => U9.mark({ attributes: { class: "api-client-url-variable" } }),
      }),
      Due = () =>
        Ree.fromClass(
          class {
            constructor(e) {
              ;((e, t, n) => {
                ;((e, t, n) => {
                  t in e ? Cue(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)
                })(e, t + "", n)
              })(this, "variables"),
                (this.variables = Pue.createDeco(e))
            }
            update(e) {
              this.variables = Pue.updateDeco(e, this.variables)
            }
          },
          {
            decorations: (e) => e.variables,
            provide: (e) =>
              Tne.atomicRanges.of((t) => {
                var n
                return (null == (n = t.plugin(e)) ? void 0 : n.variables) || U9.none
              }),
          },
        ),
      Rue = (e) => "provider" in e && !!Mn(e.provider),
      Nue = {
        key: "Mod-a",
        run: (e) => (e.dispatch({ selection: { anchor: 0, head: e.state.doc.length }, scrollIntoView: !1 }), !0),
      },
      $ue = (e) => {
        const t = Dn(null)
        function n() {
          if (e.codeMirrorRef.value) {
            const n = Rue(e) ? Mn(e.provider) : null,
              o = Mue({ ...r.value, provider: n })
            ;(t.value = new Tne({ parent: e.codeMirrorRef.value, extensions: o })), Rue(e) || a(Mn(e.content))
          }
        }
        Ya(
          e.codeMirrorRef,
          () => {
            var e
            null == (e = t.value) || e.destroy(), n()
          },
          { immediate: !0 },
        ),
          Mr(() => {
            var e
            return null == (e = t.value) ? void 0 : e.destroy()
          })
        const r = ii(() => ({
          onChange: e.onChange,
          onBlur: e.onBlur,
          onFocus: e.onFocus,
          disableTabIndent: Mn(e.disableTabIndent),
          language: Mn(e.language),
          classes: Mn(e.classes),
          readOnly: Mn(e.readOnly),
          lineNumbers: Mn(e.lineNumbers),
          withVariables: Mn(e.withVariables),
          disableEnter: Mn(e.disableEnter),
          disableCloseBrackets: Mn(e.disableCloseBrackets),
          withoutTheme: Mn(e.withoutTheme),
          lint: Mn(e.lint),
          additionalExtensions: Mn(e.extensions),
          placeholder: Mn(e.placeholder),
        }))
        Ya(
          () => (Rue(e) ? Mn(e.provider) : null),
          () => {
            var r
            Rue(e) && (null == (r = t.value) || r.destroy(), n())
          },
        ),
          Ya(
            r,
            () => {
              if (t.value) {
                const n = Rue(e) ? Mn(e.provider) : null,
                  a = Mue({ ...r.value, provider: n })
                t.value.dispatch({ effects: Y7.reconfigure.of(a) })
              }
            },
            { immediate: !0 },
          )
        const a = (e = "") => {
          t.value &&
            t.value.state.doc.toString() !== e &&
            t.value.dispatch({
              changes: { from: 0, to: t.value.state.doc.length, insert: e },
              selection: { anchor: Math.min(t.value.state.selection.main.anchor, e.length) },
            })
        }
        return (
          Ya(
            () => Mn(e.content),
            () => {
              Rue(e) || a(Mn(e.content))
            },
            { immediate: !0 },
          ),
          { setCodeMirrorContent: a, codeMirror: t }
        )
      },
      Iue = {
        html: function (e = {}) {
          let t,
            n = ""
          !1 === e.matchClosingTags && (n = "noMatch"),
            !0 === e.selfClosingTags && (n = (n ? n + " " : "") + "selfClosing"),
            ((e.nestedLanguages && e.nestedLanguages.length) || (e.nestedAttributes && e.nestedAttributes.length)) &&
              (t = kce((e.nestedLanguages || []).concat(_de), (e.nestedAttributes || []).concat(Sde)))
          let r = t ? Ede.configure({ wrap: t, dialect: n }) : n ? Tde.configure({ dialect: n }) : Tde
          return new voe(r, [
            Tde.data.of({ autocomplete: xde(e) }),
            !1 !== e.autoCloseTags ? Cde : [],
            tde().support,
            Hle().support,
          ])
        },
        json: function () {
          return new voe(Rde)
        },
        yaml: function () {
          return new voe(aue)
        },
        css: Hle,
      }
    function Mue({
      onChange: e,
      onBlur: t,
      onFocus: n,
      provider: r,
      language: a,
      classes: o = [],
      readOnly: i = !1,
      lineNumbers: s = !1,
      withVariables: l = !1,
      disableEnter: c = !1,
      disableCloseBrackets: d = !1,
      disableTabIndent: u = !1,
      withoutTheme: p = !1,
      lint: h = !1,
      additionalExtensions: f = [],
      placeholder: m,
    }) {
      const g = [
        Wne(),
        joe(Foe, { fallback: !0 }),
        Tne.theme({
          ".cm-line": { lineHeight: "20px" },
          ".cm-gutterElement": { lineHeight: "20px" },
          ".cm-tooltip": { border: "1px solid #f5c6cb", fontSize: "12px" },
          ".cm-tooltip-lint": { backgroundColor: "#ffffff" },
          ".cm-diagnostic-error": { borderLeft: "0", color: "#dc1b19" },
        }),
        Tne.updateListener.of((t) => {
          t.docChanged && (null == e || e(t.state.doc.toString()))
        }),
        Tne.domEventHandlers({
          blur: (e, n) => {
            null == t || t(n.state.doc.toString())
          },
          focus: (e, t) => {
            null == n || n(t.state.doc.toString())
          },
        }),
        Tne.editorAttributes.of({ class: o.join(" ") }),
        ...f,
      ]
      if (
        (r && g.push(r),
        p || g.push(Aue),
        i
          ? g.push(Tne.editable.of(!1))
          : (g.push(
              s6.transactionFilter.of((e) => {
                if (!e.docChanged || (!e.isUserEvent("input.type") && !e.isUserEvent("input.complete"))) return e
                let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head)
                if (!t.length) return e
                let n = e.newDoc,
                  { head: r } = e.newSelection.main,
                  a = n.lineAt(r)
                if (r > a.from + 200) return e
                let o = n.sliceString(a.from, r)
                if (!t.some((e) => e.test(o))) return e
                let { state: i } = e,
                  s = -1,
                  l = []
                for (let { head: e } of i.selection.ranges) {
                  let t = i.doc.lineAt(e)
                  if (t.from == s) continue
                  s = t.from
                  let n = koe(i, t.from)
                  if (null == n) continue
                  let r = /^\s*/.exec(t.text)[0],
                    a = xoe(i, n)
                  r != a && l.push({ from: t.from, to: t.from + r.length, insert: a })
                }
                return l.length ? [e, { changes: l, sequential: !0 }] : e
              }),
              Yoe(),
              (function (e = {}) {
                return [lse, tse, Bie.of(e), ise, Zse, cse]
              })(),
              Ine.of([...qse, Nue]),
              Yoe(),
            ),
            d || g.push([Ise, Pse], Ine.of([...Mse])),
            u ? g.push(Ine.of([{ key: "Tab", run: () => !1, shift: () => !1 }])) : g.push(Ine.of([Wse]))),
        m &&
          g.push(
            ((b = m),
            Ree.fromClass(
              class {
                constructor(e) {
                  ;(this.view = e),
                    (this.placeholder = b ? U9.set([U9.widget({ widget: new Kne(b), side: 1 }).range(0)]) : U9.none)
                }
                get decorations() {
                  return this.view.state.doc.length ? U9.none : this.placeholder
                }
              },
              { decorations: (e) => e.decorations },
            )),
          ),
        a && Iue[a] && g.push(Iue[a]()),
        h && "json" === a)
      ) {
        const e = (function (e, t = {}) {
          return [yue.of({ source: e, config: t }), vue, Tue]
        })((e) => {
          const t = []
          try {
            JSON.parse(e.state.doc.toString())
          } catch (n) {
            n instanceof Error && t.push({ from: 0, to: e.state.doc.length, severity: "error", message: n.message })
          }
          return t
        })
        g.push(e)
      }
      var b
      return (
        s &&
          g.push(
            (function (e = {}) {
              return [Dre.of(e), [_re], $re]
            })(),
          ),
        l && g.push(Due()),
        c
          ? g.push(
              Ine.of([
                { key: "Enter", run: () => !0 },
                { key: "Ctrl-Enter", mac: "Cmd-Enter", run: () => !0 },
                { key: "Shift-Enter", run: () => !0 },
              ]),
            )
          : g.push(Ine.of([{ key: "Enter", run: Hse }])),
        g
      )
    }
    const Lue = { class: "w-full" },
      Que = { class: "flex items-center justify-center h-4 w-4" },
      Bue = Ro("span", null, "Add value", -1),
      jue = Hr({
        __name: "DataTableInputSelect",
        props: { modelValue: {}, value: {} },
        emits: ["update:modelValue"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = ii(() => n.value ?? []),
            o = Dn(n.modelValue.toString()),
            i = Dn(!1),
            s = Dn(""),
            l = Dn(null)
          Ya(s, (e) => {
            r("update:modelValue", e)
          })
          const c = (e) => {
              ;(o.value = e), r("update:modelValue", e), (i.value = !1)
            },
            d = () => {
              s.value.trim() && (c(s.value), (s.value = ""))
            },
            u = () => {
              s.value.trim() || ((o.value = ""), (i.value = !1))
            },
            p = (e) => o.value === e
          return (
            Ya(i, (e) => {
              e &&
                rr(() => {
                  var e
                  null == (e = l.value) || e.focus()
                })
            }),
            (e, t) => (
              xo(),
              Eo("div", Lue, [
                i.value
                  ? Fr(
                      (xo(),
                      Eo(
                        "input",
                        {
                          key: 0,
                          ref_key: "inputRef",
                          ref: l,
                          "onUpdate:modelValue": t[0] || (t[0] = (e) => (s.value = e)),
                          class: "border-none focus:text-c-1 text-c-2 min-w-0 w-full px-2 py-1.5 outline-none",
                          placeholder: "Value",
                          type: "text",
                          onBlur: u,
                          onKeyup: Yi(d, ["enter"]),
                        },
                        null,
                        544,
                      )),
                      [[Bi, s.value]],
                    )
                  : (xo(),
                    To(
                      In(cL),
                      { key: 1, resize: "", value: o.value },
                      {
                        items: yr(() => [
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(
                              a.value,
                              (e) => (
                                xo(),
                                To(
                                  In(pL),
                                  {
                                    key: e,
                                    class:
                                      "flex gap-1.5 group/item items-center whitespace-nowrap text-ellipsis overflow-hidden",
                                    value: e,
                                    onClick: (t) => c(e),
                                  },
                                  {
                                    default: yr(() => [
                                      Ro(
                                        "div",
                                        {
                                          class: Ge([
                                            "flex items-center justify-center rounded-full p-[3px] w-4 h-4 group-hover/item:shadow-border",
                                            p(e) ? "bg-blue text-b-1" : "text-transparent",
                                          ]),
                                        },
                                        [No(In(BI), { class: "size-2.5", icon: "Checkmark", thickness: "3.5" })],
                                        2,
                                      ),
                                      Mo(" " + at(e), 1),
                                    ]),
                                    _: 2,
                                  },
                                  1032,
                                  ["value", "onClick"],
                                )
                              ),
                            ),
                            128,
                          )),
                          No(In(uL)),
                          No(
                            In(pL),
                            { class: "flex items-center gap-1.5", onClick: t[1] || (t[1] = (e) => (i.value = !0)) },
                            {
                              default: yr(() => [Ro("div", Que, [No(In(BI), { class: "h-2.5", icon: "Add" })]), Bue]),
                              _: 1,
                            },
                          ),
                        ]),
                        default: yr(() => [
                          No(
                            In(mw),
                            {
                              class: "gap-1.5 font-normal h-full justify-start px-2 py-1.5",
                              fullWidth: "",
                              variant: "ghost",
                            },
                            {
                              default: yr(() => [
                                Ro("span", null, at(o.value || "Select a value"), 1),
                                o.value ? Qo("", !0) : (xo(), To(In(BI), { key: 0, icon: "ChevronDown", size: "xs" })),
                              ]),
                              _: 1,
                            },
                          ),
                        ]),
                        _: 1,
                      },
                      8,
                      ["value"],
                    )),
              ])
            )
          )
        },
      }),
      Uue = { id: "env-dialog", class: "z-10 w-60 rounded border bg-b-1 p-1", open: !0, tabindex: "0" },
      Fue = { key: 0 },
      zue = ["onClick"],
      que = { class: "flex items-center gap-1.5 whitespace-nowrap" },
      Zue = { class: "w-20 overflow-hidden text-ellipsis text-right" },
      Hue = Hr({
        __name: "EnvironmentVariableDropdown",
        props: { query: {} },
        emits: ["select"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            { activeParsedEnvironments: a, environments: o } = E8(),
            i = X1(),
            s = new Nq(a.value, { keys: ["key", "value"] }),
            l = ii(() => {
              const e = n.query
              if (!e) return a.value.slice(-4)
              const t = s.search(e)
              return t.length > 0 ? t.map((e) => e.item) : []
            }),
            c = (e) => ("_scalarEnvId" in e ? `bg-${o[e._scalarEnvId].color}` : "bg-grey")
          return (e, t) => (
            xo(),
            Eo("dialog", Uue, [
              l.value.length
                ? (xo(),
                  Eo("ul", Fue, [
                    (xo(!0),
                    Eo(
                      go,
                      null,
                      qr(
                        l.value,
                        (e, t) => (
                          xo(),
                          Eo(
                            "li",
                            {
                              key: t,
                              class:
                                "font-code text-3xs hover:bg-b-2 flex cursor-pointer items-center justify-between gap-1.5 rounded p-1.5 transition-colors duration-150",
                              onClick: (t) =>
                                ((e) => {
                                  r("select", e)
                                })(e.key),
                            },
                            [
                              Ro("div", que, [
                                Ro("span", { class: Ge(["h-2.5 w-2.5 min-w-2.5 rounded-full", c(e)]) }, null, 2),
                                Mo(" " + at(e.key), 1),
                              ]),
                              Ro("span", Zue, at(e.value), 1),
                            ],
                            8,
                            zue,
                          )
                        ),
                      ),
                      128,
                    )),
                  ]))
                : (xo(),
                  To(
                    In(mw),
                    {
                      key: 1,
                      class:
                        "font-code text-3xs hover:bg-b-2 flex h-7 w-full justify-start gap-2 px-2 transition-colors duration-150",
                      variant: "secondary",
                      onClick: t[0] || (t[0] = (e) => In(i).push("/environment")),
                    },
                    {
                      default: yr(() => [No(In(BI), { class: "w-2", icon: "Add", size: "xs" }), Mo(" Add variable ")]),
                      _: 1,
                    },
                  )),
            ])
          )
        },
      })
    var Vue = Object.defineProperty,
      Wue = (e, t, n) =>
        ((e, t, n) => (t in e ? Vue(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)))(
          e,
          "symbol" != typeof t ? t + "" : t,
          n,
        )
    let Xue = class e extends B9 {
      constructor(e, t, n) {
        super(),
          Wue(this, "queryTerm"),
          Wue(this, "onSelect"),
          Wue(this, "dropdown", null),
          Wue(this, "withServers"),
          (this.queryTerm = e),
          (this.onSelect = t),
          (this.withServers = n)
      }
      updateQueryTerm(e) {
        this.queryTerm !== e && (this.queryTerm = e)
      }
      getQueryTerm() {
        return this.queryTerm
      }
      toDOM(e) {
        const t = document.createElement("span")
        return (
          (t.style.position = "fixed"),
          setTimeout(() => {
            var n
            const r = e.state.selection.main.head,
              a = e.coordsAtPos(r - this.queryTerm.length - 2)
            if (a) {
              const e = null == (n = document.querySelector(".scalar-client")) ? void 0 : n.getBoundingClientRect()
              e &&
                (this.dropdown = Ji({
                  render: () =>
                    si(fo, { to: ".scalar-client" }, [
                      si(Hue, {
                        query: this.queryTerm,
                        onSelect: this.onSelect,
                        withServers: this.withServers,
                        style: {
                          position: "absolute",
                          left: a.left - e.left + "px",
                          top: `calc(${a.bottom - e.top}px + 6px)`,
                        },
                      }),
                    ]),
                })),
                this.dropdown.use(e2),
                this.dropdown.mount(t)
            }
          }, 0),
          t
        )
      }
      destroy() {
        this.dropdown && (this.dropdown.unmount(), (this.dropdown = null))
      }
      eq(t) {
        return t instanceof e && this.queryTerm === t.queryTerm
      }
    }
    const Yue = (e) =>
      Ree.fromClass(
        class {
          constructor(e) {
            Wue(this, "decorations"),
              Wue(this, "widget", null),
              Wue(this, "view"),
              (this.view = e),
              (this.decorations = U9.none),
              (this.handleDropdownSelect = this.handleDropdownSelect.bind(this))
          }
          handleDropdownSelect(t) {
            var n
            if (!this.widget) return
            const { state: r, dispatch: a } = this.view,
              o = r.selection.main.head,
              i = Math.max(0, o - this.widget.getQueryTerm().length - 2),
              s = `{{${t}}}`
            a({ changes: { from: i, to: o, insert: s } }),
              null == (n = this.widget) || n.destroy(),
              (this.widget = null),
              (this.decorations = U9.none),
              this.view.dispatch({ effects: Y7.appendConfig.of([]) })
            const l = i + s.length
            ;(this.widget = new Xue("", this.handleDropdownSelect, e.withServers)),
              (this.decorations = U9.set([U9.widget({ widget: this.widget, side: 1 }).range(l)])),
              this.view.dispatch({ selection: { anchor: l } }),
              this.view.focus()
          }
          update(e) {
            var t, n
            const r = e.state.selection.main.head,
              a = e.state.doc.sliceString(0, r),
              o = [],
              i = a.lastIndexOf("{{")
            if (i > a.lastIndexOf("}}")) {
              const e = a.slice(i + 2)
              this.widget && this.widget.getQueryTerm() === e
                ? this.widget.updateQueryTerm(e)
                : (null == (t = this.widget) || t.destroy(), (this.widget = new Xue(e, this.handleDropdownSelect))),
                o.push(U9.widget({ widget: this.widget, side: 1 }).range(r))
            } else null == (n = this.widget) || n.destroy(), (this.widget = null)
            this.decorations = U9.set(o)
          }
        },
        { decorations: (e) => e.decorations },
      )
    var Gue = Object.defineProperty,
      Kue = (e, t, n) =>
        ((e, t, n) => (t in e ? Gue(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)))(
          e,
          "symbol" != typeof t ? t + "" : t,
          n,
        )
    const { activeParsedEnvironments: Jue, isReadOnly: epe, environments: tpe } = E8()
    let npe = class e extends B9 {
      constructor(e) {
        super(), Kue(this, "app"), (this.variableName = e)
      }
      toDOM() {
        const e = document.createElement("span")
        ;(e.className = "cm-pill"), (e.textContent = `${this.variableName}`)
        const t = Hr({
          props: ["variableName"],
          render() {
            const t = Jue.value.find((e) => e.key === this.variableName)
            t &&
              (e.className += ` ${((e) => ("_scalarEnvId" in e ? `bg-${tpe[e._scalarEnvId].color}` : "bg-grey"))(t)}`)
            const n = t
              ? si("div", { class: "p-2" }, t.value)
              : si("div", { class: "divide-y divide-1/2 grid" }, [
                  si("span", { class: "p-2" }, "Variable not found"),
                  !epe.value &&
                    si("div", { class: "p-1" }, [
                      si(
                        mw,
                        {
                          class:
                            "gap-1.5 justify-start font-normal px-1 py-1.5 h-auto transition-colors rounded no-underline text-xxs w-full hover:bg-b-2",
                          variant: "ghost",
                          onClick: () => {
                            window.location.href = "/environment"
                          },
                        },
                        [si(BI, { class: "w-2", icon: "Add", size: "xs" }), "Add variable"],
                      ),
                    ]),
                ])
            return si(
              PQ,
              { align: "start", class: "bg-b-1 w-full", delay: 0, side: "bottom", sideOffset: 6 },
              {
                trigger: () => si("span", `${this.variableName}`),
                content: () =>
                  si("div", { class: "w-content shadow-lg rounded bg-b-1 text-xxs leading-5 text-c-1" }, n),
              },
            )
          },
        })
        return (this.app = Ji(t, { variableName: this.variableName })), this.app.mount(e), e
      }
      destroy() {
        this.app && this.app.unmount()
      }
      eq(t) {
        return t instanceof e && t.variableName === this.variableName
      }
      ignoreEvent(e) {
        return !1
      }
    }
    const rpe = Ree.fromClass(
        class {
          constructor(e) {
            Kue(this, "decorations"), (this.decorations = this.buildDecorations(e))
          }
          update(e) {
            ;(e.docChanged || e.viewportChanged) && (this.decorations = this.buildDecorations(e.view))
          }
          buildDecorations(e) {
            const t = new f6()
            for (const { from: n, to: r } of e.visibleRanges) {
              const a = e.state.doc.sliceString(n, r),
                o = /{{(.*?)}}/g
              let i
              for (; null !== (i = o.exec(a)); ) {
                const e = n + i.index,
                  r = e + i[0].length,
                  a = i[1]
                t.add(e, r, U9.widget({ widget: new npe(a), side: 1 }))
              }
            }
            return t.finish()
          }
        },
        { decorations: (e) => e.decorations },
      ),
      ape = Tne.domEventHandlers({
        keydown(e, t) {
          if ("Backspace" === e.key) {
            const { state: n } = t,
              { from: r, to: a } = n.selection.main
            if (r === a && r > 0 && "}}" === n.doc.sliceString(r - 2, r))
              return (
                t.dispatch({ changes: { from: r - 2, to: a }, selection: { anchor: r - 2 } }), e.preventDefault(), !0
              )
          }
          return !1
        },
      }),
      ope = ["id"],
      ipe = { key: 3, class: "absolute centered-y right-7 text-orange text-xs" },
      spe = {
        key: 4,
        class:
          "required absolute centered-y right-0 pt-px pr-2 text-xxs text-c-3 bg-b-1 shadow-[-8px_0_4px_var(--scalar-background-1)] opacity-100 duration-150 transition-opacity peer-has-[.cm-focused]:opacity-0",
      },
      lpe = Hr({
        inheritAttrs: !1,
        __name: "CodeInput",
        props: {
          colorPicker: { type: Boolean, default: !1 },
          modelValue: {},
          error: { type: Boolean },
          emitOnBlur: { type: Boolean, default: !0 },
          lineNumbers: { type: Boolean },
          lint: { type: Boolean },
          disableTabIndent: { type: Boolean, default: !1 },
          language: {},
          handleFieldSubmit: {},
          handleFieldChange: {},
          placeholder: {},
          required: { type: Boolean },
          disableEnter: { type: Boolean, default: !1 },
          disableCloseBrackets: { type: Boolean, default: !1 },
          enum: {},
          type: {},
          nullable: { type: Boolean, default: !1 },
          withVariables: { type: Boolean, default: !0 },
          withServers: { type: Boolean, default: !1 },
        },
        emits: ["submit", "update:modelValue"],
        setup(e, { emit: t }) {
          var n
          const r = e,
            a = t,
            o = ra(),
            i = o.id || `id-${NL()}`,
            s = Dn(!1),
            { activeWorkspace: l } = E8()
          const c = []
          r.colorPicker && c.push(Sie),
            r.withVariables && !l.value.isReadOnly && c.push(Yue({ withServers: r.withServers })),
            c.push(rpe, ape)
          const d = Dn(null),
            { codeMirror: u } = $ue({
              content: zn(() => (void 0 !== r.modelValue ? String(r.modelValue) : "")),
              onChange: function (e) {
                return e === r.modelValue
                  ? null
                  : r.handleFieldChange
                    ? r.handleFieldChange(e)
                    : a("update:modelValue", e)
              },
              onFocus: () => (s.value = !0),
              onBlur: (e) =>
                (function (e) {
                  ;(s.value = !1),
                    r.emitOnBlur &&
                      r.modelValue &&
                      (function (e) {
                        r.handleFieldSubmit ? r.handleFieldSubmit(e) : a("submit", e)
                      })(e)
                })(e),
              codeMirrorRef: d,
              disableTabIndent: zn(() => r.disableTabIndent),
              disableEnter: zn(() => r.disableEnter),
              disableCloseBrackets: zn(() => r.disableCloseBrackets),
              lineNumbers: zn(() => r.lineNumbers),
              language: zn(() => r.language),
              lint: zn(() => r.lint),
              extensions: c,
              placeholder: zn(() => r.placeholder),
            })
          null == (n = u.value) || n.focus(),
            Ya(u, () => {
              u.value && Object.prototype.hasOwnProperty.call(o, "autofocus") && u.value.focus()
            })
          const p = ii(() => {
            var e
            return "boolean" === r.type || (null != (e = r.type) && e.includes("boolean")) || r.nullable
              ? ["true", "false", "null"]
              : ["true", "false"]
          })
          return (e, t) => {
            var n
            return (
              xo(),
              Eo(
                go,
                null,
                [
                  r.enum && r.enum.length
                    ? (xo(),
                      To(
                        jue,
                        {
                          key: 0,
                          modelValue: r.modelValue,
                          value: r.enum,
                          "onUpdate:modelValue": t[0] || (t[0] = (e) => a("update:modelValue", e)),
                        },
                        null,
                        8,
                        ["modelValue", "value"],
                      ))
                    : "boolean" === r.type || (null != (n = r.type) && n.includes("boolean"))
                      ? (xo(),
                        To(
                          jue,
                          {
                            key: 1,
                            modelValue: r.modelValue,
                            value: p.value,
                            "onUpdate:modelValue": t[1] || (t[1] = (e) => a("update:modelValue", e)),
                          },
                          null,
                          8,
                          ["modelValue", "value"],
                        ))
                      : (xo(),
                        Eo(
                          "div",
                          Fo({ key: 2, id: In(i) }, e.$attrs, {
                            ref_key: "codeMirrorRef",
                            ref: d,
                            class: [
                              "peer font-code w-full whitespace-nowrap text-xs leading-[1.44] relative",
                              { "flow-code-input--error": e.error },
                            ],
                          }),
                          null,
                          16,
                          ope,
                        )),
                  e.$slots.warning ? (xo(), Eo("div", ipe, [Xr(e.$slots, "warning", {}, void 0, !0)])) : Qo("", !0),
                  Xr(e.$slots, "icon", {}, void 0, !0),
                  e.required ? (xo(), Eo("div", spe, " Required ")) : Qo("", !0),
                ],
                64,
              )
            )
          }
        },
      }),
      cpe = T8(lpe, [["__scopeId", "data-v-5c9fc64f"]]),
      dpe = (e, t = 2) => (e > 1e3 ? (e / 1e3).toFixed(t) + "s" : e + "ms"),
      upe = {
        100: { color: "text-yellow" },
        200: { color: "text-green" },
        202: { color: "text-green" },
        300: { color: "text-blue" },
        304: { color: "text-blue" },
        400: { color: "text-red" },
        401: { color: "text-orange" },
        422: { color: "text-yellow" },
        423: { color: "text-purple" },
        505: { color: "text-orange" },
      },
      ppe = (e) => upe[e] || { color: "text-grey" },
      hpe = { class: "font-code flex flex-1 gap-1.5 text-sm font-medium" },
      fpe = { class: "text-c-2 gap-0" },
      mpe = { class: "font-code text-c-3 flex flex-row items-center gap-1.5 text-sm font-medium" },
      gpe = Hr({
        __name: "AddressBarHistory",
        props: { open: { type: Boolean } },
        setup(e) {
          const { activeRequest: t, requestExampleMutators: n } = E8(),
            r = X1()
          function a(e) {
            const t = new URL(e),
              n = new URLSearchParams(t.search).get("scalar_url")
            return n ? new URL(n).href : t.href
          }
          return (e, o) => (
            xo(),
            Eo(
              go,
              null,
              [
                In(t).history.length
                  ? (xo(),
                    To(
                      In(Ny),
                      { key: 0, class: "hover:bg-b-2 mr-1 rounded p-1.5" },
                      {
                        default: yr(() => [
                          No(In(BI), { class: "text-c-3", icon: "History", size: "sm", thickness: "2.25" }),
                        ]),
                        _: 1,
                      },
                    ))
                  : Qo("", !0),
                Ro(
                  "div",
                  {
                    class: Ge([
                      "absolute left-0 top-[33px] w-full rounded before:pointer-events-none before:absolute before:left-0 before:top-[-33px] before:h-[calc(100%+33px)] before:w-full before:rounded z-50",
                      { "before:shadow-lg": e.open },
                    ]),
                  },
                  [
                    No(
                      In($y),
                      {
                        class:
                          "bg-b-1 custom-scroll bg-mix-transparent bg-mix-amount-30 max-h-[300px] rounded-b p-[3px] pt-0 backdrop-blur",
                      },
                      {
                        default: yr(() => [
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(
                              In(t).history,
                              ({ response: e }, o) => (
                                xo(),
                                To(
                                  In(Iy),
                                  {
                                    key: o,
                                    class:
                                      "ui-active:bg-b-2 text-c-1 ui-active:text-c-1 flex cursor-pointer flex-row gap-2.5 rounded py-1.5 pr-3",
                                    value: o,
                                    onClick: (e) =>
                                      (function (e) {
                                        const a = t.value.history[e]
                                        t.value.uid !== a.request.requestUid &&
                                          r.push(`/request/${a.request.requestUid}`),
                                          n.set(a.request)
                                      })(o),
                                  },
                                  {
                                    default: yr(() => {
                                      var t
                                      return [
                                        Ro("div", hpe, [
                                          e.config.method
                                            ? (xo(),
                                              To(
                                                $8,
                                                { key: 0, class: "text-[11px] min-w-[44px]", method: e.config.method },
                                                null,
                                                8,
                                                ["method"],
                                              ))
                                            : Qo("", !0),
                                          Ro("span", fpe, at(a(e.config.url)), 1),
                                        ]),
                                        Ro("div", mpe, [
                                          Ro("span", null, at(In(dpe)(e.duration)), 1),
                                          Ro("span", { class: Ge([In(ppe)(e.status).color]) }, at(e.status), 3),
                                          Ro("span", null, at(null == (t = In(Td)[e.status]) ? void 0 : t.name), 1),
                                        ]),
                                      ]
                                    }),
                                    _: 2,
                                  },
                                  1032,
                                  ["value", "onClick"],
                                )
                              ),
                            ),
                            128,
                          )),
                        ]),
                        _: 1,
                      },
                    ),
                  ],
                  2,
                ),
              ],
              64,
            )
          )
        },
      }),
      bpe = Mm(Symbol()),
      vpe = (e) => (br("data-v-231a70ec"), (e = e()), vr(), e),
      ype = { key: 0, class: "order-last lg:order-none lg:w-auto w-full" },
      Ope = { class: "m-auto flex basis-1/2 flex-row items-center" },
      wpe = { class: "pointer-events-none absolute left-0 top-0 z-10 block h-full w-full overflow-hidden" },
      xpe = { class: "flex gap-1" },
      kpe = { class: "scroll-timeline-x scroll-timeline-x-hidden relative flex w-full" },
      _pe = vpe(() => Ro("div", { class: "fade-left" }, null, -1)),
      Spe = vpe(() => Ro("div", { class: "fade-right" }, null, -1)),
      Epe = vpe(() => Ro("span", { class: "text-xxs relative z-10 lg:flex hidden" }, "Send", -1)),
      Tpe = Hr({
        __name: "AddressBar",
        setup(e) {
          const {
              activeRequest: t,
              activeExample: n,
              isReadOnly: r,
              requestMutators: a,
              requestExampleMutators: o,
              requestsHistory: i,
            } = E8(),
            s = Dn(i.value[0]),
            l = Qm()
          Am(Hz() ? l.meta_enter : l.ctrl_enter, () => bpe.emit()),
            Ya(
              () => {
                var e
                return null == (e = t.value) ? void 0 : e.path
              },
              (e) => {
                t.value &&
                  ((e) => {
                    !t.value || t.value.path === e || a.edit(t.value.uid, "path", e)
                  })(e)
              },
            )
          const c = Dn(100),
            d = Dn(!1)
          function u(e) {
            t.value && a.edit(t.value.uid, "method", e)
          }
          function p() {
            if (!t.value) return
            const { method: e } = t.value
            return Ed[e].backgroundColor
          }
          bpe.on(() => {
            if (d.value) return
            d.value = !0
            const e = setInterval(() => {
              ;(c.value -= 5), c.value <= 0 && (clearInterval(e), (c.value = 100), (d.value = !1))
            }, 20)
          })
          const h = (e) => {
            n.value && o.edit(n.value.uid, "url", e)
          }
          return (e, a) =>
            In(t) && In(n)
              ? (xo(),
                Eo("div", ype, [
                  Ro("div", Ope, [
                    No(
                      In(Ry),
                      { modelValue: s.value, "onUpdate:modelValue": a[2] || (a[2] = (e) => (s.value = e)) },
                      {
                        default: yr(({ open: e }) => [
                          Ro(
                            "div",
                            {
                              class: Ge([
                                "text-xxs bg-b-1 relative flex w-full lg:min-w-[720px] lg:max-w-[720px] order-last lg:order-none flex-1 flex-row items-stretch rounded border p-[3px]",
                                { "rounded-b-none": e },
                                { "border-transparent": e },
                              ]),
                            },
                            [
                              Ro("div", wpe, [
                                Ro(
                                  "div",
                                  {
                                    class: Ge([
                                      "bg-mix-transparent bg-mix-amount-95 absolute left-0 top-0 h-full w-full",
                                      p(),
                                    ]),
                                    style: He({ transform: `translate3d(-${c.value}%,0,0)` }),
                                  },
                                  null,
                                  6,
                                ),
                              ]),
                              Ro("div", xpe, [
                                No(
                                  $8,
                                  {
                                    class: "font-code text-xxs font-medium",
                                    isEditable: !In(r),
                                    isSquare: "",
                                    method: In(t).method,
                                    onChange: u,
                                  },
                                  null,
                                  8,
                                  ["isEditable", "method"],
                                ),
                              ]),
                              Ro("div", kpe, [
                                _pe,
                                No(
                                  cpe,
                                  {
                                    disableCloseBrackets: "",
                                    disabled: In(r),
                                    disableEnter: "",
                                    disableTabIndent: "",
                                    emitOnBlur: !1,
                                    modelValue: In(n).url,
                                    placeholder: "Enter URL to get started",
                                    server: "",
                                    onSubmit: a[0] || (a[0] = (e) => In(bpe).emit()),
                                    "onUpdate:modelValue": h,
                                  },
                                  null,
                                  8,
                                  ["disabled", "modelValue"],
                                ),
                                Spe,
                              ]),
                              No(gpe, { open: e }, null, 8, ["open"]),
                              No(
                                In(mw),
                                {
                                  class: "relative h-auto shrink-0 gap-1 overflow-hidden pl-2 pr-2.5 py-1 z-[1]",
                                  disabled: d.value,
                                  onClick: a[1] || (a[1] = (e) => In(bpe).emit()),
                                },
                                {
                                  default: yr(() => [
                                    No(In(BI), {
                                      class: "relative z-10 shrink-0 fill-current",
                                      icon: "Play",
                                      size: "xs",
                                    }),
                                    Epe,
                                  ]),
                                  _: 1,
                                },
                                8,
                                ["disabled"],
                              ),
                            ],
                            2,
                          ),
                        ]),
                        _: 1,
                      },
                      8,
                      ["modelValue"],
                    ),
                  ]),
                ]))
              : Qo("", !0)
        },
      }),
      Ape = T8(Tpe, [["__scopeId", "data-v-231a70ec"]]),
      Cpe = { class: "bg-b-1 sticky top-0 z-50 px-3 py-2.5 pb-0" },
      Ppe = { class: "w-[15px] flex items-center justify-center" },
      Dpe = { class: "sidebar-search-input ml-1.5 flex w-full items-center justify-between text-sm font-medium" },
      Rpe = Ro("span", { class: "sidebar-search-placeholder" }, "Search", -1),
      Npe = Hr({
        __name: "SearchButton",
        emits: ["openSearchModal"],
        setup(e, { emit: t }) {
          const n = t
          return (e, t) => (
            xo(),
            Eo("div", Cpe, [
              Ro(
                "button",
                {
                  class: "shadow-border text-c-2 flex w-full items-center rounded p-1.5",
                  type: "button",
                  onClick: t[0] || (t[0] = (e) => n("openSearchModal")),
                },
                [
                  Ro("div", Ppe, [No(In(BI), { icon: "Search", size: "xs", thickness: "2.5" })]),
                  Ro("div", Dpe, [Rpe, No(R8, { hotkey: "k" })]),
                ],
              ),
            ])
          )
        },
      }),
      $pe = ((e) => (br("data-v-b9a9246e"), (e = e()), vr(), e))(() =>
        Ro("div", { class: "ref-search-meta" }, [Ro("span", null, " Navigate"), Ro("span", null, " Select")], -1),
      ),
      Ipe = Hr({
        __name: "SearchModal",
        props: { modalState: {} },
        setup(e) {
          const t = e,
            n = X1(),
            { requests: r } = E8(),
            a = Qm(),
            o = Dn([]),
            i = Dn([]),
            s = Dn(0),
            l = Dn(""),
            c = Dn(null),
            d = new Nq(o.value, { keys: ["title", "description", "body"] }),
            u = () => {
              ;(s.value = 0), (i.value = d.search(l.value))
            }
          function p(e) {
            n.push(e.item.id), t.modalState.hide()
          }
          Ya(
            () => t.modalState.open,
            (e) => {
              var t
              e && (null == (t = c.value) || t.focus(), (l.value = ""), (s.value = 0), (i.value = []))
            },
          ),
            Ya(
              r,
              (e) => {
                Object.keys(e).forEach((e) => {
                  const t = r[e]
                  o.value.push({
                    id: e,
                    title: t.summary ?? t.method,
                    description: t.description ?? "",
                    httpVerb: t.method,
                    path: t.path,
                  })
                }),
                  d.setCollection(o.value)
              },
              { immediate: !0 },
            )
          const h = ii(() => f.value[s.value]),
            f = ii(() => (0 === l.value.length ? o.value.map((e) => ({ item: e })) : i.value))
          return (
            Am(a.enter, () => {
              t.modalState.open && window && p(h.value)
            }),
            Am(a.ArrowDown, () => {
              var e
              t.modalState.open &&
                window &&
                (s.value < f.value.length - 1 ? s.value++ : (s.value = 0),
                null == (e = document.getElementById(`search-modal-${h.value.item.id}`)) ||
                  e.scrollIntoView({ behavior: "smooth", block: "center" }))
            }),
            Am(a.ArrowUp, () => {
              var e
              t.modalState.open &&
                window &&
                (s.value > 0 ? s.value-- : (s.value = f.value.length - 1),
                null == (e = document.getElementById(`search-modal-${h.value.item.id}`)) ||
                  e.scrollIntoView({ behavior: "smooth", block: "center" }))
            }),
            (e, t) => (
              xo(),
              To(
                In(sw),
                { state: e.modalState, variant: "search" },
                {
                  default: yr(() => [
                    Ro(
                      "div",
                      { ref_key: "searchModalRef", ref: c, class: "ref-search-container" },
                      [
                        No(
                          In(wL),
                          {
                            modelValue: l.value,
                            "onUpdate:modelValue": t[0] || (t[0] = (e) => (l.value = e)),
                            onInput: u,
                          },
                          null,
                          8,
                          ["modelValue"],
                        ),
                      ],
                      512,
                    ),
                    No(
                      In(RL),
                      { class: "ref-search-results custom-scroll", noResults: !f.value.length },
                      {
                        query: yr(() => [Mo(at(l.value), 1)]),
                        default: yr(() => [
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(
                              f.value,
                              (e, t) => (
                                xo(),
                                To(
                                  In(PL),
                                  {
                                    id: `#search-modal-${e.item.id}`,
                                    key: e.refIndex,
                                    active: s.value === t,
                                    icon: "Terminal",
                                    onClick: (t) => p(e),
                                    onFocus: (e) => (s.value = t),
                                  },
                                  Zr(
                                    {
                                      addon: yr(() => [
                                        No(In($8), { method: e.item.httpVerb ?? "get" }, null, 8, ["method"]),
                                      ]),
                                      default: yr(() => [Mo(at(e.item.title) + " ", 1)]),
                                      _: 2,
                                    },
                                    [
                                      (e.item.httpVerb || e.item.path) && e.item.path !== e.item.title
                                        ? { name: "description", fn: yr(() => [Mo(at(e.item.path), 1)]), key: "0" }
                                        : e.item.description
                                          ? {
                                              name: "description",
                                              fn: yr(() => [Mo(at(e.item.description), 1)]),
                                              key: "1",
                                            }
                                          : void 0,
                                    ],
                                  ),
                                  1032,
                                  ["id", "active", "onClick", "onFocus"],
                                )
                              ),
                            ),
                            128,
                          )),
                        ]),
                        _: 1,
                      },
                      8,
                      ["noResults"],
                    ),
                    $pe,
                  ]),
                  _: 1,
                },
                8,
                ["state"],
              )
            )
          )
        },
      }),
      Mpe = T8(Ipe, [["__scopeId", "data-v-b9a9246e"]]),
      Lpe = { class: "fixed relative bottom-[50px] z-10 flex p-2" },
      Qpe = Hr({
        __name: "SidebarButton",
        props: { click: { type: Function } },
        setup(e) {
          const t = e,
            n = () => {
              t.click()
            }
          return (e, t) => (
            xo(),
            Eo("div", Lpe, [
              No(
                In(mw),
                {
                  class: "bg-b-1 text-c-1 hover:bg-b-2 group relative w-full border p-1.5 h-auto",
                  icon: "Plus",
                  variant: "outlined",
                  onClick: n,
                },
                {
                  default: yr(() => [
                    Xr(e.$slots, "title"),
                    No(R8, {
                      class: "absolute right-2 group-hover:opacity-80 text-c-2",
                      hotkey: "N",
                      onHotkeyPressed: n,
                    }),
                  ]),
                  _: 3,
                },
              ),
            ])
          )
        },
      }),
      Bpe = { class: "size-3.5", fill: "none", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" },
      jpe = Ro(
        "defs",
        null,
        [
          Ro("clipPath", { id: "mask" }, [
            Ro("path", { "clip-rule": "evenodd", d: "M9 3.2H4c-1.7 0-3 1.3-3 3v11.5c0 1.7 1.3 3 3 3h5V3.2z" }),
          ]),
        ],
        -1,
      ),
      Upe = { "clip-path": "url(#mask)" },
      Fpe = Ro(
        "path",
        {
          d: "M20 20.8H4c-1.7 0-3-1.3-3-3V6.2c0-1.7 1.3-3 3-3h16c1.7 0 3 1.3 3 3v11.5c0 1.7-1.3 3-3 3zM9 3.2v17.5",
          stroke: "currentColor",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "2",
        },
        null,
        -1,
      ),
      zpe = Hr({
        __name: "SidebarToggle",
        props: { modelValue: { type: Boolean } },
        emits: ["update:modelValue"],
        setup: (e) => (e, t) => (
          xo(),
          Eo(
            "button",
            {
              class: "text-c-3 hover:bg-b-3 active:text-c-1 p-2 rounded",
              type: "button",
              onClick: t[0] || (t[0] = (t) => e.$emit("update:modelValue", !e.modelValue)),
            },
            [
              (xo(),
              Eo("svg", Bpe, [
                jpe,
                Ro("g", Upe, [
                  Ro(
                    "path",
                    {
                      class: Ge([
                        "transition-transform duration-300",
                        e.modelValue ? "translate-x-0" : "-translate-x-1/2",
                      ]),
                      d: "M1 3.2h8v17.5H1z",
                      fill: "currentColor",
                    },
                    null,
                    2,
                  ),
                ]),
                Fpe,
              ])),
            ],
          )
        ),
      }),
      qpe = { class: "m-1 mt-0 flex min-h-0 flex-1 rounded xl:rounded-lg xl:border xl:overflow-hidden leading-3 z-0" },
      Zpe = T8({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", qpe, [Xr(e.$slots, "default")])
          },
        ],
      ]),
      Hpe = { class: "divide divide-y xl:divide-y-0 xl:divide-x flex xl:flex-row flex-col custom-scroll rounded" },
      Vpe = T8({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("div", Hpe, [Xr(e.$slots, "default")])
          },
        ],
      ]),
      Wpe = {
        class:
          "request-section-content request-section-content-filter bg-b-2 text-c-3 bg-b-1 sticky top-0 z-10 mb-2.5 hidden xl:flex justify-center rounded p-[2.25px] text-xs gap-0.5",
      },
      Xpe = ["isActive", "onClick"],
      Ype = Hr({
        __name: "ContextBar",
        props: { sections: {}, activeSection: {} },
        emits: ["setActiveSection"],
        setup: (e) => (e, t) => (
          xo(),
          Eo("div", Wpe, [
            (xo(!0),
            Eo(
              go,
              null,
              qr(
                e.sections,
                (t) => (
                  xo(),
                  Eo(
                    "button",
                    {
                      key: t,
                      class: Ge([
                        "hover:bg-b-3 w-full rounded px-1 py-1 text-center font-medium",
                        [
                          e.activeSection === t
                            ? "bg-b-1 text-c-1 dark:bg-b-3 border pointer-events-none"
                            : "border border-transparent",
                        ],
                      ]),
                      isActive: e.activeSection === t,
                      type: "button",
                      onClick: (n) => e.$emit("setActiveSection", t),
                    },
                    at(t),
                    11,
                    Xpe,
                  )
                ),
              ),
              128,
            )),
          ])
        ),
      }),
      Gpe = ["aria-labelledby"],
      Kpe = ["id"],
      Jpe = Hr({
        __name: "ViewLayoutSection",
        setup(e) {
          const t = NL()
          return (e, n) => (
            xo(),
            Eo(
              "section",
              { "aria-labelledby": In(t), class: "flex xl:min-w-0 xl:flex-1 flex-col xl:custom-scroll bg-b-1" },
              [
                Ro(
                  "div",
                  {
                    id: In(t),
                    class:
                      "xl:min-h-header py-2.5 flex items-center border-b px-4 xl:px-6 text-sm font-medium sticky top-0 bg-b-1 z-20 rounded-t xl:rounded-none",
                  },
                  [Xr(e.$slots, "title")],
                  8,
                  Kpe,
                ),
                Xr(e.$slots, "default"),
              ],
              8,
              Gpe,
            )
          )
        },
      }),
      ehe = { class: "flex flex-1 items-center gap-1.5" },
      the = {
        key: 0,
        class: "bg-b-2 text-c-2 text-3xs inline-flex h-4 w-4 items-center justify-center rounded-full font-semibold",
      },
      nhe = { class: "flex items-center gap-2" },
      rhe = { key: 0, class: "ui-not-open:invisible -my-1 flex items-center gap-2" },
      ahe = Hr({
        __name: "ViewLayoutCollapse",
        props: { defaultOpen: { type: Boolean, default: !0 }, itemCount: { default: 0 } },
        setup: (e) => (e, t) => (
          xo(),
          To(
            In(Oy),
            {
              as: "div",
              class:
                "focus-within:bg-b-2 focus-within:text-c-1 text-c-2 rounded request-item ui-not-open:bg-transparent ui-open:pb-1 ui-open:mb-3 ui-not-open:mb-0 ui-not-open:pb-0",
              defaultOpen: e.defaultOpen,
            },
            {
              default: yr(({ open: t }) => [
                No(
                  In(wy),
                  {
                    class:
                      "hover:text-c-1 group flex w-full items-center gap-1.5 overflow-hidden py-1.5 text-sm font-medium px-1.5",
                  },
                  {
                    default: yr(() => [
                      No(In(BI), {
                        class: "text-c-3 group-hover:text-c-1 ui-open:rotate-90 ui-not-open:rotate-0",
                        icon: "ChevronRight",
                        size: "sm",
                        thickness: "2.5",
                      }),
                      Ro("div", ehe, [
                        Xr(e.$slots, "title", { open: t }),
                        !t && e.itemCount ? (xo(), Eo("span", the, at(e.itemCount), 1)) : Qo("", !0),
                      ]),
                      Ro("div", nhe, [
                        e.$slots.actions ? (xo(), Eo("div", rhe, [Xr(e.$slots, "actions", { open: t })])) : Qo("", !0),
                      ]),
                    ]),
                    _: 2,
                  },
                  1024,
                ),
                No(
                  In(xy),
                  { class: "rounded-b" },
                  { default: yr(() => [Xr(e.$slots, "default", { open: t })]), _: 2 },
                  1024,
                ),
              ]),
              _: 3,
            },
            8,
            ["defaultOpen"],
          )
        ),
      }),
      ohe = Hr({
        __name: "DataTableCell",
        props: { is: { default: "td" } },
        setup: (e) => (e, t) => (
          xo(),
          To(
            Tr(e.is),
            {
              class:
                "min-h-8 min-w-8 border-l-0 border-t-0 border-b-1/2 border-r-1/2 flex text-sm last:border-r-0 group-last:border-b-transparent p-0 m-0 relative",
              role: "cell",
            },
            { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
          )
        ),
      }),
      ihe = { key: 0, class: "text-c-2 flex min-w-[100px] items-center border-r-1/2 pl-2 pr-0" },
      she = { class: "row-1" },
      lhe = ["id", "max", "min", "readOnly", "required", "type", "value"],
      che = {
        key: 0,
        class:
          "absolute centered-y right-0 pt-px pr-2 text-xxs text-c-3 bg-b-1 shadow-[-8px_0_4px_var(--scalar-background-1)] opacity-100 duration-150 transition-opacity peer-focus:opacity-0",
      },
      dhe = { key: 1, class: "absolute centered-y right-7 text-orange text-xs" },
      uhe = Hr({
        inheritAttrs: !1,
        __name: "DataTableInput",
        props: {
          id: {},
          type: {},
          containerClass: {},
          required: { type: Boolean, default: !1 },
          modelValue: {},
          readOnly: { type: Boolean, default: !1 },
          enum: {},
          min: {},
          max: {},
        },
        emits: ["update:modelValue", "inputFocus", "inputBlur", "selectVariable"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = Dn(!0),
            o = Dn(""),
            i = Dn(!1),
            s = () => {
              i.value || r("inputBlur")
            },
            l = ii(() => ("password" === n.type ? (a.value ? "password" : "text") : (n.type ?? "text"))),
            c = (e) => {
              const t = e.target
              ;(o.value = t.value), r("update:modelValue", t.value)
            }
          return (e, t) => (
            xo(),
            To(
              ohe,
              { class: Ge(["relative row", e.containerClass]) },
              {
                default: yr(() => [
                  e.$slots.default ? (xo(), Eo("div", ihe, [Xr(e.$slots, "default", {}, void 0, !0)])) : Qo("", !0),
                  Ro("div", she, [
                    n.enum && n.enum.length
                      ? (xo(),
                        To(
                          jue,
                          {
                            key: 0,
                            modelValue: n.modelValue,
                            value: n.enum,
                            "onUpdate:modelValue": t[0] || (t[0] = (e) => r("update:modelValue", e)),
                          },
                          null,
                          8,
                          ["modelValue", "value"],
                        ))
                      : (xo(),
                        Eo(
                          go,
                          { key: 1 },
                          [
                            Ro(
                              "input",
                              Fo(e.$attrs, {
                                id: e.id,
                                autocomplete: "off",
                                class:
                                  "border-none focus:text-c-1 text-c-2 min-w-0 w-full peer px-2 py-1.5 outline-none",
                                "data-1p-ignore": "",
                                max: e.max,
                                min: e.min,
                                readOnly: e.readOnly,
                                required: e.required,
                                spellcheck: "false",
                                type: l.value,
                                value: e.modelValue,
                                onBlur: s,
                                onFocus: t[1] || (t[1] = (e) => r("inputFocus")),
                                onInput: c,
                              }),
                              null,
                              16,
                              lhe,
                            ),
                            e.required ? (xo(), Eo("div", che, " Required ")) : Qo("", !0),
                          ],
                          64,
                        )),
                  ]),
                  e.$slots.warning ? (xo(), Eo("div", dhe, [Xr(e.$slots, "warning", {}, void 0, !0)])) : Qo("", !0),
                  Xr(e.$slots, "icon", {}, void 0, !0),
                  "password" === e.type
                    ? (xo(),
                      To(
                        In(mL),
                        {
                          key: 2,
                          class: "-ml-.5 mr-1 h-6 w-6 self-center p-1.5",
                          icon: a.value ? "Show" : "Hide",
                          label: a.value ? "Show Password" : "Hide Password",
                          onClick: t[2] || (t[2] = (e) => (a.value = !a.value)),
                        },
                        null,
                        8,
                        ["icon", "label"],
                      ))
                    : Qo("", !0),
                ]),
                _: 3,
              },
              8,
              ["class"],
            )
          )
        },
      }),
      phe = T8(uhe, [["__scopeId", "data-v-7949fbac"]]),
      hhe = ["for"],
      fhe = Hr({
        __name: "RequestAuthDataTableInput",
        props: {
          id: {},
          type: {},
          containerClass: {},
          required: { type: Boolean, default: !1 },
          modelValue: {},
          readOnly: { type: Boolean, default: !1 },
        },
        emits: ["update:modelValue", "inputFocus", "inputBlur", "selectVariable"],
        setup(e, { emit: t }) {
          const n = e,
            r = t
          return (e, t) => (
            xo(),
            To(
              phe,
              Fo(
                {
                  id: n.id,
                  containerClass: n.containerClass,
                  modelValue: n.modelValue,
                  readOnly: n.readOnly,
                  required: n.required,
                  type: n.type,
                },
                e.$attrs,
                {
                  onInputBlur: t[0] || (t[0] = (e) => r("inputBlur")),
                  onInputFocus: t[1] || (t[1] = (e) => r("inputFocus")),
                  onSelectVariable: t[2] || (t[2] = (e) => r("selectVariable", e)),
                  "onUpdate:modelValue": t[3] || (t[3] = (e) => r("update:modelValue", e)),
                },
              ),
              {
                default: yr(() => [Ro("label", { for: n.id }, [Xr(e.$slots, "default")], 8, hhe)]),
                icon: yr(() => [Xr(e.$slots, "icon")]),
                _: 3,
              },
              16,
              ["id", "containerClass", "modelValue", "readOnly", "required", "type"],
            )
          )
        },
      }),
      mhe = { key: 0, class: "sr-only" },
      ghe = Hr({
        __name: "DataTable",
        props: { columns: {}, scroll: { type: Boolean } },
        setup: (e) => (e, t) => (
          xo(),
          Eo(
            "div",
            {
              class: Ge([
                "border-1/2 rounded mx-1 bg-b-1",
                e.scroll ? "overflow-x-auto custom-scroll" : "overflow-visible",
              ]),
            },
            [
              Ro(
                "table",
                {
                  class: Ge(["grid auto-rows-auto min-h-8 mb-0", { "min-w-full w-max": e.scroll }]),
                  style: He({ gridTemplateColumns: e.columns.map((e) => e || "1fr").join(" ") }),
                },
                [
                  e.$slots.caption ? (xo(), Eo("caption", mhe, [Xr(e.$slots, "caption")])) : Qo("", !0),
                  Xr(e.$slots, "default"),
                ],
                6,
              ),
            ],
            2,
          )
        ),
      }),
      bhe = { class: "group contents w-fit min-w-full" },
      vhe = T8({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("tr", bhe, [Xr(e.$slots, "default")])
          },
        ],
      ]),
      yhe = Hr({
        __name: "DataTableHeader",
        setup: (e) => (e, t) => (
          xo(),
          To(
            ohe,
            { is: "th", class: "truncate font-medium px-2 py-1.5" },
            { default: yr(() => [Xr(e.$slots, "default")]), _: 3 },
          )
        ),
      }),
      Ohe = ["checked", "disabled"],
      whe = {
        class:
          "w-full h-full flex items-center justify-center centered text-border peer-checked:text-c-2 pointer-events-none absolute before:absolute before:opacity-0 group-hover/cell:before:opacity-100 before:border before:rounded before:w-9/12 before:aspect-square before:top-1/2 before:left-1/2 before:transform before:-translate-x-1/2 before:-translate-y-1/2 before:border-[1px]",
      },
      xhe = Hr({
        __name: "DataTableCheckbox",
        props: { modelValue: { type: Boolean }, disabled: { type: Boolean } },
        emits: ["update:modelValue"],
        setup: (e) => (e, t) => (
          xo(),
          To(
            ohe,
            { class: "group/cell relative flex min-w-8" },
            {
              default: yr(() => [
                Ro(
                  "input",
                  {
                    checked: e.modelValue,
                    class: "peer absolute inset-0 opacity-0 cursor-pointer",
                    disabled: e.disabled,
                    tabindex: "-1",
                    type: "checkbox",
                    onChange: t[0] || (t[0] = (t) => e.$emit("update:modelValue", t.target.checked)),
                  },
                  null,
                  40,
                  Ohe,
                ),
                Ro("div", whe, [No(In(BI), { icon: "Checkmark", size: "xs", thickness: "2.5" })]),
              ]),
              _: 1,
            },
          )
        ),
      }),
      khe = { class: "flex h-full w-full" },
      _he = Ro(
        "div",
        { class: "text-c-2 min-w-[100px] items-center pl-2 h-full border-r-1/2" },
        [Ro("span", { class: "h-8 flex items-center" }, " Scopes ")],
        -1,
      ),
      She = { class: "flex-1 text-c-3" },
      Ehe = { class: "grid auto-rows-auto border-t-1/2", style: { gridTemplateColumns: "1fr auto" } },
      The = { class: "font-code text-xs" },
      Ahe = Hr({
        __name: "OAuthScopesInput",
        props: { activeFlow: {}, schemeModel: {}, updateScheme: { type: Function } },
        setup(e) {
          const t = e,
            n = ii(() => {
              var e
              return Object.entries((null == (e = t.activeFlow) ? void 0 : e.scopes) ?? {}).map(([e, t]) => ({
                id: e,
                label: e,
                description: t,
              }))
            }),
            r = ii(() => {
              var e
              return (null == (e = t.activeFlow) ? void 0 : e.selectedScopes) || []
            })
          return (e, a) => (
            xo(),
            To(
              In(ohe),
              { class: "items-center min-h-8 h-auto" },
              {
                default: yr(() => [
                  Ro("div", khe, [
                    _he,
                    No(
                      In(Oy),
                      { as: "div", class: "flex flex-col w-full" },
                      {
                        default: yr(() => [
                          No(
                            In(wy),
                            {
                              class:
                                "group/scopes-accordion flex items-center text-left min-h-8 gap-1.5 h-auto pl-2 hover:bg-b-2 pr-2.5 cursor-pointer",
                            },
                            {
                              default: yr(({ open: t }) => {
                                var n, r, a
                                return [
                                  Ro(
                                    "div",
                                    She,
                                    " Selected " +
                                      at(
                                        (null == (r = null == (n = e.activeFlow) ? void 0 : n.selectedScopes)
                                          ? void 0
                                          : r.length) || 0,
                                      ) +
                                      " / " +
                                      at(
                                        Object.keys((null == (a = e.activeFlow) ? void 0 : a.scopes) ?? {}).length || 0,
                                      ),
                                    1,
                                  ),
                                  No(
                                    In(BI),
                                    {
                                      class: "text-c-3 group-hover/scopes-accordion:text-c-2",
                                      icon: t ? "ChevronDown" : "ChevronRight",
                                      size: "xs",
                                    },
                                    null,
                                    8,
                                    ["icon"],
                                  ),
                                ]
                              }),
                              _: 1,
                            },
                          ),
                          No(
                            In(xy),
                            { as: "template" },
                            {
                              default: yr(() => [
                                Ro("table", Ehe, [
                                  (xo(!0),
                                  Eo(
                                    go,
                                    null,
                                    qr(
                                      n.value,
                                      ({ id: e, label: n, description: a }) => (
                                        xo(),
                                        To(
                                          In(vhe),
                                          {
                                            key: e,
                                            class: "text-c-2",
                                            onClick: (n) =>
                                              (function (e, n) {
                                                n
                                                  ? t.updateScheme(`flows.${t.schemeModel.flowKey}.selectedScopes`, [
                                                      ...r.value,
                                                      e,
                                                    ])
                                                  : t.updateScheme(
                                                      `flows.${t.schemeModel.flowKey}.selectedScopes`,
                                                      r.value.filter((t) => t !== e),
                                                    )
                                              })(e, !r.value.includes(e)),
                                          },
                                          {
                                            default: yr(() => [
                                              No(
                                                In(ohe),
                                                { class: "w-full px-2 py-1.5 hover:bg-b-2 cursor-pointer" },
                                                {
                                                  default: yr(() => [
                                                    Ro("span", null, [
                                                      Ro("span", The, at(n), 1),
                                                      Ro("span", null, " " + at(a), 1),
                                                    ]),
                                                  ]),
                                                  _: 2,
                                                },
                                                1024,
                                              ),
                                              No(
                                                In(xhe),
                                                { modelValue: r.value.includes(e), "onUpdate:modelValue": () => {} },
                                                null,
                                                8,
                                                ["modelValue"],
                                              ),
                                            ]),
                                            _: 2,
                                          },
                                          1032,
                                          ["onClick"],
                                        )
                                      ),
                                    ),
                                    128,
                                  )),
                                ]),
                              ]),
                              _: 1,
                            },
                          ),
                        ]),
                        _: 1,
                      },
                    ),
                  ]),
                ]),
                _: 1,
              },
            )
          )
        },
      }),
      Che = async (e, t) => {
        if (!("clientSecret" in e.flow))
          throw new Error("Authorize Servers only works for Client Credentials or Authorization Code flow")
        if (!e.flow) throw new Error("OAuth2 flow was not defined")
        const { flow: n, scheme: r } = e,
          a = n.selectedScopes.join(" "),
          o = new URLSearchParams()
        o.set("client_id", r.clientId),
          o.set("scope", a),
          n.clientSecret && o.set("client_secret", n.clientSecret),
          r.redirectUri && o.set("redirect_uri", r.redirectUri),
          t && (o.set("code", t), o.set("grant_type", "authorization_code")),
          "secondValue" in n
            ? (o.set("grant_type", "password"), o.set("username", n.value), o.set("password", n.secondValue))
            : o.set("grant_type", "client_credentials")
        try {
          const e = { "Content-Type": "application/x-www-form-urlencoded" }
          r.clientId && n.clientSecret && (e.Authorization = `Basic ${btoa(`${r.clientId}:${n.clientSecret}`)}`)
          const t = await fetch(n.tokenUrl, { method: "POST", headers: e, body: o }),
            { access_token: a } = await t.json()
          return a
        } catch {
          throw new Error("Failed to get an access token. Please check your credentials.")
        }
      },
      Phe = { class: "h-8 flex items-center justify-self-end" },
      Dhe = Hr({
        __name: "OAuth2",
        props: { activeScheme: {}, schemeModel: {}, updateScheme: { type: Function } },
        setup(e) {
          const t = e,
            n = mn({
              isValid: !1,
              isInvalid: !1,
              isLoading: !1,
              startLoading() {
                this.isLoading = !0
              },
              stopLoading() {
                this.isLoading = !1
              },
              validate(e = 800) {
                this.isValid = !0
                const t = e - 300
                return new Promise((e) => setTimeout(() => this.clear().then(() => e(!0)), t))
              },
              invalidate(e = 1100) {
                this.isInvalid = !0
                const t = e - 300
                return new Promise((e) => setTimeout(() => this.clear().then(() => e(!0)), t))
              },
              clear(e = 300) {
                return (
                  (this.isValid = !1),
                  (this.isInvalid = !1),
                  (this.isLoading = !1),
                  new Promise((t) => {
                    setTimeout(() => {
                      t(!0)
                    }, e)
                  })
                )
              },
            }),
            r = async () => {
              if (n.isLoading) return
              n.startLoading()
              const e = await ((e, t) =>
                new Promise((n, r) => {
                  const { flow: a, scheme: o } = e
                  if ("clientCredentials" === t.flowKey || "password" === t.flowKey) Che(e).then(n).catch(r)
                  else {
                    const i = a.selectedScopes.join(" "),
                      s = (Math.random() + 1).toString(36).substring(7),
                      l = new URL("authorizationUrl" in a ? a.authorizationUrl : a.tokenUrl)
                    "implicit" === t.flowKey
                      ? l.searchParams.set("response_type", "token")
                      : "authorizationCode" === t.flowKey && l.searchParams.set("response_type", "code"),
                      l.searchParams.set("client_id", o.clientId),
                      l.searchParams.set("redirect_uri", o.redirectUri),
                      l.searchParams.set("scope", i),
                      l.searchParams.set("state", s)
                    const c = window.open(l, "openAuth2Window", "left=100,top=100,width=800,height=600")
                    if (c) {
                      const t = setInterval(function () {
                        var a
                        let o = null,
                          i = null
                        try {
                          const e = new URL(c.location.href).searchParams
                          ;(o = e.get("access_token")), (i = e.get("code"))
                        } catch {}
                        if (c.closed || o || i)
                          if ((clearInterval(t), c.close(), o)) {
                            const e = null == (a = c.location.href.match(/state=([^&]*)/)) ? void 0 : a[1]
                            o && e === s && n(o)
                          } else
                            i
                              ? Che(e, i).then(n).catch(r)
                              : (clearInterval(t), r(new Error("Window was closed without granting authorization")))
                      }, 200)
                    }
                  }
                }))(t.activeScheme, t.schemeModel).finally(() => n.stopLoading())
              e && t.updateScheme(`flows.${t.schemeModel.flowKey}.token`, e)
            }
          return (e, t) =>
            e.activeScheme.flow.token
              ? (xo(),
                To(
                  In(vhe),
                  { key: 0 },
                  {
                    default: yr(() => [
                      No(
                        fhe,
                        {
                          id: "oauth2-access-token",
                          class: "border-r-transparent",
                          modelValue: e.activeScheme.flow.token,
                          type: "password",
                          "onUpdate:modelValue":
                            t[0] || (t[0] = (t) => e.updateScheme(`flows.${e.schemeModel.flowKey}.token`, t)),
                        },
                        { default: yr(() => [Mo(" Access Token ")]), _: 1 },
                        8,
                        ["modelValue"],
                      ),
                      No(
                        In(ohe),
                        { class: "flex items-center p-0.5" },
                        {
                          default: yr(() => [
                            No(
                              In(mw),
                              {
                                size: "sm",
                                variant: "ghost",
                                onClick:
                                  t[1] || (t[1] = (t) => e.updateScheme(`flows.${e.schemeModel.flowKey}.token`, "")),
                              },
                              { default: yr(() => [Mo(" Clear ")]), _: 1 },
                            ),
                          ]),
                          _: 1,
                        },
                      ),
                    ]),
                    _: 1,
                  },
                ))
              : (xo(),
                Eo(
                  go,
                  { key: 1 },
                  [
                    ["implicit", "authorizationCode"].includes(e.schemeModel.flowKey)
                      ? (xo(),
                        To(
                          In(vhe),
                          { key: 0 },
                          {
                            default: yr(() => [
                              No(
                                fhe,
                                {
                                  id: "oauth2-redirect-uri",
                                  modelValue: e.activeScheme.scheme.redirectUri,
                                  placeholder: "https://galaxy.scalar.com/callback",
                                  "onUpdate:modelValue": t[2] || (t[2] = (t) => e.updateScheme("redirectUri", t)),
                                },
                                { default: yr(() => [Mo(" Redirect URI ")]), _: 1 },
                                8,
                                ["modelValue"],
                              ),
                            ]),
                            _: 1,
                          },
                        ))
                      : Qo("", !0),
                    "password" === e.schemeModel.flowKey && "value" in e.activeScheme.flow
                      ? (xo(),
                        Eo(
                          go,
                          { key: 1 },
                          [
                            No(In(vhe), null, {
                              default: yr(() => [
                                No(
                                  fhe,
                                  {
                                    id: "oauth2-password-username",
                                    class: "text-c-2",
                                    modelValue: e.activeScheme.flow.value,
                                    placeholder: "ScalarEnjoyer01",
                                    "onUpdate:modelValue":
                                      t[3] || (t[3] = (t) => e.updateScheme("flows.password.value", t)),
                                  },
                                  { default: yr(() => [Mo(" Username ")]), _: 1 },
                                  8,
                                  ["modelValue"],
                                ),
                              ]),
                              _: 1,
                            }),
                            No(In(vhe), null, {
                              default: yr(() => [
                                No(
                                  fhe,
                                  {
                                    id: "oauth2-password-password",
                                    modelValue: e.activeScheme.flow.secondValue,
                                    placeholder: "XYZ123",
                                    type: "password",
                                    "onUpdate:modelValue":
                                      t[4] || (t[4] = (t) => e.updateScheme("flows.password.secondValue", t)),
                                  },
                                  { default: yr(() => [Mo(" Password ")]), _: 1 },
                                  8,
                                  ["modelValue"],
                                ),
                              ]),
                              _: 1,
                            }),
                          ],
                          64,
                        ))
                      : Qo("", !0),
                    No(In(vhe), null, {
                      default: yr(() => [
                        No(
                          fhe,
                          {
                            id: "oauth2-client-id",
                            modelValue: e.activeScheme.scheme.clientId,
                            placeholder: "12345",
                            "onUpdate:modelValue": t[5] || (t[5] = (t) => e.updateScheme("clientId", t)),
                          },
                          { default: yr(() => [Mo(" Client ID ")]), _: 1 },
                          8,
                          ["modelValue"],
                        ),
                      ]),
                      _: 1,
                    }),
                    "clientSecret" in e.activeScheme.flow
                      ? (xo(),
                        To(
                          In(vhe),
                          { key: 2 },
                          {
                            default: yr(() => [
                              No(
                                fhe,
                                {
                                  id: "oauth2-client-secret",
                                  modelValue: e.activeScheme.flow.clientSecret,
                                  placeholder: "XYZ123",
                                  type: "password",
                                  "onUpdate:modelValue":
                                    t[6] ||
                                    (t[6] = (t) =>
                                      ("authorizationCode" === e.schemeModel.flowKey ||
                                        "clientCredentials" === e.schemeModel.flowKey ||
                                        "password" === e.schemeModel.flowKey) &&
                                      e.updateScheme(`flows.${e.schemeModel.flowKey}.clientSecret`, t)),
                                },
                                { default: yr(() => [Mo(" Client Secret ")]), _: 1 },
                                8,
                                ["modelValue"],
                              ),
                            ]),
                            _: 1,
                          },
                        ))
                      : Qo("", !0),
                    e.activeScheme.flow.scopes
                      ? (xo(),
                        To(
                          In(vhe),
                          { key: 3 },
                          {
                            default: yr(() => [
                              No(
                                Ahe,
                                {
                                  activeFlow: e.activeScheme.flow,
                                  schemeModel: e.schemeModel,
                                  updateScheme: e.updateScheme,
                                },
                                null,
                                8,
                                ["activeFlow", "schemeModel", "updateScheme"],
                              ),
                            ]),
                            _: 1,
                          },
                        ))
                      : Qo("", !0),
                    No(
                      In(vhe),
                      { class: "min-w-full" },
                      {
                        default: yr(() => [
                          Ro("div", Phe, [
                            No(
                              In(mw),
                              {
                                class: "p-0 py-0.5 px-2 mr-1",
                                loading: In(n),
                                size: "sm",
                                variant: "outlined",
                                onClick: r,
                              },
                              { default: yr(() => [Mo(" Authorize ")]), _: 1 },
                              8,
                              ["loading"],
                            ),
                          ]),
                        ]),
                        _: 1,
                      },
                    ),
                  ],
                  64,
                ))
        },
      }),
      Rhe = { class: "flex gap-1" },
      Nhe = { class: "flex h-8 items-center" },
      $he = Ro(
        "div",
        { class: "text-c-2 flex min-w-[100px] items-center border-r-1/2 pr-0 pl-2 h-full" },
        " Auth Type ",
        -1,
      ),
      Ihe = { class: "pl-2" },
      Mhe = Hr({
        __name: "RequestAuth",
        props: { title: {} },
        setup(e) {
          const {
              activeCollection: t,
              collectionMutators: n,
              activeSecurityRequirements: r,
              activeSecurityScheme: a,
              securitySchemes: o,
              securitySchemeMutators: i,
            } = E8(),
            s = (e) => {
              const t = o[e]
              switch (null == t ? void 0 : t.type) {
                case "apiKey":
                  return `${Qe(t.in)} (${e})`
                case "http":
                  return `${Qe(t.scheme)} Authentication (${e})`
                case "openIdConnect":
                  return `Open ID Connect (${e})`
                default:
                  return "None"
              }
            },
            l = ii(() =>
              r.value.flatMap((e) => {
                const t = Object.keys(e)
                return 0 === t.length
                  ? { id: "none", label: "None" }
                  : t.flatMap((e) => {
                      const t = o[e]
                      return "oauth2" === (null == t ? void 0 : t.type)
                        ? Object.keys(t.flows).map((t) => {
                            return {
                              id: `${e}${t}`,
                              label: `${
                                ((n = t),
                                n
                                  .replace(/([A-Z])/g, (e) => ` ${e}`)
                                  .replace(/^./, (e) => e.toUpperCase())
                                  .trim())
                              } (${e})`,
                              flowKey: t,
                              uid: e,
                            }
                            var n
                          })
                        : { id: e, label: s(e) }
                    })
              }),
            ),
            c = ii({
              get: () => {
                var e, n
                const r = null == (n = null == (e = t.value) ? void 0 : e.selectedSecuritySchemes) ? void 0 : n[0]
                return (
                  l.value.find(
                    ({ id: e }) => e === `${null == r ? void 0 : r.uid}${(null == r ? void 0 : r.flowKey) ?? ""}`,
                  ) || l.value[0]
                )
              },
              set: (e) => {
                if (null == e || !e.id) return
                const r = "uid" in e ? { flowKey: e.flowKey, uid: e.uid } : { uid: e.id }
                n.edit(t.value.uid, "selectedSecuritySchemes", [r])
              },
            }),
            d = (e, t) => {
              var n
              return i.edit((null == (n = a.value) ? void 0 : n.scheme.uid) ?? "", e, t)
            }
          return (e, t) => (
            xo(),
            To(
              ahe,
              { class: "group/params", itemCount: l.value.length },
              {
                title: yr(() => [Ro("div", Rhe, at(e.title), 1)]),
                default: yr(() => [
                  Ro("form", null, [
                    No(
                      In(ghe),
                      { class: "flex-1", columns: [""] },
                      {
                        default: yr(() => {
                          var e, n, r, o
                          return [
                            No(In(vhe), null, {
                              default: yr(() => [
                                No(
                                  In(yhe),
                                  {
                                    class: "relative col-span-full cursor-pointer py-[0px] px-[0px] flex items-center",
                                  },
                                  {
                                    default: yr(() => [
                                      No(
                                        In(vL),
                                        {
                                          modelValue: c.value,
                                          "onUpdate:modelValue": t[0] || (t[0] = (e) => (c.value = e)),
                                          class: "text-xs w-full left-2",
                                          fullWidth: "",
                                          options: l.value,
                                          teleport: "",
                                        },
                                        {
                                          default: yr(() => [
                                            No(
                                              In(mw),
                                              {
                                                class:
                                                  "flex gap-1.5 h-auto py-0 px-0 text-c-2 hover:text-c-1 font-normal",
                                                fullWidth: "",
                                                variant: "ghost",
                                              },
                                              {
                                                default: yr(() => {
                                                  var e
                                                  return [
                                                    Ro("div", Nhe, [
                                                      $he,
                                                      Ro("span", Ihe, at(null == (e = c.value) ? void 0 : e.label), 1),
                                                      No(In(BI), { icon: "ChevronDown", size: "xs" }),
                                                    ]),
                                                  ]
                                                }),
                                                _: 1,
                                              },
                                            ),
                                          ]),
                                          _: 1,
                                        },
                                        8,
                                        ["modelValue", "options"],
                                      ),
                                    ]),
                                    _: 1,
                                  },
                                ),
                              ]),
                              _: 1,
                            }),
                            "http" === (null == (e = In(a)) ? void 0 : e.scheme.type) &&
                            "bearer" === In(a).scheme.scheme
                              ? (xo(),
                                To(
                                  In(vhe),
                                  { key: 0 },
                                  {
                                    default: yr(() => [
                                      No(
                                        fhe,
                                        {
                                          id: "http-bearer-token",
                                          modelValue: In(a).scheme.value,
                                          placeholder: "Token",
                                          type: "password",
                                          "onUpdate:modelValue": t[1] || (t[1] = (e) => d("value", e)),
                                        },
                                        { default: yr(() => [Mo(" Bearer Token ")]), _: 1 },
                                        8,
                                        ["modelValue"],
                                      ),
                                    ]),
                                    _: 1,
                                  },
                                ))
                              : "http" === (null == (n = In(a)) ? void 0 : n.scheme.type) &&
                                  "basic" === In(a).scheme.scheme
                                ? (xo(),
                                  Eo(
                                    go,
                                    { key: 1 },
                                    [
                                      No(In(vhe), null, {
                                        default: yr(() => [
                                          No(
                                            fhe,
                                            {
                                              id: "http-basic-username",
                                              class: "text-c-2",
                                              modelValue: In(a).scheme.value,
                                              placeholder: "ScalarEnjoyer01",
                                              "onUpdate:modelValue": t[2] || (t[2] = (e) => d("value", e)),
                                            },
                                            { default: yr(() => [Mo(" Username ")]), _: 1 },
                                            8,
                                            ["modelValue"],
                                          ),
                                        ]),
                                        _: 1,
                                      }),
                                      No(In(vhe), null, {
                                        default: yr(() => [
                                          No(
                                            fhe,
                                            {
                                              id: "http-basic-password",
                                              modelValue: In(a).scheme.secondValue,
                                              placeholder: "xxxxxx",
                                              type: "password",
                                              "onUpdate:modelValue": t[3] || (t[3] = (e) => d("secondValue", e)),
                                            },
                                            { default: yr(() => [Mo(" Password ")]), _: 1 },
                                            8,
                                            ["modelValue"],
                                          ),
                                        ]),
                                        _: 1,
                                      }),
                                    ],
                                    64,
                                  ))
                                : "apiKey" === (null == (r = In(a)) ? void 0 : r.scheme.type)
                                  ? (xo(),
                                    To(
                                      In(vhe),
                                      { key: 2 },
                                      {
                                        default: yr(() => [
                                          No(
                                            fhe,
                                            {
                                              id: `api-key-${In(a).scheme.name}`,
                                              modelValue: In(a).scheme.value,
                                              placeholder: "Value",
                                              type: "password",
                                              "onUpdate:modelValue": t[4] || (t[4] = (e) => d("value", e)),
                                            },
                                            { default: yr(() => [Mo(at(In(a).scheme.name), 1)]), _: 1 },
                                            8,
                                            ["id", "modelValue"],
                                          ),
                                        ]),
                                        _: 1,
                                      },
                                    ))
                                  : "oauth2" === (null == (o = In(a)) ? void 0 : o.scheme.type) &&
                                      "uid" in c.value &&
                                      In(a).flow
                                    ? (xo(),
                                      To(
                                        In(Dhe),
                                        { key: 3, activeScheme: In(a), schemeModel: c.value, updateScheme: d },
                                        null,
                                        8,
                                        ["activeScheme", "schemeModel"],
                                      ))
                                    : Qo("", !0),
                          ]
                        }),
                        _: 1,
                      },
                    ),
                  ]),
                ]),
                _: 1,
              },
              8,
              ["itemCount"],
            )
          )
        },
      }),
      Lhe = {
        class:
          "grid gap-1.5 pointer-events-none min-w-48 w-content shadow-lg rounded bg-b-1 z-100 p-2 text-xxs leading-5 z-10 text-c-1",
      },
      Qhe = { class: "flex items-center text-c-2" },
      Bhe = { key: 0 },
      jhe = { key: 1, class: "before:content-[''] before:block before:mx-[0.5ch] flex" },
      Uhe = { key: 2, class: "before:content-[''] before:block before:mx-[0.5ch] flex whitespace-nowrap" },
      Fhe = { key: 3, class: "before:content-[''] before:block before:mx-[0.5ch] flex whitespace-nowrap" },
      zhe = { key: 4, class: "before:content-[''] before:block before:mx-[0.5ch] flex whitespace-nowrap" },
      qhe = { key: 0, class: "leading-snug text-pretty text-sm", style: { maxWidth: "16rem" } },
      Zhe = Hr({
        __name: "RequestTableTooltip",
        props: { item: {} },
        setup: (e) => (e, t) => (
          xo(),
          To(
            In(PQ),
            { align: "start", class: "w-full", delay: 0, side: "left", triggerClass: "p-[7px]" },
            {
              trigger: yr(() => [
                No(In(BI), {
                  class: "ml-1 text-c-3 group-hover/info:text-c-1",
                  icon: "Info",
                  size: "sm",
                  thickness: "1.5",
                }),
              ]),
              content: yr(() => [
                Ro("div", Lhe, [
                  Ro("div", Qhe, [
                    e.item.type ? (xo(), Eo("span", Bhe, at(e.item.type), 1)) : Qo("", !0),
                    e.item.format ? (xo(), Eo("span", jhe, at(e.item.format), 1)) : Qo("", !0),
                    e.item.minimum ? (xo(), Eo("span", Uhe, "min: " + at(e.item.minimum), 1)) : Qo("", !0),
                    e.item.maximum ? (xo(), Eo("span", Fhe, "max: " + at(e.item.maximum), 1)) : Qo("", !0),
                    e.item.default ? (xo(), Eo("span", zhe, "default: " + at(e.item.default), 1)) : Qo("", !0),
                  ]),
                  e.item.description ? (xo(), Eo("span", qhe, at(e.item.description), 1)) : Qo("", !0),
                ]),
              ]),
              _: 1,
            },
          )
        ),
      }),
      Hhe = { class: "text-c-2 max-w-[100%] overflow-hidden filemask flex items-end justify-end" },
      Vhe = ["onClick"],
      Whe = ((e) => (br("data-v-92212893"), (e = e()), vr(), e))(() => Ro("span", null, "File", -1)),
      Xhe = Hr({
        __name: "RequestTable",
        props: {
          items: {},
          isEnabledHidden: { type: Boolean, default: !1 },
          showUploadButton: { type: Boolean, default: !1 },
        },
        emits: ["updateRow", "toggleRow", "addRow", "deleteRow", "inputFocus", "inputBlur", "uploadFile", "removeFile"],
        setup(e, { emit: t }) {
          const n = t,
            r = e.isEnabledHidden ? ["", ""] : ["", "", "36px"],
            a = (e, t, r) => {
              n("updateRow", e, t, r)
            },
            o = (e) => !!(e.description || e.type || e.default || e.format),
            i = (e) =>
              ii(() => {
                if ("integer" === e.type && void 0 !== e.value) {
                  const t = Number(e.value)
                  if (void 0 !== e.minimum && t < e.minimum) return `Min is ${e.minimum}`
                  if (void 0 !== e.maximum && t > e.maximum) return `Max is ${e.maximum}`
                }
                return !1
              }),
            s = (e) => (Array.isArray(e.default) && 1 === e.default.length ? e.default[0] : e.default)
          return (e, t) => (
            xo(),
            To(
              ghe,
              { class: "flex-1", columns: In(r) },
              {
                default: yr(() => [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(
                      e.items,
                      (r, l) => (
                        xo(),
                        To(
                          vhe,
                          { key: l },
                          {
                            default: yr(() => [
                              e.isEnabledHidden
                                ? Qo("", !0)
                                : (xo(),
                                  To(
                                    xhe,
                                    {
                                      key: 0,
                                      modelValue: r.enabled,
                                      "onUpdate:modelValue": (e) => n("toggleRow", l, e),
                                    },
                                    null,
                                    8,
                                    ["modelValue", "onUpdate:modelValue"],
                                  )),
                              No(
                                ohe,
                                null,
                                {
                                  default: yr(() => [
                                    No(
                                      cpe,
                                      {
                                        disableCloseBrackets: "",
                                        disableEnter: "",
                                        disableTabIndent: "",
                                        modelValue: r.key,
                                        placeholder: "Key",
                                        required: r.required,
                                        onBlur: t[0] || (t[0] = (e) => n("inputBlur")),
                                        onFocus: t[1] || (t[1] = (e) => n("inputFocus")),
                                        onInput: (t) => e.items && l === e.items.length - 1 && n("addRow"),
                                        onSelectVariable: (e) => a(l, "key", e),
                                        "onUpdate:modelValue": (e) => n("updateRow", l, "key", e),
                                      },
                                      null,
                                      8,
                                      ["modelValue", "required", "onInput", "onSelectVariable", "onUpdate:modelValue"],
                                    ),
                                  ]),
                                  _: 2,
                                },
                                1024,
                              ),
                              No(
                                ohe,
                                null,
                                {
                                  default: yr(() => [
                                    No(
                                      cpe,
                                      {
                                        disableCloseBrackets: "",
                                        disableEnter: "",
                                        disableTabIndent: "",
                                        enum: r.enum,
                                        max: r.maximum,
                                        min: r.minimum,
                                        modelValue: r.value,
                                        nullable: r.nullable,
                                        placeholder: "Value",
                                        type: r.type,
                                        onBlur: t[2] || (t[2] = (e) => n("inputBlur")),
                                        onFocus: t[3] || (t[3] = (e) => n("inputFocus")),
                                        onInput: (t) => e.items && l === e.items.length - 1 && n("addRow"),
                                        onSelectVariable: (e) => a(l, "value", e),
                                        "onUpdate:modelValue": (e) => n("updateRow", l, "value", e),
                                      },
                                      Zr(
                                        {
                                          icon: yr(() => [
                                            o(r)
                                              ? (xo(),
                                                To(Zhe, { key: 0, item: { ...r, default: s(r) } }, null, 8, ["item"]))
                                              : Qo("", !0),
                                          ]),
                                          _: 2,
                                        },
                                        [
                                          i(r).value
                                            ? { name: "warning", fn: yr(() => [Mo(at(i(r).value), 1)]), key: "0" }
                                            : void 0,
                                        ],
                                      ),
                                      1032,
                                      [
                                        "enum",
                                        "max",
                                        "min",
                                        "modelValue",
                                        "nullable",
                                        "type",
                                        "onInput",
                                        "onSelectVariable",
                                        "onUpdate:modelValue",
                                      ],
                                    ),
                                  ]),
                                  _: 2,
                                },
                                1024,
                              ),
                              e.showUploadButton
                                ? (xo(),
                                  To(
                                    ohe,
                                    {
                                      key: 1,
                                      class:
                                        "group/upload p-1 overflow-hidden relative text-ellipsis whitespace-nowrap",
                                    },
                                    {
                                      default: yr(() => {
                                        var e
                                        return [
                                          r.file
                                            ? (xo(),
                                              Eo(
                                                go,
                                                { key: 0 },
                                                [
                                                  Ro("div", Hhe, [
                                                    Ro("span", null, at(null == (e = r.file) ? void 0 : e.name), 1),
                                                  ]),
                                                  Ro(
                                                    "button",
                                                    {
                                                      class:
                                                        "absolute bg-b-2 font-medium centered-x centered-y hidden rounded text-center p-0.5 w-[calc(100%_-_8px)] group-hover/upload:block text-xs",
                                                      type: "button",
                                                      onClick: (e) => n("removeFile", l),
                                                    },
                                                    " Delete ",
                                                    8,
                                                    Vhe,
                                                  ),
                                                ],
                                                64,
                                              ))
                                            : (xo(),
                                              To(
                                                In(mw),
                                                {
                                                  key: 1,
                                                  class: "bg-b-2 hover:bg-b-3 border-0 py-px text-c-2",
                                                  size: "sm",
                                                  variant: "outlined",
                                                  onClick: (e) =>
                                                    ((e) => {
                                                      n("uploadFile", e)
                                                    })(l),
                                                },
                                                {
                                                  default: yr(() => [
                                                    Whe,
                                                    No(In(BI), {
                                                      class: "ml-1",
                                                      icon: "UploadSimple",
                                                      size: "xs",
                                                      thickness: "2.5",
                                                    }),
                                                  ]),
                                                  _: 2,
                                                },
                                                1032,
                                                ["onClick"],
                                              )),
                                        ]
                                      }),
                                      _: 2,
                                    },
                                    1024,
                                  ))
                                : Qo("", !0),
                            ]),
                            _: 2,
                          },
                          1024,
                        )
                      ),
                    ),
                    128,
                  )),
                ]),
                _: 1,
              },
              8,
              ["columns"],
            )
          )
        },
      }),
      Yhe = T8(Xhe, [["__scopeId", "data-v-92212893"]]),
      Ghe = {
        key: 0,
        class:
          "text-c-3 flex min-h-14 w-full items-center justify-center rounded border border-dashed text-center text-base",
      },
      Khe = [Ro("span", null, "No Body", -1)],
      Jhe = { key: 0, class: "text-c-3 flex min-h-10 w-full items-center justify-center p-2 text-sm" },
      efe = [Ro("span", null, "No Body", -1)],
      tfe = { key: 1, class: "flex items-center justify-center p-1.5 overflow-hidden" },
      nfe = { class: "text-c-2 text-xs w-full border rounded p-1 max-w-full overflow-hidden whitespace-nowrap" },
      rfe = Ro("span", null, "Upload File", -1),
      afe = Hr({
        __name: "RequestBody",
        props: { title: {}, body: {}, formData: {} },
        setup(e) {
          const { activeRequest: t, activeExample: n, requestExampleMutators: r } = E8(),
            a = Dn("none"),
            o = Dn(null),
            i = { json: "json", xml: "xml", yaml: "yaml", edn: "edn", other: "html" },
            s = ii(() => {
              const e = a.value
              return i[e] ?? "plaintext"
            })
          function l() {
            console.log("deleteRow")
          }
          const c = (e, a, i) => {
              if (!t.value || !n.value) return
              const s = d.value
              if (s.length > e) {
                const t = [...s]
                ;(t[e] = { ...t[e], [a]: i }),
                  ("" !== t[e].key || "" !== t[e].value) && (t[e].enabled = !0),
                  "" === t[e].key && "" === t[e].value && t.splice(e, 1),
                  r.edit(n.value.uid, "body.formData.value", t)
              } else {
                const e = [u4({ [a]: i })]
                r.edit(n.value.uid, "body.formData.value", e),
                  rr(() => {
                    var e
                    o.value && (null == (e = o.value.querySelectorAll("input")["key" === a ? 0 : 1]) || e.focus())
                  })
              }
            },
            d = ii(() => {
              var e
              return (null == (e = n.value) ? void 0 : e.body.formData.value) ?? []
            }),
            u = () => {
              if (!t.value || !n.value) return
              const e = u4({ enabled: !1 }),
                a = [...d.value, e]
              r.edit(n.value.uid, "body.formData.value", a)
            },
            p = (e) => {
              !t.value || !n.value || r.edit(n.value.uid, "body.raw.value", e)
            },
            h = async (e) => {
              const { open: a } = I8({
                onChange: async (a) => {
                  const o = null == a ? void 0 : a[0]
                  if (o && t.value && n.value) {
                    const t = [...d.value]
                    ;(t[e] = { ...t[e], file: o }), r.edit(n.value.uid, "body.formData.value", t)
                  }
                },
                multiple: !1,
                accept: "*/*",
              })
              a()
            }
          function f() {
            !t.value || !n.value || r.edit(n.value.uid, "body.binary", void 0)
          }
          function m(e) {
            if (!t.value || !n.value) return
            const a = [...d.value]
            ;(a[e] = { ...a[e], file: void 0 }), r.edit(n.value.uid, "body.formData.value", a)
          }
          function g() {
            const { open: e } = I8({
              onChange: async (e) => {
                const a = null == e ? void 0 : e[0]
                a && t.value && n.value && r.edit(n.value.uid, "body.binary", a)
              },
              multiple: !1,
              accept: "*/*",
            })
            e()
          }
          const b = Object.entries({
              multipartForm: "Multipart Form",
              formUrlEncoded: "Form URL Encoded",
              binaryFile: "Binary File",
              json: "JSON",
              xml: "XML",
              yaml: "YAML",
              edn: "EDN",
              other: "Other",
              none: "None",
            }).map(([e, t]) => ({ id: e, label: t, value: e })),
            v = ii({
              get: () => b.find((e) => e.id === a.value),
              set: (e) => {
                null != e && e.id && (a.value = e.id)
              },
            }),
            y = ii(() =>
              n.value
                ? "formData" === n.value.body.activeBody &&
                  n.value.body.formData &&
                  n.value.body.formData.value.length > 0
                  ? "multipartForm"
                  : "raw" === n.value.body.activeBody
                    ? n.value.body.raw.encoding
                    : a.value
                : "none",
            )
          return (
            "none" !== y.value && (a.value = y.value),
            Ya(
              y,
              (e) => {
                e && (a.value = e)
              },
              { immediate: !0 },
            ),
            Ya(
              a,
              (e) => {
                ;("multipartForm" === e || "formUrlEncoded" === e) && 0 === d.value.length && u(),
                  ((e) => {
                    const t = ((e) =>
                        "multipartForm" === e
                          ? "multipart/form-data"
                          : "formUrlEncoded" === e
                            ? "application/x-www-form-urlencoded"
                            : "binaryFile" === e
                              ? "application/octet-stream"
                              : "none" !== e
                                ? `application/${e}`
                                : "")(e),
                      a = ((e) =>
                        "multipartForm" === e || "formUrlEncoded" === e
                          ? "formData"
                          : "binaryFile" === e
                            ? "binary"
                            : "raw")(e)
                    r.edit(n.value.uid, "body.activeBody", a)
                    const o = [...n.value.parameters.headers].findIndex(
                        (e) => e.key.toLowerCase() === "Content-Type".toLowerCase(),
                      ),
                      i = [...n.value.parameters.headers][o]
                    if ((null == i ? void 0 : i.value) !== t)
                      if (i && t) {
                        const e = [...n.value.parameters.headers]
                        ;(e[o].value = t), r.edit(n.value.uid, "parameters.headers", e)
                      } else if (t) {
                        const e = [
                          ...n.value.parameters.headers.filter(
                            (e) => e.key.toLowerCase() !== "Content-Type".toLowerCase(),
                          ),
                        ]
                        e.push({ key: "Content-Type", value: t, enabled: !0 }),
                          r.edit(n.value.uid, "parameters.headers", e)
                      }
                  })(e)
              },
              { immediate: !0 },
            ),
            (e, t) => (
              xo(),
              To(ahe, null, {
                title: yr(() => [Mo(at(e.title), 1)]),
                default: yr(() => [
                  e.body && 0 === e.body.length && e.formData && 0 === e.formData.length
                    ? (xo(), Eo("div", Ghe, Khe))
                    : e.formData && e.formData.length > 0
                      ? (xo(), Eo(go, { key: 1 }, [], 64))
                      : (xo(),
                        To(
                          ghe,
                          { key: 2, columns: [""] },
                          {
                            default: yr(() => [
                              No(vhe, null, {
                                default: yr(() => [
                                  No(
                                    yhe,
                                    {
                                      class:
                                        "relative col-span-full flex h-8 cursor-pointer items-center px-[2.25px] py-[2.25px]",
                                    },
                                    {
                                      default: yr(() => [
                                        No(
                                          In(vL),
                                          {
                                            modelValue: v.value,
                                            "onUpdate:modelValue": t[0] || (t[0] = (e) => (v.value = e)),
                                            class: "text-xxs w-full",
                                            fullWidth: "",
                                            options: In(b),
                                            teleport: "",
                                          },
                                          {
                                            default: yr(() => [
                                              No(
                                                In(mw),
                                                {
                                                  class:
                                                    "flex gap-1.5 h-auto px-1.5 text-c-2 font-normal hover:text-c-1",
                                                  fullWidth: "",
                                                  variant: "ghost",
                                                },
                                                {
                                                  default: yr(() => {
                                                    var e
                                                    return [
                                                      Ro("span", null, at(null == (e = v.value) ? void 0 : e.label), 1),
                                                      No(In(BI), { icon: "ChevronDown", size: "xs", thickness: "2.5" }),
                                                    ]
                                                  }),
                                                  _: 1,
                                                },
                                              ),
                                            ]),
                                            _: 1,
                                          },
                                          8,
                                          ["modelValue", "options"],
                                        ),
                                      ]),
                                      _: 1,
                                    },
                                  ),
                                ]),
                                _: 1,
                              }),
                              No(vhe, null, {
                                default: yr(() => {
                                  var e, t, r
                                  return [
                                    "none" === a.value
                                      ? (xo(), Eo("div", Jhe, efe))
                                      : "binaryFile" === a.value
                                        ? (xo(),
                                          Eo("div", tfe, [
                                            null != (e = In(n)) && e.body.binary
                                              ? (xo(),
                                                Eo(
                                                  go,
                                                  { key: 0 },
                                                  [
                                                    Ro(
                                                      "span",
                                                      nfe,
                                                      at(null == (t = In(n)) ? void 0 : t.body.binary.name),
                                                      1,
                                                    ),
                                                    No(
                                                      In(mw),
                                                      {
                                                        class: "bg-b-2 hover:bg-b-3 border-0 text-c-2 ml-1",
                                                        size: "sm",
                                                        variant: "outlined",
                                                        onClick: f,
                                                      },
                                                      { default: yr(() => [Mo(" Delete ")]), _: 1 },
                                                    ),
                                                  ],
                                                  64,
                                                ))
                                              : (xo(),
                                                To(
                                                  In(mw),
                                                  {
                                                    key: 1,
                                                    class: "bg-b-2 hover:bg-b-3 border-0 text-c-2",
                                                    size: "sm",
                                                    variant: "outlined",
                                                    onClick: g,
                                                  },
                                                  {
                                                    default: yr(() => [
                                                      rfe,
                                                      No(In(BI), {
                                                        class: "ml-1",
                                                        icon: "UploadSimple",
                                                        size: "xs",
                                                        thickness: "2.5",
                                                      }),
                                                    ]),
                                                    _: 1,
                                                  },
                                                )),
                                          ]))
                                        : "multipartForm" == a.value
                                          ? (xo(),
                                            To(
                                              Yhe,
                                              {
                                                key: 2,
                                                ref_key: "tableWrapperRef",
                                                ref: o,
                                                class:
                                                  "!m-0 rounded-t-none shadow-none border-l-0 border-r-0 border-t-0 border-b-0",
                                                columns: ["32px", "", "", "61px"],
                                                items: d.value,
                                                showUploadButton: "",
                                                onAddRow: u,
                                                onDeleteRow: l,
                                                onRemoveFile: m,
                                                onUpdateRow: c,
                                                onUploadFile: h,
                                              },
                                              null,
                                              8,
                                              ["items"],
                                            ))
                                          : "formUrlEncoded" == a.value
                                            ? (xo(),
                                              To(
                                                Yhe,
                                                {
                                                  key: 3,
                                                  ref_key: "tableWrapperRef",
                                                  ref: o,
                                                  class:
                                                    "!m-0 rounded-t-none border-t-0 shadow-none border-l-0 border-r-0 border-t-0 border-b-0",
                                                  columns: ["32px", "", "", "61px"],
                                                  items: d.value,
                                                  showUploadButton: "",
                                                  onAddRow: u,
                                                  onDeleteRow: l,
                                                  onRemoveFile: m,
                                                  onUpdateRow: c,
                                                  onUploadFile: h,
                                                },
                                                null,
                                                8,
                                                ["items"],
                                              ))
                                            : (xo(),
                                              To(
                                                cpe,
                                                {
                                                  key: 4,
                                                  content: "",
                                                  language: s.value,
                                                  lineNumbers: "",
                                                  lint: "",
                                                  modelValue: (null == (r = In(n)) ? void 0 : r.body.raw.value) ?? "",
                                                  "onUpdate:modelValue": p,
                                                },
                                                null,
                                                8,
                                                ["language", "modelValue"],
                                              )),
                                  ]
                                }),
                                _: 1,
                              }),
                              No(vhe),
                            ]),
                            _: 1,
                          },
                        )),
                ]),
                _: 1,
              })
            )
          )
        },
      }),
      ofe = { class: "text-c-2 flex whitespace-nowrap opacity-0 group-hover/params:opacity-100 request-meta-buttons" },
      ife = Hr({
        __name: "RequestParams",
        props: { title: {}, paramKey: {} },
        setup(e) {
          const t = e,
            { activeRequest: n, activeExample: r, requestExampleMutators: a } = E8(),
            o = ii(() => {
              var e
              return (null == (e = r.value) ? void 0 : e.parameters[t.paramKey]) ?? []
            })
          Nr(() => {
            u()
          })
          const i = () => {
              if (!n.value || !r.value) return
              const e = u4({ enabled: !1 }),
                i = [...o.value, e]
              a.edit(r.value.uid, `parameters.${t.paramKey}`, i)
            },
            s = Dn(null),
            l = (e, i, l) => {
              if (!n.value || !r.value) return
              const c = o.value
              if (c.length > e) {
                const n = [...c]
                ;(n[e] = { ...n[e], [i]: l }),
                  ("" !== n[e].key || "" !== n[e].value) && (n[e].enabled = !0),
                  "" === n[e].key && "" === n[e].value && n.splice(e, 1),
                  a.edit(r.value.uid, `parameters.${t.paramKey}`, n)
              } else {
                const e = [u4({ [i]: l })]
                a.edit(r.value.uid, `parameters.${t.paramKey}`, e),
                  rr(() => {
                    var e
                    s.value && (null == (e = s.value.querySelectorAll("input")["key" === i ? 0 : 1]) || e.focus())
                  })
              }
            },
            c = (e, o) => n.value && r.value && a.edit(r.value.uid, `parameters.${t.paramKey}.${e}.enabled`, o),
            d = () => {
              !n.value ||
                !r.value ||
                (a.edit(r.value.uid, `parameters.${t.paramKey}`, []),
                rr(() => {
                  i()
                }))
            }
          function u() {
            if (0 === o.value.length) i()
            else if (o.value.length >= 1) {
              const e = o.value[o.value.length - 1]
              "" !== e.key && "" !== e.value && i()
            }
          }
          const p = ii(() => o.value.filter((e) => e.key || e.value).length)
          return (
            Ya(
              () => r.value,
              (e, t) => {
                e !== t && u()
              },
              { immediate: !0 },
            ),
            (e, t) => (
              xo(),
              To(
                ahe,
                { class: "group/params", itemCount: p.value },
                {
                  title: yr(() => [Mo(at(e.title), 1)]),
                  actions: yr(() => [
                    Ro("div", ofe, [
                      No(
                        In(mw),
                        { class: "px-1 transition-none", size: "sm", variant: "ghost", onClick: Wi(d, ["stop"]) },
                        { default: yr(() => [Mo(" Clear ")]), _: 1 },
                      ),
                    ]),
                  ]),
                  default: yr(() => [
                    Ro(
                      "div",
                      { ref_key: "tableWrapperRef", ref: s },
                      [
                        No(
                          Yhe,
                          {
                            class: "flex-1",
                            columns: ["32px", "", ""],
                            items: o.value,
                            onAddRow: i,
                            onToggleRow: c,
                            onUpdateRow: l,
                          },
                          null,
                          8,
                          ["items"],
                        ),
                      ],
                      512,
                    ),
                  ]),
                  _: 1,
                },
                8,
                ["itemCount"],
              )
            )
          )
        },
      }),
      sfe = {
        key: 1,
        class: "text-c-3 px-4 text-sm border rounded min-h-12 justify-center flex items-center bg-b-1 mx-1",
      },
      lfe = Ro("code", { class: "bg-b-2 ml-1 px-1 rounded" }, "/endpoint/{my_path_variable}", -1),
      cfe = Hr({
        __name: "RequestPathParams",
        props: { title: {}, paramKey: {} },
        setup(e) {
          const t = e,
            { activeRequest: n, activeExample: r, requestMutators: a, requestExampleMutators: o } = E8(),
            i = ii(() => {
              var e
              return (null == (e = r.value) ? void 0 : e.parameters[t.paramKey]) ?? []
            }),
            s = (e, i, s) => {
              var l, c
              if (!n.value || !r.value) return
              const d = r.value.parameters[t.paramKey],
                u = null == (l = d[e]) ? void 0 : l.key
              if ("key" === i) {
                if (null != (c = d[e]) && c.required) return
                if (s) {
                  const e = encodeURIComponent(u),
                    t = encodeURIComponent(s),
                    r = new RegExp(`(?<=/):${e}(?=[/?#]|$)`, "g"),
                    o = n.value.path.replace(r, `:${t}`)
                  a.edit(n.value.uid, "path", o)
                } else {
                  d.splice(e, 1)
                  const t = new RegExp(`/:${encodeURIComponent(u)}(?=[/?#]|$)`, "g"),
                    r = n.value.path.replace(t, "")
                  a.edit(n.value.uid, "path", r)
                }
              }
              o.edit(r.value.uid, `parameters.${t.paramKey}.${e}.${i}`, s)
            }
          return (e, t) => (
            xo(),
            To(
              ahe,
              { itemCount: i.value.length },
              {
                title: yr(() => [Mo(at(e.title), 1)]),
                default: yr(() => [
                  i.value.length
                    ? (xo(),
                      To(
                        Yhe,
                        { key: 0, class: "flex-1", isEnabledHidden: "", items: i.value, onUpdateRow: s },
                        null,
                        8,
                        ["items"],
                      ))
                    : (xo(), Eo("div", sfe, [Mo(" You can use variables in your path: "), lfe])),
                ]),
                _: 1,
              },
              8,
              ["itemCount"],
            )
          )
        },
      }),
      dfe = { class: "flex-1" },
      ufe = { class: "text-c-3 pl-1" },
      pfe = { class: "request-section-content custom-scroll flex flex-1 flex-col px-2 xl:px-5 py-2.5" },
      hfe = Hr({
        __name: "RequestSection",
        setup(e) {
          const { activeRequest: t, activeExample: n, activeSecurityRequirements: r } = E8(),
            a = ["POST", "PUT", "PATCH", "DELETE"],
            o = ii(() => {
              const e = ["All", "Auth", "Request", "Cookies", "Headers", "Query", "Body"]
              return (
                n.value.parameters.path.length || e.splice(e.indexOf("Request"), 1),
                a.includes(t.value.method) || e.splice(e.indexOf("Body"), 1),
                i.value && e.splice(e.indexOf("Auth"), 1),
                e
              )
            }),
            i = ii(() => 0 === r.value.length || "[{}]" === JSON.stringify(r.value)),
            s = Dn("All")
          return (
            Ya(t, (e) => {
              "Body" === s.value && !a.includes(e.method) && (s.value = "All")
            }),
            (e, r) => (
              xo(),
              To(Jpe, null, {
                title: yr(() => {
                  var e
                  return [
                    No(In(BI), { class: "text-c-3 mr-2", icon: "ExternalLink", size: "sm", thickness: "2.5" }),
                    Ro("div", dfe, [Mo(" Request "), Ro("span", ufe, at(null == (e = In(t)) ? void 0 : e.summary), 1)]),
                  ]
                }),
                default: yr(() => [
                  Ro("div", pfe, [
                    No(
                      Ype,
                      {
                        activeSection: s.value,
                        sections: o.value,
                        onSetActiveSection: r[0] || (r[0] = (e) => (s.value = e)),
                      },
                      null,
                      8,
                      ["activeSection", "sections"],
                    ),
                    Fr(No(Mhe, { title: "Authentication" }, null, 512), [
                      [mi, !i.value && ("All" === s.value || "Auth" === s.value)],
                    ]),
                    Fr(No(cfe, { paramKey: "path", title: "Path Variables" }, null, 512), [
                      [mi, ("All" === s.value || "Request" === s.value) && In(n).parameters.path.length > 0],
                    ]),
                    Fr(No(ife, { paramKey: "cookies", title: "Cookies" }, null, 512), [
                      [mi, "All" === s.value || "Cookies" === s.value],
                    ]),
                    Fr(No(ife, { paramKey: "headers", title: "Headers" }, null, 512), [
                      [mi, "All" === s.value || "Headers" === s.value],
                    ]),
                    Fr(No(ife, { paramKey: "query", title: "Query Parameters" }, null, 512), [
                      [mi, "All" === s.value || "Query" === s.value],
                    ]),
                    Fr(No(afe, { body: "foo", title: "Body" }, null, 512), [
                      [mi, ("All" === s.value || "Body" === s.value) && a.includes(In(t).method)],
                    ]),
                  ]),
                ]),
                _: 1,
              })
            )
          )
        },
      }),
      ffe = Hr({
        __name: "ResponseBody",
        props: { title: {}, data: { default: null }, headers: {} },
        setup(e) {
          const t = e,
            n = ii(() => {
              var e
              const n =
                (null == (e = t.headers.find((e) => "content-type" === e.name.toLowerCase())) ? void 0 : e.value) ?? ""
              return n.includes("json") ? "json" : (n.includes("html"), "html")
            }),
            r = Dn(null)
          return (
            $ue({ codeMirrorRef: r, readOnly: !0, lineNumbers: !0, content: zn(() => t.data), language: n }),
            (e, t) => (
              xo(),
              To(ahe, null, {
                title: yr(() => [Mo(at(e.title), 1)]),
                default: yr(() => [Ro("div", { ref_key: "codeMirrorRef", ref: r }, null, 512)]),
                _: 1,
              })
            )
          )
        },
      }),
      mfe = T8(ffe, [["__scopeId", "data-v-223b333c"]]),
      gfe = Hr({
        __name: "ScalarAsciiArt",
        props: { art: {}, animate: { type: Boolean } },
        setup(e) {
          const t = e,
            n = ii(() => t.art.split("\n")),
            r = (e, t) => ({
              animationDuration: 100 * e + "ms, 500ms",
              animationTimingFunction: `steps(${e}), step-end`,
              animationDelay: 100 * t + "ms, 0ms",
              animationIterationCount: "1, " + (100 * (n.value.length + n.value[n.value.length - 1].length + 5)) / 500,
            })
          return (e, t) => (
            xo(),
            Eo(
              "div",
              {
                class: Ge([
                  "ascii-art font-code text-c-3 flex flex-col items-start text-[6px] leading-[7px]",
                  { "ascii-art-animate": e.animate },
                ]),
              },
              [
                (xo(!0),
                Eo(
                  go,
                  null,
                  qr(
                    n.value,
                    (e, t) => (
                      xo(),
                      Eo(
                        "span",
                        { key: t, class: "inline-block", style: He({ width: `calc(${e.length + 1}ch)` }) },
                        [
                          Ro(
                            "span",
                            { class: "inline-block whitespace-pre overflow-hidden", style: He(r(e.length, t)) },
                            at(e),
                            5,
                          ),
                        ],
                        4,
                      )
                    ),
                  ),
                  128,
                )),
              ],
              2,
            )
          )
        },
      }),
      bfe = T8(gfe, [["__scopeId", "data-v-80684d49"]]),
      vfe = { class: "relative col-1 flex-center gap-6 p-2 capitalize" },
      yfe = { class: "flex h-[calc(100%_-_50px)] flex-col items-center justify-center" },
      Ofe = { class: "text-c-3 right-4 mt-auto flex w-full flex-col items-end gap-2 text-sm" },
      wfe = { key: 0, class: "flex items-center gap-1.5", type: "button" },
      xfe = Hr({
        __name: "ResponseEmpty",
        setup(e) {
          const { isReadOnly: t } = E8()
          return (e, n) => (
            xo(),
            Eo("div", vfe, [
              Ro("div", yfe, [
                No(
                  bfe,
                  {
                    art: In(
                      "                         .,,uod8B8bou,,.\n                ..,uod8BBBBBBBBBBBBBBBBRPFT?l!i:.\n           ||||||||||||||!?TFPRBBBBBBBBBBBBBBB8m=,\n           ||||   '\"\"^^!!||||||||||TFPRBBBVT!:...!\n           ||||            '\"\"^^!!|||||?!:.......!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||,                    ||||.........`\n           |||||!!-._               ||||.......;.\n           ':!|||||||||!!-._        ||||.....bBBBBWdou,.\n         bBBBBB86foi!|||||||!!-..:|||!..bBBBBBBBBBBBBBBY!\n         ::!?TFPRBBBBBB86foi!||||||||!!bBBBBBBBBBBBBBBY..!\n         :::::::::!?TFPRBBBBBB86ftiaabBBBBBBBBBBBBBBY....!\n         :::;`\"^!:;::::::!?TFPRBBBBBBBBBBBBBBBBBBBY......!\n         ;::::::...''^::::::::::!?TFPRBBBBBBBBBBY........!\n     .ob86foi;::::::::::::::::::::::::!?TFPRBY..........`\n    .b888888888886foi;:::::::::::::::::::::::..........`\n .b888888888888888888886foi;::::::::::::::::..........\n.b888888888888888888888888888886foi;:::::::::......`\n!Tf998888888888888888888888888888888886foi;:::....`\n  '\"^!|Tf9988888888888888888888888888888888!::..`\n       '\"^!|Tf998888888888888888888888889!! '`\n             '\"^!|Tf9988888888888888888!!`            iBBbo.\n                  '\"^!|Tf998888888889!`             WBBBBbo.\n                        '\"^!|Tf9989!`              YBBBP^'\n                              '\"^!`               `\n",
                    ),
                  },
                  null,
                  8,
                  ["art"],
                ),
              ]),
              Ro("div", Ofe, [
                Ro(
                  "button",
                  {
                    class: "flex items-center gap-1.5",
                    type: "button",
                    onClick: n[0] || (n[0] = (e) => In(bpe).emit()),
                  },
                  [Mo(" Send Request "), No(R8, { hotkey: "" })],
                ),
                In(t) ? Qo("", !0) : (xo(), Eo("button", wfe, [Mo(" New Request "), No(R8, { hotkey: "N" })])),
              ]),
            ])
          )
        },
      }),
      kfe = ["href"],
      _fe = Hr({
        __name: "HelpfulLink",
        props: { href: {} },
        setup: (e) => (e, t) => (
          xo(),
          Eo(
            "a",
            {
              class: "cursor-help decoration-c-3 underline underline-offset-2",
              href: e.href,
              rel: "noopener noreferrer",
              target: "_blank",
            },
            [Xr(e.$slots, "default")],
            8,
            kfe,
          )
        ),
      }),
      Sfe = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
      Efe = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"],
      Tfe = ["b", "kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      Afe = ["b", "kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      Cfe = (e, t, n) => {
        let r = e
        return (
          "string" == typeof t || Array.isArray(t)
            ? (r = e.toLocaleString(t, n))
            : (!0 !== t && void 0 === n) || (r = e.toLocaleString(void 0, n)),
          r
        )
      }
    function Pfe(e, t = {}) {
      if (!Number.isFinite(e)) throw new TypeError("Expected a finite number")
      t.colonNotation &&
        ((t.compact = !1), (t.formatSubMilliseconds = !1), (t.separateMilliseconds = !1), (t.verbose = !1)),
        t.compact && ((t.secondsDecimalDigits = 0), (t.millisecondsDecimalDigits = 0))
      const n = [],
        r = (e, r, a, o) => {
          if (!((0 !== n.length && t.colonNotation) || 0 !== e || (t.colonNotation && "m" === a))) return
          let i, s
          if (((o = (o || e || "0").toString()), t.colonNotation)) {
            ;(i = n.length > 0 ? ":" : ""), (s = "")
            const e = o.includes(".") ? o.split(".")[0].length : o.length,
              t = n.length > 0 ? 2 : 1
            o = "0".repeat(Math.max(0, t - e)) + o
          } else (i = ""), (s = t.verbose ? " " + ((l = r), 1 === e ? l : `${l}s`) : a)
          var l
          n.push(i + o + s)
        },
        a = (function (e) {
          if ("number" != typeof e) throw new TypeError("Expected a number")
          const t = e > 0 ? Math.floor : Math.ceil
          return {
            days: t(e / 864e5),
            hours: t(e / 36e5) % 24,
            minutes: t(e / 6e4) % 60,
            seconds: t(e / 1e3) % 60,
            milliseconds: t(e) % 1e3,
            microseconds: t(1e3 * e) % 1e3,
            nanoseconds: t(1e6 * e) % 1e3,
          }
        })(e)
      if (
        (r(Math.trunc(a.days / 365), "year", "y"),
        r(a.days % 365, "day", "d"),
        r(a.hours, "hour", "h"),
        r(a.minutes, "minute", "m"),
        t.separateMilliseconds || t.formatSubMilliseconds || (!t.colonNotation && e < 1e3))
      )
        if ((r(a.seconds, "second", "s"), t.formatSubMilliseconds))
          r(a.milliseconds, "millisecond", "ms"),
            r(a.microseconds, "microsecond", "s"),
            r(a.nanoseconds, "nanosecond", "ns")
        else {
          const e = a.milliseconds + a.microseconds / 1e3 + a.nanoseconds / 1e6,
            n = "number" == typeof t.millisecondsDecimalDigits ? t.millisecondsDecimalDigits : 0,
            o = e >= 1 ? Math.round(e) : Math.ceil(e),
            i = n ? e.toFixed(n) : o
          r(Number.parseFloat(i), "millisecond", "ms", i)
        }
      else {
        const n = ((e, t) => {
            const n = Math.floor(e * 10 ** t + 1e-7)
            return (Math.round(n) / 10 ** t).toFixed(t)
          })((e / 1e3) % 60, "number" == typeof t.secondsDecimalDigits ? t.secondsDecimalDigits : 1),
          a = t.keepDecimalsOnWholeSeconds ? n : n.replace(/\.0+$/, "")
        r(Number.parseFloat(a), "second", "s", a)
      }
      if (0 === n.length) return "0" + (t.verbose ? " milliseconds" : "ms")
      if (t.compact) return n[0]
      if ("number" == typeof t.unitCount) {
        const e = t.colonNotation ? "" : " "
        return n.slice(0, Math.max(t.unitCount, 1)).join(e)
      }
      return t.colonNotation ? n.join("") : n.join(" ")
    }
    const Dfe = { class: "flex gap-1.5 text-c-3 pl-1" },
      Rfe = { key: 0 },
      Nfe = { key: 1 },
      $fe = Hr({
        __name: "ResponseMetaInformation",
        props: { response: {} },
        setup(e) {
          const t = e,
            n = (e) => {
              var t
              const n = parseInt((null == (t = e.headers) ? void 0 : t["content-length"]) || "0", 10)
              return n
                ? (function (e, t) {
                    if (!Number.isFinite(e)) throw new TypeError(`Expected a finite number, got ${typeof e}: ${e}`)
                    const n = (t = { bits: !1, binary: !1, space: !0, ...t }).bits
                        ? t.binary
                          ? Afe
                          : Tfe
                        : t.binary
                          ? Efe
                          : Sfe,
                      r = t.space ? " " : ""
                    if (t.signed && 0 === e) return ` 0${r}${n[0]}`
                    const a = e < 0,
                      o = a ? "-" : t.signed ? "+" : ""
                    let i
                    if (
                      (a && (e = -e),
                      void 0 !== t.minimumFractionDigits && (i = { minimumFractionDigits: t.minimumFractionDigits }),
                      void 0 !== t.maximumFractionDigits &&
                        (i = { maximumFractionDigits: t.maximumFractionDigits, ...i }),
                      e < 1)
                    )
                      return o + Cfe(e, t.locale, i) + r + n[0]
                    const s = Math.min(
                      Math.floor(t.binary ? Math.log(e) / Math.log(1024) : Math.log10(e) / 3),
                      n.length - 1,
                    )
                    return (
                      (e /= (t.binary ? 1024 : 1e3) ** s),
                      i || (e = e.toPrecision(3)),
                      o + Cfe(Number(e), t.locale, i) + r + n[s]
                    )
                  })(n)
                : void 0
            },
            r = ii(() => {
              const e = t.response.status
              if (e) return Td[e] ?? void 0
            })
          return (e, t) => (
            xo(),
            Eo("div", Dfe, [
              Ro("span", null, at(In(Pfe)(e.response.duration)), 1),
              n(e.response) ? (xo(), Eo("span", Rfe, at(n(e.response)), 1)) : Qo("", !0),
              r.value
                ? (xo(),
                  Eo(
                    go,
                    { key: 1 },
                    [
                      r.value.url
                        ? (xo(),
                          To(
                            _fe,
                            { key: 0, href: r.value.url },
                            { default: yr(() => [Mo(at(e.response.status) + " " + at(r.value.name), 1)]), _: 1 },
                            8,
                            ["href"],
                          ))
                        : (xo(), Eo("span", Nfe, at(e.response.status) + " " + at(r.value.name), 1)),
                    ],
                    64,
                  ))
                : Qo("", !0),
            ])
          )
        },
      }),
      Ife = { class: "flex-1 px-2 py-1.5 whitespace-nowrap" },
      Mfe = Hr({
        __name: "DataTableText",
        props: { text: {} },
        setup: (e) => (e, t) => (
          xo(), To(ohe, { class: "relative flex" }, { default: yr(() => [Ro("span", Ife, at(e.text), 1)]), _: 1 })
        ),
      }),
      Lfe = {
        key: 1,
        class: "text-c-3 px-4 text-sm border border-1/2 rounded min-h-12 justify-center flex items-center bg-b-1 mx-1",
      },
      Qfe = Hr({
        __name: "ResponseCookies",
        props: { cookies: {} },
        setup: (e) => (e, t) => (
          xo(),
          To(
            ahe,
            { defaultOpen: !1 },
            {
              title: yr(() => [Mo("Cookies")]),
              default: yr(() => [
                (xo(),
                Eo(
                  go,
                  { key: 0 },
                  [
                    e.cookies.length
                      ? (xo(),
                        To(
                          ghe,
                          { key: 0, class: "flex-1", columns: ["", ""] },
                          {
                            default: yr(() => [
                              (xo(!0),
                              Eo(
                                go,
                                null,
                                qr(
                                  e.cookies,
                                  (e, t) => (
                                    xo(),
                                    To(
                                      vhe,
                                      { key: t },
                                      {
                                        default: yr(() => [
                                          No(Mfe, { text: e.name }, null, 8, ["text"]),
                                          No(Mfe, { text: e.value }, null, 8, ["text"]),
                                        ]),
                                        _: 2,
                                      },
                                      1024,
                                    )
                                  ),
                                ),
                                128,
                              )),
                            ]),
                            _: 1,
                          },
                        ))
                      : (xo(), Eo("div", Lfe, " No cookies ")),
                  ],
                  64,
                )),
              ]),
              _: 1,
            },
          )
        ),
      }),
      Bfe = {
        key: 1,
        class: "text-c-3 px-4 text-sm border rounded min-h-12 justify-center flex items-center bg-b-1 mx-1",
      },
      jfe = Hr({
        __name: "ResponseHeaders",
        props: { headers: {} },
        setup(e) {
          const t = (e) =>
            e
              .split("-")
              .map((e) => e.charAt(0).toUpperCase() + e.slice(1))
              .join("-")
          return (e, n) => (
            xo(),
            To(
              ahe,
              { defaultOpen: !1, itemCount: e.headers.length },
              {
                title: yr(() => [Mo("Headers")]),
                default: yr(() => [
                  e.headers.length
                    ? (xo(),
                      To(
                        ghe,
                        { key: 0, columns: ["minmax(auto, min-content)", "minmax(50%, 1fr)"], scroll: "" },
                        {
                          default: yr(() => [
                            (xo(!0),
                            Eo(
                              go,
                              null,
                              qr(
                                e.headers,
                                (e, n) => (
                                  xo(),
                                  To(
                                    vhe,
                                    { key: n, class: "text-c-1" },
                                    {
                                      default: yr(() => [
                                        No(
                                          Mfe,
                                          { class: "sticky left-0 z-1 bg-b-1 max-w-48", text: t(e.name) },
                                          null,
                                          8,
                                          ["text"],
                                        ),
                                        No(Mfe, { class: "z-0", text: e.value }, null, 8, ["text"]),
                                      ]),
                                      _: 2,
                                    },
                                    1024,
                                  )
                                ),
                              ),
                              128,
                            )),
                          ]),
                          _: 1,
                        },
                      ))
                    : (xo(), Eo("div", Bfe, " No Headers ")),
                ]),
                _: 1,
              },
              8,
              ["itemCount"],
            )
          )
        },
      }),
      Ufe = { class: "flex items-center flex-1" },
      Ffe = { class: "custom-scroll flex flex-1 flex-col px-2 xl:px-6 py-2.5" },
      zfe = Hr({
        __name: "ResponseSection",
        props: { response: {} },
        setup(e) {
          const t = e,
            n = ii(() => {
              var e
              const n = null == (e = t.response) ? void 0 : e.headers
              return n
                ? Object.keys(n)
                    .map((e) => ({ name: e, value: n[e], required: !1 }))
                    .filter((e) => !["rest-api-client-content-length", "X-API-Client-Content-Length"].includes(e.name))
                : []
            }),
            r = ii(() => {
              var e, n
              const r = null == (n = null == (e = t.response) ? void 0 : e.headers) ? void 0 : n.cookies
              return r ? Object.keys(r).map((e) => ({ name: e, value: r[e], required: !1 })) : []
            }),
            a = ii(() => {
              var e
              const n = null == (e = t.response) ? void 0 : e.data
              return n && xd(n)
                ? JSON.stringify(JSON.parse(n), null, 2)
                : n && "object" == typeof _n(n)
                  ? JSON.stringify(n, null, 2)
                  : n
            }),
            o = ["All", "Body", "Headers", "Cookies"],
            i = Dn("All")
          return (e, t) => (
            xo(),
            To(Jpe, null, {
              title: yr(() => [
                No(In(BI), { class: "text-c-3 mr-2 rotate-180", icon: "ExternalLink", size: "sm", thickness: "2.5" }),
                Ro("div", Ufe, [
                  Mo(" Response "),
                  e.response ? (xo(), To($fe, { key: 0, response: e.response }, null, 8, ["response"])) : Qo("", !0),
                ]),
              ]),
              default: yr(() => [
                Ro("div", Ffe, [
                  e.response
                    ? (xo(),
                      Eo(
                        go,
                        { key: 1 },
                        [
                          No(
                            Ype,
                            {
                              activeSection: i.value,
                              sections: o,
                              onSetActiveSection: t[0] || (t[0] = (e) => (i.value = e)),
                            },
                            null,
                            8,
                            ["activeSection"],
                          ),
                          "All" === i.value || "Cookies" === i.value
                            ? (xo(), To(Qfe, { key: 0, cookies: r.value }, null, 8, ["cookies"]))
                            : Qo("", !0),
                          "All" === i.value || "Headers" === i.value
                            ? (xo(), To(jfe, { key: 1, headers: n.value }, null, 8, ["headers"]))
                            : Qo("", !0),
                          "All" === i.value || "Body" === i.value
                            ? (xo(),
                              To(mfe, { key: 2, active: !0, data: a.value, headers: n.value, title: "Body" }, null, 8, [
                                "data",
                                "headers",
                              ]))
                            : Qo("", !0),
                        ],
                        64,
                      ))
                    : (xo(), To(xfe, { key: 0 })),
                ]),
              ]),
              _: 1,
            })
          )
        },
      }),
      qfe = Dn(null),
      Zfe = Dn(null),
      Hfe = ["draggable"],
      Vfe = Hr({
        __name: "Draggable",
        props: {
          ceiling: { default: 0.8 },
          floor: { default: 0.2 },
          isDraggable: { type: Boolean, default: !0 },
          isDroppable: { type: Boolean, default: !0 },
          parentIds: {},
          id: {},
        },
        emits: ["onDragEnd", "onDragStart"],
        setup(e, { emit: t }) {
          const n = e,
            r = t,
            a = ii(() => ((n.parentIds.length ?? 0) > 0 ? n.parentIds[n.parentIds.length - 1] : null)),
            o = (e) => {
              !e.dataTransfer ||
                !(e.target instanceof HTMLDivElement) ||
                !n.isDraggable ||
                (e.target.classList.add("dragging"),
                (e.dataTransfer.dropEffect = "move"),
                (e.dataTransfer.effectAllowed = "move"),
                (qfe.value = { id: n.id, parentId: a.value }),
                r("onDragStart", { id: n.id, parentId: a.value }))
            },
            i = ((e, t) => {
              let n = !1
              return function (...t) {
                n || (e(...t), (n = !0), setTimeout(() => (n = !1), 25))
              }
            })((e) => {
              var t, r, o
              if (
                (null == (t = qfe.value) ? void 0 : t.id) === n.id ||
                n.parentIds.includes((null == (r = qfe.value) ? void 0 : r.id) ?? "") ||
                !n.isDroppable
              )
                return
              const i = null == (o = Zfe.value) ? void 0 : o.offset,
                s = e.target.offsetHeight,
                l = n.floor * s,
                c = n.ceiling * s
              let d = 3
              e.offsetY <= 0 && i && 3 !== i
                ? (d = i)
                : e.offsetY <= l
                  ? (d = 0)
                  : e.offsetY >= c
                    ? (d = 1)
                    : e.offsetY > l && e.offsetY < c && (d = 2),
                (Zfe.value = { id: n.id, parentId: a.value, offset: d })
            }),
            s = ["above", "below", "asChild"],
            l = ii(() => {
              var e
              let t = "sidebar-indent-nested"
              return (
                n.isDroppable &&
                  n.id === (null == (e = Zfe.value) ? void 0 : e.id) &&
                  (t += ` dragover-${s[Zfe.value.offset]}`),
                t
              )
            }),
            c = () => {
              if (!Zfe.value || !qfe.value) return
              const e = { ...qfe.value },
                t = { ...Zfe.value }
              ;(qfe.value = null),
                (Zfe.value = null),
                document.querySelectorAll("div.dragging").forEach((e) => e.classList.remove("dragging")),
                e.id !== t.id && r("onDragEnd", e, t)
            }
          return (e, t) => (
            xo(),
            Eo(
              "div",
              {
                class: Ge(l.value),
                draggable: e.isDraggable,
                onDragend: c,
                onDragover: t[0] || (t[0] = Wi((...e) => In(i) && In(i)(...e), ["prevent", "stop"])),
                onDragstart: Wi(o, ["stop"]),
              },
              [Xr(e.$slots, "default")],
              42,
              Hfe,
            )
          )
        },
      }),
      Wfe = Ro("span", null, "Add Example", -1),
      Xfe = Ro("span", null, "Rename", -1),
      Yfe = Ro("span", null, "Duplicate", -1),
      Gfe = Ro("span", null, "Delete", -1),
      Kfe = Hr({
        __name: "RequestSidebarItemMenu",
        props: { item: {} },
        setup(e) {
          const t = e,
            { activeWorkspace: n, requestMutators: r, requestExampleMutators: a } = E8(),
            { replace: o } = X1(),
            i = () => N8.emit({ commandName: "Add Example", metaData: t.item.uid }),
            s = () => {
              console.log("rename")
            },
            l = () => {
              console.log("duplicate")
            },
            c = () => {
              if ("requestUid" in t.item)
                a.delete(t.item), n2.value[Y1.Examples] === t.item.uid && o(`/workspace/${n.value}/request/default`)
              else {
                const e = R4(t.item.uid)
                if (!e.length) return
                r.delete(t.item, e[0]),
                  n2.value[Y1.Request] === t.item.uid && o(`/workspace/${n.value.uid}/request/default`)
              }
            },
            d = ii(() => "summary" in t.item)
          return (e, t) => (
            xo(),
            To(
              In(cL),
              { teleport: "#scalar-client" },
              {
                items: yr(() => [
                  d.value
                    ? (xo(),
                      To(
                        In(pL),
                        { key: 0, class: "flex !gap-2", onClick: i },
                        {
                          default: yr(() => [No(In(BI), { class: "inline-flex", icon: "Add", size: "sm" }), Wfe]),
                          _: 1,
                        },
                      ))
                    : Qo("", !0),
                  No(
                    In(pL),
                    { class: "flex !gap-2", onClick: s },
                    { default: yr(() => [No(In(BI), { class: "inline-flex", icon: "Edit", size: "sm" }), Xfe]), _: 1 },
                  ),
                  No(
                    In(pL),
                    { class: "flex !gap-2", onClick: l },
                    {
                      default: yr(() => [No(In(BI), { class: "inline-flex", icon: "Duplicate", size: "sm" }), Yfe]),
                      _: 1,
                    },
                  ),
                  No(In(uL)),
                  No(
                    In(pL),
                    { class: "flex !gap-2", onClick: c },
                    { default: yr(() => [No(In(BI), { class: "inline-flex", icon: "Trash", size: "sm" }), Gfe]), _: 1 },
                  ),
                ]),
                default: yr(() => [
                  No(
                    In(mw),
                    {
                      class:
                        "z-10 hover:bg-b-3 transition-none p-1 group-hover:flex ui-open:flex absolute left-0 hidden -translate-x-full -ml-1",
                      size: "sm",
                      variant: "ghost",
                    },
                    { default: yr(() => [No(In(BI), { icon: "Ellipses", size: "sm" })]), _: 1 },
                  ),
                ]),
                _: 1,
              },
            )
          )
        },
      }),
      Jfe = { class: "z-10 font-medium w-full editable-sidebar-hover-item pl-2" },
      eme = { class: "relative" },
      tme = { class: "flex" },
      nme = { class: "z-10 flex h-fit items-center justify-center max-w-[14px]" },
      rme = { class: "z-10 font-medium" },
      ame = { key: 2 },
      ome = "hover:bg-sidebar-active-b indent-padding-left",
      ime = Hr({
        __name: "RequestSidebarItem",
        props: {
          isDraggable: { type: Boolean, default: !1 },
          isDroppable: { type: Boolean, default: !1 },
          parentUids: {},
          item: {},
        },
        emits: ["onDragEnd"],
        setup(e) {
          vi((e) => ({ "28f0b1bd": u.value, "9782e23e": p.value }))
          const t = e,
            { activeRequest: n, activeWorkspace: r, folders: a, isReadOnly: o, requests: i, requestExamples: s } = E8(),
            { collapsedSidebarFolders: l, toggleSidebarFolder: c } = k4(),
            d = ii(() => "childUids" in t.item),
            u = ii(() =>
              t.parentUids.length
                ? o.value
                  ? 12 * (t.parentUids.length - 1) + "px"
                  : 12 * t.parentUids.length + "px"
                : "12px",
            ),
            p = ii(() =>
              t.parentUids.length
                ? o.value
                  ? 12 * (t.parentUids.length - 1) + "px"
                  : 12 * t.parentUids.length + "px"
                : "0px",
            ),
            h = (e) => {
              var t
              return "spec" in e
                ? null == (t = e.spec.info)
                  ? void 0
                  : t.title
                : "summary" in e
                  ? e.summary || e.path
                  : "name" in e
                    ? e.name
                    : ""
            },
            f = ii(() => ("requestUid" in t.item ? i[t.item.requestUid] : t.item).method),
            m = ii(() => {
              var e
              return (
                l[t.item.uid] ||
                ((null == (e = n.value) ? void 0 : e.uid) === t.item.uid && t.item.childUids.length > 1)
              )
            }),
            g = ii(() => "default" === n2.value[Y1.Request] && n.value.uid === t.item.uid)
          return (e, n) => {
            const u = Sr("RequestSidebarItem", !0)
            return (
              xo(),
              Eo(
                "div",
                {
                  class: Ge([
                    "relative flex flex-row",
                    [
                      (In(o) && e.parentUids.length > 1) || (!In(o) && e.parentUids.length)
                        ? "before:bg-b-3 before:absolute before:left-[calc(.75rem_+_.5px)] before:top-0 before:z-10 before:h-[calc(100%_+_.5px)] last:before:h-full before:w-px mb-[.5px] last:mb-0 indent-border-line-offset"
                        : "",
                    ],
                  ]),
                },
                [
                  No(
                    In(Vfe),
                    {
                      id: e.item.uid,
                      ceiling: d.value ? 0.8 : 0.5,
                      class: "flex flex-1 flex-col gap-[.5px] text-sm",
                      floor: d.value ? 0.2 : 0.5,
                      isDraggable: e.parentUids.length > 0 && e.isDraggable,
                      isDroppable: e.isDroppable,
                      parentIds: e.parentUids,
                      onOnDragEnd: n[2] || (n[2] = (...t) => e.$emit("onDragEnd", ...t)),
                    },
                    {
                      default: yr(() => [
                        "summary" in e.item || "requestUid" in e.item
                          ? (xo(),
                            To(
                              In(z1),
                              {
                                key: 0,
                                class: "no-underline",
                                to:
                                  "requestUid" in t.item
                                    ? `/workspace/${r.value.uid}/request/${t.item.requestUid}/examples/${t.item.uid}`
                                    : `/workspace/${r.value.uid}/request/${t.item.uid}`,
                              },
                              {
                                default: yr(({ isExactActive: t }) => [
                                  Ro(
                                    "div",
                                    {
                                      class: Ge([
                                        "group relative flex min-h-8 cursor-pointer flex-row items-start justify-between gap-2 py-1.5 pr-2 rounded editable-sidebar-hover",
                                        [
                                          ome,
                                          t || g.value
                                            ? "bg-sidebar-active-b text-sidebar-active-c transition-none"
                                            : "text-sidebar-c-2",
                                        ],
                                      ]),
                                      tabindex: "0",
                                    },
                                    [
                                      Ro("span", Jfe, at(h(e.item)), 1),
                                      Ro("div", eme, [
                                        In(o)
                                          ? Qo("", !0)
                                          : (xo(), To(Kfe, { key: 0, item: e.item }, null, 8, ["item"])),
                                        Ro("span", tme, [
                                          Mo("  "),
                                          No(In($8), { class: "font-bold", method: f.value }, null, 8, ["method"]),
                                        ]),
                                      ]),
                                    ],
                                    2,
                                  ),
                                ]),
                                _: 1,
                              },
                              8,
                              ["to"],
                            ))
                          : !In(o) || e.parentUids.length
                            ? (xo(),
                              Eo(
                                "button",
                                {
                                  key: 1,
                                  class: Ge([
                                    "hover:bg-b-2 group relative flex w-full flex-row justify-start gap-1.5 rounded p-1.5 z-[1]",
                                    ome,
                                  ]),
                                  type: "button",
                                  onClick: n[0] || (n[0] = (t) => In(c)(e.item.uid)),
                                },
                                [
                                  Ro("span", nme, [
                                    Xr(
                                      e.$slots,
                                      "leftIcon",
                                      {},
                                      () => [
                                        Ro(
                                          "div",
                                          { class: Ge({ "rotate-90": In(l)[e.item.uid] }) },
                                          [
                                            No(In(BI), {
                                              class: "text-c-3 text-sm",
                                              icon: "ChevronRight",
                                              size: "sm",
                                              thickness: "2.5",
                                            }),
                                          ],
                                          2,
                                        ),
                                      ],
                                      !0,
                                    ),
                                    Mo("  "),
                                  ]),
                                  Ro("span", rme, at(h(e.item)), 1),
                                ],
                              ))
                            : Qo("", !0),
                        "childUids" in e.item
                          ? Fr(
                              (xo(),
                              Eo(
                                "div",
                                ame,
                                [
                                  (xo(!0),
                                  Eo(
                                    go,
                                    null,
                                    qr(
                                      "summary" in e.item ? e.item.childUids.slice(1) : e.item.childUids,
                                      (t) => (
                                        xo(),
                                        To(
                                          u,
                                          {
                                            key: t,
                                            isDraggable: e.isDraggable,
                                            isDroppable: e.isDroppable,
                                            item: In(a)[t] || In(i)[t] || In(s)[t],
                                            parentUids: [...e.parentUids, e.item.uid],
                                            onOnDragEnd: n[1] || (n[1] = (...t) => e.$emit("onDragEnd", ...t)),
                                          },
                                          null,
                                          8,
                                          ["isDraggable", "isDroppable", "item", "parentUids"],
                                        )
                                      ),
                                    ),
                                    128,
                                  )),
                                ],
                                512,
                              )),
                              [[mi, m.value]],
                            )
                          : Qo("", !0),
                      ]),
                      _: 3,
                    },
                    8,
                    ["id", "ceiling", "floor", "isDraggable", "isDroppable", "parentIds"],
                  ),
                ],
                2,
              )
            )
          }
        },
      }),
      sme = T8(ime, [["__scopeId", "data-v-18928cac"]]),
      lme = { class: "w-sidebar relative flex flex-col border-r bg-b-1" },
      cme = { key: 0, class: "xl:min-h-header py-2.5 flex items-center border-b px-4 text-sm" },
      dme = { class: "font-medium m-0 text-sm" },
      ume = { class: "custom-scroll sidebar-height" },
      pme = Hr({
        __name: "Sidebar",
        props: { title: {} },
        setup(e) {
          const { isReadOnly: t } = E8()
          return (e, n) => (
            xo(),
            Eo("aside", lme, [
              Xr(e.$slots, "header"),
              !In(t) && e.title ? (xo(), Eo("div", cme, [Ro("h2", dme, at(e.title), 1)])) : Qo("", !0),
              Ro("div", ume, [Xr(e.$slots, "content")]),
              Xr(e.$slots, "button"),
            ])
          )
        },
      }),
      hme = { class: "xl:min-h-header py-2.5 flex items-center border-b px-2.5 text-sm" },
      fme = { class: "font-medium m-0 text-sm flex gap-1.5 items-center" },
      mme = { class: "flex items-center justify-center h-4 w-4" },
      gme = Ro("span", null, "Create new workspace", -1),
      bme = Hr({
        __name: "WorkspaceDropdown",
        setup(e) {
          const { activeWorkspace: t, workspaces: n } = E8(),
            { push: r } = X1(),
            a = () => N8.emit({ commandName: "Create Workspace" })
          return (e, o) => (
            xo(),
            Eo("div", hme, [
              No(In(cL), null, {
                items: yr(() => [
                  (xo(!0),
                  Eo(
                    go,
                    null,
                    qr(
                      In(n),
                      (e, n) => (
                        xo(),
                        To(
                          In(pL),
                          {
                            key: n,
                            class:
                              "flex gap-1.5 group/item items-center whitespace-nowrap text-ellipsis overflow-hidden",
                            onClick: Wi(
                              (e) =>
                                ((e) => {
                                  e !== t.value.uid && r(`/workspace/${e}`)
                                })(n),
                              ["stop"],
                            ),
                          },
                          {
                            default: yr(() => [
                              Ro(
                                "div",
                                {
                                  class: Ge([
                                    "flex items-center justify-center rounded-full p-[3px] w-4 h-4 group-hover/item:shadow-border",
                                    In(t).uid === n ? "bg-blue text-b-1" : "text-transparent",
                                  ]),
                                },
                                [No(In(BI), { class: "size-2.5", icon: "Checkmark", thickness: "3.5" })],
                                2,
                              ),
                              Mo(" " + at(e.name), 1),
                            ]),
                            _: 2,
                          },
                          1032,
                          ["onClick"],
                        )
                      ),
                    ),
                    128,
                  )),
                  No(In(uL)),
                  No(
                    In(pL),
                    { class: "flex items-center gap-1.5", onClick: a },
                    { default: yr(() => [Ro("div", mme, [No(In(BI), { class: "h-2.5", icon: "Add" })]), gme]), _: 1 },
                  ),
                ]),
                default: yr(() => [
                  No(
                    In(mw),
                    {
                      class: "font-normal h-full justify-start py-1.5 px-1.5 text-c-1 hover:bg-b-2 w-fit",
                      fullWidth: "",
                      variant: "ghost",
                    },
                    {
                      default: yr(() => [
                        Ro("h2", fme, [
                          Mo(at(In(t).name) + " ", 1),
                          No(In(BI), { class: "size-2.5", icon: "ChevronDown", thickness: "3.5" }),
                        ]),
                      ]),
                      _: 1,
                    },
                  ),
                ]),
                _: 1,
              }),
            ])
          )
        },
      })
    /*! js-cookie v3.0.5 | MIT */ function vme(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t]
        for (var r in n) e[r] = n[r]
      }
      return e
    }
    var yme = (function e(t, n) {
      function r(e, r, a) {
        if ("undefined" != typeof document) {
          "number" == typeof (a = vme({}, n, a)).expires && (a.expires = new Date(Date.now() + 864e5 * a.expires)),
            a.expires && (a.expires = a.expires.toUTCString()),
            (e = encodeURIComponent(e)
              .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
              .replace(/[()]/g, escape))
          var o = ""
          for (var i in a) a[i] && ((o += "; " + i), !0 !== a[i] && (o += "=" + a[i].split(";")[0]))
          return (document.cookie = e + "=" + t.write(r, e) + o)
        }
      }
      return Object.create(
        {
          set: r,
          get: function (e) {
            if ("undefined" != typeof document && (!arguments.length || e)) {
              for (var n = document.cookie ? document.cookie.split("; ") : [], r = {}, a = 0; a < n.length; a++) {
                var o = n[a].split("="),
                  i = o.slice(1).join("=")
                try {
                  var s = decodeURIComponent(o[0])
                  if (((r[s] = t.read(i, s)), e === s)) break
                } catch (e) {}
              }
              return e ? r[e] : r
            }
          },
          remove: function (e, t) {
            r(e, "", vme({}, t, { expires: -1 }))
          },
          withAttributes: function (t) {
            return e(this.converter, vme({}, this.attributes, t))
          },
          withConverter: function (t) {
            return e(vme({}, this.converter, t), this.attributes)
          },
        },
        { attributes: { value: Object.freeze(n) }, converter: { value: Object.freeze(t) } },
      )
    })(
      {
        read: function (e) {
          return '"' === e[0] && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
        },
        write: function (e) {
          return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
        },
      },
      { path: "/" },
    )
    const Ome = (e = []) => e.reduce((e, t) => (t.key && (e[t.key] = t.value), e), {}),
      wme = { class: "lg:min-h-header flex items-center w-full justify-center p-1 flex-wrap t-app__top-container" },
      xme = { class: "flex flex-row items-center gap-1 lg:px-1 lg:mb-0 mb-0.5 lg:flex-1 w-6/12" },
      kme = { class: "flex flex-row items-center gap-1 lg:px-1 lg:mb-0 mb-0.5 lg:flex-1 justify-end w-6/12" },
      _me = Hr({
        __name: "Request",
        setup(e) {
          var t
          const {
              activeExample: n,
              activeRequest: r,
              activeSecurityScheme: a,
              activeWorkspaceServers: o,
              activeWorkspace: i,
              environments: s,
              requestMutators: l,
              activeWorkspaceCollections: c,
              modalState: d,
            } = E8(),
            { collapsedSidebarFolders: u } = k4(),
            p = aw(),
            h = Dn(!(null != (t = i.value) && t.isReadOnly)),
            f = async () => {
              var e
              if (!r.value || !n.value)
                return void console.warn("There is no request active at the moment. Please select one then try again.")
              let t = n.value.url
              const c = Object.values(s).reduce((e, t) => {
                try {
                  return { ...e, ...JSON.parse(t.raw) }
                } catch {
                  return e
                }
              }, {})
              t = t.replace(
                /\{\{(.*?)\}\}/g,
                (e, t) => (
                  o.value.forEach((e) => {
                    if (e.url === t) return t
                  }),
                  c[t] || t
                ),
              )
              const { request: d, response: u } = await (async (e, t, n, r, a) => {
                var o
                let i = n
                t.parameters.path.forEach((e) => {
                  !e.key || !e.value || (i = i.replace(`{${e.key}}`, e.value))
                })
                const s = Ome(t.parameters.headers.filter(({ enabled: e }) => e))
                let l = null
                if ("binary" === t.body.activeBody && t.body.binary)
                  (s["Content-Type"] = t.body.binary.type),
                    (s["Content-Disposition"] = `attachment; filename="${t.body.binary.name}"`),
                    (l = t.body.binary)
                else if ("raw" === t.body.activeBody && t.body.raw.value) l = t.body.raw.value
                else if ("formData" === t.body.activeBody) {
                  s["Content-Type"] = "multipart/form-data"
                  const e = new FormData()
                  "form-data" === t.body.formData.encoding &&
                    (t.body.formData.value.forEach((t) => {
                      t.key && t.value ? e.append(t.key, t.value) : t.file && e.append(t.file.name, t.file)
                    }),
                    (l = e))
                }
                const c = [],
                  [d, u] = i.split("?")
                new URLSearchParams(u ?? "").forEach((e, t) => {
                  c.push({ key: t, value: e, enabled: !0 })
                })
                const p = {
                    ...Ome(t.parameters.query.filter(({ enabled: e }) => e).filter(({ value: e }) => "" !== e)),
                    ...Ome(c),
                  },
                  h = { ...Ome((t.parameters.cookies ?? []).filter(({ enabled: e }) => e)) }
                if (null != r && r.scheme) {
                  const { scheme: e } = r
                  if ("apiKey" === e.type && e.value)
                    switch (e.in) {
                      case "cookie":
                        h[e.name] = e.value
                        break
                      case "query":
                        p[e.name] = e.value
                        break
                      case "header":
                        s[e.name] = e.value
                    }
                  else
                    "http" === e.type && e.value
                      ? "basic" === e.scheme && e.secondValue
                        ? (s.Authorization = `Basic ${btoa(`${e.value}:${e.secondValue}`)}`)
                        : (s.Authorization = `Bearer ${e.value}`)
                      : "oauth2" === e.type &&
                        null != (o = r.flow) &&
                        o.token &&
                        (s.Authorization = `Bearer ${r.flow.token}`)
                }
                Object.keys(h).forEach((e) => {
                  yme.set(e, h[e], { sameSite: "None", secure: !0 })
                })
                const f = new URLSearchParams(p).toString()
                i = `${d}${f ? "?" + f : ""}`
                const m = { url: gs(a, i), method: e.method, headers: s }
                l && (m.data = l)
                const g = Date.now()
                try {
                  const e = await wf(m)
                  return (
                    bs(a, i) &&
                      [
                        "Access-Control-Allow-Headers",
                        "Access-Control-Allow-Origin",
                        "Access-Control-Allow-Methods",
                        "Access-Control-Expose-Headers",
                      ]
                        .map((e) => e.toLowerCase())
                        .forEach((t) => delete e.headers[t]),
                    { sentTime: Date.now(), request: t, response: { ...e, duration: Date.now() - g } }
                  )
                } catch (e) {
                  const n = e.response
                  return (
                    console.error("ERROR", e),
                    { sentTime: Date.now(), request: t, response: n ? { ...n, duration: Date.now() - g } : void 0 }
                  )
                }
              })(r.value, n.value, t, a.value, null == (e = i.value) ? void 0 : e.proxyUrl)
              d && u
                ? l.edit(r.value.uid, "history", [
                    ...r.value.history,
                    { request: d, response: u, timestamp: Date.now() },
                  ])
                : console.warn("No response or request was returned")
            }
          Nr(() => bpe.on(f)), Mr(() => bpe.off(f))
          const m = () => N8.emit(),
            g = Qm()
          Rm(document, "keydown", (e) => {
            ;(Hz() ? g.meta.value : g.ctrl.value) && "b" === e.key && (h.value = !h.value),
              (Hz() ? g.meta.value : g.ctrl.value) && "k" === e.key && (p.open ? p.hide() : p.show())
          })
          const b = () => {
            if (!r.value) return ""
            const { method: e } = r.value
            return Ed[e].backgroundColor
          }
          return (e, t) => (
            xo(),
            Eo(
              go,
              null,
              [
                Ro(
                  "div",
                  {
                    class: Ge([
                      "flex flex-1 flex-col rounded-lg rounded-b-none rounded-r-none pt-0 h-full client-wrapper-bg-color",
                      b(),
                    ]),
                  },
                  [
                    Ro("div", wme, [
                      Ro("div", xme, [
                        No(
                          zpe,
                          { modelValue: h.value, "onUpdate:modelValue": t[0] || (t[0] = (e) => (h.value = e)) },
                          null,
                          8,
                          ["modelValue"],
                        ),
                      ]),
                      No(Ape),
                      Ro("div", kme, [
                        In(i).isReadOnly
                          ? (xo(),
                            Eo(
                              "button",
                              {
                                key: 0,
                                class: "text-c-3 hover:bg-b-3 active:text-c-1 p-2 rounded",
                                type: "button",
                                onClick: t[1] || (t[1] = (e) => In(d).hide()),
                              },
                              [No(In(BI), { icon: "Close", size: "lg", thickness: "1.75" })],
                            ))
                          : Qo("", !0),
                      ]),
                    ]),
                    No(Zpe, null, {
                      default: yr(() => [
                        Fr(
                          No(
                            In(pme),
                            { class: Ge([h.value ? "sidebar-active-width" : ""]) },
                            Zr(
                              {
                                content: yr(() => [
                                  No(Npe, { onOpenSearchModal: t[2] || (t[2] = (e) => In(p).show()) }),
                                  Ro(
                                    "div",
                                    {
                                      class: "custom-scroll flex flex-1 flex-col overflow-visible px-3 pb-12 pt-2.5",
                                      onDragenter: t[3] || (t[3] = Wi(() => {}, ["prevent"])),
                                      onDragover: t[4] || (t[4] = Wi(() => {}, ["prevent"])),
                                    },
                                    [
                                      (xo(!0),
                                      Eo(
                                        go,
                                        null,
                                        qr(
                                          In(c),
                                          (e, t) => (
                                            xo(),
                                            To(
                                              sme,
                                              {
                                                key: e.uid,
                                                isDraggable: !In(i).isReadOnly,
                                                isDroppable: !In(i).isReadOnly,
                                                item: e,
                                                parentUids: [],
                                                onOnDragEnd: (...e) => {},
                                              },
                                              {
                                                leftIcon: yr(() => [
                                                  No(In(BI), {
                                                    class: "text-sidebar-c-2 text-sm group-hover:hidden",
                                                    icon: "CodeFolder",
                                                    size: "sm",
                                                    thickness: "2",
                                                  }),
                                                  Ro(
                                                    "div",
                                                    { class: Ge({ "rotate-90": In(u)[e.uid] }) },
                                                    [
                                                      No(In(BI), {
                                                        class: "text-c-3 hidden text-sm group-hover:block",
                                                        icon: "ChevronRight",
                                                        size: "sm",
                                                      }),
                                                    ],
                                                    2,
                                                  ),
                                                ]),
                                                _: 2,
                                              },
                                              1032,
                                              ["isDraggable", "isDroppable", "item", "onOnDragEnd"],
                                            )
                                          ),
                                        ),
                                        128,
                                      )),
                                    ],
                                    32,
                                  ),
                                ]),
                                button: yr(() => [
                                  In(i).isReadOnly
                                    ? Qo("", !0)
                                    : (xo(),
                                      To(Qpe, { key: 0, click: m }, { title: yr(() => [Mo("Add Item")]), _: 1 })),
                                ]),
                                _: 2,
                              },
                              [In(i).isReadOnly ? void 0 : { name: "header", fn: yr(() => [No(In(bme))]), key: "0" }],
                            ),
                            1032,
                            ["class"],
                          ),
                          [[mi, h.value]],
                        ),
                        In(n)
                          ? (xo(),
                            To(
                              Vpe,
                              { key: 0, class: Ge(["flex-1", [h.value ? "sidebar-active-hide-layout" : ""]]) },
                              {
                                default: yr(() => {
                                  var e, t, n, a, o
                                  return [
                                    No(hfe),
                                    No(
                                      zfe,
                                      {
                                        response:
                                          null ==
                                          (o =
                                            null == (a = null == (e = In(r)) ? void 0 : e.history)
                                              ? void 0
                                              : a[
                                                  (null == (n = null == (t = In(r)) ? void 0 : t.history)
                                                    ? void 0
                                                    : n.length) - 1
                                                ])
                                            ? void 0
                                            : o.response,
                                      },
                                      null,
                                      8,
                                      ["response"],
                                    ),
                                  ]
                                }),
                                _: 1,
                              },
                              8,
                              ["class"],
                            ))
                          : Qo("", !0),
                      ]),
                      _: 1,
                    }),
                  ],
                  2,
                ),
                No(Mpe, { modalState: In(p) }, null, 8, ["modalState"]),
              ],
              64,
            )
          )
        },
      }),
      Sme = T8(_me, [["__scopeId", "data-v-60c28ddd"]]),
      Eme = Object.freeze(
        Object.defineProperty({ __proto__: null, default: Sme }, Symbol.toStringTag, { value: "Module" }),
      ),
      Tme = { class: "flex flex-col gap-1 p-2" },
      Ame = T8({}, [
        [
          "render",
          function (e, t) {
            return xo(), Eo("ul", Tme, [Xr(e.$slots, "default")])
          },
        ],
      ]),
      Cme = { class: "flex justify-end gap-3" },
      Pme = Hr({
        __name: "SidebarListElementForm",
        props: { danger: { type: Boolean }, label: {} },
        emits: ["cancel", "submit"],
        setup(e, { emit: t }) {
          const n = t
          return (e, t) => (
            xo(),
            Eo(
              "form",
              {
                class: "flex flex-col gap-6 text-base",
                onSubmit: t[1] || (t[1] = Wi((e) => n("submit"), ["prevent"])),
              },
              [
                Xr(e.$slots, "default"),
                Ro("div", Cme, [
                  No(
                    In(mw),
                    { variant: "outlined", onClick: t[0] || (t[0] = (e) => n("cancel")) },
                    { default: yr(() => [Mo(" Cancel ")]), _: 1 },
                  ),
                  No(
                    In(mw),
                    { error: e.danger, type: "submit" },
                    { default: yr(() => [Mo(at(e.label ?? "Submit"), 1)]), _: 1 },
                    8,
                    ["error"],
                  ),
                ]),
              ],
              32,
            )
          )
        },
      }),
      Dme = Ro("p", null, "Are you sure you want to remove it?", -1),
      Rme = Hr({
        __name: "DeleteSidebarListElement",
        props: { variableName: {} },
        emits: ["close", "delete"],
        setup(e, { emit: t }) {
          const n = t
          async function r() {
            n("delete")
          }
          return (e, t) => (
            xo(),
            To(
              Pme,
              {
                danger: "",
                label: `Delete ${e.variableName}`,
                onCancel: t[0] || (t[0] = (e) => n("close")),
                onSubmit: r,
              },
              { default: yr(() => [Dme]), _: 1 },
              8,
              ["label"],
            )
          )
        },
      }),
      Nme = { class: "absolute flex right-1 opacity-0 group-hover:opacity-100" },
      $me = Hr({
        __name: "SidebarListElementActions",
        props: { variable: {} },
        emits: ["delete"],
        setup(e, { emit: t }) {
          const { variable: n } = e,
            r = t,
            a = Dn({ action: "None", name: "" }),
            o = aw(),
            { copyToClipboard: i } = (() => {
              const { toast: e } = Vu()
              return {
                copyToClipboard: (t) => {
                  navigator.clipboard.writeText(t).then(() => {
                    e("Copied to the clipboard.", "info")
                  })
                },
              }
            })()
          function s() {
            o.hide(), (a.value = { action: "None", name: "" })
          }
          return (e, t) => (
            xo(),
            Eo(
              go,
              null,
              [
                Ro("div", Nme, [
                  Ro(
                    "button",
                    {
                      class: "text-c-3 hover:bg-b-3 hover:text-c-1 rounded p-[5px]",
                      type: "button",
                      onClick: t[0] || (t[0] = (t) => In(i)(e.variable.name)),
                    },
                    [No(In(BI), { class: "h-3 w-3", icon: "Clipboard" })],
                  ),
                  e.variable.isDefault
                    ? Qo("", !0)
                    : (xo(),
                      Eo(
                        "button",
                        {
                          key: 0,
                          class: "text-c-3 hover:bg-b-3 hover:text-c-1 rounded p-1",
                          type: "button",
                          onClick:
                            t[1] ||
                            (t[1] = Wi(
                              (e) => ((a.value = { action: "Delete", name: n.name }), void o.show()),
                              ["prevent"],
                            )),
                        },
                        [No(In(BI), { class: "h-3.5 w-3.5", icon: "Close" })],
                      )),
                ]),
                No(
                  In(sw),
                  { state: In(o), title: `${a.value.action} ${a.value.name}` },
                  {
                    default: yr(() => [
                      "Delete" === a.value.action
                        ? (xo(),
                          To(
                            Rme,
                            {
                              key: 0,
                              variableName: a.value.name,
                              onClose: s,
                              onDelete:
                                t[2] ||
                                (t[2] = (t) =>
                                  (function (e) {
                                    r("delete", e), s()
                                  })(e.variable.uid)),
                            },
                            null,
                            8,
                            ["variableName"],
                          ))
                        : Qo("", !0),
                    ]),
                    _: 1,
                  },
                  8,
                  ["state", "title"],
                ),
              ],
              64,
            )
          )
        },
      }),
      Ime = { key: 0, class: "hover:bg-b-3 rounded p-1.5", type: "button" },
      Mme = Hr({
        __name: "SidebarListElement",
        props: { variable: {} },
        emits: ["delete"],
        setup(e, { emit: t }) {
          const n = t,
            r = X1(),
            a = (e) => {
              n("delete", e)
            }
          return (e, t) => {
            const n = Sr("router-link")
            return (
              xo(),
              Eo("li", null, [
                No(
                  n,
                  {
                    class: Ge([
                      "text-c-2 hover:bg-b-2 group relative block flex items-center gap-1 rounded py-1 pr-2 font-medium",
                      [e.variable.color ? "pl-1" : "pl-2"],
                    ]),
                    exactActiveClass: "active-link",
                    to: `${e.variable.uid}`,
                    onClick:
                      t[0] ||
                      (t[0] = Wi(
                        (t) =>
                          ((e, t) => {
                            e.metaKey ? window.open(t, "_blank") : r.push(t)
                          })(t, e.variable.uid),
                        ["prevent"],
                      )),
                  },
                  {
                    default: yr(() => [
                      e.variable.color
                        ? (xo(),
                          Eo("button", Ime, [
                            Ro("div", { class: Ge(["h-2.5 w-2.5 rounded-xl", `bg-${e.variable.color}`]) }, null, 2),
                          ]))
                        : Qo("", !0),
                      Mo(" " + at(e.variable.name) + " ", 1),
                      No(
                        $me,
                        { variable: { ...e.variable, isDefault: e.variable.isDefault ?? !1 }, onDelete: a },
                        null,
                        8,
                        ["variable"],
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ["class", "to"],
                ),
              ])
            )
          }
        },
      }),
      Lme = T8(Mme, [["__scopeId", "data-v-f43d5cfd"]]),
      Qme = { class: "flex flex-row gap-1.5 space-x-1" },
      Bme = ["onClick"],
      jme = Hr({
        __name: "EnvironmentColors",
        props: { activeColor: {} },
        emits: ["select"],
        setup(e) {
          const t = [
            { color: "grey", bgClass: "bg-grey" },
            { color: "red", bgClass: "bg-red" },
            { color: "yellow", bgClass: "bg-yellow" },
            { color: "green", bgClass: "bg-green" },
            { color: "orange", bgClass: "bg-orange" },
            { color: "blue", bgClass: "bg-blue" },
            { color: "text-c-2", bgClass: "bg-c-2" },
            { color: "purple", bgClass: "bg-purple" },
            { color: "pink", bgClass: "bg-pink" },
          ]
          return (e, n) => (
            xo(),
            Eo("div", Qme, [
              (xo(),
              Eo(
                go,
                null,
                qr(t, (t) =>
                  Ro(
                    "div",
                    {
                      key: t.color,
                      class: Ge(["flex h-5 w-5 cursor-pointer items-center justify-center rounded-full", t.bgClass]),
                      onClick: (n) => e.$emit("select", t.color),
                    },
                    [
                      e.activeColor === t.color
                        ? (xo(), To(In(BI), { key: 0, icon: "Checkmark", size: "xs" }))
                        : Qo("", !0),
                    ],
                    10,
                    Bme,
                  ),
                ),
                64,
              )),
            ])
          )
        },
      }),
      Ume = { class: "flex-1" },
      Fme = ["value"],
      zme = { class: "colors ml-auto" },
      qme = Hr({
        __name: "Environment",
        setup(e) {
          const t = X1(),
            { environments: n, environmentMutators: r } = E8(),
            a = Dn(null),
            o = Dn(null),
            i = Dn(!1)
          function s() {
            const e = {
              name: "New Environment",
              uid: NL(),
              color: "grey",
              raw: JSON.stringify({ exampleKey: "exampleValue" }, null, 2),
              parsed: [],
              isDefault: !1,
            }
            r.add(e), (a.value = e.uid), t.push(a.value)
          }
          function l(e) {
            a.value && r.edit(a.value, "raw", e)
          }
          const c = (e) => {
              a.value && (n[a.value].color = e)
            },
            d = () => {
              a.value &&
                !n[a.value].isDefault &&
                ((i.value = !0),
                rr(() => {
                  var e
                  null == (e = o.value) || e.focus()
                }))
            },
            u = (e) => {
              const t = e.target.value
              a.value && !n[a.value].isDefault && (n[a.value].name = t)
            }
          return (
            Nr(() => {
              "default" === t.currentRoute.value.params.environment && (a.value = n.default.uid)
            }),
            (e, t) => (
              xo(),
              To(Zpe, null, {
                default: yr(() => [
                  No(
                    pme,
                    { title: "Environment" },
                    {
                      content: yr(() => [
                        Ro("div", Ume, [
                          No(Ame, null, {
                            default: yr(() => [
                              (xo(!0),
                              Eo(
                                go,
                                null,
                                qr(
                                  In(n),
                                  (e) => (
                                    xo(),
                                    To(
                                      Lme,
                                      {
                                        key: e.uid,
                                        class: "text-xs",
                                        variable: { name: e.name, uid: e.uid, color: e.color, isDefault: e.isDefault },
                                        onClick: (t) => (a.value = e.uid),
                                        onDelete: (t) =>
                                          ((e) => {
                                            r.delete(e), a.value === e && (a.value = null)
                                          })(e.uid),
                                      },
                                      null,
                                      8,
                                      ["variable", "onClick", "onDelete"],
                                    )
                                  ),
                                ),
                                128,
                              )),
                            ]),
                            _: 1,
                          }),
                        ]),
                      ]),
                      button: yr(() => [
                        No(Qpe, { click: s }, { title: yr(() => [Mo("Add Environment Variable")]), _: 1 }),
                      ]),
                      _: 1,
                    },
                  ),
                  No(
                    Vpe,
                    { class: "flex-1" },
                    {
                      default: yr(() => [
                        No(
                          Jpe,
                          null,
                          Zr(
                            {
                              default: yr(() => [
                                a.value
                                  ? (xo(),
                                    To(
                                      cpe,
                                      {
                                        key: 0,
                                        class: "px-2 py-2.5",
                                        lineNumbers: "",
                                        modelValue: In(n)[a.value].raw,
                                        "onUpdate:modelValue": l,
                                      },
                                      null,
                                      8,
                                      ["modelValue"],
                                    ))
                                  : Qo("", !0),
                              ]),
                              _: 2,
                            },
                            [
                              a.value
                                ? {
                                    name: "title",
                                    fn: yr(() => [
                                      !i.value || In(n)[a.value].isDefault
                                        ? (xo(), Eo("span", { key: 0, onDblclick: d }, at(In(n)[a.value].name), 33))
                                        : (xo(),
                                          Eo(
                                            "input",
                                            {
                                              key: 1,
                                              ref_key: "nameInputRef",
                                              ref: o,
                                              class: "ring-1 ring-offset-4 ring-b-outline rounded",
                                              spellcheck: "false",
                                              type: "text",
                                              value: In(n)[a.value].name,
                                              onBlur: t[0] || (t[0] = (e) => (i.value = !1)),
                                              onInput: u,
                                              onKeyup: t[1] || (t[1] = Yi((e) => (i.value = !1), ["enter"])),
                                            },
                                            null,
                                            40,
                                            Fme,
                                          )),
                                      Ro("div", zme, [
                                        No(jme, { activeColor: In(n)[a.value].color, onSelect: c }, null, 8, [
                                          "activeColor",
                                        ]),
                                      ]),
                                    ]),
                                    key: "0",
                                  }
                                : void 0,
                            ],
                          ),
                          1024,
                        ),
                      ]),
                      _: 1,
                    },
                  ),
                ]),
                _: 1,
              })
            )
          )
        },
      }),
      Zme = Object.freeze(
        Object.defineProperty({ __proto__: null, default: qme }, Symbol.toStringTag, { value: "Module" }),
      ),
      Hme = { class: "custom-scroll flex flex-1 flex-col gap-1.5 px-5 py-2" },
      Vme = Hr({
        __name: "Form",
        props: { title: {}, options: {}, data: {}, onUpdate: { type: Function } },
        setup: (e) => (e, t) => (
          xo(),
          To(Jpe, null, {
            title: yr(() => [Ro("span", null, at(e.title), 1)]),
            default: yr(() => [
              Ro("div", Hme, [
                Object.keys(e.data).length > 0
                  ? (xo(),
                    To(
                      ghe,
                      { key: 0, columns: [""] },
                      {
                        default: yr(() => [
                          (xo(!0),
                          Eo(
                            go,
                            null,
                            qr(
                              e.options,
                              (t, n) => (
                                xo(),
                                To(
                                  vhe,
                                  { key: n, class: Ge({ "border-t": 0 === n }) },
                                  {
                                    default: yr(() => [
                                      No(
                                        phe,
                                        {
                                          modelValue: String(e.data[t.key] ?? ""),
                                          placeholder: t.placeholder,
                                          "onUpdate:modelValue": (n) => e.onUpdate(t.key, n),
                                        },
                                        { default: yr(() => [Mo(at(t.label), 1)]), _: 2 },
                                        1032,
                                        ["modelValue", "placeholder", "onUpdate:modelValue"],
                                      ),
                                    ]),
                                    _: 2,
                                  },
                                  1032,
                                  ["class"],
                                )
                              ),
                            ),
                            128,
                          )),
                        ]),
                        _: 1,
                      },
                    ))
                  : Qo("", !0),
              ]),
            ]),
            _: 1,
          })
        ),
      }),
      Wme = Hr({
        __name: "CookieForm",
        setup(e) {
          const { cookies: t, activeCookieId: n, cookieMutators: r } = E8(),
            a = [
              { label: "Key", key: "key", placeholder: "Username" },
              { label: "Value", key: "value", placeholder: "123" },
              { label: "Domain", key: "domain", placeholder: "scalar.com" },
              { label: "Path", key: "path", placeholder: "/" },
              { label: "Expires", key: "expires", placeholder: "Tomorrow" },
              { label: "Secure", key: "secure", placeholder: "True/False" },
              { label: "HttpOnly", key: "httpOnly", placeholder: "True/False" },
            ],
            o = ii(() => t[n.value] || {}),
            i = (e, t) => {
              n.value && r.edit(n.value, e, t)
            }
          return (e, t) => (
            xo(), To(Vme, { data: o.value, onUpdate: i, options: a, title: "Cookie" }, null, 8, ["data"])
          )
        },
      }),
      Xme = Ro("span", null, "Raw Cookie String", -1),
      Yme = Hr({
        __name: "CookieRaw",
        setup(e) {
          const { cookies: t, activeCookieId: n } = E8()
          return (e, r) => (
            xo(),
            To(Jpe, null, {
              title: yr(() => [Xme]),
              default: yr(() => [
                In(n) && In(t)[In(n)]
                  ? (xo(), To(cpe, { key: 0, class: "px-2 py-2.5", lineNumbers: "", modelValue: "" }))
                  : Qo("", !0),
              ]),
              _: 1,
            })
          )
        },
      }),
      Gme = { class: "flex-1" },
      Kme = Hr({
        __name: "Cookies",
        setup(e) {
          const { cookies: t, cookieMutators: n } = E8(),
            r = X1(),
            a = () => {
              const e = M3({
                uid: NL(),
                name: "Cookie",
                value: "",
                domain: "",
                path: "/",
                secure: !1,
                httpOnly: !1,
                sameSite: "None",
              })
              n.add(e), r.push(e.uid)
            }
          return (e, n) => (
            xo(),
            To(Zpe, null, {
              default: yr(() => [
                No(
                  In(pme),
                  { title: "Domain" },
                  {
                    content: yr(() => [
                      Ro("div", Gme, [
                        No(Ame, null, {
                          default: yr(() => [
                            (xo(!0),
                            Eo(
                              go,
                              null,
                              qr(
                                In(t),
                                (e) => (
                                  xo(),
                                  To(
                                    Lme,
                                    { key: e.uid, class: "text-xs", variable: { name: e.name, uid: e.uid } },
                                    null,
                                    8,
                                    ["variable"],
                                  )
                                ),
                              ),
                              128,
                            )),
                          ]),
                          _: 1,
                        }),
                      ]),
                    ]),
                    button: yr(() => [No(Qpe, { click: a }, { title: yr(() => [Mo("Add Item")]), _: 1 })]),
                    _: 1,
                  },
                ),
                No(Vpe, { class: "flex-1" }, { default: yr(() => [No(Wme), No(Yme)]), _: 1 }),
              ]),
              _: 1,
            })
          )
        },
      }),
      Jme = Object.freeze(
        Object.defineProperty({ __proto__: null, default: Kme }, Symbol.toStringTag, { value: "Module" }),
      ),
      ege = { class: "w-full" },
      tge = Hr({
        __name: "ServerForm",
        setup(e) {
          const { activeCollection: t, servers: n, serverMutators: r } = E8(),
            a = [
              { label: "URL", key: "url", placeholder: "https://void.scalar.com/api" },
              { label: "Label", key: "description", placeholder: "Production" },
            ],
            o = xa(L1),
            i = ii(() => {
              var e, r
              return n[
                t.value && "default" === o.params.server
                  ? null == (e = t.value)
                    ? void 0
                    : e.spec.serverUids[0]
                  : ((null == (r = t.value) ? void 0 : r.spec.serverUids.find((e) => e === o.params.server)) ?? "")
              ]
            }),
            s = (e, n) => {
              t.value && r.edit(i.value.uid, e, n)
            },
            l = (e, n) => {
              t.value && r.edit(i.value.uid, `variables.${e}.value`, n)
            },
            c = ii(() => {
              var e
              return Object.entries((null == (e = i.value) ? void 0 : e.variables) ?? {}).map(([e, t]) => {
                var n
                return {
                  key: e,
                  label: e,
                  placeholder: t.default ?? (null == (n = null == t ? void 0 : t.enum) ? void 0 : n[0]) ?? "",
                }
              })
            }),
            d = ii(() =>
              Object.entries(i.value.variables ?? {}).reduce((e, [t, n]) => {
                var r
                return (
                  (e[t] = n.value ?? n.default ?? (null == (r = null == n ? void 0 : n.enum) ? void 0 : r[0]) ?? ""), e
                )
              }, {}),
            )
          return (e, t) => (
            xo(),
            Eo("div", ege, [
              i.value
                ? (xo(),
                  Eo(
                    go,
                    { key: 0 },
                    [
                      No(Vme, { data: i.value, onUpdate: s, options: a, title: "Server" }, null, 8, ["data"]),
                      Object.keys(d.value).length
                        ? (xo(),
                          To(
                            Vme,
                            { key: 0, data: d.value, onUpdate: l, options: c.value, title: "Variables" },
                            null,
                            8,
                            ["data", "options"],
                          ))
                        : Qo("", !0),
                    ],
                    64,
                  ))
                : Qo("", !0),
            ])
          )
        },
      }),
      nge = { class: "flex-1" },
      rge = Hr({
        __name: "Servers",
        setup(e) {
          const { activeCollection: t, servers: n, serverMutators: r } = E8(),
            { push: a } = X1(),
            o = () => {
              if (!t.value) return
              const e = a4({ url: "http://localhost" })
              r.add(e, t.value.uid), a(`/servers/${e.uid}`)
            }
          return (e, r) => (
            xo(),
            To(Zpe, null, {
              default: yr(() => [
                No(
                  In(pme),
                  { title: "Servers" },
                  {
                    content: yr(() => [
                      Ro("div", nge, [
                        No(Ame, null, {
                          default: yr(() => {
                            var e
                            return [
                              (xo(!0),
                              Eo(
                                go,
                                null,
                                qr(
                                  null == (e = In(t)) ? void 0 : e.spec.serverUids,
                                  (e) => (
                                    xo(),
                                    To(
                                      Lme,
                                      { key: e, class: "text-xs", variable: { name: In(n)[e].url, uid: e } },
                                      null,
                                      8,
                                      ["variable"],
                                    )
                                  ),
                                ),
                                128,
                              )),
                            ]
                          }),
                          _: 1,
                        }),
                      ]),
                    ]),
                    button: yr(() => [No(Qpe, { click: o }, { title: yr(() => [Mo("Add Server")]), _: 1 })]),
                    _: 1,
                  },
                ),
                No(Vpe, { class: "flex-1" }, { default: yr(() => [No(tge)]), _: 1 }),
              ]),
              _: 1,
            })
          )
        },
      }),
      age = Object.freeze(
        Object.defineProperty({ __proto__: null, default: rge }, Symbol.toStringTag, { value: "Module" }),
      )
  })
//# sourceMappingURL=/sm/a5ca14c080aa12771ea7357befdeb882ac98814091ab40a642a07858e6b3c077.map
